var global = Function("return this;")();
/*!
  * Ender: open module JavaScript framework (client-lib)
  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)
  * http://ender.no.de
  * License MIT
  */
!function (context) {

  // a global object for node.js module compatiblity
  // ============================================

  context['global'] = context

  // Implements simple module system
  // losely based on CommonJS Modules spec v1.1.1
  // ============================================

  var modules = {}
    , old = context.$

  function require (identifier) {
    // modules can be required from ender's build system, or found on the window
    var module = modules[identifier] || window[identifier]
    if (!module) throw new Error("Requested module '" + identifier + "' has not been defined.")
    return module
  }

  function provide (name, what) {
    return (modules[name] = what)
  }

  context['provide'] = provide
  context['require'] = require

  function aug(o, o2) {
    for (var k in o2) k != 'noConflict' && k != '_VERSION' && (o[k] = o2[k])
    return o
  }

  function boosh(s, r, els) {
    // string || node || nodelist || window
    if (typeof s == 'string' || s.nodeName || (s.length && 'item' in s) || s == window) {
      els = ender._select(s, r)
      els.selector = s
    } else els = isFinite(s.length) ? s : [s]
    return aug(els, boosh)
  }

  function ender(s, r) {
    return boosh(s, r)
  }

  aug(ender, {
      _VERSION: '0.3.6'
    , fn: boosh // for easy compat to jQuery plugins
    , ender: function (o, chain) {
        aug(chain ? boosh : ender, o)
      }
    , _select: function (s, r) {
        return (r || document).querySelectorAll(s)
      }
  })

  aug(boosh, {
    forEach: function (fn, scope, i) {
      // opt out of native forEach so we can intentionally call our own scope
      // defaulting to the current item and be able to return self
      for (i = 0, l = this.length; i < l; ++i) i in this && fn.call(scope || this[i], this[i], i, this)
      // return self for chaining
      return this
    },
    $: ender // handy reference to self
  })

  ender.noConflict = function () {
    context.$ = old
    return this
  }

  if (typeof module !== 'undefined' && module.exports) module.exports = ender
  // use subscript notation as extern for Closure compilation
  context['ender'] = context['$'] = context['ender'] || ender

}(this);
// pakmanager:hoek/lib/escape
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Declare internals
    
    var internals = {};
    
    
    exports.escapeJavaScript = function (input) {
    
        if (!input) {
            return '';
        }
    
        var escaped = '';
    
        for (var i = 0, il = input.length; i < il; ++i) {
    
            var charCode = input.charCodeAt(i);
    
            if (internals.isSafe(charCode)) {
                escaped += input[i];
            }
            else {
                escaped += internals.escapeJavaScriptChar(charCode);
            }
        }
    
        return escaped;
    };
    
    
    exports.escapeHtml = function (input) {
    
        if (!input) {
            return '';
        }
    
        var escaped = '';
    
        for (var i = 0, il = input.length; i < il; ++i) {
    
            var charCode = input.charCodeAt(i);
    
            if (internals.isSafe(charCode)) {
                escaped += input[i];
            }
            else {
                escaped += internals.escapeHtmlChar(charCode);
            }
        }
    
        return escaped;
    };
    
    
    internals.escapeJavaScriptChar = function (charCode) {
    
        if (charCode >= 256) {
            return '\\u' + internals.padLeft('' + charCode, 4);
        }
    
        var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
        return '\\x' + internals.padLeft(hexValue, 2);
    };
    
    
    internals.escapeHtmlChar = function (charCode) {
    
        var namedEscape = internals.namedHtml[charCode];
        if (typeof namedEscape !== 'undefined') {
            return namedEscape;
        }
    
        if (charCode >= 256) {
            return '&#' + charCode + ';';
        }
    
        var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
        return '&#x' + internals.padLeft(hexValue, 2) + ';';
    };
    
    
    internals.padLeft = function (str, len) {
    
        while (str.length < len) {
            str = '0' + str;
        }
    
        return str;
    };
    
    
    internals.isSafe = function (charCode) {
    
        return (typeof internals.safeCharCodes[charCode] !== 'undefined');
    };
    
    
    internals.namedHtml = {
        '38': '&amp;',
        '60': '&lt;',
        '62': '&gt;',
        '34': '&quot;',
        '160': '&nbsp;',
        '162': '&cent;',
        '163': '&pound;',
        '164': '&curren;',
        '169': '&copy;',
        '174': '&reg;'
    };
    
    
    internals.safeCharCodes = (function () {
    
        var safe = {};
    
        for (var i = 32; i < 123; ++i) {
    
            if ((i >= 97) ||                    // a-z
                (i >= 65 && i <= 90) ||         // A-Z
                (i >= 48 && i <= 57) ||         // 0-9
                i === 32 ||                     // space
                i === 46 ||                     // .
                i === 44 ||                     // ,
                i === 45 ||                     // -
                i === 58 ||                     // :
                i === 95) {                     // _
    
                safe[i] = null;
            }
        }
    
        return safe;
    }());
    
  provide("hoek/lib/escape", module.exports);
}(global));

// pakmanager:hoek
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Crypto = require('crypto');
    var Path = require('path');
    var Util = require('util');
    var Escape =  require('hoek/lib/escape');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Clone object or array
    
    exports.clone = function (obj, seen) {
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return obj;
        }
    
        seen = seen || { orig: [], copy: [] };
    
        var lookup = seen.orig.indexOf(obj);
        if (lookup !== -1) {
            return seen.copy[lookup];
        }
    
        var newObj;
        var cloneDeep = false;
    
        if (!Array.isArray(obj)) {
            if (Buffer.isBuffer(obj)) {
                newObj = new Buffer(obj);
            }
            else if (obj instanceof Date) {
                newObj = new Date(obj.getTime());
            }
            else if (obj instanceof RegExp) {
                newObj = new RegExp(obj);
            }
            else {
                var proto = Object.getPrototypeOf(obj);
                if (proto &&
                    proto.isImmutable) {
    
                    newObj = obj;
                }
                else {
                    newObj = Object.create(proto);
                    cloneDeep = true;
                }
            }
        }
        else {
            newObj = [];
            cloneDeep = true;
        }
    
        seen.orig.push(obj);
        seen.copy.push(newObj);
    
        if (cloneDeep) {
            var keys = Object.getOwnPropertyNames(obj);
            for (var i = 0, il = keys.length; i < il; ++i) {
                var key = keys[i];
                var descriptor = Object.getOwnPropertyDescriptor(obj, key);
                if (descriptor.get ||
                    descriptor.set) {
    
                    Object.defineProperty(newObj, key, descriptor);
                }
                else {
                    newObj[key] = exports.clone(obj[key], seen);
                }
            }
        }
    
        return newObj;
    };
    
    
    // Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied
    /*eslint-disable */
    exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {
    /*eslint-enable */
        exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');
        exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');
    
        if (!source) {
            return target;
        }
    
        if (Array.isArray(source)) {
            exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
            if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
                target.length = 0;                                                          // Must not change target assignment
            }
    
            for (var i = 0, il = source.length; i < il; ++i) {
                target.push(exports.clone(source[i]));
            }
    
            return target;
        }
    
        var keys = Object.keys(source);
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var value = source[key];
            if (value &&
                typeof value === 'object') {
    
                if (!target[key] ||
                    typeof target[key] !== 'object' ||
                    (Array.isArray(target[key]) ^ Array.isArray(value)) ||
                    value instanceof Date ||
                    Buffer.isBuffer(value) ||
                    value instanceof RegExp) {
    
                    target[key] = exports.clone(value);
                }
                else {
                    exports.merge(target[key], value, isNullOverride, isMergeArrays);
                }
            }
            else {
                if (value !== null &&
                    value !== undefined) {                              // Explicit to preserve empty strings
    
                    target[key] = value;
                }
                else if (isNullOverride !== false) {                    // Defaults to true
                    target[key] = value;
                }
            }
        }
    
        return target;
    };
    
    
    // Apply options to a copy of the defaults
    
    exports.applyToDefaults = function (defaults, options, isNullOverride) {
    
        exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
        exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
    
        if (!options) {                                                 // If no options, return null
            return null;
        }
    
        var copy = exports.clone(defaults);
    
        if (options === true) {                                         // If options is set to true, use defaults
            return copy;
        }
    
        return exports.merge(copy, options, isNullOverride === true, false);
    };
    
    
    // Clone an object except for the listed keys which are shallow copied
    
    exports.cloneWithShallow = function (source, keys) {
    
        if (!source ||
            typeof source !== 'object') {
    
            return source;
        }
    
        var storage = internals.store(source, keys);    // Move shallow copy items to storage
        var copy = exports.clone(source);               // Deep copy the rest
        internals.restore(copy, source, storage);       // Shallow copy the stored items and restore
        return copy;
    };
    
    
    internals.store = function (source, keys) {
    
        var storage = {};
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            var value = exports.reach(source, key);
            if (value !== undefined) {
                storage[key] = value;
                internals.reachSet(source, key, undefined);
            }
        }
    
        return storage;
    };
    
    
    internals.restore = function (copy, source, storage) {
    
        var keys = Object.keys(storage);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            internals.reachSet(copy, key, storage[key]);
            internals.reachSet(source, key, storage[key]);
        }
    };
    
    
    internals.reachSet = function (obj, key, value) {
    
        var path = key.split('.');
        var ref = obj;
        for (var i = 0, il = path.length; i < il; ++i) {
            var segment = path[i];
            if (i + 1 === il) {
                ref[segment] = value;
            }
    
            ref = ref[segment];
        }
    };
    
    
    // Apply options to defaults except for the listed keys which are shallow copied from option without merging
    
    exports.applyToDefaultsWithShallow = function (defaults, options, keys) {
    
        exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
        exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
        exports.assert(keys && Array.isArray(keys), 'Invalid keys');
    
        if (!options) {                                                 // If no options, return null
            return null;
        }
    
        var copy = exports.cloneWithShallow(defaults, keys);
    
        if (options === true) {                                         // If options is set to true, use defaults
            return copy;
        }
    
        var storage = internals.store(options, keys);   // Move shallow copy items to storage
        exports.merge(copy, options, false, false);     // Deep copy the rest
        internals.restore(copy, options, storage);      // Shallow copy the stored items and restore
        return copy;
    };
    
    
    // Deep object or array comparison
    
    exports.deepEqual = function (obj, ref, options, seen) {
    
        options = options || { prototype: true };
    
        var type = typeof obj;
    
        if (type !== typeof ref) {
            return false;
        }
    
        if (type !== 'object' ||
            obj === null ||
            ref === null) {
    
            if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
                return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0
            }
    
            return obj !== obj && ref !== ref;                  // NaN
        }
    
        seen = seen || [];
        if (seen.indexOf(obj) !== -1) {
            return true;                            // If previous comparison failed, it would have stopped execution
        }
    
        seen.push(obj);
    
        if (Array.isArray(obj)) {
            if (!Array.isArray(ref)) {
                return false;
            }
    
            if (!options.part && obj.length !== ref.length) {
                return false;
            }
    
            for (var i = 0, il = obj.length; i < il; ++i) {
                if (options.part) {
                    var found = false;
                    for (var r = 0, rl = ref.length; r < rl; ++r) {
                        if (exports.deepEqual(obj[i], ref[r], options, seen)) {
                            found = true;
                            break;
                        }
                    }
    
                    return found;
                }
    
                if (!exports.deepEqual(obj[i], ref[i], options, seen)) {
                    return false;
                }
            }
    
            return true;
        }
    
        if (Buffer.isBuffer(obj)) {
            if (!Buffer.isBuffer(ref)) {
                return false;
            }
    
            if (obj.length !== ref.length) {
                return false;
            }
    
            for (var j = 0, jl = obj.length; j < jl; ++j) {
                if (obj[j] !== ref[j]) {
                    return false;
                }
            }
    
            return true;
        }
    
        if (obj instanceof Date) {
            return (ref instanceof Date && obj.getTime() === ref.getTime());
        }
    
        if (obj instanceof RegExp) {
            return (ref instanceof RegExp && obj.toString() === ref.toString());
        }
    
        if (options.prototype) {
            if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
                return false;
            }
        }
    
        var keys = Object.getOwnPropertyNames(obj);
    
        if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {
            return false;
        }
    
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var descriptor = Object.getOwnPropertyDescriptor(obj, key);
            if (descriptor.get) {
                if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {
                    return false;
                }
            }
            else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {
                return false;
            }
        }
    
        return true;
    };
    
    
    // Remove duplicate items from array
    
    exports.unique = function (array, key) {
    
        var index = {};
        var result = [];
    
        for (var i = 0, il = array.length; i < il; ++i) {
            var id = (key ? array[i][key] : array[i]);
            if (index[id] !== true) {
    
                result.push(array[i]);
                index[id] = true;
            }
        }
    
        return result;
    };
    
    
    // Convert array into object
    
    exports.mapToObject = function (array, key) {
    
        if (!array) {
            return null;
        }
    
        var obj = {};
        for (var i = 0, il = array.length; i < il; ++i) {
            if (key) {
                if (array[i][key]) {
                    obj[array[i][key]] = true;
                }
            }
            else {
                obj[array[i]] = true;
            }
        }
    
        return obj;
    };
    
    
    // Find the common unique items in two arrays
    
    exports.intersect = function (array1, array2, justFirst) {
    
        if (!array1 || !array2) {
            return [];
        }
    
        var common = [];
        var hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);
        var found = {};
        for (var i = 0, il = array2.length; i < il; ++i) {
            if (hash[array2[i]] && !found[array2[i]]) {
                if (justFirst) {
                    return array2[i];
                }
    
                common.push(array2[i]);
                found[array2[i]] = true;
            }
        }
    
        return (justFirst ? null : common);
    };
    
    
    // Test if the reference contains the values
    
    exports.contain = function (ref, values, options) {
    
        /*
            string -> string(s)
            array -> item(s)
            object -> key(s)
            object -> object (key:value)
        */
    
        var valuePairs = null;
        if (typeof ref === 'object' &&
            typeof values === 'object' &&
            !Array.isArray(ref) &&
            !Array.isArray(values)) {
    
            valuePairs = values;
            values = Object.keys(values);
        }
        else {
            values = [].concat(values);
        }
    
        options = options || {};            // deep, once, only, part
    
        exports.assert(arguments.length >= 2, 'Insufficient arguments');
        exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');
        exports.assert(values.length, 'Values array cannot be empty');
    
        var compare, compareFlags;
        if (options.deep) {
            compare = exports.deepEqual;
    
            var hasOnly = options.hasOwnProperty('only'), hasPart = options.hasOwnProperty('part');
    
            compareFlags = {
                prototype: hasOnly ? options.only : hasPart ? !options.part : false,
                part: hasOnly ? !options.only : hasPart ? options.part : true
            };
        }
        else {
            compare = function (a, b) {
    
                return a === b;
            };
        }
    
        var misses = false;
        var matches = new Array(values.length);
        for (var i = 0, il = matches.length; i < il; ++i) {
            matches[i] = 0;
        }
    
        if (typeof ref === 'string') {
            var pattern = '(';
            for (i = 0, il = values.length; i < il; ++i) {
                var value = values[i];
                exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
                pattern += (i ? '|' : '') + exports.escapeRegex(value);
            }
    
            var regex = new RegExp(pattern + ')', 'g');
            var leftovers = ref.replace(regex, function ($0, $1) {
    
                var index = values.indexOf($1);
                ++matches[index];
                return '';          // Remove from string
            });
    
            misses = !!leftovers;
        }
        else if (Array.isArray(ref)) {
            for (i = 0, il = ref.length; i < il; ++i) {
                for (var j = 0, jl = values.length, matched = false; j < jl && matched === false; ++j) {
                    matched = compare(values[j], ref[i], compareFlags) && j;
                }
    
                if (matched !== false) {
                    ++matches[matched];
                }
                else {
                    misses = true;
                }
            }
        }
        else {
            var keys = Object.keys(ref);
            for (i = 0, il = keys.length; i < il; ++i) {
                var key = keys[i];
                var pos = values.indexOf(key);
                if (pos !== -1) {
                    if (valuePairs &&
                        !compare(valuePairs[key], ref[key], compareFlags)) {
    
                        return false;
                    }
    
                    ++matches[pos];
                }
                else {
                    misses = true;
                }
            }
        }
    
        var result = false;
        for (i = 0, il = matches.length; i < il; ++i) {
            result = result || !!matches[i];
            if ((options.once && matches[i] > 1) ||
                (!options.part && !matches[i])) {
    
                return false;
            }
        }
    
        if (options.only &&
            misses) {
    
            return false;
        }
    
        return result;
    };
    
    
    // Flatten array
    
    exports.flatten = function (array, target) {
    
        var result = target || [];
    
        for (var i = 0, il = array.length; i < il; ++i) {
            if (Array.isArray(array[i])) {
                exports.flatten(array[i], result);
            }
            else {
                result.push(array[i]);
            }
        }
    
        return result;
    };
    
    
    // Convert an object key chain string ('a.b.c') to reference (object[a][b][c])
    
    exports.reach = function (obj, chain, options) {
    
        if (!chain) {
            return obj;
        }
    
        options = options || {};
        if (typeof options === 'string') {
            options = { separator: options };
        }
    
        var path = chain.split(options.separator || '.');
        var ref = obj;
        for (var i = 0, il = path.length; i < il; ++i) {
            var key = path[i];
            if (key[0] === '-' && Array.isArray(ref)) {
                key = key.slice(1, key.length);
                key = ref.length - key;
            }
    
            if (!ref ||
                !ref.hasOwnProperty(key) ||
                (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties
    
                exports.assert(!options.strict || i + 1 === il, 'Missing segment', key, 'in reach path ', chain);
                exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
                ref = options.default;
                break;
            }
    
            ref = ref[key];
        }
    
        return ref;
    };
    
    
    exports.reachTemplate = function (obj, template, options) {
    
        return template.replace(/{([^}]+)}/g, function ($0, chain) {
    
            var value = exports.reach(obj, chain, options);
            return (value === undefined || value === null ? '' : value);
        });
    };
    
    
    exports.formatStack = function (stack) {
    
        var trace = [];
        for (var i = 0, il = stack.length; i < il; ++i) {
            var item = stack[i];
            trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
        }
    
        return trace;
    };
    
    
    exports.formatTrace = function (trace) {
    
        var display = [];
    
        for (var i = 0, il = trace.length; i < il; ++i) {
            var row = trace[i];
            display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
        }
    
        return display;
    };
    
    
    exports.callStack = function (slice) {
    
        // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    
        var v8 = Error.prepareStackTrace;
        Error.prepareStackTrace = function (err, stack) {
    
            return stack;
        };
    
        var capture = {};
        Error.captureStackTrace(capture, arguments.callee);     /*eslint no-caller:0 */
        var stack = capture.stack;
    
        Error.prepareStackTrace = v8;
    
        var trace = exports.formatStack(stack);
    
        if (slice) {
            return trace.slice(slice);
        }
    
        return trace;
    };
    
    
    exports.displayStack = function (slice) {
    
        var trace = exports.callStack(slice === undefined ? 1 : slice + 1);
    
        return exports.formatTrace(trace);
    };
    
    
    exports.abortThrow = false;
    
    
    exports.abort = function (message, hideStack) {
    
        if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
            throw new Error(message || 'Unknown error');
        }
    
        var stack = '';
        if (!hideStack) {
            stack = exports.displayStack(1).join('\n\t');
        }
        console.log('ABORT: ' + message + '\n\t' + stack);
        process.exit(1);
    };
    
    
    exports.assert = function (condition /*, msg1, msg2, msg3 */) {
    
        if (condition) {
            return;
        }
    
        if (arguments.length === 2 && arguments[1] instanceof Error) {
            throw arguments[1];
        }
    
        var msgs = [];
        for (var i = 1, il = arguments.length; i < il; ++i) {
            if (arguments[i] !== '') {
                msgs.push(arguments[i]);            // Avoids Array.slice arguments leak, allowing for V8 optimizations
            }
        }
    
        msgs = msgs.map(function (msg) {
    
            return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);
        });
        throw new Error(msgs.join(' ') || 'Unknown error');
    };
    
    
    exports.Timer = function () {
    
        this.ts = 0;
        this.reset();
    };
    
    
    exports.Timer.prototype.reset = function () {
    
        this.ts = Date.now();
    };
    
    
    exports.Timer.prototype.elapsed = function () {
    
        return Date.now() - this.ts;
    };
    
    
    exports.Bench = function () {
    
        this.ts = 0;
        this.reset();
    };
    
    
    exports.Bench.prototype.reset = function () {
    
        this.ts = exports.Bench.now();
    };
    
    
    exports.Bench.prototype.elapsed = function () {
    
        return exports.Bench.now() - this.ts;
    };
    
    
    exports.Bench.now = function () {
    
        var ts = process.hrtime();
        return (ts[0] * 1e3) + (ts[1] / 1e6);
    };
    
    
    // Escape string for Regex construction
    
    exports.escapeRegex = function (string) {
    
        // Escape ^$.*+-?=!:|\/()[]{},
        return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
    };
    
    
    // Base64url (RFC 4648) encode
    
    exports.base64urlEncode = function (value, encoding) {
    
        var buf = (Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary'));
        return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    };
    
    
    // Base64url (RFC 4648) decode
    
    exports.base64urlDecode = function (value, encoding) {
    
        if (value &&
            !/^[\w\-]*$/.test(value)) {
    
            return new Error('Invalid character');
        }
    
        try {
            var buf = new Buffer(value, 'base64');
            return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));
        }
        catch (err) {
            return err;
        }
    };
    
    
    // Escape attribute value for use in HTTP header
    
    exports.escapeHeaderAttribute = function (attribute) {
    
        // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "
    
        exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');
    
        return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
    };
    
    
    exports.escapeHtml = function (string) {
    
        return Escape.escapeHtml(string);
    };
    
    
    exports.escapeJavaScript = function (string) {
    
        return Escape.escapeJavaScript(string);
    };
    
    
    exports.nextTick = function (callback) {
    
        return function () {
    
            var args = arguments;
            process.nextTick(function () {
    
                callback.apply(null, args);
            });
        };
    };
    
    
    exports.once = function (method) {
    
        if (method._hoekOnce) {
            return method;
        }
    
        var once = false;
        var wrapped = function () {
    
            if (!once) {
                once = true;
                method.apply(null, arguments);
            }
        };
    
        wrapped._hoekOnce = true;
    
        return wrapped;
    };
    
    
    exports.isAbsolutePath = function (path, platform) {
    
        if (!path) {
            return false;
        }
    
        if (Path.isAbsolute) {                      // node >= 0.11
            return Path.isAbsolute(path);
        }
    
        platform = platform || process.platform;
    
        // Unix
    
        if (platform !== 'win32') {
            return path[0] === '/';
        }
    
        // Windows
    
        return !!/^(?:[a-zA-Z]:[\\\/])|(?:[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/])/.test(path);        // C:\ or \\something\something
    };
    
    
    exports.isInteger = function (value) {
    
        return (typeof value === 'number' &&
                parseFloat(value) === parseInt(value, 10) &&
                !isNaN(value));
    };
    
    
    exports.ignore = function () { };
    
    
    exports.inherits = Util.inherits;
    
    
    exports.format = Util.format;
    
    
    exports.transform = function (source, transform, options) {
    
        exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');
    
        if (Array.isArray(source)) {
            return source.map(function (obj) {
    
                return exports.transform(obj, transform, options);
            });
        }
    
        var result = {};
        var keys = Object.keys(transform);
    
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var path = key.split('.');
            var sourcePath = transform[key];
    
            exports.assert(typeof sourcePath === 'string', 'All mappings must be "." delineated strings');
    
            var segment;
            var res = result;
    
            while (path.length > 1) {
                segment = path.shift();
                if (!res[segment]) {
                    res[segment] = {};
                }
                res = res[segment];
            }
            segment = path.shift();
            res[segment] = exports.reach(source, sourcePath, options);
        }
    
        return result;
    };
    
    
    exports.uniqueFilename = function (path, extension) {
    
        if (extension) {
            extension = extension[0] !== '.' ? '.' + extension : extension;
        }
        else {
            extension = '';
        }
    
        path = Path.resolve(path);
        var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
        return Path.join(path, name);
    };
    
    
    exports.stringify = function () {
    
        try {
            return JSON.stringify.apply(null, arguments);
        }
        catch (err) {
            return '[Cannot display object: ' + err.message + ']';
        }
    };
    
    
    exports.shallow = function (source) {
    
        var target = {};
        var keys = Object.keys(source);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            target[key] = source[key];
        }
    
        return target;
    };
    
  provide("hoek", module.exports);
}(global));

// pakmanager:ansi-regex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function () {
    	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
    };
    
  provide("ansi-regex", module.exports);
}(global));

// pakmanager:has-flag
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (flag, argv) {
    	argv = argv || process.argv;
    
    	var terminatorPos = argv.indexOf('--');
    	var prefix = /^--/.test(flag) ? '' : '--';
    	var pos = argv.indexOf(prefix + flag);
    
    	return pos !== -1 && (terminatorPos !== -1 ? pos < terminatorPos : true);
    };
    
  provide("has-flag", module.exports);
}(global));

// pakmanager:is-property
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    function isProperty(str) {
      return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
    }
    module.exports = isProperty
  provide("is-property", module.exports);
}(global));

// pakmanager:core-util-is
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    
    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    
    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    
    function isBuffer(arg) {
      return Buffer.isBuffer(arg);
    }
    exports.isBuffer = isBuffer;
    
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  provide("core-util-is", module.exports);
}(global));

// pakmanager:inherits
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('util').inherits
    
  provide("inherits", module.exports);
}(global));

// pakmanager:isarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };
    
  provide("isarray", module.exports);
}(global));

// pakmanager:process-nextick-args
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = nextTick;
    
    function nextTick(fn) {
      var args = new Array(arguments.length - 1);
      var i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
    }
    
  provide("process-nextick-args", module.exports);
}(global));

// pakmanager:string_decoder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    var Buffer = require('buffer').Buffer;
    
    var isBufferEncoding = Buffer.isEncoding
      || function(encoding) {
           switch (encoding && encoding.toLowerCase()) {
             case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
             default: return false;
           }
         }
    
    
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    
    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
    
      // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
      this.charBuffer = new Buffer(6);
      // Number of bytes received for the current incomplete multi-byte character.
      this.charReceived = 0;
      // Number of bytes expected for the current incomplete multi-byte character.
      this.charLength = 0;
    };
    
    
    // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      // if our last write ended with an incomplete multibyte character
      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
            buffer.length;
    
        // add the new bytes to the char buffer
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
    
        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        }
    
        // remove bytes belonging to the current character from the buffer
        buffer = buffer.slice(available, buffer.length);
    
        // get the character that was split
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    
        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
    
        // if there are no more bytes in this buffer, just emit our char
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
    
      // determine and set charLength / charReceived
      this.detectIncompleteChar(buffer);
    
      var end = buffer.length;
      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
    
      charStr += buffer.toString(this.encoding, 0, end);
    
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
    
      // or just emit the charStr
      return charStr;
    };
    
    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = (buffer.length >= 3) ? 3 : buffer.length;
    
      // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
    
        // See http://en.wikipedia.org/wiki/UTF-8#Description
    
        // 110XXXXX
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
    
        // 1110XXXX
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
    
        // 11110XXX
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    
    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);
    
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
    
      return res;
    };
    
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
    
  provide("string_decoder", module.exports);
}(global));

// pakmanager:util-deprecate
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * For Node.js, simply re-export the core `util.deprecate` function.
     */
    
    module.exports = require('util').deprecate;
    
  provide("util-deprecate", module.exports);
}(global));

// pakmanager:deep-is
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var pSlice = Array.prototype.slice;
    var Object_keys = typeof Object.keys === 'function'
        ? Object.keys
        : function (obj) {
            var keys = [];
            for (var key in obj) keys.push(key);
            return keys;
        }
    ;
    
    var deepEqual = module.exports = function (actual, expected) {
      // enforce Object.is +0 !== -0
      if (actual === 0 && expected === 0) {
        return areZerosEqual(actual, expected);
    
      // 7.1. All identical values are equivalent, as determined by ===.
      } else if (actual === expected) {
        return true;
    
      } else if (actual instanceof Date && expected instanceof Date) {
        return actual.getTime() === expected.getTime();
    
      } else if (isNumberNaN(actual)) {
        return isNumberNaN(expected);
    
      // 7.3. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
      } else if (typeof actual != 'object' && typeof expected != 'object') {
        return actual == expected;
    
      // 7.4. For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
      } else {
        return objEquiv(actual, expected);
      }
    };
    
    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }
    
    function isArguments(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    
    function isNumberNaN(value) {
      // NaN === NaN -> false
      return typeof value == 'number' && value !== value;
    }
    
    function areZerosEqual(zeroA, zeroB) {
      // (1 / +0|0) -> Infinity, but (1 / -0) -> -Infinity and (Infinity !== -Infinity)
      return (1 / zeroA) === (1 / zeroB);
    }
    
    function objEquiv(a, b) {
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
        return false;
    
      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) return false;
      //~~~I've managed to break Object.keys through screwy arguments passing.
      //   Converting to array solves the problem.
      if (isArguments(a)) {
        if (!isArguments(b)) {
          return false;
        }
        a = pSlice.call(a);
        b = pSlice.call(b);
        return deepEqual(a, b);
      }
      try {
        var ka = Object_keys(a),
            kb = Object_keys(b),
            key, i;
      } catch (e) {//happens when one is a string literal and the other isn't
        return false;
      }
      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length)
        return false;
      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }
      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key])) return false;
      }
      return true;
    }
    
  provide("deep-is", module.exports);
}(global));

// pakmanager:wordwrap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wordwrap = module.exports = function (start, stop, params) {
        if (typeof start === 'object') {
            params = start;
            start = params.start;
            stop = params.stop;
        }
        
        if (typeof stop === 'object') {
            params = stop;
            start = start || params.start;
            stop = undefined;
        }
        
        if (!stop) {
            stop = start;
            start = 0;
        }
        
        if (!params) params = {};
        var mode = params.mode || 'soft';
        var re = mode === 'hard' ? /\b/ : /(\S+\s+)/;
        
        return function (text) {
            var chunks = text.toString()
                .split(re)
                .reduce(function (acc, x) {
                    if (mode === 'hard') {
                        for (var i = 0; i < x.length; i += stop - start) {
                            acc.push(x.slice(i, i + stop - start));
                        }
                    }
                    else acc.push(x)
                    return acc;
                }, [])
            ;
            
            return chunks.reduce(function (lines, rawChunk) {
                if (rawChunk === '') return lines;
                
                var chunk = rawChunk.replace(/\t/g, '    ');
                
                var i = lines.length - 1;
                if (lines[i].length + chunk.length > stop) {
                    lines[i] = lines[i].replace(/\s+$/, '');
                    
                    chunk.split(/\n/).forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else if (chunk.match(/\n/)) {
                    var xs = chunk.split(/\n/);
                    lines[i] += xs.shift();
                    xs.forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else {
                    lines[i] += chunk;
                }
                
                return lines;
            }, [ new Array(start + 1).join(' ') ]).join('\n');
        };
    };
    
    wordwrap.soft = wordwrap;
    
    wordwrap.hard = function (start, stop) {
        return wordwrap(start, stop, { mode : 'hard' });
    };
    
  provide("wordwrap", module.exports);
}(global));

// pakmanager:fast-levenshtein
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function() {
      'use strict';
    
      /**
       * Extend an Object with another Object's properties.
       *
       * The source objects are specified as additional arguments.
       *
       * @param dst Object the object to extend.
       *
       * @return Object the final object.
       */
      var _extend = function(dst) {
        var sources = Array.prototype.slice.call(arguments, 1);
        for (var i=0; i<sources.length; ++i) {
          var src = sources[i];
          for (var p in src) {
            if (src.hasOwnProperty(p)) dst[p] = src[p];
          }
        }
        return dst;
      };
    
      /**
       * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.
       */
      var Levenshtein = {
        /**
         * Calculate levenshtein distance of the two strings.
         *
         * @param str1 String the first string.
         * @param str2 String the second string.
         * @return Integer the levenshtein distance (0 and above).
         */
        get: function(str1, str2) {
          // base cases
          if (str1 === str2) return 0;
          if (str1.length === 0) return str2.length;
          if (str2.length === 0) return str1.length;
    
          // two rows
          var prevRow  = new Array(str2.length + 1),
              curCol, nextCol, i, j, tmp;
    
          // initialise previous row
          for (i=0; i<prevRow.length; ++i) {
            prevRow[i] = i;
          }
    
          // calculate current row distance from previous row
          for (i=0; i<str1.length; ++i) {
            nextCol = i + 1;
    
            for (j=0; j<str2.length; ++j) {
              curCol = nextCol;
    
              // substution
              nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );
              // insertion
              tmp = curCol + 1;
              if (nextCol > tmp) {
                nextCol = tmp;
              }
              // deletion
              tmp = prevRow[j + 1] + 1;
              if (nextCol > tmp) {
                nextCol = tmp;
              }
    
              // copy current col value into previous (in preparation for next iteration)
              prevRow[j] = curCol;
            }
    
            // copy last col value into previous (in preparation for next iteration)
            prevRow[j] = nextCol;
          }
    
          return nextCol;
        },
    
        /**
         * Asynchronously calculate levenshtein distance of the two strings.
         *
         * @param str1 String the first string.
         * @param str2 String the second string.
         * @param cb Function callback function with signature: function(Error err, int distance)
         * @param [options] Object additional options.
         * @param [options.progress] Function progress callback with signature: function(percentComplete)
         */
        getAsync: function(str1, str2, cb, options) {
          options = _extend({}, {
            progress: null
          }, options);
    
          // base cases
          if (str1 === str2) return cb(null, 0);
          if (str1.length === 0) return cb(null, str2.length);
          if (str2.length === 0) return cb(null, str1.length);
    
          // two rows
          var prevRow  = new Array(str2.length + 1),
              curCol, nextCol,
              i, j, tmp,
              startTime, currentTime;
    
          // initialise previous row
          for (i=0; i<prevRow.length; ++i) {
            prevRow[i] = i;
          }
    
          nextCol = 1;
          i = 0;
          j = -1;
    
          var __calculate = function() {
            // reset timer
            startTime = new Date().valueOf();
            currentTime = startTime;
    
            // keep going until one second has elapsed
            while (currentTime - startTime < 1000) {
              // reached end of current row?
              if (str2.length <= (++j)) {
                // copy current into previous (in preparation for next iteration)
                prevRow[j] = nextCol;
    
                // if already done all chars
                if (str1.length <= (++i)) {
                  return cb(null, nextCol);
                }
                // else if we have more left to do
                else {
                  nextCol = i + 1;
                  j = 0;
                }
              }
    
              // calculation
              curCol = nextCol;
    
              // substution
              nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );
              // insertion
              tmp = curCol + 1;
              if (nextCol > tmp) {
                nextCol = tmp;
              }
              // deletion
              tmp = prevRow[j + 1] + 1;
              if (nextCol > tmp) {
                nextCol = tmp;
              }
    
              // copy current into previous (in preparation for next iteration)
              prevRow[j] = curCol;
    
              // get current time
              currentTime = new Date().valueOf();
            }
    
            // send a progress update?
            if (null !== options.progress) {
              try {
                options.progress.call(null, (i * 100.0/ str1.length));
              } catch (err) {
                return cb('Progress callback: ' + err.toString());
              }
            }
    
            // next iteration
            setTimeout(__calculate(), 0);
          };
    
          __calculate();
        }
    
      };
    
      // amd
      if (typeof define !== "undefined" && define !== null && define.amd) {
        define(function() {
          return Levenshtein;
        });
      }
      // commonjs
      else if (typeof module !== "undefined" && module !== null) {
        module.exports = Levenshtein;
      }
      // web worker
      else if (typeof self !== "undefined" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {
        self.Levenshtein = Levenshtein;
      }
      // browser main thread
      else if (typeof window !== "undefined" && window !== null) {
        window.Levenshtein = Levenshtein;
      }
    }());
    
    
  provide("fast-levenshtein", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_writable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // A bit simpler than readable streams.
    // Implement an async ._write(chunk, cb), and it'll handle all
    // the drain event emission and buffering.
    
    'use strict';
    
    module.exports = Writable;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Writable.WritableState = WritableState;
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var Stream;
    (function (){try{
      Stream = require('st' + 'ream');
    }catch(_){}finally{
      if (!Stream)
        Stream = require('events').EventEmitter;
    }}())
    /*</replacement>*/
    
    var Buffer = require('buffer').Buffer;
    
    util.inherits(Writable, Stream);
    
    function nop() {}
    
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }
    
    function WritableState(options, stream) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      options = options || {};
    
      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;
    
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
    
      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;
    
      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;
    
      // a flag to see when we're in the middle of a write.
      this.writing = false;
    
      // when true all writes will be buffered until .uncork() call
      this.corked = 0;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;
    
      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
    
      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;
    
      // the amount that is being written when _write is called.
      this.writelen = 0;
    
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
    
      // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted
      this.pendingcb = 0;
    
      // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams
      this.prefinished = false;
    
      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;
    }
    
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    
    (function (){try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: require('util-deprecate')(function() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use ' +
          '_writableState.getBuffer() instead.')
    });
    }catch(_){}}());
    
    
    function Writable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
    
      this._writableState = new WritableState(options, this);
    
      // legacy.
      this.writable = true;
    
      if (options) {
        if (typeof options.write === 'function')
          this._write = options.write;
    
        if (typeof options.writev === 'function')
          this._writev = options.writev;
      }
    
      Stream.call(this);
    }
    
    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    
    
    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      processNextTick(cb, er);
    }
    
    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
    
      if (!(Buffer.isBuffer(chunk)) &&
          typeof chunk !== 'string' &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        processNextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
    
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
    
      if (typeof cb !== 'function')
        cb = nop;
    
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
    
      return ret;
    };
    
    Writable.prototype.cork = function() {
      var state = this._writableState;
    
      state.corked++;
    };
    
    Writable.prototype.uncork = function() {
      var state = this._writableState;
    
      if (state.corked) {
        state.corked--;
    
        if (!state.writing &&
            !state.corked &&
            !state.finished &&
            !state.bufferProcessing &&
            state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string')
        encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
    'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
    .indexOf((encoding + '').toLowerCase()) > -1))
        throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
    };
    
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode &&
          state.decodeStrings !== false &&
          typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    
    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
    
      state.length += len;
    
      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret)
        state.needDrain = true;
    
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
    
      return ret;
    }
    
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync)
        processNextTick(cb, er);
      else
        cb(er);
    
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
    
      onwriteStateUpdate(state);
    
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);
    
        if (!finished &&
            !state.corked &&
            !state.bufferProcessing &&
            state.bufferedRequest) {
          clearBuffer(stream, state);
        }
    
        if (sync) {
          processNextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    
    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    
    
    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
    
      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var buffer = [];
        var cbs = [];
        while (entry) {
          cbs.push(entry.callback);
          buffer.push(entry);
          entry = entry.next;
        }
    
        // count the one we are adding, as well.
        // TODO(isaacs) clean this up
        state.pendingcb++;
        state.lastBufferedRequest = null;
        doWrite(stream, state, true, state.length, buffer, '', function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
    
        // Clear buffer
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
    
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.
          if (state.writing) {
            break;
          }
        }
    
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    
    Writable.prototype._writev = null;
    
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
    
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (chunk !== null && chunk !== undefined)
        this.write(chunk, encoding);
    
      // .end() fully uncorks
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
    
      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    
    
    function needFinish(state) {
      return (state.ending &&
              state.length === 0 &&
              state.bufferedRequest === null &&
              !state.finished &&
              !state.writing);
    }
    
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }
    
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          processNextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
    
  provide("readable-stream/lib/_stream_writable", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_readable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = Readable;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var isArray = require('isarray');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Readable.ReadableState = ReadableState;
    
    var EE = require('events').EventEmitter;
    
    /*<replacement>*/
    if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var Stream;
    (function (){try{
      Stream = require('st' + 'ream');
    }catch(_){}finally{
      if (!Stream)
        Stream = require('events').EventEmitter;
    }}())
    /*</replacement>*/
    
    var Buffer = require('buffer').Buffer;
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var debug = require('util');
    if (debug && debug.debuglog) {
      debug = debug.debuglog('stream');
    } else {
      debug = function () {};
    }
    /*</replacement>*/
    
    var StringDecoder;
    
    util.inherits(Readable, Stream);
    
    function ReadableState(options, stream) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      options = options || {};
    
      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;
    
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
    
      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;
    
      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;
    
      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;
    
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    
    function Readable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      if (!(this instanceof Readable))
        return new Readable(options);
    
      this._readableState = new ReadableState(options, this);
    
      // legacy
      this.readable = true;
    
      if (options && typeof options.read === 'function')
        this._read = options.read;
    
      Stream.call(this);
    }
    
    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
    
      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
    
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    
    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
    
          if (!addToFront)
            state.reading = false;
    
          // if we want the data now, just emit it.
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
    
            if (state.needReadable)
              emitReadable(stream);
          }
    
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    
      return needMoreData(state);
    }
    
    
    
    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended &&
             (state.needReadable ||
              state.length < state.highWaterMark ||
              state.length === 0);
    }
    
    // backwards compatibility.
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require('string_decoder/').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    
    // Don't raise the hwm > 128MB
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
    
      if (state.objectMode)
        return n === 0 ? 0 : 1;
    
      if (n === null || isNaN(n)) {
        // only flow one buffer at a time
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
    
      if (n <= 0)
        return 0;
    
      // If we're asking for more than the target buffer level,
      // then raise the water mark.  Bump up to the next highest
      // power of 2, to prevent increasing it excessively in tiny
      // amounts.
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
    
      // don't have that much.  return null, unless we've ended.
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else {
          return state.length;
        }
      }
    
      return n;
    }
    
    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function(n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
    
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
    
      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 &&
          state.needReadable &&
          (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
    
      n = howMuchToRead(n, state);
    
      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
    
      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
    
      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
      debug('need readable', doRead);
    
      // if we currently have less than the highWaterMark, then also read some
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
    
      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
    
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
          state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
      }
    
      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
    
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
    
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
    
      state.length -= n;
    
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
    
      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
    
      if (ret !== null)
        this.emit('data', ret);
    
      return ret;
    };
    
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!(Buffer.isBuffer(chunk)) &&
          typeof chunk !== 'string' &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    
    
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
    
      // emit 'readable' now to make sure it gets picked up.
      emitReadable(stream);
    }
    
    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          processNextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    
    
    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        processNextTick(maybeReadMore_, stream, state);
      }
    }
    
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended &&
             state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    
    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
    
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    
      var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
    
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        processNextTick(endFn);
      else
        src.once('end', endFn);
    
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
    
      function onend() {
        debug('onend');
        dest.end();
      }
    
      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
    
      function cleanup() {
        debug('cleanup');
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
    
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain &&
            (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
    
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          debug('false write response, pause',
                src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
    
      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      // This is a brutally ugly hack to make sure that our error handler
      // is attached before any userland ones.  NEVER DO THIS.
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
    
    
    
      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
    
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
    
      // tell the dest that it's being piped to
      dest.emit('pipe', src);
    
      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
    
      return dest;
    };
    
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    
    
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
    
      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0)
        return this;
    
      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
          return this;
    
        if (!dest)
          dest = state.pipes;
    
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
    
      // slow case. multiple pipe destinations.
    
      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
    
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
    
      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
    
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    
      dest.emit('unpipe', this);
    
      return this;
    };
    
    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
    
      // If listening to data, and it has not explicitly been paused,
      // then call resume to start the flow of data on the next tick.
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
    
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            processNextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
    
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    
    function nReadingNextTick(self) {
      debug('readable nexttick read 0');
      self.read(0);
    }
    
    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        processNextTick(resume_, stream, state);
      }
    }
    
    function resume_(stream, state) {
      if (!state.reading) {
        debug('resume read 0');
        stream.read(0);
      }
    
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    
    Readable.prototype.pause = function() {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    
    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
    
      var self = this;
      stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
    
        self.push(null);
      });
    
      stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder)
          chunk = state.decoder.write(chunk);
    
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
    
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
    
      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function(method) { return function() {
            return stream[method].apply(stream, arguments);
          }; }(i);
        }
      }
    
      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
    
      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
    
      return self;
    };
    
    
    
    // exposed for testing purposes only.
    Readable._fromList = fromList;
    
    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
    
      // nothing in the list, definitely empty.
      if (list.length === 0)
        return null;
    
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        // read it all, truncate the array.
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        // read just some of it.
        if (n < list[0].length) {
          // just take a part of the first list item.
          // slice is the same for buffers and strings.
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          // first list is a perfect match
          ret = list.shift();
        } else {
          // complex case.
          // we have enough to cover it, but it spans past the first buffer.
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
    
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
    
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
    
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
    
            c += cpy;
          }
        }
      }
    
      return ret;
    }
    
    function endReadable(stream) {
      var state = stream._readableState;
    
      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
    
      if (!state.endEmitted) {
        state.ended = true;
        processNextTick(endReadableNT, state, stream);
      }
    }
    
    function endReadableNT(state, stream) {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    
  provide("readable-stream/lib/_stream_readable", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_duplex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // a duplex stream is just a stream that is both readable and writable.
    // Since JS doesn't have multiple prototypal inheritance, this class
    // prototypally inherits from Readable, and then parasitically from
    // Writable.
    
    'use strict';
    
    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    /*</replacement>*/
    
    
    module.exports = Duplex;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Readable =  require('readable-stream/lib/_stream_readable');
    var Writable =  require('readable-stream/lib/_stream_writable');
    
    util.inherits(Duplex, Readable);
    
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
    
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
    
      Readable.call(this, options);
      Writable.call(this, options);
    
      if (options && options.readable === false)
        this.readable = false;
    
      if (options && options.writable === false)
        this.writable = false;
    
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    
      this.once('end', onend);
    }
    
    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended)
        return;
    
      // no more data can be written.
      // But allow more writes to happen in this tick.
      processNextTick(onEndNT, this);
    }
    
    function onEndNT(self) {
      self.end();
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
  provide("readable-stream/lib/_stream_duplex", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_transform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    
    'use strict';
    
    module.exports = Transform;
    
    var Duplex =  require('readable-stream/lib/_stream_duplex');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(Transform, Duplex);
    
    
    function TransformState(stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
    
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
    
      var cb = ts.writecb;
    
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    
      ts.writechunk = null;
      ts.writecb = null;
    
      if (data !== null && data !== undefined)
        stream.push(data);
    
      if (cb)
        cb(er);
    
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    
    
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
    
      Duplex.call(this, options);
    
      this._transformState = new TransformState(this);
    
      // when the writable side finishes, then flush out anything remaining.
      var stream = this;
    
      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;
    
      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
    
      if (options) {
        if (typeof options.transform === 'function')
          this._transform = options.transform;
    
        if (typeof options.flush === 'function')
          this._flush = options.flush;
      }
    
      this.once('prefinish', function() {
        if (typeof this._flush === 'function')
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    
    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform ||
            rs.needReadable ||
            rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    
    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
    
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    
    
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
    
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var ts = stream._transformState;
    
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
    
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
    
      return stream.push(null);
    }
    
  provide("readable-stream/lib/_stream_transform", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_readable.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = Readable;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var isArray = require('isarray');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Readable.ReadableState = ReadableState;
    
    var EE = require('events').EventEmitter;
    
    /*<replacement>*/
    if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var Stream;
    (function (){try{
      Stream = require('st' + 'ream');
    }catch(_){}finally{
      if (!Stream)
        Stream = require('events').EventEmitter;
    }}())
    /*</replacement>*/
    
    var Buffer = require('buffer').Buffer;
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var debug = require('util');
    if (debug && debug.debuglog) {
      debug = debug.debuglog('stream');
    } else {
      debug = function () {};
    }
    /*</replacement>*/
    
    var StringDecoder;
    
    util.inherits(Readable, Stream);
    
    function ReadableState(options, stream) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      options = options || {};
    
      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;
    
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
    
      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;
    
      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;
    
      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;
    
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    
    function Readable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      if (!(this instanceof Readable))
        return new Readable(options);
    
      this._readableState = new ReadableState(options, this);
    
      // legacy
      this.readable = true;
    
      if (options && typeof options.read === 'function')
        this._read = options.read;
    
      Stream.call(this);
    }
    
    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
    
      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
    
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    
    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
    
          if (!addToFront)
            state.reading = false;
    
          // if we want the data now, just emit it.
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
    
            if (state.needReadable)
              emitReadable(stream);
          }
    
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    
      return needMoreData(state);
    }
    
    
    
    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended &&
             (state.needReadable ||
              state.length < state.highWaterMark ||
              state.length === 0);
    }
    
    // backwards compatibility.
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require('string_decoder/').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    
    // Don't raise the hwm > 128MB
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
    
      if (state.objectMode)
        return n === 0 ? 0 : 1;
    
      if (n === null || isNaN(n)) {
        // only flow one buffer at a time
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
    
      if (n <= 0)
        return 0;
    
      // If we're asking for more than the target buffer level,
      // then raise the water mark.  Bump up to the next highest
      // power of 2, to prevent increasing it excessively in tiny
      // amounts.
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
    
      // don't have that much.  return null, unless we've ended.
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else {
          return state.length;
        }
      }
    
      return n;
    }
    
    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function(n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
    
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
    
      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 &&
          state.needReadable &&
          (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
    
      n = howMuchToRead(n, state);
    
      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
    
      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
    
      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
      debug('need readable', doRead);
    
      // if we currently have less than the highWaterMark, then also read some
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
    
      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
    
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
          state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
      }
    
      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
    
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
    
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
    
      state.length -= n;
    
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
    
      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
    
      if (ret !== null)
        this.emit('data', ret);
    
      return ret;
    };
    
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!(Buffer.isBuffer(chunk)) &&
          typeof chunk !== 'string' &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    
    
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
    
      // emit 'readable' now to make sure it gets picked up.
      emitReadable(stream);
    }
    
    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          processNextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    
    
    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        processNextTick(maybeReadMore_, stream, state);
      }
    }
    
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended &&
             state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    
    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
    
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    
      var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
    
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        processNextTick(endFn);
      else
        src.once('end', endFn);
    
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
    
      function onend() {
        debug('onend');
        dest.end();
      }
    
      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
    
      function cleanup() {
        debug('cleanup');
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
    
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain &&
            (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
    
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          debug('false write response, pause',
                src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
    
      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      // This is a brutally ugly hack to make sure that our error handler
      // is attached before any userland ones.  NEVER DO THIS.
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
    
    
    
      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
    
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
    
      // tell the dest that it's being piped to
      dest.emit('pipe', src);
    
      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
    
      return dest;
    };
    
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    
    
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
    
      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0)
        return this;
    
      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
          return this;
    
        if (!dest)
          dest = state.pipes;
    
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
    
      // slow case. multiple pipe destinations.
    
      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
    
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
    
      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
    
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    
      dest.emit('unpipe', this);
    
      return this;
    };
    
    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
    
      // If listening to data, and it has not explicitly been paused,
      // then call resume to start the flow of data on the next tick.
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
    
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            processNextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
    
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    
    function nReadingNextTick(self) {
      debug('readable nexttick read 0');
      self.read(0);
    }
    
    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        processNextTick(resume_, stream, state);
      }
    }
    
    function resume_(stream, state) {
      if (!state.reading) {
        debug('resume read 0');
        stream.read(0);
      }
    
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    
    Readable.prototype.pause = function() {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    
    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
    
      var self = this;
      stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
    
        self.push(null);
      });
    
      stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder)
          chunk = state.decoder.write(chunk);
    
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
    
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
    
      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function(method) { return function() {
            return stream[method].apply(stream, arguments);
          }; }(i);
        }
      }
    
      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
    
      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
    
      return self;
    };
    
    
    
    // exposed for testing purposes only.
    Readable._fromList = fromList;
    
    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
    
      // nothing in the list, definitely empty.
      if (list.length === 0)
        return null;
    
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        // read it all, truncate the array.
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        // read just some of it.
        if (n < list[0].length) {
          // just take a part of the first list item.
          // slice is the same for buffers and strings.
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          // first list is a perfect match
          ret = list.shift();
        } else {
          // complex case.
          // we have enough to cover it, but it spans past the first buffer.
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
    
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
    
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
    
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
    
            c += cpy;
          }
        }
      }
    
      return ret;
    }
    
    function endReadable(stream) {
      var state = stream._readableState;
    
      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
    
      if (!state.endEmitted) {
        state.ended = true;
        processNextTick(endReadableNT, state, stream);
      }
    }
    
    function endReadableNT(state, stream) {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    
  provide("readable-stream/lib/_stream_readable.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_writable.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // A bit simpler than readable streams.
    // Implement an async ._write(chunk, cb), and it'll handle all
    // the drain event emission and buffering.
    
    'use strict';
    
    module.exports = Writable;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Writable.WritableState = WritableState;
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var Stream;
    (function (){try{
      Stream = require('st' + 'ream');
    }catch(_){}finally{
      if (!Stream)
        Stream = require('events').EventEmitter;
    }}())
    /*</replacement>*/
    
    var Buffer = require('buffer').Buffer;
    
    util.inherits(Writable, Stream);
    
    function nop() {}
    
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }
    
    function WritableState(options, stream) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      options = options || {};
    
      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;
    
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
    
      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;
    
      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;
    
      // a flag to see when we're in the middle of a write.
      this.writing = false;
    
      // when true all writes will be buffered until .uncork() call
      this.corked = 0;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;
    
      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
    
      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;
    
      // the amount that is being written when _write is called.
      this.writelen = 0;
    
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
    
      // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted
      this.pendingcb = 0;
    
      // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams
      this.prefinished = false;
    
      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;
    }
    
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    
    (function (){try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: require('util-deprecate')(function() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use ' +
          '_writableState.getBuffer() instead.')
    });
    }catch(_){}}());
    
    
    function Writable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
    
      this._writableState = new WritableState(options, this);
    
      // legacy.
      this.writable = true;
    
      if (options) {
        if (typeof options.write === 'function')
          this._write = options.write;
    
        if (typeof options.writev === 'function')
          this._writev = options.writev;
      }
    
      Stream.call(this);
    }
    
    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    
    
    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      processNextTick(cb, er);
    }
    
    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
    
      if (!(Buffer.isBuffer(chunk)) &&
          typeof chunk !== 'string' &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        processNextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
    
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
    
      if (typeof cb !== 'function')
        cb = nop;
    
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
    
      return ret;
    };
    
    Writable.prototype.cork = function() {
      var state = this._writableState;
    
      state.corked++;
    };
    
    Writable.prototype.uncork = function() {
      var state = this._writableState;
    
      if (state.corked) {
        state.corked--;
    
        if (!state.writing &&
            !state.corked &&
            !state.finished &&
            !state.bufferProcessing &&
            state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string')
        encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
    'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
    .indexOf((encoding + '').toLowerCase()) > -1))
        throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
    };
    
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode &&
          state.decodeStrings !== false &&
          typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    
    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
    
      state.length += len;
    
      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret)
        state.needDrain = true;
    
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
    
      return ret;
    }
    
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync)
        processNextTick(cb, er);
      else
        cb(er);
    
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
    
      onwriteStateUpdate(state);
    
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);
    
        if (!finished &&
            !state.corked &&
            !state.bufferProcessing &&
            state.bufferedRequest) {
          clearBuffer(stream, state);
        }
    
        if (sync) {
          processNextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    
    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    
    
    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
    
      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var buffer = [];
        var cbs = [];
        while (entry) {
          cbs.push(entry.callback);
          buffer.push(entry);
          entry = entry.next;
        }
    
        // count the one we are adding, as well.
        // TODO(isaacs) clean this up
        state.pendingcb++;
        state.lastBufferedRequest = null;
        doWrite(stream, state, true, state.length, buffer, '', function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
    
        // Clear buffer
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
    
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.
          if (state.writing) {
            break;
          }
        }
    
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    
    Writable.prototype._writev = null;
    
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
    
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (chunk !== null && chunk !== undefined)
        this.write(chunk, encoding);
    
      // .end() fully uncorks
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
    
      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    
    
    function needFinish(state) {
      return (state.ending &&
              state.length === 0 &&
              state.bufferedRequest === null &&
              !state.finished &&
              !state.writing);
    }
    
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }
    
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          processNextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
    
  provide("readable-stream/lib/_stream_writable.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_duplex.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // a duplex stream is just a stream that is both readable and writable.
    // Since JS doesn't have multiple prototypal inheritance, this class
    // prototypally inherits from Readable, and then parasitically from
    // Writable.
    
    'use strict';
    
    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    /*</replacement>*/
    
    
    module.exports = Duplex;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Readable =  require('readable-stream/lib/_stream_readable');
    var Writable =  require('readable-stream/lib/_stream_writable');
    
    util.inherits(Duplex, Readable);
    
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
    
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
    
      Readable.call(this, options);
      Writable.call(this, options);
    
      if (options && options.readable === false)
        this.readable = false;
    
      if (options && options.writable === false)
        this.writable = false;
    
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    
      this.once('end', onend);
    }
    
    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended)
        return;
    
      // no more data can be written.
      // But allow more writes to happen in this tick.
      processNextTick(onEndNT, this);
    }
    
    function onEndNT(self) {
      self.end();
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
  provide("readable-stream/lib/_stream_duplex.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_transform.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    
    'use strict';
    
    module.exports = Transform;
    
    var Duplex =  require('readable-stream/lib/_stream_duplex');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(Transform, Duplex);
    
    
    function TransformState(stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
    
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
    
      var cb = ts.writecb;
    
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    
      ts.writechunk = null;
      ts.writecb = null;
    
      if (data !== null && data !== undefined)
        stream.push(data);
    
      if (cb)
        cb(er);
    
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    
    
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
    
      Duplex.call(this, options);
    
      this._transformState = new TransformState(this);
    
      // when the writable side finishes, then flush out anything remaining.
      var stream = this;
    
      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;
    
      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
    
      if (options) {
        if (typeof options.transform === 'function')
          this._transform = options.transform;
    
        if (typeof options.flush === 'function')
          this._flush = options.flush;
      }
    
      this.once('prefinish', function() {
        if (typeof this._flush === 'function')
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    
    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform ||
            rs.needReadable ||
            rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    
    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
    
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    
    
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
    
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var ts = stream._transformState;
    
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
    
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
    
      return stream.push(null);
    }
    
  provide("readable-stream/lib/_stream_transform.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_passthrough.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // a passthrough stream.
    // basically just the most minimal sort of Transform stream.
    // Every written chunk gets output as-is.
    
    'use strict';
    
    module.exports = PassThrough;
    
    var Transform =  require('readable-stream/lib/_stream_transform');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(PassThrough, Transform);
    
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
    
      Transform.call(this, options);
    }
    
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    
  provide("readable-stream/lib/_stream_passthrough.js", module.exports);
}(global));

// pakmanager:readable-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = (function (){
      try {
        return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
      } catch(_){}
    }());
    exports = module.exports =  require('readable-stream/lib/_stream_readable.js');
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable =  require('readable-stream/lib/_stream_writable.js');
    exports.Duplex =  require('readable-stream/lib/_stream_duplex.js');
    exports.Transform =  require('readable-stream/lib/_stream_transform.js');
    exports.PassThrough =  require('readable-stream/lib/_stream_passthrough.js');
    
  provide("readable-stream", module.exports);
}(global));

// pakmanager:xtend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = extend
    
    function extend() {
        var target = {}
    
        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i]
    
            for (var key in source) {
                if (source.hasOwnProperty(key)) {
                    target[key] = source[key]
                }
            }
        }
    
        return target
    }
    
  provide("xtend", module.exports);
}(global));

// pakmanager:estraverse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
      Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    /*jslint vars:false, bitwise:true*/
    /*jshint indent:4*/
    /*global exports:true*/
    (function clone(exports) {
        'use strict';
    
        var Syntax,
            isArray,
            VisitorOption,
            VisitorKeys,
            objectCreate,
            objectKeys,
            BREAK,
            SKIP,
            REMOVE;
    
        function ignoreJSHintError() { }
    
        isArray = Array.isArray;
        if (!isArray) {
            isArray = function isArray(array) {
                return Object.prototype.toString.call(array) === '[object Array]';
            };
        }
    
        function deepCopy(obj) {
            var ret = {}, key, val;
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    val = obj[key];
                    if (typeof val === 'object' && val !== null) {
                        ret[key] = deepCopy(val);
                    } else {
                        ret[key] = val;
                    }
                }
            }
            return ret;
        }
    
        function shallowCopy(obj) {
            var ret = {}, key;
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    ret[key] = obj[key];
                }
            }
            return ret;
        }
        ignoreJSHintError(shallowCopy);
    
        // based on LLVM libc++ upper_bound / lower_bound
        // MIT License
    
        function upperBound(array, func) {
            var diff, len, i, current;
    
            len = array.length;
            i = 0;
    
            while (len) {
                diff = len >>> 1;
                current = i + diff;
                if (func(array[current])) {
                    len = diff;
                } else {
                    i = current + 1;
                    len -= diff + 1;
                }
            }
            return i;
        }
    
        function lowerBound(array, func) {
            var diff, len, i, current;
    
            len = array.length;
            i = 0;
    
            while (len) {
                diff = len >>> 1;
                current = i + diff;
                if (func(array[current])) {
                    i = current + 1;
                    len -= diff + 1;
                } else {
                    len = diff;
                }
            }
            return i;
        }
        ignoreJSHintError(lowerBound);
    
        objectCreate = Object.create || (function () {
            function F() { }
    
            return function (o) {
                F.prototype = o;
                return new F();
            };
        })();
    
        objectKeys = Object.keys || function (o) {
            var keys = [], key;
            for (key in o) {
                keys.push(key);
            }
            return keys;
        };
    
        function extend(to, from) {
            var keys = objectKeys(from), key, i, len;
            for (i = 0, len = keys.length; i < len; i += 1) {
                key = keys[i];
                to[key] = from[key];
            }
            return to;
        }
    
        Syntax = {
            AssignmentExpression: 'AssignmentExpression',
            AssignmentPattern: 'AssignmentPattern',
            ArrayExpression: 'ArrayExpression',
            ArrayPattern: 'ArrayPattern',
            ArrowFunctionExpression: 'ArrowFunctionExpression',
            AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
            BlockStatement: 'BlockStatement',
            BinaryExpression: 'BinaryExpression',
            BreakStatement: 'BreakStatement',
            CallExpression: 'CallExpression',
            CatchClause: 'CatchClause',
            ClassBody: 'ClassBody',
            ClassDeclaration: 'ClassDeclaration',
            ClassExpression: 'ClassExpression',
            ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
            ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
            ConditionalExpression: 'ConditionalExpression',
            ContinueStatement: 'ContinueStatement',
            DebuggerStatement: 'DebuggerStatement',
            DirectiveStatement: 'DirectiveStatement',
            DoWhileStatement: 'DoWhileStatement',
            EmptyStatement: 'EmptyStatement',
            ExportAllDeclaration: 'ExportAllDeclaration',
            ExportDefaultDeclaration: 'ExportDefaultDeclaration',
            ExportNamedDeclaration: 'ExportNamedDeclaration',
            ExportSpecifier: 'ExportSpecifier',
            ExpressionStatement: 'ExpressionStatement',
            ForStatement: 'ForStatement',
            ForInStatement: 'ForInStatement',
            ForOfStatement: 'ForOfStatement',
            FunctionDeclaration: 'FunctionDeclaration',
            FunctionExpression: 'FunctionExpression',
            GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
            Identifier: 'Identifier',
            IfStatement: 'IfStatement',
            ImportDeclaration: 'ImportDeclaration',
            ImportDefaultSpecifier: 'ImportDefaultSpecifier',
            ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
            ImportSpecifier: 'ImportSpecifier',
            Literal: 'Literal',
            LabeledStatement: 'LabeledStatement',
            LogicalExpression: 'LogicalExpression',
            MemberExpression: 'MemberExpression',
            MetaProperty: 'MetaProperty',
            MethodDefinition: 'MethodDefinition',
            ModuleSpecifier: 'ModuleSpecifier',
            NewExpression: 'NewExpression',
            ObjectExpression: 'ObjectExpression',
            ObjectPattern: 'ObjectPattern',
            Program: 'Program',
            Property: 'Property',
            RestElement: 'RestElement',
            ReturnStatement: 'ReturnStatement',
            SequenceExpression: 'SequenceExpression',
            SpreadElement: 'SpreadElement',
            Super: 'Super',
            SwitchStatement: 'SwitchStatement',
            SwitchCase: 'SwitchCase',
            TaggedTemplateExpression: 'TaggedTemplateExpression',
            TemplateElement: 'TemplateElement',
            TemplateLiteral: 'TemplateLiteral',
            ThisExpression: 'ThisExpression',
            ThrowStatement: 'ThrowStatement',
            TryStatement: 'TryStatement',
            UnaryExpression: 'UnaryExpression',
            UpdateExpression: 'UpdateExpression',
            VariableDeclaration: 'VariableDeclaration',
            VariableDeclarator: 'VariableDeclarator',
            WhileStatement: 'WhileStatement',
            WithStatement: 'WithStatement',
            YieldExpression: 'YieldExpression'
        };
    
        VisitorKeys = {
            AssignmentExpression: ['left', 'right'],
            AssignmentPattern: ['left', 'right'],
            ArrayExpression: ['elements'],
            ArrayPattern: ['elements'],
            ArrowFunctionExpression: ['params', 'body'],
            AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
            BlockStatement: ['body'],
            BinaryExpression: ['left', 'right'],
            BreakStatement: ['label'],
            CallExpression: ['callee', 'arguments'],
            CatchClause: ['param', 'body'],
            ClassBody: ['body'],
            ClassDeclaration: ['id', 'superClass', 'body'],
            ClassExpression: ['id', 'superClass', 'body'],
            ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
            ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
            ConditionalExpression: ['test', 'consequent', 'alternate'],
            ContinueStatement: ['label'],
            DebuggerStatement: [],
            DirectiveStatement: [],
            DoWhileStatement: ['body', 'test'],
            EmptyStatement: [],
            ExportAllDeclaration: ['source'],
            ExportDefaultDeclaration: ['declaration'],
            ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
            ExportSpecifier: ['exported', 'local'],
            ExpressionStatement: ['expression'],
            ForStatement: ['init', 'test', 'update', 'body'],
            ForInStatement: ['left', 'right', 'body'],
            ForOfStatement: ['left', 'right', 'body'],
            FunctionDeclaration: ['id', 'params', 'body'],
            FunctionExpression: ['id', 'params', 'body'],
            GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
            Identifier: [],
            IfStatement: ['test', 'consequent', 'alternate'],
            ImportDeclaration: ['specifiers', 'source'],
            ImportDefaultSpecifier: ['local'],
            ImportNamespaceSpecifier: ['local'],
            ImportSpecifier: ['imported', 'local'],
            Literal: [],
            LabeledStatement: ['label', 'body'],
            LogicalExpression: ['left', 'right'],
            MemberExpression: ['object', 'property'],
            MetaProperty: ['meta', 'property'],
            MethodDefinition: ['key', 'value'],
            ModuleSpecifier: [],
            NewExpression: ['callee', 'arguments'],
            ObjectExpression: ['properties'],
            ObjectPattern: ['properties'],
            Program: ['body'],
            Property: ['key', 'value'],
            RestElement: [ 'argument' ],
            ReturnStatement: ['argument'],
            SequenceExpression: ['expressions'],
            SpreadElement: ['argument'],
            Super: [],
            SwitchStatement: ['discriminant', 'cases'],
            SwitchCase: ['test', 'consequent'],
            TaggedTemplateExpression: ['tag', 'quasi'],
            TemplateElement: [],
            TemplateLiteral: ['quasis', 'expressions'],
            ThisExpression: [],
            ThrowStatement: ['argument'],
            TryStatement: ['block', 'handler', 'finalizer'],
            UnaryExpression: ['argument'],
            UpdateExpression: ['argument'],
            VariableDeclaration: ['declarations'],
            VariableDeclarator: ['id', 'init'],
            WhileStatement: ['test', 'body'],
            WithStatement: ['object', 'body'],
            YieldExpression: ['argument']
        };
    
        // unique id
        BREAK = {};
        SKIP = {};
        REMOVE = {};
    
        VisitorOption = {
            Break: BREAK,
            Skip: SKIP,
            Remove: REMOVE
        };
    
        function Reference(parent, key) {
            this.parent = parent;
            this.key = key;
        }
    
        Reference.prototype.replace = function replace(node) {
            this.parent[this.key] = node;
        };
    
        Reference.prototype.remove = function remove() {
            if (isArray(this.parent)) {
                this.parent.splice(this.key, 1);
                return true;
            } else {
                this.replace(null);
                return false;
            }
        };
    
        function Element(node, path, wrap, ref) {
            this.node = node;
            this.path = path;
            this.wrap = wrap;
            this.ref = ref;
        }
    
        function Controller() { }
    
        // API:
        // return property path array from root to current node
        Controller.prototype.path = function path() {
            var i, iz, j, jz, result, element;
    
            function addToPath(result, path) {
                if (isArray(path)) {
                    for (j = 0, jz = path.length; j < jz; ++j) {
                        result.push(path[j]);
                    }
                } else {
                    result.push(path);
                }
            }
    
            // root node
            if (!this.__current.path) {
                return null;
            }
    
            // first node is sentinel, second node is root element
            result = [];
            for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
                element = this.__leavelist[i];
                addToPath(result, element.path);
            }
            addToPath(result, this.__current.path);
            return result;
        };
    
        // API:
        // return type of current node
        Controller.prototype.type = function () {
            var node = this.current();
            return node.type || this.__current.wrap;
        };
    
        // API:
        // return array of parent elements
        Controller.prototype.parents = function parents() {
            var i, iz, result;
    
            // first node is sentinel
            result = [];
            for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
                result.push(this.__leavelist[i].node);
            }
    
            return result;
        };
    
        // API:
        // return current node
        Controller.prototype.current = function current() {
            return this.__current.node;
        };
    
        Controller.prototype.__execute = function __execute(callback, element) {
            var previous, result;
    
            result = undefined;
    
            previous  = this.__current;
            this.__current = element;
            this.__state = null;
            if (callback) {
                result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
            }
            this.__current = previous;
    
            return result;
        };
    
        // API:
        // notify control skip / break
        Controller.prototype.notify = function notify(flag) {
            this.__state = flag;
        };
    
        // API:
        // skip child nodes of current node
        Controller.prototype.skip = function () {
            this.notify(SKIP);
        };
    
        // API:
        // break traversals
        Controller.prototype['break'] = function () {
            this.notify(BREAK);
        };
    
        // API:
        // remove node
        Controller.prototype.remove = function () {
            this.notify(REMOVE);
        };
    
        Controller.prototype.__initialize = function(root, visitor) {
            this.visitor = visitor;
            this.root = root;
            this.__worklist = [];
            this.__leavelist = [];
            this.__current = null;
            this.__state = null;
            this.__fallback = visitor.fallback === 'iteration';
            this.__keys = VisitorKeys;
            if (visitor.keys) {
                this.__keys = extend(objectCreate(this.__keys), visitor.keys);
            }
        };
    
        function isNode(node) {
            if (node == null) {
                return false;
            }
            return typeof node === 'object' && typeof node.type === 'string';
        }
    
        function isProperty(nodeType, key) {
            return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
        }
    
        Controller.prototype.traverse = function traverse(root, visitor) {
            var worklist,
                leavelist,
                element,
                node,
                nodeType,
                ret,
                key,
                current,
                current2,
                candidates,
                candidate,
                sentinel;
    
            this.__initialize(root, visitor);
    
            sentinel = {};
    
            // reference
            worklist = this.__worklist;
            leavelist = this.__leavelist;
    
            // initialize
            worklist.push(new Element(root, null, null, null));
            leavelist.push(new Element(null, null, null, null));
    
            while (worklist.length) {
                element = worklist.pop();
    
                if (element === sentinel) {
                    element = leavelist.pop();
    
                    ret = this.__execute(visitor.leave, element);
    
                    if (this.__state === BREAK || ret === BREAK) {
                        return;
                    }
                    continue;
                }
    
                if (element.node) {
    
                    ret = this.__execute(visitor.enter, element);
    
                    if (this.__state === BREAK || ret === BREAK) {
                        return;
                    }
    
                    worklist.push(sentinel);
                    leavelist.push(element);
    
                    if (this.__state === SKIP || ret === SKIP) {
                        continue;
                    }
    
                    node = element.node;
                    nodeType = element.wrap || node.type;
                    candidates = this.__keys[nodeType];
                    if (!candidates) {
                        if (this.__fallback) {
                            candidates = objectKeys(node);
                        } else {
                            throw new Error('Unknown node type ' + nodeType + '.');
                        }
                    }
    
                    current = candidates.length;
                    while ((current -= 1) >= 0) {
                        key = candidates[current];
                        candidate = node[key];
                        if (!candidate) {
                            continue;
                        }
    
                        if (isArray(candidate)) {
                            current2 = candidate.length;
                            while ((current2 -= 1) >= 0) {
                                if (!candidate[current2]) {
                                    continue;
                                }
                                if (isProperty(nodeType, candidates[current])) {
                                    element = new Element(candidate[current2], [key, current2], 'Property', null);
                                } else if (isNode(candidate[current2])) {
                                    element = new Element(candidate[current2], [key, current2], null, null);
                                } else {
                                    continue;
                                }
                                worklist.push(element);
                            }
                        } else if (isNode(candidate)) {
                            worklist.push(new Element(candidate, key, null, null));
                        }
                    }
                }
            }
        };
    
        Controller.prototype.replace = function replace(root, visitor) {
            function removeElem(element) {
                var i,
                    key,
                    nextElem,
                    parent;
    
                if (element.ref.remove()) {
                    // When the reference is an element of an array.
                    key = element.ref.key;
                    parent = element.ref.parent;
    
                    // If removed from array, then decrease following items' keys.
                    i = worklist.length;
                    while (i--) {
                        nextElem = worklist[i];
                        if (nextElem.ref && nextElem.ref.parent === parent) {
                            if  (nextElem.ref.key < key) {
                                break;
                            }
                            --nextElem.ref.key;
                        }
                    }
                }
            }
    
            var worklist,
                leavelist,
                node,
                nodeType,
                target,
                element,
                current,
                current2,
                candidates,
                candidate,
                sentinel,
                outer,
                key;
    
            this.__initialize(root, visitor);
    
            sentinel = {};
    
            // reference
            worklist = this.__worklist;
            leavelist = this.__leavelist;
    
            // initialize
            outer = {
                root: root
            };
            element = new Element(root, null, null, new Reference(outer, 'root'));
            worklist.push(element);
            leavelist.push(element);
    
            while (worklist.length) {
                element = worklist.pop();
    
                if (element === sentinel) {
                    element = leavelist.pop();
    
                    target = this.__execute(visitor.leave, element);
    
                    // node may be replaced with null,
                    // so distinguish between undefined and null in this place
                    if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                        // replace
                        element.ref.replace(target);
                    }
    
                    if (this.__state === REMOVE || target === REMOVE) {
                        removeElem(element);
                    }
    
                    if (this.__state === BREAK || target === BREAK) {
                        return outer.root;
                    }
                    continue;
                }
    
                target = this.__execute(visitor.enter, element);
    
                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                    element.node = target;
                }
    
                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                    element.node = null;
                }
    
                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
    
                // node may be null
                node = element.node;
                if (!node) {
                    continue;
                }
    
                worklist.push(sentinel);
                leavelist.push(element);
    
                if (this.__state === SKIP || target === SKIP) {
                    continue;
                }
    
                nodeType = element.wrap || node.type;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = objectKeys(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }
    
                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }
    
                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                    }
                }
            }
    
            return outer.root;
        };
    
        function traverse(root, visitor) {
            var controller = new Controller();
            return controller.traverse(root, visitor);
        }
    
        function replace(root, visitor) {
            var controller = new Controller();
            return controller.replace(root, visitor);
        }
    
        function extendCommentRange(comment, tokens) {
            var target;
    
            target = upperBound(tokens, function search(token) {
                return token.range[0] > comment.range[0];
            });
    
            comment.extendedRange = [comment.range[0], comment.range[1]];
    
            if (target !== tokens.length) {
                comment.extendedRange[1] = tokens[target].range[0];
            }
    
            target -= 1;
            if (target >= 0) {
                comment.extendedRange[0] = tokens[target].range[1];
            }
    
            return comment;
        }
    
        function attachComments(tree, providedComments, tokens) {
            // At first, we should calculate extended comment ranges.
            var comments = [], comment, len, i, cursor;
    
            if (!tree.range) {
                throw new Error('attachComments needs range information');
            }
    
            // tokens array is empty, we attach comments to tree as 'leadingComments'
            if (!tokens.length) {
                if (providedComments.length) {
                    for (i = 0, len = providedComments.length; i < len; i += 1) {
                        comment = deepCopy(providedComments[i]);
                        comment.extendedRange = [0, tree.range[0]];
                        comments.push(comment);
                    }
                    tree.leadingComments = comments;
                }
                return tree;
            }
    
            for (i = 0, len = providedComments.length; i < len; i += 1) {
                comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
            }
    
            // This is based on John Freeman's implementation.
            cursor = 0;
            traverse(tree, {
                enter: function (node) {
                    var comment;
    
                    while (cursor < comments.length) {
                        comment = comments[cursor];
                        if (comment.extendedRange[1] > node.range[0]) {
                            break;
                        }
    
                        if (comment.extendedRange[1] === node.range[0]) {
                            if (!node.leadingComments) {
                                node.leadingComments = [];
                            }
                            node.leadingComments.push(comment);
                            comments.splice(cursor, 1);
                        } else {
                            cursor += 1;
                        }
                    }
    
                    // already out of owned node
                    if (cursor === comments.length) {
                        return VisitorOption.Break;
                    }
    
                    if (comments[cursor].extendedRange[0] > node.range[1]) {
                        return VisitorOption.Skip;
                    }
                }
            });
    
            cursor = 0;
            traverse(tree, {
                leave: function (node) {
                    var comment;
    
                    while (cursor < comments.length) {
                        comment = comments[cursor];
                        if (node.range[1] < comment.extendedRange[0]) {
                            break;
                        }
    
                        if (node.range[1] === comment.extendedRange[0]) {
                            if (!node.trailingComments) {
                                node.trailingComments = [];
                            }
                            node.trailingComments.push(comment);
                            comments.splice(cursor, 1);
                        } else {
                            cursor += 1;
                        }
                    }
    
                    // already out of owned node
                    if (cursor === comments.length) {
                        return VisitorOption.Break;
                    }
    
                    if (comments[cursor].extendedRange[0] > node.range[1]) {
                        return VisitorOption.Skip;
                    }
                }
            });
    
            return tree;
        }
    
        exports.version = require('./package.json').version;
        exports.Syntax = Syntax;
        exports.traverse = traverse;
        exports.replace = replace;
        exports.attachComments = attachComments;
        exports.VisitorKeys = VisitorKeys;
        exports.VisitorOption = VisitorOption;
        exports.Controller = Controller;
        exports.cloneEnvironment = function () { return clone({}); };
    
        return exports;
    }(exports));
    /* vim: set sw=4 ts=4 et tw=80 : */
    
  provide("estraverse", module.exports);
}(global));

// pakmanager:esutils/code
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
      Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    
    (function () {
        'use strict';
    
        var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
    
        // See `tools/generate-identifier-regex.js`.
        ES5Regex = {
            // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
            NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
        };
    
        ES6Regex = {
            // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
            // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        };
    
        function isDecimalDigit(ch) {
            return 0x30 <= ch && ch <= 0x39;  // 0..9
        }
    
        function isHexDigit(ch) {
            return 0x30 <= ch && ch <= 0x39 ||  // 0..9
                0x61 <= ch && ch <= 0x66 ||     // a..f
                0x41 <= ch && ch <= 0x46;       // A..F
        }
    
        function isOctalDigit(ch) {
            return ch >= 0x30 && ch <= 0x37;  // 0..7
        }
    
        // 7.2 White Space
    
        NON_ASCII_WHITESPACES = [
            0x1680, 0x180E,
            0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
            0x202F, 0x205F,
            0x3000,
            0xFEFF
        ];
    
        function isWhiteSpace(ch) {
            return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
                ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
        }
    
        // 7.3 Line Terminators
    
        function isLineTerminator(ch) {
            return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
        }
    
        // 7.6 Identifier Names and Identifiers
    
        function fromCodePoint(cp) {
            if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
            var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
            var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
            return cu1 + cu2;
        }
    
        IDENTIFIER_START = new Array(0x80);
        for(ch = 0; ch < 0x80; ++ch) {
            IDENTIFIER_START[ch] =
                ch >= 0x61 && ch <= 0x7A ||  // a..z
                ch >= 0x41 && ch <= 0x5A ||  // A..Z
                ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
        }
    
        IDENTIFIER_PART = new Array(0x80);
        for(ch = 0; ch < 0x80; ++ch) {
            IDENTIFIER_PART[ch] =
                ch >= 0x61 && ch <= 0x7A ||  // a..z
                ch >= 0x41 && ch <= 0x5A ||  // A..Z
                ch >= 0x30 && ch <= 0x39 ||  // 0..9
                ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
        }
    
        function isIdentifierStartES5(ch) {
            return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
        }
    
        function isIdentifierPartES5(ch) {
            return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
        }
    
        function isIdentifierStartES6(ch) {
            return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
        }
    
        function isIdentifierPartES6(ch) {
            return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
        }
    
        module.exports = {
            isDecimalDigit: isDecimalDigit,
            isHexDigit: isHexDigit,
            isOctalDigit: isOctalDigit,
            isWhiteSpace: isWhiteSpace,
            isLineTerminator: isLineTerminator,
            isIdentifierStartES5: isIdentifierStartES5,
            isIdentifierPartES5: isIdentifierPartES5,
            isIdentifierStartES6: isIdentifierStartES6,
            isIdentifierPartES6: isIdentifierPartES6
        };
    }());
    /* vim: set sw=4 ts=4 et tw=80 : */
    
  provide("esutils/code", module.exports);
}(global));

// pakmanager:esutils/ast
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    
    (function () {
        'use strict';
    
        function isExpression(node) {
            if (node == null) { return false; }
            switch (node.type) {
                case 'ArrayExpression':
                case 'AssignmentExpression':
                case 'BinaryExpression':
                case 'CallExpression':
                case 'ConditionalExpression':
                case 'FunctionExpression':
                case 'Identifier':
                case 'Literal':
                case 'LogicalExpression':
                case 'MemberExpression':
                case 'NewExpression':
                case 'ObjectExpression':
                case 'SequenceExpression':
                case 'ThisExpression':
                case 'UnaryExpression':
                case 'UpdateExpression':
                    return true;
            }
            return false;
        }
    
        function isIterationStatement(node) {
            if (node == null) { return false; }
            switch (node.type) {
                case 'DoWhileStatement':
                case 'ForInStatement':
                case 'ForStatement':
                case 'WhileStatement':
                    return true;
            }
            return false;
        }
    
        function isStatement(node) {
            if (node == null) { return false; }
            switch (node.type) {
                case 'BlockStatement':
                case 'BreakStatement':
                case 'ContinueStatement':
                case 'DebuggerStatement':
                case 'DoWhileStatement':
                case 'EmptyStatement':
                case 'ExpressionStatement':
                case 'ForInStatement':
                case 'ForStatement':
                case 'IfStatement':
                case 'LabeledStatement':
                case 'ReturnStatement':
                case 'SwitchStatement':
                case 'ThrowStatement':
                case 'TryStatement':
                case 'VariableDeclaration':
                case 'WhileStatement':
                case 'WithStatement':
                    return true;
            }
            return false;
        }
    
        function isSourceElement(node) {
          return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
        }
    
        function trailingStatement(node) {
            switch (node.type) {
            case 'IfStatement':
                if (node.alternate != null) {
                    return node.alternate;
                }
                return node.consequent;
    
            case 'LabeledStatement':
            case 'ForStatement':
            case 'ForInStatement':
            case 'WhileStatement':
            case 'WithStatement':
                return node.body;
            }
            return null;
        }
    
        function isProblematicIfStatement(node) {
            var current;
    
            if (node.type !== 'IfStatement') {
                return false;
            }
            if (node.alternate == null) {
                return false;
            }
            current = node.consequent;
            do {
                if (current.type === 'IfStatement') {
                    if (current.alternate == null)  {
                        return true;
                    }
                }
                current = trailingStatement(current);
            } while (current);
    
            return false;
        }
    
        module.exports = {
            isExpression: isExpression,
            isStatement: isStatement,
            isIterationStatement: isIterationStatement,
            isSourceElement: isSourceElement,
            isProblematicIfStatement: isProblematicIfStatement,
    
            trailingStatement: trailingStatement
        };
    }());
    /* vim: set sw=4 ts=4 et tw=80 : */
    
  provide("esutils/ast", module.exports);
}(global));

// pakmanager:esutils/keyword
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    
    (function () {
        'use strict';
    
        var code =  require('esutils/code');
    
        function isStrictModeReservedWordES6(id) {
            switch (id) {
            case 'implements':
            case 'interface':
            case 'package':
            case 'private':
            case 'protected':
            case 'public':
            case 'static':
            case 'let':
                return true;
            default:
                return false;
            }
        }
    
        function isKeywordES5(id, strict) {
            // yield should not be treated as keyword under non-strict mode.
            if (!strict && id === 'yield') {
                return false;
            }
            return isKeywordES6(id, strict);
        }
    
        function isKeywordES6(id, strict) {
            if (strict && isStrictModeReservedWordES6(id)) {
                return true;
            }
    
            switch (id.length) {
            case 2:
                return (id === 'if') || (id === 'in') || (id === 'do');
            case 3:
                return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
            case 4:
                return (id === 'this') || (id === 'else') || (id === 'case') ||
                    (id === 'void') || (id === 'with') || (id === 'enum');
            case 5:
                return (id === 'while') || (id === 'break') || (id === 'catch') ||
                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
                    (id === 'class') || (id === 'super');
            case 6:
                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                    (id === 'switch') || (id === 'export') || (id === 'import');
            case 7:
                return (id === 'default') || (id === 'finally') || (id === 'extends');
            case 8:
                return (id === 'function') || (id === 'continue') || (id === 'debugger');
            case 10:
                return (id === 'instanceof');
            default:
                return false;
            }
        }
    
        function isReservedWordES5(id, strict) {
            return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
        }
    
        function isReservedWordES6(id, strict) {
            return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
        }
    
        function isRestrictedWord(id) {
            return id === 'eval' || id === 'arguments';
        }
    
        function isIdentifierNameES5(id) {
            var i, iz, ch;
    
            if (id.length === 0) { return false; }
    
            ch = id.charCodeAt(0);
            if (!code.isIdentifierStartES5(ch)) {
                return false;
            }
    
            for (i = 1, iz = id.length; i < iz; ++i) {
                ch = id.charCodeAt(i);
                if (!code.isIdentifierPartES5(ch)) {
                    return false;
                }
            }
            return true;
        }
    
        function decodeUtf16(lead, trail) {
            return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
        }
    
        function isIdentifierNameES6(id) {
            var i, iz, ch, lowCh, check;
    
            if (id.length === 0) { return false; }
    
            check = code.isIdentifierStartES6;
            for (i = 0, iz = id.length; i < iz; ++i) {
                ch = id.charCodeAt(i);
                if (0xD800 <= ch && ch <= 0xDBFF) {
                    ++i;
                    if (i >= iz) { return false; }
                    lowCh = id.charCodeAt(i);
                    if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                        return false;
                    }
                    ch = decodeUtf16(ch, lowCh);
                }
                if (!check(ch)) {
                    return false;
                }
                check = code.isIdentifierPartES6;
            }
            return true;
        }
    
        function isIdentifierES5(id, strict) {
            return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
        }
    
        function isIdentifierES6(id, strict) {
            return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
        }
    
        module.exports = {
            isKeywordES5: isKeywordES5,
            isKeywordES6: isKeywordES6,
            isReservedWordES5: isReservedWordES5,
            isReservedWordES6: isReservedWordES6,
            isRestrictedWord: isRestrictedWord,
            isIdentifierNameES5: isIdentifierNameES5,
            isIdentifierNameES6: isIdentifierNameES6,
            isIdentifierES5: isIdentifierES5,
            isIdentifierES6: isIdentifierES6
        };
    }());
    /* vim: set sw=4 ts=4 et tw=80 : */
    
  provide("esutils/keyword", module.exports);
}(global));

// pakmanager:esutils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    
    
    (function () {
        'use strict';
    
        exports.ast =  require('esutils/ast');
        exports.code =  require('esutils/code');
        exports.keyword =  require('esutils/keyword');
    }());
    /* vim: set sw=4 ts=4 et tw=80 : */
    
  provide("esutils", module.exports);
}(global));

// pakmanager:esprima
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    
    (function (root, factory) {
        'use strict';
    
        // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
        // Rhino, and plain browser loading.
    
        /* istanbul ignore next */
        if (typeof define === 'function' && define.amd) {
            define(['exports'], factory);
        } else if (typeof exports !== 'undefined') {
            factory(exports);
        } else {
            factory((root.esprima = {}));
        }
    }(this, function (exports) {
        'use strict';
    
        var Token,
            TokenName,
            FnExprTokens,
            Syntax,
            PlaceHolders,
            Messages,
            Regex,
            source,
            strict,
            index,
            lineNumber,
            lineStart,
            hasLineTerminator,
            lastIndex,
            lastLineNumber,
            lastLineStart,
            startIndex,
            startLineNumber,
            startLineStart,
            scanning,
            length,
            lookahead,
            state,
            extra,
            isBindingElement,
            isAssignmentTarget,
            firstCoverInitializedNameError;
    
        Token = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9,
            Template: 10
        };
    
        TokenName = {};
        TokenName[Token.BooleanLiteral] = 'Boolean';
        TokenName[Token.EOF] = '<end>';
        TokenName[Token.Identifier] = 'Identifier';
        TokenName[Token.Keyword] = 'Keyword';
        TokenName[Token.NullLiteral] = 'Null';
        TokenName[Token.NumericLiteral] = 'Numeric';
        TokenName[Token.Punctuator] = 'Punctuator';
        TokenName[Token.StringLiteral] = 'String';
        TokenName[Token.RegularExpression] = 'RegularExpression';
        TokenName[Token.Template] = 'Template';
    
        // A function following one of those tokens is an expression.
        FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                        'return', 'case', 'delete', 'throw', 'void',
                        // assignment operators
                        '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                        '&=', '|=', '^=', ',',
                        // binary/unary operators
                        '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                        '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                        '<=', '<', '>', '!=', '!=='];
    
        Syntax = {
            AssignmentExpression: 'AssignmentExpression',
            AssignmentPattern: 'AssignmentPattern',
            ArrayExpression: 'ArrayExpression',
            ArrayPattern: 'ArrayPattern',
            ArrowFunctionExpression: 'ArrowFunctionExpression',
            BlockStatement: 'BlockStatement',
            BinaryExpression: 'BinaryExpression',
            BreakStatement: 'BreakStatement',
            CallExpression: 'CallExpression',
            CatchClause: 'CatchClause',
            ClassBody: 'ClassBody',
            ClassDeclaration: 'ClassDeclaration',
            ClassExpression: 'ClassExpression',
            ConditionalExpression: 'ConditionalExpression',
            ContinueStatement: 'ContinueStatement',
            DoWhileStatement: 'DoWhileStatement',
            DebuggerStatement: 'DebuggerStatement',
            EmptyStatement: 'EmptyStatement',
            ExportAllDeclaration: 'ExportAllDeclaration',
            ExportDefaultDeclaration: 'ExportDefaultDeclaration',
            ExportNamedDeclaration: 'ExportNamedDeclaration',
            ExportSpecifier: 'ExportSpecifier',
            ExpressionStatement: 'ExpressionStatement',
            ForStatement: 'ForStatement',
            ForOfStatement: 'ForOfStatement',
            ForInStatement: 'ForInStatement',
            FunctionDeclaration: 'FunctionDeclaration',
            FunctionExpression: 'FunctionExpression',
            Identifier: 'Identifier',
            IfStatement: 'IfStatement',
            ImportDeclaration: 'ImportDeclaration',
            ImportDefaultSpecifier: 'ImportDefaultSpecifier',
            ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
            ImportSpecifier: 'ImportSpecifier',
            Literal: 'Literal',
            LabeledStatement: 'LabeledStatement',
            LogicalExpression: 'LogicalExpression',
            MemberExpression: 'MemberExpression',
            MetaProperty: 'MetaProperty',
            MethodDefinition: 'MethodDefinition',
            NewExpression: 'NewExpression',
            ObjectExpression: 'ObjectExpression',
            ObjectPattern: 'ObjectPattern',
            Program: 'Program',
            Property: 'Property',
            RestElement: 'RestElement',
            ReturnStatement: 'ReturnStatement',
            SequenceExpression: 'SequenceExpression',
            SpreadElement: 'SpreadElement',
            Super: 'Super',
            SwitchCase: 'SwitchCase',
            SwitchStatement: 'SwitchStatement',
            TaggedTemplateExpression: 'TaggedTemplateExpression',
            TemplateElement: 'TemplateElement',
            TemplateLiteral: 'TemplateLiteral',
            ThisExpression: 'ThisExpression',
            ThrowStatement: 'ThrowStatement',
            TryStatement: 'TryStatement',
            UnaryExpression: 'UnaryExpression',
            UpdateExpression: 'UpdateExpression',
            VariableDeclaration: 'VariableDeclaration',
            VariableDeclarator: 'VariableDeclarator',
            WhileStatement: 'WhileStatement',
            WithStatement: 'WithStatement',
            YieldExpression: 'YieldExpression'
        };
    
        PlaceHolders = {
            ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
        };
    
        // Error messages should be identical to V8.
        Messages = {
            UnexpectedToken: 'Unexpected token %0',
            UnexpectedNumber: 'Unexpected number',
            UnexpectedString: 'Unexpected string',
            UnexpectedIdentifier: 'Unexpected identifier',
            UnexpectedReserved: 'Unexpected reserved word',
            UnexpectedTemplate: 'Unexpected quasi %0',
            UnexpectedEOS: 'Unexpected end of input',
            NewlineAfterThrow: 'Illegal newline after throw',
            InvalidRegExp: 'Invalid regular expression',
            UnterminatedRegExp: 'Invalid regular expression: missing /',
            InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
            InvalidLHSInForIn: 'Invalid left-hand side in for-in',
            InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
            MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
            NoCatchOrFinally: 'Missing catch or finally after try',
            UnknownLabel: 'Undefined label \'%0\'',
            Redeclaration: '%0 \'%1\' has already been declared',
            IllegalContinue: 'Illegal continue statement',
            IllegalBreak: 'Illegal break statement',
            IllegalReturn: 'Illegal return statement',
            StrictModeWith: 'Strict mode code may not include a with statement',
            StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
            StrictVarName: 'Variable name may not be eval or arguments in strict mode',
            StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
            StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
            StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
            StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
            StrictDelete: 'Delete of an unqualified identifier in strict mode.',
            StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
            StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
            StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
            StrictReservedWord: 'Use of future reserved word in strict mode',
            TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
            ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
            DefaultRestParameter: 'Unexpected token =',
            ObjectPatternAsRestParameter: 'Unexpected token {',
            DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
            ConstructorSpecialMethod: 'Class constructor may not be an accessor',
            DuplicateConstructor: 'A class may only have one constructor',
            StaticPrototype: 'Classes may not have static property named prototype',
            MissingFromClause: 'Unexpected token',
            NoAsAfterImportNamespace: 'Unexpected token',
            InvalidModuleSpecifier: 'Unexpected token',
            IllegalImportDeclaration: 'Unexpected token',
            IllegalExportDeclaration: 'Unexpected token',
            DuplicateBinding: 'Duplicate binding %0'
        };
    
        // See also tools/generate-unicode-regex.js.
        Regex = {
            // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
    
            // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        };
    
        // Ensure the condition is true, otherwise throw an error.
        // This is only to have a better contract semantic, i.e. another safety net
        // to catch a logic error. The condition shall be fulfilled in normal case.
        // Do NOT use this to enforce a certain condition on any user input.
    
        function assert(condition, message) {
            /* istanbul ignore if */
            if (!condition) {
                throw new Error('ASSERT: ' + message);
            }
        }
    
        function isDecimalDigit(ch) {
            return (ch >= 0x30 && ch <= 0x39);   // 0..9
        }
    
        function isHexDigit(ch) {
            return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
        }
    
        function isOctalDigit(ch) {
            return '01234567'.indexOf(ch) >= 0;
        }
    
        function octalToDecimal(ch) {
            // \0 is not octal escape sequence
            var octal = (ch !== '0'), code = '01234567'.indexOf(ch);
    
            if (index < length && isOctalDigit(source[index])) {
                octal = true;
                code = code * 8 + '01234567'.indexOf(source[index++]);
    
                // 3 digits are only allowed when string starts
                // with 0, 1, 2, 3
                if ('0123'.indexOf(ch) >= 0 &&
                        index < length &&
                        isOctalDigit(source[index])) {
                    code = code * 8 + '01234567'.indexOf(source[index++]);
                }
            }
    
            return {
                code: code,
                octal: octal
            };
        }
    
        // ECMA-262 11.2 White Space
    
        function isWhiteSpace(ch) {
            return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
                (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
        }
    
        // ECMA-262 11.3 Line Terminators
    
        function isLineTerminator(ch) {
            return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
        }
    
        // ECMA-262 11.6 Identifier Names and Identifiers
    
        function fromCodePoint(cp) {
            return (cp < 0x10000) ? String.fromCharCode(cp) :
                String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
        }
    
        function isIdentifierStart(ch) {
            return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
                (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
                (ch >= 0x61 && ch <= 0x7A) ||         // a..z
                (ch === 0x5C) ||                      // \ (backslash)
                ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
        }
    
        function isIdentifierPart(ch) {
            return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
                (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
                (ch >= 0x61 && ch <= 0x7A) ||         // a..z
                (ch >= 0x30 && ch <= 0x39) ||         // 0..9
                (ch === 0x5C) ||                      // \ (backslash)
                ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
        }
    
        // ECMA-262 11.6.2.2 Future Reserved Words
    
        function isFutureReservedWord(id) {
            switch (id) {
            case 'enum':
            case 'export':
            case 'import':
            case 'super':
                return true;
            default:
                return false;
            }
        }
    
        function isStrictModeReservedWord(id) {
            switch (id) {
            case 'implements':
            case 'interface':
            case 'package':
            case 'private':
            case 'protected':
            case 'public':
            case 'static':
            case 'yield':
            case 'let':
                return true;
            default:
                return false;
            }
        }
    
        function isRestrictedWord(id) {
            return id === 'eval' || id === 'arguments';
        }
    
        // ECMA-262 11.6.2.1 Keywords
    
        function isKeyword(id) {
    
            // 'const' is specialized as Keyword in V8.
            // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.
            // Some others are from future reserved words.
    
            switch (id.length) {
            case 2:
                return (id === 'if') || (id === 'in') || (id === 'do');
            case 3:
                return (id === 'var') || (id === 'for') || (id === 'new') ||
                    (id === 'try') || (id === 'let');
            case 4:
                return (id === 'this') || (id === 'else') || (id === 'case') ||
                    (id === 'void') || (id === 'with') || (id === 'enum');
            case 5:
                return (id === 'while') || (id === 'break') || (id === 'catch') ||
                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
                    (id === 'class') || (id === 'super');
            case 6:
                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                    (id === 'switch') || (id === 'export') || (id === 'import');
            case 7:
                return (id === 'default') || (id === 'finally') || (id === 'extends');
            case 8:
                return (id === 'function') || (id === 'continue') || (id === 'debugger');
            case 10:
                return (id === 'instanceof');
            default:
                return false;
            }
        }
    
        // ECMA-262 11.4 Comments
    
        function addComment(type, value, start, end, loc) {
            var comment;
    
            assert(typeof start === 'number', 'Comment must have valid position');
    
            state.lastCommentStart = start;
    
            comment = {
                type: type,
                value: value
            };
            if (extra.range) {
                comment.range = [start, end];
            }
            if (extra.loc) {
                comment.loc = loc;
            }
            extra.comments.push(comment);
            if (extra.attachComment) {
                extra.leadingComments.push(comment);
                extra.trailingComments.push(comment);
            }
        }
    
        function skipSingleLineComment(offset) {
            var start, loc, ch, comment;
    
            start = index - offset;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - offset
                }
            };
    
            while (index < length) {
                ch = source.charCodeAt(index);
                ++index;
                if (isLineTerminator(ch)) {
                    hasLineTerminator = true;
                    if (extra.comments) {
                        comment = source.slice(start + offset, index - 1);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart - 1
                        };
                        addComment('Line', comment, start, index - 1, loc);
                    }
                    if (ch === 13 && source.charCodeAt(index) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    return;
                }
            }
    
            if (extra.comments) {
                comment = source.slice(start + offset, index);
                loc.end = {
                    line: lineNumber,
                    column: index - lineStart
                };
                addComment('Line', comment, start, index, loc);
            }
        }
    
        function skipMultiLineComment() {
            var start, loc, ch, comment;
    
            if (extra.comments) {
                start = index - 2;
                loc = {
                    start: {
                        line: lineNumber,
                        column: index - lineStart - 2
                    }
                };
            }
    
            while (index < length) {
                ch = source.charCodeAt(index);
                if (isLineTerminator(ch)) {
                    if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                        ++index;
                    }
                    hasLineTerminator = true;
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                } else if (ch === 0x2A) {
                    // Block comment ends with '*/'.
                    if (source.charCodeAt(index + 1) === 0x2F) {
                        ++index;
                        ++index;
                        if (extra.comments) {
                            comment = source.slice(start + 2, index - 2);
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            addComment('Block', comment, start, index, loc);
                        }
                        return;
                    }
                    ++index;
                } else {
                    ++index;
                }
            }
    
            // Ran off the end of the file - the whole thing is a comment
            if (extra.comments) {
                loc.end = {
                    line: lineNumber,
                    column: index - lineStart
                };
                comment = source.slice(start + 2, index);
                addComment('Block', comment, start, index, loc);
            }
            tolerateUnexpectedToken();
        }
    
        function skipComment() {
            var ch, start;
            hasLineTerminator = false;
    
            start = (index === 0);
            while (index < length) {
                ch = source.charCodeAt(index);
    
                if (isWhiteSpace(ch)) {
                    ++index;
                } else if (isLineTerminator(ch)) {
                    hasLineTerminator = true;
                    ++index;
                    if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    start = true;
                } else if (ch === 0x2F) { // U+002F is '/'
                    ch = source.charCodeAt(index + 1);
                    if (ch === 0x2F) {
                        ++index;
                        ++index;
                        skipSingleLineComment(2);
                        start = true;
                    } else if (ch === 0x2A) {  // U+002A is '*'
                        ++index;
                        ++index;
                        skipMultiLineComment();
                    } else {
                        break;
                    }
                } else if (start && ch === 0x2D) { // U+002D is '-'
                    // U+003E is '>'
                    if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                        // '-->' is a single-line comment
                        index += 3;
                        skipSingleLineComment(3);
                    } else {
                        break;
                    }
                } else if (ch === 0x3C) { // U+003C is '<'
                    if (source.slice(index + 1, index + 4) === '!--') {
                        ++index; // `<`
                        ++index; // `!`
                        ++index; // `-`
                        ++index; // `-`
                        skipSingleLineComment(4);
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
        }
    
        function scanHexEscape(prefix) {
            var i, len, ch, code = 0;
    
            len = (prefix === 'u') ? 4 : 2;
            for (i = 0; i < len; ++i) {
                if (index < length && isHexDigit(source[index])) {
                    ch = source[index++];
                    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
                } else {
                    return '';
                }
            }
            return String.fromCharCode(code);
        }
    
        function scanUnicodeCodePointEscape() {
            var ch, code;
    
            ch = source[index];
            code = 0;
    
            // At least, one hex digit is required.
            if (ch === '}') {
                throwUnexpectedToken();
            }
    
            while (index < length) {
                ch = source[index++];
                if (!isHexDigit(ch)) {
                    break;
                }
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            }
    
            if (code > 0x10FFFF || ch !== '}') {
                throwUnexpectedToken();
            }
    
            return fromCodePoint(code);
        }
    
        function codePointAt(i) {
            var cp, first, second;
    
            cp = source.charCodeAt(i);
            if (cp >= 0xD800 && cp <= 0xDBFF) {
                second = source.charCodeAt(i + 1);
                if (second >= 0xDC00 && second <= 0xDFFF) {
                    first = cp;
                    cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                }
            }
    
            return cp;
        }
    
        function getComplexIdentifier() {
            var cp, ch, id;
    
            cp = codePointAt(index);
            id = fromCodePoint(cp);
            index += id.length;
    
            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (cp === 0x5C) {
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                if (source[index] === '{') {
                    ++index;
                    ch = scanUnicodeCodePointEscape();
                } else {
                    ch = scanHexEscape('u');
                    cp = ch.charCodeAt(0);
                    if (!ch || ch === '\\' || !isIdentifierStart(cp)) {
                        throwUnexpectedToken();
                    }
                }
                id = ch;
            }
    
            while (index < length) {
                cp = codePointAt(index);
                if (!isIdentifierPart(cp)) {
                    break;
                }
                ch = fromCodePoint(cp);
                id += ch;
                index += ch.length;
    
                // '\u' (U+005C, U+0075) denotes an escaped character.
                if (cp === 0x5C) {
                    id = id.substr(0, id.length - 1);
                    if (source.charCodeAt(index) !== 0x75) {
                        throwUnexpectedToken();
                    }
                    ++index;
                    if (source[index] === '{') {
                        ++index;
                        ch = scanUnicodeCodePointEscape();
                    } else {
                        ch = scanHexEscape('u');
                        cp = ch.charCodeAt(0);
                        if (!ch || ch === '\\' || !isIdentifierPart(cp)) {
                            throwUnexpectedToken();
                        }
                    }
                    id += ch;
                }
            }
    
            return id;
        }
    
        function getIdentifier() {
            var start, ch;
    
            start = index++;
            while (index < length) {
                ch = source.charCodeAt(index);
                if (ch === 0x5C) {
                    // Blackslash (U+005C) marks Unicode escape sequence.
                    index = start;
                    return getComplexIdentifier();
                } else if (ch >= 0xD800 && ch < 0xDFFF) {
                    // Need to handle surrogate pairs.
                    index = start;
                    return getComplexIdentifier();
                }
                if (isIdentifierPart(ch)) {
                    ++index;
                } else {
                    break;
                }
            }
    
            return source.slice(start, index);
        }
    
        function scanIdentifier() {
            var start, id, type;
    
            start = index;
    
            // Backslash (U+005C) starts an escaped character.
            id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();
    
            // There is no keyword or literal with only one character.
            // Thus, it must be an identifier.
            if (id.length === 1) {
                type = Token.Identifier;
            } else if (isKeyword(id)) {
                type = Token.Keyword;
            } else if (id === 'null') {
                type = Token.NullLiteral;
            } else if (id === 'true' || id === 'false') {
                type = Token.BooleanLiteral;
            } else {
                type = Token.Identifier;
            }
    
            return {
                type: type,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
    
    
        // ECMA-262 11.7 Punctuators
    
        function scanPunctuator() {
            var token, str;
    
            token = {
                type: Token.Punctuator,
                value: '',
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
    
            // Check for most common single-character punctuators.
            str = source[index];
            switch (str) {
    
            case '(':
                if (extra.tokenize) {
                    extra.openParenToken = extra.tokens.length;
                }
                ++index;
                break;
    
            case '{':
                if (extra.tokenize) {
                    extra.openCurlyToken = extra.tokens.length;
                }
                state.curlyStack.push('{');
                ++index;
                break;
    
            case '.':
                ++index;
                if (source[index] === '.' && source[index + 1] === '.') {
                    // Spread operator: ...
                    index += 2;
                    str = '...';
                }
                break;
    
            case '}':
                ++index;
                state.curlyStack.pop();
                break;
            case ')':
            case ';':
            case ',':
            case '[':
            case ']':
            case ':':
            case '?':
            case '~':
                ++index;
                break;
    
            default:
                // 4-character punctuator.
                str = source.substr(index, 4);
                if (str === '>>>=') {
                    index += 4;
                } else {
    
                    // 3-character punctuators.
                    str = str.substr(0, 3);
                    if (str === '===' || str === '!==' || str === '>>>' ||
                        str === '<<=' || str === '>>=') {
                        index += 3;
                    } else {
    
                        // 2-character punctuators.
                        str = str.substr(0, 2);
                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                            str === '<=' || str === '>=' || str === '=>') {
                            index += 2;
                        } else {
    
                            // 1-character punctuators.
                            str = source[index];
                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                                ++index;
                            }
                        }
                    }
                }
            }
    
            if (index === token.start) {
                throwUnexpectedToken();
            }
    
            token.end = index;
            token.value = str;
            return token;
        }
    
        // ECMA-262 11.8.3 Numeric Literals
    
        function scanHexLiteral(start) {
            var number = '';
    
            while (index < length) {
                if (!isHexDigit(source[index])) {
                    break;
                }
                number += source[index++];
            }
    
            if (number.length === 0) {
                throwUnexpectedToken();
            }
    
            if (isIdentifierStart(source.charCodeAt(index))) {
                throwUnexpectedToken();
            }
    
            return {
                type: Token.NumericLiteral,
                value: parseInt('0x' + number, 16),
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
    
        function scanBinaryLiteral(start) {
            var ch, number;
    
            number = '';
    
            while (index < length) {
                ch = source[index];
                if (ch !== '0' && ch !== '1') {
                    break;
                }
                number += source[index++];
            }
    
            if (number.length === 0) {
                // only 0b or 0B
                throwUnexpectedToken();
            }
    
            if (index < length) {
                ch = source.charCodeAt(index);
                /* istanbul ignore else */
                if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                    throwUnexpectedToken();
                }
            }
    
            return {
                type: Token.NumericLiteral,
                value: parseInt(number, 2),
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
    
        function scanOctalLiteral(prefix, start) {
            var number, octal;
    
            if (isOctalDigit(prefix)) {
                octal = true;
                number = '0' + source[index++];
            } else {
                octal = false;
                ++index;
                number = '';
            }
    
            while (index < length) {
                if (!isOctalDigit(source[index])) {
                    break;
                }
                number += source[index++];
            }
    
            if (!octal && number.length === 0) {
                // only 0o or 0O
                throwUnexpectedToken();
            }
    
            if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
                throwUnexpectedToken();
            }
    
            return {
                type: Token.NumericLiteral,
                value: parseInt(number, 8),
                octal: octal,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
    
        function isImplicitOctalLiteral() {
            var i, ch;
    
            // Implicit octal, unless there is a non-octal digit.
            // (Annex B.1.1 on Numeric Literals)
            for (i = index + 1; i < length; ++i) {
                ch = source[i];
                if (ch === '8' || ch === '9') {
                    return false;
                }
                if (!isOctalDigit(ch)) {
                    return true;
                }
            }
    
            return true;
        }
    
        function scanNumericLiteral() {
            var number, start, ch;
    
            ch = source[index];
            assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
                'Numeric literal must start with a decimal digit or a decimal point');
    
            start = index;
            number = '';
            if (ch !== '.') {
                number = source[index++];
                ch = source[index];
    
                // Hex number starts with '0x'.
                // Octal number starts with '0'.
                // Octal number in ES6 starts with '0o'.
                // Binary number in ES6 starts with '0b'.
                if (number === '0') {
                    if (ch === 'x' || ch === 'X') {
                        ++index;
                        return scanHexLiteral(start);
                    }
                    if (ch === 'b' || ch === 'B') {
                        ++index;
                        return scanBinaryLiteral(start);
                    }
                    if (ch === 'o' || ch === 'O') {
                        return scanOctalLiteral(ch, start);
                    }
    
                    if (isOctalDigit(ch)) {
                        if (isImplicitOctalLiteral()) {
                            return scanOctalLiteral(ch, start);
                        }
                    }
                }
    
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
                ch = source[index];
            }
    
            if (ch === '.') {
                number += source[index++];
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
                ch = source[index];
            }
    
            if (ch === 'e' || ch === 'E') {
                number += source[index++];
    
                ch = source[index];
                if (ch === '+' || ch === '-') {
                    number += source[index++];
                }
                if (isDecimalDigit(source.charCodeAt(index))) {
                    while (isDecimalDigit(source.charCodeAt(index))) {
                        number += source[index++];
                    }
                } else {
                    throwUnexpectedToken();
                }
            }
    
            if (isIdentifierStart(source.charCodeAt(index))) {
                throwUnexpectedToken();
            }
    
            return {
                type: Token.NumericLiteral,
                value: parseFloat(number),
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
    
        // ECMA-262 11.8.4 String Literals
    
        function scanStringLiteral() {
            var str = '', quote, start, ch, unescaped, octToDec, octal = false;
    
            quote = source[index];
            assert((quote === '\'' || quote === '"'),
                'String literal must starts with a quote');
    
            start = index;
            ++index;
    
            while (index < length) {
                ch = source[index++];
    
                if (ch === quote) {
                    quote = '';
                    break;
                } else if (ch === '\\') {
                    ch = source[index++];
                    if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                        switch (ch) {
                        case 'u':
                        case 'x':
                            if (source[index] === '{') {
                                ++index;
                                str += scanUnicodeCodePointEscape();
                            } else {
                                unescaped = scanHexEscape(ch);
                                if (!unescaped) {
                                    throw throwUnexpectedToken();
                                }
                                str += unescaped;
                            }
                            break;
                        case 'n':
                            str += '\n';
                            break;
                        case 'r':
                            str += '\r';
                            break;
                        case 't':
                            str += '\t';
                            break;
                        case 'b':
                            str += '\b';
                            break;
                        case 'f':
                            str += '\f';
                            break;
                        case 'v':
                            str += '\x0B';
                            break;
                        case '8':
                        case '9':
                            str += ch;
                            tolerateUnexpectedToken();
                            break;
    
                        default:
                            if (isOctalDigit(ch)) {
                                octToDec = octalToDecimal(ch);
    
                                octal = octToDec.octal || octal;
                                str += String.fromCharCode(octToDec.code);
                            } else {
                                str += ch;
                            }
                            break;
                        }
                    } else {
                        ++lineNumber;
                        if (ch === '\r' && source[index] === '\n') {
                            ++index;
                        }
                        lineStart = index;
                    }
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    break;
                } else {
                    str += ch;
                }
            }
    
            if (quote !== '') {
                throwUnexpectedToken();
            }
    
            return {
                type: Token.StringLiteral,
                value: str,
                octal: octal,
                lineNumber: startLineNumber,
                lineStart: startLineStart,
                start: start,
                end: index
            };
        }
    
        // ECMA-262 11.8.6 Template Literal Lexical Components
    
        function scanTemplate() {
            var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;
    
            terminated = false;
            tail = false;
            start = index;
            head = (source[index] === '`');
            rawOffset = 2;
    
            ++index;
    
            while (index < length) {
                ch = source[index++];
                if (ch === '`') {
                    rawOffset = 1;
                    tail = true;
                    terminated = true;
                    break;
                } else if (ch === '$') {
                    if (source[index] === '{') {
                        state.curlyStack.push('${');
                        ++index;
                        terminated = true;
                        break;
                    }
                    cooked += ch;
                } else if (ch === '\\') {
                    ch = source[index++];
                    if (!isLineTerminator(ch.charCodeAt(0))) {
                        switch (ch) {
                        case 'n':
                            cooked += '\n';
                            break;
                        case 'r':
                            cooked += '\r';
                            break;
                        case 't':
                            cooked += '\t';
                            break;
                        case 'u':
                        case 'x':
                            if (source[index] === '{') {
                                ++index;
                                cooked += scanUnicodeCodePointEscape();
                            } else {
                                restore = index;
                                unescaped = scanHexEscape(ch);
                                if (unescaped) {
                                    cooked += unescaped;
                                } else {
                                    index = restore;
                                    cooked += ch;
                                }
                            }
                            break;
                        case 'b':
                            cooked += '\b';
                            break;
                        case 'f':
                            cooked += '\f';
                            break;
                        case 'v':
                            cooked += '\v';
                            break;
    
                        default:
                            if (ch === '0') {
                                if (isDecimalDigit(source.charCodeAt(index))) {
                                    // Illegal: \01 \02 and so on
                                    throwError(Messages.TemplateOctalLiteral);
                                }
                                cooked += '\0';
                            } else if (isOctalDigit(ch)) {
                                // Illegal: \1 \2
                                throwError(Messages.TemplateOctalLiteral);
                            } else {
                                cooked += ch;
                            }
                            break;
                        }
                    } else {
                        ++lineNumber;
                        if (ch === '\r' && source[index] === '\n') {
                            ++index;
                        }
                        lineStart = index;
                    }
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                    cooked += '\n';
                } else {
                    cooked += ch;
                }
            }
    
            if (!terminated) {
                throwUnexpectedToken();
            }
    
            if (!head) {
                state.curlyStack.pop();
            }
    
            return {
                type: Token.Template,
                value: {
                    cooked: cooked,
                    raw: source.slice(start + 1, index - rawOffset)
                },
                head: head,
                tail: tail,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
    
        // ECMA-262 11.8.5 Regular Expression Literals
    
        function testRegExp(pattern, flags) {
            // The BMP character to use as a replacement for astral symbols when
            // translating an ES6 "u"-flagged pattern to an ES5-compatible
            // approximation.
            // Note: replacing with '\uFFFF' enables false positives in unlikely
            // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
            // pattern that would not be detected by this substitution.
            var astralSubstitute = '\uFFFF',
                tmp = pattern;
    
            if (flags.indexOf('u') >= 0) {
                tmp = tmp
                    // Replace every Unicode escape sequence with the equivalent
                    // BMP character or a constant ASCII code point in the case of
                    // astral symbols. (See the above note on `astralSubstitute`
                    // for more information.)
                    .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
                        var codePoint = parseInt($1 || $2, 16);
                        if (codePoint > 0x10FFFF) {
                            throwUnexpectedToken(null, Messages.InvalidRegExp);
                        }
                        if (codePoint <= 0xFFFF) {
                            return String.fromCharCode(codePoint);
                        }
                        return astralSubstitute;
                    })
                    // Replace each paired surrogate with a single ASCII symbol to
                    // avoid throwing on regular expressions that are only valid in
                    // combination with the "u" flag.
                    .replace(
                        /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                        astralSubstitute
                    );
            }
    
            // First, detect invalid regular expressions.
            try {
                RegExp(tmp);
            } catch (e) {
                throwUnexpectedToken(null, Messages.InvalidRegExp);
            }
    
            // Return a regular expression object for this pattern-flag pair, or
            // `null` in case the current environment doesn't support the flags it
            // uses.
            try {
                return new RegExp(pattern, flags);
            } catch (exception) {
                return null;
            }
        }
    
        function scanRegExpBody() {
            var ch, str, classMarker, terminated, body;
    
            ch = source[index];
            assert(ch === '/', 'Regular expression literal must start with a slash');
            str = source[index++];
    
            classMarker = false;
            terminated = false;
            while (index < length) {
                ch = source[index++];
                str += ch;
                if (ch === '\\') {
                    ch = source[index++];
                    // ECMA-262 7.8.5
                    if (isLineTerminator(ch.charCodeAt(0))) {
                        throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                    }
                    str += ch;
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                } else if (classMarker) {
                    if (ch === ']') {
                        classMarker = false;
                    }
                } else {
                    if (ch === '/') {
                        terminated = true;
                        break;
                    } else if (ch === '[') {
                        classMarker = true;
                    }
                }
            }
    
            if (!terminated) {
                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
            }
    
            // Exclude leading and trailing slash.
            body = str.substr(1, str.length - 2);
            return {
                value: body,
                literal: str
            };
        }
    
        function scanRegExpFlags() {
            var ch, str, flags, restore;
    
            str = '';
            flags = '';
            while (index < length) {
                ch = source[index];
                if (!isIdentifierPart(ch.charCodeAt(0))) {
                    break;
                }
    
                ++index;
                if (ch === '\\' && index < length) {
                    ch = source[index];
                    if (ch === 'u') {
                        ++index;
                        restore = index;
                        ch = scanHexEscape('u');
                        if (ch) {
                            flags += ch;
                            for (str += '\\u'; restore < index; ++restore) {
                                str += source[restore];
                            }
                        } else {
                            index = restore;
                            flags += 'u';
                            str += '\\u';
                        }
                        tolerateUnexpectedToken();
                    } else {
                        str += '\\';
                        tolerateUnexpectedToken();
                    }
                } else {
                    flags += ch;
                    str += ch;
                }
            }
    
            return {
                value: flags,
                literal: str
            };
        }
    
        function scanRegExp() {
            var start, body, flags, value;
            scanning = true;
    
            lookahead = null;
            skipComment();
            start = index;
    
            body = scanRegExpBody();
            flags = scanRegExpFlags();
            value = testRegExp(body.value, flags.value);
            scanning = false;
            if (extra.tokenize) {
                return {
                    type: Token.RegularExpression,
                    value: value,
                    regex: {
                        pattern: body.value,
                        flags: flags.value
                    },
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    start: start,
                    end: index
                };
            }
    
            return {
                literal: body.literal + flags.literal,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                start: start,
                end: index
            };
        }
    
        function collectRegex() {
            var pos, loc, regex, token;
    
            skipComment();
    
            pos = index;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
    
            regex = scanRegExp();
    
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
    
            /* istanbul ignore next */
            if (!extra.tokenize) {
                // Pop the previous token, which is likely '/' or '/='
                if (extra.tokens.length > 0) {
                    token = extra.tokens[extra.tokens.length - 1];
                    if (token.range[0] === pos && token.type === 'Punctuator') {
                        if (token.value === '/' || token.value === '/=') {
                            extra.tokens.pop();
                        }
                    }
                }
    
                extra.tokens.push({
                    type: 'RegularExpression',
                    value: regex.literal,
                    regex: regex.regex,
                    range: [pos, index],
                    loc: loc
                });
            }
    
            return regex;
        }
    
        function isIdentifierName(token) {
            return token.type === Token.Identifier ||
                token.type === Token.Keyword ||
                token.type === Token.BooleanLiteral ||
                token.type === Token.NullLiteral;
        }
    
        function advanceSlash() {
            var prevToken,
                checkToken;
            // Using the following algorithm:
            // https://github.com/mozilla/sweet.js/wiki/design
            prevToken = extra.tokens[extra.tokens.length - 1];
            if (!prevToken) {
                // Nothing before that: it cannot be a division.
                return collectRegex();
            }
            if (prevToken.type === 'Punctuator') {
                if (prevToken.value === ']') {
                    return scanPunctuator();
                }
                if (prevToken.value === ')') {
                    checkToken = extra.tokens[extra.openParenToken - 1];
                    if (checkToken &&
                            checkToken.type === 'Keyword' &&
                            (checkToken.value === 'if' ||
                             checkToken.value === 'while' ||
                             checkToken.value === 'for' ||
                             checkToken.value === 'with')) {
                        return collectRegex();
                    }
                    return scanPunctuator();
                }
                if (prevToken.value === '}') {
                    // Dividing a function by anything makes little sense,
                    // but we have to check for that.
                    if (extra.tokens[extra.openCurlyToken - 3] &&
                            extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                        // Anonymous function.
                        checkToken = extra.tokens[extra.openCurlyToken - 4];
                        if (!checkToken) {
                            return scanPunctuator();
                        }
                    } else if (extra.tokens[extra.openCurlyToken - 4] &&
                            extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                        // Named function.
                        checkToken = extra.tokens[extra.openCurlyToken - 5];
                        if (!checkToken) {
                            return collectRegex();
                        }
                    } else {
                        return scanPunctuator();
                    }
                    // checkToken determines whether the function is
                    // a declaration or an expression.
                    if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                        // It is an expression.
                        return scanPunctuator();
                    }
                    // It is a declaration.
                    return collectRegex();
                }
                return collectRegex();
            }
            if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
                return collectRegex();
            }
            return scanPunctuator();
        }
    
        function advance() {
            var cp, token;
    
            if (index >= length) {
                return {
                    type: Token.EOF,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    start: index,
                    end: index
                };
            }
    
            cp = source.charCodeAt(index);
    
            if (isIdentifierStart(cp)) {
                token = scanIdentifier();
                if (strict && isStrictModeReservedWord(token.value)) {
                    token.type = Token.Keyword;
                }
                return token;
            }
    
            // Very common: ( and ) and ;
            if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
                return scanPunctuator();
            }
    
            // String literal starts with single quote (U+0027) or double quote (U+0022).
            if (cp === 0x27 || cp === 0x22) {
                return scanStringLiteral();
            }
    
            // Dot (.) U+002E can also start a floating-point number, hence the need
            // to check the next character.
            if (cp === 0x2E) {
                if (isDecimalDigit(source.charCodeAt(index + 1))) {
                    return scanNumericLiteral();
                }
                return scanPunctuator();
            }
    
            if (isDecimalDigit(cp)) {
                return scanNumericLiteral();
            }
    
            // Slash (/) U+002F can also start a regex.
            if (extra.tokenize && cp === 0x2F) {
                return advanceSlash();
            }
    
            // Template literals start with ` (U+0060) for template head
            // or } (U+007D) for template middle or template tail.
            if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
                return scanTemplate();
            }
    
            // Possible identifier start in a surrogate pair.
            if (cp >= 0xD800 && cp < 0xDFFF) {
                cp = codePointAt(index);
                if (isIdentifierStart(cp)) {
                    return scanIdentifier();
                }
            }
    
            return scanPunctuator();
        }
    
        function collectToken() {
            var loc, token, value, entry;
    
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
    
            token = advance();
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
    
            if (token.type !== Token.EOF) {
                value = source.slice(token.start, token.end);
                entry = {
                    type: TokenName[token.type],
                    value: value,
                    range: [token.start, token.end],
                    loc: loc
                };
                if (token.regex) {
                    entry.regex = {
                        pattern: token.regex.pattern,
                        flags: token.regex.flags
                    };
                }
                extra.tokens.push(entry);
            }
    
            return token;
        }
    
        function lex() {
            var token;
            scanning = true;
    
            lastIndex = index;
            lastLineNumber = lineNumber;
            lastLineStart = lineStart;
    
            skipComment();
    
            token = lookahead;
    
            startIndex = index;
            startLineNumber = lineNumber;
            startLineStart = lineStart;
    
            lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
            scanning = false;
            return token;
        }
    
        function peek() {
            scanning = true;
    
            skipComment();
    
            lastIndex = index;
            lastLineNumber = lineNumber;
            lastLineStart = lineStart;
    
            startIndex = index;
            startLineNumber = lineNumber;
            startLineStart = lineStart;
    
            lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
            scanning = false;
        }
    
        function Position() {
            this.line = startLineNumber;
            this.column = startIndex - startLineStart;
        }
    
        function SourceLocation() {
            this.start = new Position();
            this.end = null;
        }
    
        function WrappingSourceLocation(startToken) {
            this.start = {
                line: startToken.lineNumber,
                column: startToken.start - startToken.lineStart
            };
            this.end = null;
        }
    
        function Node() {
            if (extra.range) {
                this.range = [startIndex, 0];
            }
            if (extra.loc) {
                this.loc = new SourceLocation();
            }
        }
    
        function WrappingNode(startToken) {
            if (extra.range) {
                this.range = [startToken.start, 0];
            }
            if (extra.loc) {
                this.loc = new WrappingSourceLocation(startToken);
            }
        }
    
        WrappingNode.prototype = Node.prototype = {
    
            processComment: function () {
                var lastChild,
                    leadingComments,
                    trailingComments,
                    bottomRight = extra.bottomRightStack,
                    i,
                    comment,
                    last = bottomRight[bottomRight.length - 1];
    
                if (this.type === Syntax.Program) {
                    if (this.body.length > 0) {
                        return;
                    }
                }
    
                if (extra.trailingComments.length > 0) {
                    trailingComments = [];
                    for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                        comment = extra.trailingComments[i];
                        if (comment.range[0] >= this.range[1]) {
                            trailingComments.unshift(comment);
                            extra.trailingComments.splice(i, 1);
                        }
                    }
                    extra.trailingComments = [];
                } else {
                    if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                        trailingComments = last.trailingComments;
                        delete last.trailingComments;
                    }
                }
    
                // Eating the stack.
                while (last && last.range[0] >= this.range[0]) {
                    lastChild = bottomRight.pop();
                    last = bottomRight[bottomRight.length - 1];
                }
    
                if (lastChild) {
                    if (lastChild.leadingComments) {
                        leadingComments = [];
                        for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
                            comment = lastChild.leadingComments[i];
                            if (comment.range[1] <= this.range[0]) {
                                leadingComments.unshift(comment);
                                lastChild.leadingComments.splice(i, 1);
                            }
                        }
    
                        if (!lastChild.leadingComments.length) {
                            lastChild.leadingComments = undefined;
                        }
                    }
                } else if (extra.leadingComments.length > 0) {
                    leadingComments = [];
                    for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                        comment = extra.leadingComments[i];
                        if (comment.range[1] <= this.range[0]) {
                            leadingComments.unshift(comment);
                            extra.leadingComments.splice(i, 1);
                        }
                    }
                }
    
    
                if (leadingComments && leadingComments.length > 0) {
                    this.leadingComments = leadingComments;
                }
                if (trailingComments && trailingComments.length > 0) {
                    this.trailingComments = trailingComments;
                }
    
                bottomRight.push(this);
            },
    
            finish: function () {
                if (extra.range) {
                    this.range[1] = lastIndex;
                }
                if (extra.loc) {
                    this.loc.end = {
                        line: lastLineNumber,
                        column: lastIndex - lastLineStart
                    };
                    if (extra.source) {
                        this.loc.source = extra.source;
                    }
                }
    
                if (extra.attachComment) {
                    this.processComment();
                }
            },
    
            finishArrayExpression: function (elements) {
                this.type = Syntax.ArrayExpression;
                this.elements = elements;
                this.finish();
                return this;
            },
    
            finishArrayPattern: function (elements) {
                this.type = Syntax.ArrayPattern;
                this.elements = elements;
                this.finish();
                return this;
            },
    
            finishArrowFunctionExpression: function (params, defaults, body, expression) {
                this.type = Syntax.ArrowFunctionExpression;
                this.id = null;
                this.params = params;
                this.defaults = defaults;
                this.body = body;
                this.generator = false;
                this.expression = expression;
                this.finish();
                return this;
            },
    
            finishAssignmentExpression: function (operator, left, right) {
                this.type = Syntax.AssignmentExpression;
                this.operator = operator;
                this.left = left;
                this.right = right;
                this.finish();
                return this;
            },
    
            finishAssignmentPattern: function (left, right) {
                this.type = Syntax.AssignmentPattern;
                this.left = left;
                this.right = right;
                this.finish();
                return this;
            },
    
            finishBinaryExpression: function (operator, left, right) {
                this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
                this.operator = operator;
                this.left = left;
                this.right = right;
                this.finish();
                return this;
            },
    
            finishBlockStatement: function (body) {
                this.type = Syntax.BlockStatement;
                this.body = body;
                this.finish();
                return this;
            },
    
            finishBreakStatement: function (label) {
                this.type = Syntax.BreakStatement;
                this.label = label;
                this.finish();
                return this;
            },
    
            finishCallExpression: function (callee, args) {
                this.type = Syntax.CallExpression;
                this.callee = callee;
                this.arguments = args;
                this.finish();
                return this;
            },
    
            finishCatchClause: function (param, body) {
                this.type = Syntax.CatchClause;
                this.param = param;
                this.body = body;
                this.finish();
                return this;
            },
    
            finishClassBody: function (body) {
                this.type = Syntax.ClassBody;
                this.body = body;
                this.finish();
                return this;
            },
    
            finishClassDeclaration: function (id, superClass, body) {
                this.type = Syntax.ClassDeclaration;
                this.id = id;
                this.superClass = superClass;
                this.body = body;
                this.finish();
                return this;
            },
    
            finishClassExpression: function (id, superClass, body) {
                this.type = Syntax.ClassExpression;
                this.id = id;
                this.superClass = superClass;
                this.body = body;
                this.finish();
                return this;
            },
    
            finishConditionalExpression: function (test, consequent, alternate) {
                this.type = Syntax.ConditionalExpression;
                this.test = test;
                this.consequent = consequent;
                this.alternate = alternate;
                this.finish();
                return this;
            },
    
            finishContinueStatement: function (label) {
                this.type = Syntax.ContinueStatement;
                this.label = label;
                this.finish();
                return this;
            },
    
            finishDebuggerStatement: function () {
                this.type = Syntax.DebuggerStatement;
                this.finish();
                return this;
            },
    
            finishDoWhileStatement: function (body, test) {
                this.type = Syntax.DoWhileStatement;
                this.body = body;
                this.test = test;
                this.finish();
                return this;
            },
    
            finishEmptyStatement: function () {
                this.type = Syntax.EmptyStatement;
                this.finish();
                return this;
            },
    
            finishExpressionStatement: function (expression) {
                this.type = Syntax.ExpressionStatement;
                this.expression = expression;
                this.finish();
                return this;
            },
    
            finishForStatement: function (init, test, update, body) {
                this.type = Syntax.ForStatement;
                this.init = init;
                this.test = test;
                this.update = update;
                this.body = body;
                this.finish();
                return this;
            },
    
            finishForOfStatement: function (left, right, body) {
                this.type = Syntax.ForOfStatement;
                this.left = left;
                this.right = right;
                this.body = body;
                this.finish();
                return this;
            },
    
            finishForInStatement: function (left, right, body) {
                this.type = Syntax.ForInStatement;
                this.left = left;
                this.right = right;
                this.body = body;
                this.each = false;
                this.finish();
                return this;
            },
    
            finishFunctionDeclaration: function (id, params, defaults, body, generator) {
                this.type = Syntax.FunctionDeclaration;
                this.id = id;
                this.params = params;
                this.defaults = defaults;
                this.body = body;
                this.generator = generator;
                this.expression = false;
                this.finish();
                return this;
            },
    
            finishFunctionExpression: function (id, params, defaults, body, generator) {
                this.type = Syntax.FunctionExpression;
                this.id = id;
                this.params = params;
                this.defaults = defaults;
                this.body = body;
                this.generator = generator;
                this.expression = false;
                this.finish();
                return this;
            },
    
            finishIdentifier: function (name) {
                this.type = Syntax.Identifier;
                this.name = name;
                this.finish();
                return this;
            },
    
            finishIfStatement: function (test, consequent, alternate) {
                this.type = Syntax.IfStatement;
                this.test = test;
                this.consequent = consequent;
                this.alternate = alternate;
                this.finish();
                return this;
            },
    
            finishLabeledStatement: function (label, body) {
                this.type = Syntax.LabeledStatement;
                this.label = label;
                this.body = body;
                this.finish();
                return this;
            },
    
            finishLiteral: function (token) {
                this.type = Syntax.Literal;
                this.value = token.value;
                this.raw = source.slice(token.start, token.end);
                if (token.regex) {
                    this.regex = token.regex;
                }
                this.finish();
                return this;
            },
    
            finishMemberExpression: function (accessor, object, property) {
                this.type = Syntax.MemberExpression;
                this.computed = accessor === '[';
                this.object = object;
                this.property = property;
                this.finish();
                return this;
            },
    
            finishMetaProperty: function (meta, property) {
                this.type = Syntax.MetaProperty;
                this.meta = meta;
                this.property = property;
                this.finish();
                return this;
            },
    
            finishNewExpression: function (callee, args) {
                this.type = Syntax.NewExpression;
                this.callee = callee;
                this.arguments = args;
                this.finish();
                return this;
            },
    
            finishObjectExpression: function (properties) {
                this.type = Syntax.ObjectExpression;
                this.properties = properties;
                this.finish();
                return this;
            },
    
            finishObjectPattern: function (properties) {
                this.type = Syntax.ObjectPattern;
                this.properties = properties;
                this.finish();
                return this;
            },
    
            finishPostfixExpression: function (operator, argument) {
                this.type = Syntax.UpdateExpression;
                this.operator = operator;
                this.argument = argument;
                this.prefix = false;
                this.finish();
                return this;
            },
    
            finishProgram: function (body, sourceType) {
                this.type = Syntax.Program;
                this.body = body;
                this.sourceType = sourceType;
                this.finish();
                return this;
            },
    
            finishProperty: function (kind, key, computed, value, method, shorthand) {
                this.type = Syntax.Property;
                this.key = key;
                this.computed = computed;
                this.value = value;
                this.kind = kind;
                this.method = method;
                this.shorthand = shorthand;
                this.finish();
                return this;
            },
    
            finishRestElement: function (argument) {
                this.type = Syntax.RestElement;
                this.argument = argument;
                this.finish();
                return this;
            },
    
            finishReturnStatement: function (argument) {
                this.type = Syntax.ReturnStatement;
                this.argument = argument;
                this.finish();
                return this;
            },
    
            finishSequenceExpression: function (expressions) {
                this.type = Syntax.SequenceExpression;
                this.expressions = expressions;
                this.finish();
                return this;
            },
    
            finishSpreadElement: function (argument) {
                this.type = Syntax.SpreadElement;
                this.argument = argument;
                this.finish();
                return this;
            },
    
            finishSwitchCase: function (test, consequent) {
                this.type = Syntax.SwitchCase;
                this.test = test;
                this.consequent = consequent;
                this.finish();
                return this;
            },
    
            finishSuper: function () {
                this.type = Syntax.Super;
                this.finish();
                return this;
            },
    
            finishSwitchStatement: function (discriminant, cases) {
                this.type = Syntax.SwitchStatement;
                this.discriminant = discriminant;
                this.cases = cases;
                this.finish();
                return this;
            },
    
            finishTaggedTemplateExpression: function (tag, quasi) {
                this.type = Syntax.TaggedTemplateExpression;
                this.tag = tag;
                this.quasi = quasi;
                this.finish();
                return this;
            },
    
            finishTemplateElement: function (value, tail) {
                this.type = Syntax.TemplateElement;
                this.value = value;
                this.tail = tail;
                this.finish();
                return this;
            },
    
            finishTemplateLiteral: function (quasis, expressions) {
                this.type = Syntax.TemplateLiteral;
                this.quasis = quasis;
                this.expressions = expressions;
                this.finish();
                return this;
            },
    
            finishThisExpression: function () {
                this.type = Syntax.ThisExpression;
                this.finish();
                return this;
            },
    
            finishThrowStatement: function (argument) {
                this.type = Syntax.ThrowStatement;
                this.argument = argument;
                this.finish();
                return this;
            },
    
            finishTryStatement: function (block, handler, finalizer) {
                this.type = Syntax.TryStatement;
                this.block = block;
                this.guardedHandlers = [];
                this.handlers = handler ? [handler] : [];
                this.handler = handler;
                this.finalizer = finalizer;
                this.finish();
                return this;
            },
    
            finishUnaryExpression: function (operator, argument) {
                this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
                this.operator = operator;
                this.argument = argument;
                this.prefix = true;
                this.finish();
                return this;
            },
    
            finishVariableDeclaration: function (declarations) {
                this.type = Syntax.VariableDeclaration;
                this.declarations = declarations;
                this.kind = 'var';
                this.finish();
                return this;
            },
    
            finishLexicalDeclaration: function (declarations, kind) {
                this.type = Syntax.VariableDeclaration;
                this.declarations = declarations;
                this.kind = kind;
                this.finish();
                return this;
            },
    
            finishVariableDeclarator: function (id, init) {
                this.type = Syntax.VariableDeclarator;
                this.id = id;
                this.init = init;
                this.finish();
                return this;
            },
    
            finishWhileStatement: function (test, body) {
                this.type = Syntax.WhileStatement;
                this.test = test;
                this.body = body;
                this.finish();
                return this;
            },
    
            finishWithStatement: function (object, body) {
                this.type = Syntax.WithStatement;
                this.object = object;
                this.body = body;
                this.finish();
                return this;
            },
    
            finishExportSpecifier: function (local, exported) {
                this.type = Syntax.ExportSpecifier;
                this.exported = exported || local;
                this.local = local;
                this.finish();
                return this;
            },
    
            finishImportDefaultSpecifier: function (local) {
                this.type = Syntax.ImportDefaultSpecifier;
                this.local = local;
                this.finish();
                return this;
            },
    
            finishImportNamespaceSpecifier: function (local) {
                this.type = Syntax.ImportNamespaceSpecifier;
                this.local = local;
                this.finish();
                return this;
            },
    
            finishExportNamedDeclaration: function (declaration, specifiers, src) {
                this.type = Syntax.ExportNamedDeclaration;
                this.declaration = declaration;
                this.specifiers = specifiers;
                this.source = src;
                this.finish();
                return this;
            },
    
            finishExportDefaultDeclaration: function (declaration) {
                this.type = Syntax.ExportDefaultDeclaration;
                this.declaration = declaration;
                this.finish();
                return this;
            },
    
            finishExportAllDeclaration: function (src) {
                this.type = Syntax.ExportAllDeclaration;
                this.source = src;
                this.finish();
                return this;
            },
    
            finishImportSpecifier: function (local, imported) {
                this.type = Syntax.ImportSpecifier;
                this.local = local || imported;
                this.imported = imported;
                this.finish();
                return this;
            },
    
            finishImportDeclaration: function (specifiers, src) {
                this.type = Syntax.ImportDeclaration;
                this.specifiers = specifiers;
                this.source = src;
                this.finish();
                return this;
            },
    
            finishYieldExpression: function (argument, delegate) {
                this.type = Syntax.YieldExpression;
                this.argument = argument;
                this.delegate = delegate;
                this.finish();
                return this;
            }
        };
    
    
        function recordError(error) {
            var e, existing;
    
            for (e = 0; e < extra.errors.length; e++) {
                existing = extra.errors[e];
                // Prevent duplicated error.
                /* istanbul ignore next */
                if (existing.index === error.index && existing.message === error.message) {
                    return;
                }
            }
    
            extra.errors.push(error);
        }
    
        function constructError(msg, column) {
            var error = new Error(msg);
            try {
                throw error;
            } catch (base) {
                /* istanbul ignore else */
                if (Object.create && Object.defineProperty) {
                    error = Object.create(base);
                    Object.defineProperty(error, 'column', { value: column });
                }
            } finally {
                return error;
            }
        }
    
        function createError(line, pos, description) {
            var msg, column, error;
    
            msg = 'Line ' + line + ': ' + description;
            column = pos - (scanning ? lineStart : lastLineStart) + 1;
            error = constructError(msg, column);
            error.lineNumber = line;
            error.description = description;
            error.index = pos;
            return error;
        }
    
        // Throw an exception
    
        function throwError(messageFormat) {
            var args, msg;
    
            args = Array.prototype.slice.call(arguments, 1);
            msg = messageFormat.replace(/%(\d)/g,
                function (whole, idx) {
                    assert(idx < args.length, 'Message reference must be in range');
                    return args[idx];
                }
            );
    
            throw createError(lastLineNumber, lastIndex, msg);
        }
    
        function tolerateError(messageFormat) {
            var args, msg, error;
    
            args = Array.prototype.slice.call(arguments, 1);
            /* istanbul ignore next */
            msg = messageFormat.replace(/%(\d)/g,
                function (whole, idx) {
                    assert(idx < args.length, 'Message reference must be in range');
                    return args[idx];
                }
            );
    
            error = createError(lineNumber, lastIndex, msg);
            if (extra.errors) {
                recordError(error);
            } else {
                throw error;
            }
        }
    
        // Throw an exception because of the token.
    
        function unexpectedTokenError(token, message) {
            var value, msg = message || Messages.UnexpectedToken;
    
            if (token) {
                if (!message) {
                    msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                        (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                        (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                        (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                        (token.type === Token.Template) ? Messages.UnexpectedTemplate :
                        Messages.UnexpectedToken;
    
                    if (token.type === Token.Keyword) {
                        if (isFutureReservedWord(token.value)) {
                            msg = Messages.UnexpectedReserved;
                        } else if (strict && isStrictModeReservedWord(token.value)) {
                            msg = Messages.StrictReservedWord;
                        }
                    }
                }
    
                value = (token.type === Token.Template) ? token.value.raw : token.value;
            } else {
                value = 'ILLEGAL';
            }
    
            msg = msg.replace('%0', value);
    
            return (token && typeof token.lineNumber === 'number') ?
                createError(token.lineNumber, token.start, msg) :
                createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
        }
    
        function throwUnexpectedToken(token, message) {
            throw unexpectedTokenError(token, message);
        }
    
        function tolerateUnexpectedToken(token, message) {
            var error = unexpectedTokenError(token, message);
            if (extra.errors) {
                recordError(error);
            } else {
                throw error;
            }
        }
    
        // Expect the next token to match the specified punctuator.
        // If not, an exception will be thrown.
    
        function expect(value) {
            var token = lex();
            if (token.type !== Token.Punctuator || token.value !== value) {
                throwUnexpectedToken(token);
            }
        }
    
        /**
         * @name expectCommaSeparator
         * @description Quietly expect a comma when in tolerant mode, otherwise delegates
         * to <code>expect(value)</code>
         * @since 2.0
         */
        function expectCommaSeparator() {
            var token;
    
            if (extra.errors) {
                token = lookahead;
                if (token.type === Token.Punctuator && token.value === ',') {
                    lex();
                } else if (token.type === Token.Punctuator && token.value === ';') {
                    lex();
                    tolerateUnexpectedToken(token);
                } else {
                    tolerateUnexpectedToken(token, Messages.UnexpectedToken);
                }
            } else {
                expect(',');
            }
        }
    
        // Expect the next token to match the specified keyword.
        // If not, an exception will be thrown.
    
        function expectKeyword(keyword) {
            var token = lex();
            if (token.type !== Token.Keyword || token.value !== keyword) {
                throwUnexpectedToken(token);
            }
        }
    
        // Return true if the next token matches the specified punctuator.
    
        function match(value) {
            return lookahead.type === Token.Punctuator && lookahead.value === value;
        }
    
        // Return true if the next token matches the specified keyword
    
        function matchKeyword(keyword) {
            return lookahead.type === Token.Keyword && lookahead.value === keyword;
        }
    
        // Return true if the next token matches the specified contextual keyword
        // (where an identifier is sometimes a keyword depending on the context)
    
        function matchContextualKeyword(keyword) {
            return lookahead.type === Token.Identifier && lookahead.value === keyword;
        }
    
        // Return true if the next token is an assignment operator
    
        function matchAssign() {
            var op;
    
            if (lookahead.type !== Token.Punctuator) {
                return false;
            }
            op = lookahead.value;
            return op === '=' ||
                op === '*=' ||
                op === '/=' ||
                op === '%=' ||
                op === '+=' ||
                op === '-=' ||
                op === '<<=' ||
                op === '>>=' ||
                op === '>>>=' ||
                op === '&=' ||
                op === '^=' ||
                op === '|=';
        }
    
        function consumeSemicolon() {
            // Catch the very common case first: immediately a semicolon (U+003B).
            if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
                lex();
                return;
            }
    
            if (hasLineTerminator) {
                return;
            }
    
            // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
            lastIndex = startIndex;
            lastLineNumber = startLineNumber;
            lastLineStart = startLineStart;
    
            if (lookahead.type !== Token.EOF && !match('}')) {
                throwUnexpectedToken(lookahead);
            }
        }
    
        // Cover grammar support.
        //
        // When an assignment expression position starts with an left parenthesis, the determination of the type
        // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
        // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
        //
        // There are three productions that can be parsed in a parentheses pair that needs to be determined
        // after the outermost pair is closed. They are:
        //
        //   1. AssignmentExpression
        //   2. BindingElements
        //   3. AssignmentTargets
        //
        // In order to avoid exponential backtracking, we use two flags to denote if the production can be
        // binding element or assignment target.
        //
        // The three productions have the relationship:
        //
        //   BindingElements  AssignmentTargets  AssignmentExpression
        //
        // with a single exception that CoverInitializedName when used directly in an Expression, generates
        // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
        // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
        //
        // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
        // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
        // the CoverInitializedName check is conducted.
        //
        // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
        // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
        // pattern. The CoverInitializedName check is deferred.
        function isolateCoverGrammar(parser) {
            var oldIsBindingElement = isBindingElement,
                oldIsAssignmentTarget = isAssignmentTarget,
                oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
                result;
            isBindingElement = true;
            isAssignmentTarget = true;
            firstCoverInitializedNameError = null;
            result = parser();
            if (firstCoverInitializedNameError !== null) {
                throwUnexpectedToken(firstCoverInitializedNameError);
            }
            isBindingElement = oldIsBindingElement;
            isAssignmentTarget = oldIsAssignmentTarget;
            firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
            return result;
        }
    
        function inheritCoverGrammar(parser) {
            var oldIsBindingElement = isBindingElement,
                oldIsAssignmentTarget = isAssignmentTarget,
                oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
                result;
            isBindingElement = true;
            isAssignmentTarget = true;
            firstCoverInitializedNameError = null;
            result = parser();
            isBindingElement = isBindingElement && oldIsBindingElement;
            isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
            firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
            return result;
        }
    
        // ECMA-262 13.3.3 Destructuring Binding Patterns
    
        function parseArrayPattern(params, kind) {
            var node = new Node(), elements = [], rest, restNode;
            expect('[');
    
            while (!match(']')) {
                if (match(',')) {
                    lex();
                    elements.push(null);
                } else {
                    if (match('...')) {
                        restNode = new Node();
                        lex();
                        params.push(lookahead);
                        rest = parseVariableIdentifier(params, kind);
                        elements.push(restNode.finishRestElement(rest));
                        break;
                    } else {
                        elements.push(parsePatternWithDefault(params, kind));
                    }
                    if (!match(']')) {
                        expect(',');
                    }
                }
    
            }
    
            expect(']');
    
            return node.finishArrayPattern(elements);
        }
    
        function parsePropertyPattern(params, kind) {
            var node = new Node(), key, keyToken, computed = match('['), init;
            if (lookahead.type === Token.Identifier) {
                keyToken = lookahead;
                key = parseVariableIdentifier();
                if (match('=')) {
                    params.push(keyToken);
                    lex();
                    init = parseAssignmentExpression();
    
                    return node.finishProperty(
                        'init', key, false,
                        new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, false);
                } else if (!match(':')) {
                    params.push(keyToken);
                    return node.finishProperty('init', key, false, key, false, true);
                }
            } else {
                key = parseObjectPropertyKey(params, kind);
            }
            expect(':');
            init = parsePatternWithDefault(params, kind);
            return node.finishProperty('init', key, computed, init, false, false);
        }
    
        function parseObjectPattern(params, kind) {
            var node = new Node(), properties = [];
    
            expect('{');
    
            while (!match('}')) {
                properties.push(parsePropertyPattern(params, kind));
                if (!match('}')) {
                    expect(',');
                }
            }
    
            lex();
    
            return node.finishObjectPattern(properties);
        }
    
        function parsePattern(params, kind) {
            if (match('[')) {
                return parseArrayPattern(params, kind);
            } else if (match('{')) {
                return parseObjectPattern(params, kind);
            }
            params.push(lookahead);
            return parseVariableIdentifier(kind);
        }
    
        function parsePatternWithDefault(params, kind) {
            var startToken = lookahead, pattern, previousAllowYield, right;
            pattern = parsePattern(params, kind);
            if (match('=')) {
                lex();
                previousAllowYield = state.allowYield;
                state.allowYield = true;
                right = isolateCoverGrammar(parseAssignmentExpression);
                state.allowYield = previousAllowYield;
                pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
            }
            return pattern;
        }
    
        // ECMA-262 12.2.5 Array Initializer
    
        function parseArrayInitializer() {
            var elements = [], node = new Node(), restSpread;
    
            expect('[');
    
            while (!match(']')) {
                if (match(',')) {
                    lex();
                    elements.push(null);
                } else if (match('...')) {
                    restSpread = new Node();
                    lex();
                    restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));
    
                    if (!match(']')) {
                        isAssignmentTarget = isBindingElement = false;
                        expect(',');
                    }
                    elements.push(restSpread);
                } else {
                    elements.push(inheritCoverGrammar(parseAssignmentExpression));
    
                    if (!match(']')) {
                        expect(',');
                    }
                }
            }
    
            lex();
    
            return node.finishArrayExpression(elements);
        }
    
        // ECMA-262 12.2.6 Object Initializer
    
        function parsePropertyFunction(node, paramInfo, isGenerator) {
            var previousStrict, body;
    
            isAssignmentTarget = isBindingElement = false;
    
            previousStrict = strict;
            body = isolateCoverGrammar(parseFunctionSourceElements);
    
            if (strict && paramInfo.firstRestricted) {
                tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
            }
            if (strict && paramInfo.stricted) {
                tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
            }
    
            strict = previousStrict;
            return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);
        }
    
        function parsePropertyMethodFunction() {
            var params, method, node = new Node(),
                previousAllowYield = state.allowYield;
    
            state.allowYield = false;
            params = parseParams();
            state.allowYield = previousAllowYield;
    
            state.allowYield = false;
            method = parsePropertyFunction(node, params, false);
            state.allowYield = previousAllowYield;
    
            return method;
        }
    
        function parseObjectPropertyKey() {
            var token, node = new Node(), expr;
    
            token = lex();
    
            // Note: This function is called only from parseObjectProperty(), where
            // EOF and Punctuator tokens are already filtered out.
    
            switch (token.type) {
            case Token.StringLiteral:
            case Token.NumericLiteral:
                if (strict && token.octal) {
                    tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
                }
                return node.finishLiteral(token);
            case Token.Identifier:
            case Token.BooleanLiteral:
            case Token.NullLiteral:
            case Token.Keyword:
                return node.finishIdentifier(token.value);
            case Token.Punctuator:
                if (token.value === '[') {
                    expr = isolateCoverGrammar(parseAssignmentExpression);
                    expect(']');
                    return expr;
                }
                break;
            }
            throwUnexpectedToken(token);
        }
    
        function lookaheadPropertyName() {
            switch (lookahead.type) {
            case Token.Identifier:
            case Token.StringLiteral:
            case Token.BooleanLiteral:
            case Token.NullLiteral:
            case Token.NumericLiteral:
            case Token.Keyword:
                return true;
            case Token.Punctuator:
                return lookahead.value === '[';
            }
            return false;
        }
    
        // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
        // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
        // This can only be determined after we consumed up to the left parentheses.
        //
        // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
        // is responsible to visit other options.
        function tryParseMethodDefinition(token, key, computed, node) {
            var value, options, methodNode, params,
                previousAllowYield = state.allowYield;
    
            if (token.type === Token.Identifier) {
                // check for `get` and `set`;
    
                if (token.value === 'get' && lookaheadPropertyName()) {
                    computed = match('[');
                    key = parseObjectPropertyKey();
                    methodNode = new Node();
                    expect('(');
                    expect(')');
    
                    state.allowYield = false;
                    value = parsePropertyFunction(methodNode, {
                        params: [],
                        defaults: [],
                        stricted: null,
                        firstRestricted: null,
                        message: null
                    }, false);
                    state.allowYield = previousAllowYield;
    
                    return node.finishProperty('get', key, computed, value, false, false);
                } else if (token.value === 'set' && lookaheadPropertyName()) {
                    computed = match('[');
                    key = parseObjectPropertyKey();
                    methodNode = new Node();
                    expect('(');
    
                    options = {
                        params: [],
                        defaultCount: 0,
                        defaults: [],
                        firstRestricted: null,
                        paramSet: {}
                    };
                    if (match(')')) {
                        tolerateUnexpectedToken(lookahead);
                    } else {
                        state.allowYield = false;
                        parseParam(options);
                        state.allowYield = previousAllowYield;
                        if (options.defaultCount === 0) {
                            options.defaults = [];
                        }
                    }
                    expect(')');
    
                    state.allowYield = false;
                    value = parsePropertyFunction(methodNode, options, false);
                    state.allowYield = previousAllowYield;
    
                    return node.finishProperty('set', key, computed, value, false, false);
                }
            } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
    
                state.allowYield = true;
                params = parseParams();
                state.allowYield = previousAllowYield;
    
                state.allowYield = false;
                value = parsePropertyFunction(methodNode, params, true);
                state.allowYield = previousAllowYield;
    
                return node.finishProperty('init', key, computed, value, true, false);
            }
    
            if (key && match('(')) {
                value = parsePropertyMethodFunction();
                return node.finishProperty('init', key, computed, value, true, false);
            }
    
            // Not a MethodDefinition.
            return null;
        }
    
        function parseObjectProperty(hasProto) {
            var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;
    
            computed = match('[');
            if (match('*')) {
                lex();
            } else {
                key = parseObjectPropertyKey();
            }
            maybeMethod = tryParseMethodDefinition(token, key, computed, node);
            if (maybeMethod) {
                return maybeMethod;
            }
    
            if (!key) {
                throwUnexpectedToken(lookahead);
            }
    
            // Check for duplicated __proto__
            if (!computed) {
                proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||
                    (key.type === Syntax.Literal && key.value === '__proto__');
                if (hasProto.value && proto) {
                    tolerateError(Messages.DuplicateProtoProperty);
                }
                hasProto.value |= proto;
            }
    
            if (match(':')) {
                lex();
                value = inheritCoverGrammar(parseAssignmentExpression);
                return node.finishProperty('init', key, computed, value, false, false);
            }
    
            if (token.type === Token.Identifier) {
                if (match('=')) {
                    firstCoverInitializedNameError = lookahead;
                    lex();
                    value = isolateCoverGrammar(parseAssignmentExpression);
                    return node.finishProperty('init', key, computed,
                        new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
                }
                return node.finishProperty('init', key, computed, key, false, true);
            }
    
            throwUnexpectedToken(lookahead);
        }
    
        function parseObjectInitializer() {
            var properties = [], hasProto = {value: false}, node = new Node();
    
            expect('{');
    
            while (!match('}')) {
                properties.push(parseObjectProperty(hasProto));
    
                if (!match('}')) {
                    expectCommaSeparator();
                }
            }
    
            expect('}');
    
            return node.finishObjectExpression(properties);
        }
    
        function reinterpretExpressionAsPattern(expr) {
            var i;
            switch (expr.type) {
            case Syntax.Identifier:
            case Syntax.MemberExpression:
            case Syntax.RestElement:
            case Syntax.AssignmentPattern:
                break;
            case Syntax.SpreadElement:
                expr.type = Syntax.RestElement;
                reinterpretExpressionAsPattern(expr.argument);
                break;
            case Syntax.ArrayExpression:
                expr.type = Syntax.ArrayPattern;
                for (i = 0; i < expr.elements.length; i++) {
                    if (expr.elements[i] !== null) {
                        reinterpretExpressionAsPattern(expr.elements[i]);
                    }
                }
                break;
            case Syntax.ObjectExpression:
                expr.type = Syntax.ObjectPattern;
                for (i = 0; i < expr.properties.length; i++) {
                    reinterpretExpressionAsPattern(expr.properties[i].value);
                }
                break;
            case Syntax.AssignmentExpression:
                expr.type = Syntax.AssignmentPattern;
                reinterpretExpressionAsPattern(expr.left);
                break;
            default:
                // Allow other node type for tolerant parsing.
                break;
            }
        }
    
        // ECMA-262 12.2.9 Template Literals
    
        function parseTemplateElement(option) {
            var node, token;
    
            if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
                throwUnexpectedToken();
            }
    
            node = new Node();
            token = lex();
    
            return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
        }
    
        function parseTemplateLiteral() {
            var quasi, quasis, expressions, node = new Node();
    
            quasi = parseTemplateElement({ head: true });
            quasis = [quasi];
            expressions = [];
    
            while (!quasi.tail) {
                expressions.push(parseExpression());
                quasi = parseTemplateElement({ head: false });
                quasis.push(quasi);
            }
    
            return node.finishTemplateLiteral(quasis, expressions);
        }
    
        // ECMA-262 12.2.10 The Grouping Operator
    
        function parseGroupExpression() {
            var expr, expressions, startToken, i, params = [];
    
            expect('(');
    
            if (match(')')) {
                lex();
                if (!match('=>')) {
                    expect('=>');
                }
                return {
                    type: PlaceHolders.ArrowParameterPlaceHolder,
                    params: [],
                    rawParams: []
                };
            }
    
            startToken = lookahead;
            if (match('...')) {
                expr = parseRestElement(params);
                expect(')');
                if (!match('=>')) {
                    expect('=>');
                }
                return {
                    type: PlaceHolders.ArrowParameterPlaceHolder,
                    params: [expr]
                };
            }
    
            isBindingElement = true;
            expr = inheritCoverGrammar(parseAssignmentExpression);
    
            if (match(',')) {
                isAssignmentTarget = false;
                expressions = [expr];
    
                while (startIndex < length) {
                    if (!match(',')) {
                        break;
                    }
                    lex();
    
                    if (match('...')) {
                        if (!isBindingElement) {
                            throwUnexpectedToken(lookahead);
                        }
                        expressions.push(parseRestElement(params));
                        expect(')');
                        if (!match('=>')) {
                            expect('=>');
                        }
                        isBindingElement = false;
                        for (i = 0; i < expressions.length; i++) {
                            reinterpretExpressionAsPattern(expressions[i]);
                        }
                        return {
                            type: PlaceHolders.ArrowParameterPlaceHolder,
                            params: expressions
                        };
                    }
    
                    expressions.push(inheritCoverGrammar(parseAssignmentExpression));
                }
    
                expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
            }
    
    
            expect(')');
    
            if (match('=>')) {
                if (expr.type === Syntax.Identifier && expr.name === 'yield') {
                    return {
                        type: PlaceHolders.ArrowParameterPlaceHolder,
                        params: [expr]
                    };
                }
    
                if (!isBindingElement) {
                    throwUnexpectedToken(lookahead);
                }
    
                if (expr.type === Syntax.SequenceExpression) {
                    for (i = 0; i < expr.expressions.length; i++) {
                        reinterpretExpressionAsPattern(expr.expressions[i]);
                    }
                } else {
                    reinterpretExpressionAsPattern(expr);
                }
    
                expr = {
                    type: PlaceHolders.ArrowParameterPlaceHolder,
                    params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
                };
            }
            isBindingElement = false;
            return expr;
        }
    
    
        // ECMA-262 12.2 Primary Expressions
    
        function parsePrimaryExpression() {
            var type, token, expr, node;
    
            if (match('(')) {
                isBindingElement = false;
                return inheritCoverGrammar(parseGroupExpression);
            }
    
            if (match('[')) {
                return inheritCoverGrammar(parseArrayInitializer);
            }
    
            if (match('{')) {
                return inheritCoverGrammar(parseObjectInitializer);
            }
    
            type = lookahead.type;
            node = new Node();
    
            if (type === Token.Identifier) {
                if (state.sourceType === 'module' && lookahead.value === 'await') {
                    tolerateUnexpectedToken(lookahead);
                }
                expr = node.finishIdentifier(lex().value);
            } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
                isAssignmentTarget = isBindingElement = false;
                if (strict && lookahead.octal) {
                    tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
                }
                expr = node.finishLiteral(lex());
            } else if (type === Token.Keyword) {
                if (!strict && state.allowYield && matchKeyword('yield')) {
                    return parseNonComputedProperty();
                }
                isAssignmentTarget = isBindingElement = false;
                if (matchKeyword('function')) {
                    return parseFunctionExpression();
                }
                if (matchKeyword('this')) {
                    lex();
                    return node.finishThisExpression();
                }
                if (matchKeyword('class')) {
                    return parseClassExpression();
                }
                throwUnexpectedToken(lex());
            } else if (type === Token.BooleanLiteral) {
                isAssignmentTarget = isBindingElement = false;
                token = lex();
                token.value = (token.value === 'true');
                expr = node.finishLiteral(token);
            } else if (type === Token.NullLiteral) {
                isAssignmentTarget = isBindingElement = false;
                token = lex();
                token.value = null;
                expr = node.finishLiteral(token);
            } else if (match('/') || match('/=')) {
                isAssignmentTarget = isBindingElement = false;
                index = startIndex;
    
                if (typeof extra.tokens !== 'undefined') {
                    token = collectRegex();
                } else {
                    token = scanRegExp();
                }
                lex();
                expr = node.finishLiteral(token);
            } else if (type === Token.Template) {
                expr = parseTemplateLiteral();
            } else {
                throwUnexpectedToken(lex());
            }
    
            return expr;
        }
    
        // ECMA-262 12.3 Left-Hand-Side Expressions
    
        function parseArguments() {
            var args = [], expr;
    
            expect('(');
    
            if (!match(')')) {
                while (startIndex < length) {
                    if (match('...')) {
                        expr = new Node();
                        lex();
                        expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
                    } else {
                        expr = isolateCoverGrammar(parseAssignmentExpression);
                    }
                    args.push(expr);
                    if (match(')')) {
                        break;
                    }
                    expectCommaSeparator();
                }
            }
    
            expect(')');
    
            return args;
        }
    
        function parseNonComputedProperty() {
            var token, node = new Node();
    
            token = lex();
    
            if (!isIdentifierName(token)) {
                throwUnexpectedToken(token);
            }
    
            return node.finishIdentifier(token.value);
        }
    
        function parseNonComputedMember() {
            expect('.');
    
            return parseNonComputedProperty();
        }
    
        function parseComputedMember() {
            var expr;
    
            expect('[');
    
            expr = isolateCoverGrammar(parseExpression);
    
            expect(']');
    
            return expr;
        }
    
        // ECMA-262 12.3.3 The new Operator
    
        function parseNewExpression() {
            var callee, args, node = new Node();
    
            expectKeyword('new');
    
            if (match('.')) {
                lex();
                if (lookahead.type === Token.Identifier && lookahead.value === 'target') {
                    if (state.inFunctionBody) {
                        lex();
                        return node.finishMetaProperty('new', 'target');
                    }
                }
                throwUnexpectedToken(lookahead);
            }
    
            callee = isolateCoverGrammar(parseLeftHandSideExpression);
            args = match('(') ? parseArguments() : [];
    
            isAssignmentTarget = isBindingElement = false;
    
            return node.finishNewExpression(callee, args);
        }
    
        // ECMA-262 12.3.4 Function Calls
    
        function parseLeftHandSideExpressionAllowCall() {
            var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;
    
            startToken = lookahead;
            state.allowIn = true;
    
            if (matchKeyword('super') && state.inFunctionBody) {
                expr = new Node();
                lex();
                expr = expr.finishSuper();
                if (!match('(') && !match('.') && !match('[')) {
                    throwUnexpectedToken(lookahead);
                }
            } else {
                expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
            }
    
            for (;;) {
                if (match('.')) {
                    isBindingElement = false;
                    isAssignmentTarget = true;
                    property = parseNonComputedMember();
                    expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
                } else if (match('(')) {
                    isBindingElement = false;
                    isAssignmentTarget = false;
                    args = parseArguments();
                    expr = new WrappingNode(startToken).finishCallExpression(expr, args);
                } else if (match('[')) {
                    isBindingElement = false;
                    isAssignmentTarget = true;
                    property = parseComputedMember();
                    expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
                } else if (lookahead.type === Token.Template && lookahead.head) {
                    quasi = parseTemplateLiteral();
                    expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
                } else {
                    break;
                }
            }
            state.allowIn = previousAllowIn;
    
            return expr;
        }
    
        // ECMA-262 12.3 Left-Hand-Side Expressions
    
        function parseLeftHandSideExpression() {
            var quasi, expr, property, startToken;
            assert(state.allowIn, 'callee of new expression always allow in keyword.');
    
            startToken = lookahead;
    
            if (matchKeyword('super') && state.inFunctionBody) {
                expr = new Node();
                lex();
                expr = expr.finishSuper();
                if (!match('[') && !match('.')) {
                    throwUnexpectedToken(lookahead);
                }
            } else {
                expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
            }
    
            for (;;) {
                if (match('[')) {
                    isBindingElement = false;
                    isAssignmentTarget = true;
                    property = parseComputedMember();
                    expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
                } else if (match('.')) {
                    isBindingElement = false;
                    isAssignmentTarget = true;
                    property = parseNonComputedMember();
                    expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
                } else if (lookahead.type === Token.Template && lookahead.head) {
                    quasi = parseTemplateLiteral();
                    expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
                } else {
                    break;
                }
            }
            return expr;
        }
    
        // ECMA-262 12.4 Postfix Expressions
    
        function parsePostfixExpression() {
            var expr, token, startToken = lookahead;
    
            expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);
    
            if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
                if (match('++') || match('--')) {
                    // ECMA-262 11.3.1, 11.3.2
                    if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                        tolerateError(Messages.StrictLHSPostfix);
                    }
    
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInAssignment);
                    }
    
                    isAssignmentTarget = isBindingElement = false;
    
                    token = lex();
                    expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
                }
            }
    
            return expr;
        }
    
        // ECMA-262 12.5 Unary Operators
    
        function parseUnaryExpression() {
            var token, expr, startToken;
    
            if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
                expr = parsePostfixExpression();
            } else if (match('++') || match('--')) {
                startToken = lookahead;
                token = lex();
                expr = inheritCoverGrammar(parseUnaryExpression);
                // ECMA-262 11.4.4, 11.4.5
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPrefix);
                }
    
                if (!isAssignmentTarget) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }
                expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
                isAssignmentTarget = isBindingElement = false;
            } else if (match('+') || match('-') || match('~') || match('!')) {
                startToken = lookahead;
                token = lex();
                expr = inheritCoverGrammar(parseUnaryExpression);
                expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
                isAssignmentTarget = isBindingElement = false;
            } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
                startToken = lookahead;
                token = lex();
                expr = inheritCoverGrammar(parseUnaryExpression);
                expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
                if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                    tolerateError(Messages.StrictDelete);
                }
                isAssignmentTarget = isBindingElement = false;
            } else {
                expr = parsePostfixExpression();
            }
    
            return expr;
        }
    
        function binaryPrecedence(token, allowIn) {
            var prec = 0;
    
            if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
                return 0;
            }
    
            switch (token.value) {
            case '||':
                prec = 1;
                break;
    
            case '&&':
                prec = 2;
                break;
    
            case '|':
                prec = 3;
                break;
    
            case '^':
                prec = 4;
                break;
    
            case '&':
                prec = 5;
                break;
    
            case '==':
            case '!=':
            case '===':
            case '!==':
                prec = 6;
                break;
    
            case '<':
            case '>':
            case '<=':
            case '>=':
            case 'instanceof':
                prec = 7;
                break;
    
            case 'in':
                prec = allowIn ? 7 : 0;
                break;
    
            case '<<':
            case '>>':
            case '>>>':
                prec = 8;
                break;
    
            case '+':
            case '-':
                prec = 9;
                break;
    
            case '*':
            case '/':
            case '%':
                prec = 11;
                break;
    
            default:
                break;
            }
    
            return prec;
        }
    
        // ECMA-262 12.6 Multiplicative Operators
        // ECMA-262 12.7 Additive Operators
        // ECMA-262 12.8 Bitwise Shift Operators
        // ECMA-262 12.9 Relational Operators
        // ECMA-262 12.10 Equality Operators
        // ECMA-262 12.11 Binary Bitwise Operators
        // ECMA-262 12.12 Binary Logical Operators
    
        function parseBinaryExpression() {
            var marker, markers, expr, token, prec, stack, right, operator, left, i;
    
            marker = lookahead;
            left = inheritCoverGrammar(parseUnaryExpression);
    
            token = lookahead;
            prec = binaryPrecedence(token, state.allowIn);
            if (prec === 0) {
                return left;
            }
            isAssignmentTarget = isBindingElement = false;
            token.prec = prec;
            lex();
    
            markers = [marker, lookahead];
            right = isolateCoverGrammar(parseUnaryExpression);
    
            stack = [left, token, right];
    
            while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
    
                // Reduce: make a binary expression from the three topmost entries.
                while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                    right = stack.pop();
                    operator = stack.pop().value;
                    left = stack.pop();
                    markers.pop();
                    expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                    stack.push(expr);
                }
    
                // Shift.
                token = lex();
                token.prec = prec;
                stack.push(token);
                markers.push(lookahead);
                expr = isolateCoverGrammar(parseUnaryExpression);
                stack.push(expr);
            }
    
            // Final reduce to clean-up the stack.
            i = stack.length - 1;
            expr = stack[i];
            markers.pop();
            while (i > 1) {
                expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
                i -= 2;
            }
    
            return expr;
        }
    
    
        // ECMA-262 12.13 Conditional Operator
    
        function parseConditionalExpression() {
            var expr, previousAllowIn, consequent, alternate, startToken;
    
            startToken = lookahead;
    
            expr = inheritCoverGrammar(parseBinaryExpression);
            if (match('?')) {
                lex();
                previousAllowIn = state.allowIn;
                state.allowIn = true;
                consequent = isolateCoverGrammar(parseAssignmentExpression);
                state.allowIn = previousAllowIn;
                expect(':');
                alternate = isolateCoverGrammar(parseAssignmentExpression);
    
                expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
                isAssignmentTarget = isBindingElement = false;
            }
    
            return expr;
        }
    
        // ECMA-262 14.2 Arrow Function Definitions
    
        function parseConciseBody() {
            if (match('{')) {
                return parseFunctionSourceElements();
            }
            return isolateCoverGrammar(parseAssignmentExpression);
        }
    
        function checkPatternParam(options, param) {
            var i;
            switch (param.type) {
            case Syntax.Identifier:
                validateParam(options, param, param.name);
                break;
            case Syntax.RestElement:
                checkPatternParam(options, param.argument);
                break;
            case Syntax.AssignmentPattern:
                checkPatternParam(options, param.left);
                break;
            case Syntax.ArrayPattern:
                for (i = 0; i < param.elements.length; i++) {
                    if (param.elements[i] !== null) {
                        checkPatternParam(options, param.elements[i]);
                    }
                }
                break;
            case Syntax.YieldExpression:
                break;
            default:
                assert(param.type === Syntax.ObjectPattern, 'Invalid type');
                for (i = 0; i < param.properties.length; i++) {
                    checkPatternParam(options, param.properties[i].value);
                }
                break;
            }
        }
        function reinterpretAsCoverFormalsList(expr) {
            var i, len, param, params, defaults, defaultCount, options, token;
    
            defaults = [];
            defaultCount = 0;
            params = [expr];
    
            switch (expr.type) {
            case Syntax.Identifier:
                break;
            case PlaceHolders.ArrowParameterPlaceHolder:
                params = expr.params;
                break;
            default:
                return null;
            }
    
            options = {
                paramSet: {}
            };
    
            for (i = 0, len = params.length; i < len; i += 1) {
                param = params[i];
                switch (param.type) {
                case Syntax.AssignmentPattern:
                    params[i] = param.left;
                    if (param.right.type === Syntax.YieldExpression) {
                        if (param.right.argument) {
                            throwUnexpectedToken(lookahead);
                        }
                        param.right.type = Syntax.Identifier;
                        param.right.name = 'yield';
                        delete param.right.argument;
                        delete param.right.delegate;
                    }
                    defaults.push(param.right);
                    ++defaultCount;
                    checkPatternParam(options, param.left);
                    break;
                default:
                    checkPatternParam(options, param);
                    params[i] = param;
                    defaults.push(null);
                    break;
                }
            }
    
            if (strict || !state.allowYield) {
                for (i = 0, len = params.length; i < len; i += 1) {
                    param = params[i];
                    if (param.type === Syntax.YieldExpression) {
                        throwUnexpectedToken(lookahead);
                    }
                }
            }
    
            if (options.message === Messages.StrictParamDupe) {
                token = strict ? options.stricted : options.firstRestricted;
                throwUnexpectedToken(token, options.message);
            }
    
            if (defaultCount === 0) {
                defaults = [];
            }
    
            return {
                params: params,
                defaults: defaults,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
            };
        }
    
        function parseArrowFunctionExpression(options, node) {
            var previousStrict, previousAllowYield, body;
    
            if (hasLineTerminator) {
                tolerateUnexpectedToken(lookahead);
            }
            expect('=>');
    
            previousStrict = strict;
            previousAllowYield = state.allowYield;
            state.allowYield = true;
    
            body = parseConciseBody();
    
            if (strict && options.firstRestricted) {
                throwUnexpectedToken(options.firstRestricted, options.message);
            }
            if (strict && options.stricted) {
                tolerateUnexpectedToken(options.stricted, options.message);
            }
    
            strict = previousStrict;
            state.allowYield = previousAllowYield;
    
            return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
        }
    
        // ECMA-262 14.4 Yield expression
    
        function parseYieldExpression() {
            var argument, expr, delegate, previousAllowYield;
    
            argument = null;
            expr = new Node();
    
            expectKeyword('yield');
    
            if (!hasLineTerminator) {
                previousAllowYield = state.allowYield;
                state.allowYield = false;
                delegate = match('*');
                if (delegate) {
                    lex();
                    argument = parseAssignmentExpression();
                } else {
                    if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {
                        argument = parseAssignmentExpression();
                    }
                }
                state.allowYield = previousAllowYield;
            }
    
            return expr.finishYieldExpression(argument, delegate);
        }
    
        // ECMA-262 12.14 Assignment Operators
    
        function parseAssignmentExpression() {
            var token, expr, right, list, startToken;
    
            startToken = lookahead;
            token = lookahead;
    
            if (!state.allowYield && matchKeyword('yield')) {
                return parseYieldExpression();
            }
    
            expr = parseConditionalExpression();
    
            if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
                isAssignmentTarget = isBindingElement = false;
                list = reinterpretAsCoverFormalsList(expr);
    
                if (list) {
                    firstCoverInitializedNameError = null;
                    return parseArrowFunctionExpression(list, new WrappingNode(startToken));
                }
    
                return expr;
            }
    
            if (matchAssign()) {
                if (!isAssignmentTarget) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }
    
                // ECMA-262 12.1.1
                if (strict && expr.type === Syntax.Identifier) {
                    if (isRestrictedWord(expr.name)) {
                        tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
                    }
                    if (isStrictModeReservedWord(expr.name)) {
                        tolerateUnexpectedToken(token, Messages.StrictReservedWord);
                    }
                }
    
                if (!match('=')) {
                    isAssignmentTarget = isBindingElement = false;
                } else {
                    reinterpretExpressionAsPattern(expr);
                }
    
                token = lex();
                right = isolateCoverGrammar(parseAssignmentExpression);
                expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
                firstCoverInitializedNameError = null;
            }
    
            return expr;
        }
    
        // ECMA-262 12.15 Comma Operator
    
        function parseExpression() {
            var expr, startToken = lookahead, expressions;
    
            expr = isolateCoverGrammar(parseAssignmentExpression);
    
            if (match(',')) {
                expressions = [expr];
    
                while (startIndex < length) {
                    if (!match(',')) {
                        break;
                    }
                    lex();
                    expressions.push(isolateCoverGrammar(parseAssignmentExpression));
                }
    
                expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
            }
    
            return expr;
        }
    
        // ECMA-262 13.2 Block
    
        function parseStatementListItem() {
            if (lookahead.type === Token.Keyword) {
                switch (lookahead.value) {
                case 'export':
                    if (state.sourceType !== 'module') {
                        tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                    }
                    return parseExportDeclaration();
                case 'import':
                    if (state.sourceType !== 'module') {
                        tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                    }
                    return parseImportDeclaration();
                case 'const':
                case 'let':
                    return parseLexicalDeclaration({inFor: false});
                case 'function':
                    return parseFunctionDeclaration(new Node());
                case 'class':
                    return parseClassDeclaration();
                }
            }
    
            return parseStatement();
        }
    
        function parseStatementList() {
            var list = [];
            while (startIndex < length) {
                if (match('}')) {
                    break;
                }
                list.push(parseStatementListItem());
            }
    
            return list;
        }
    
        function parseBlock() {
            var block, node = new Node();
    
            expect('{');
    
            block = parseStatementList();
    
            expect('}');
    
            return node.finishBlockStatement(block);
        }
    
        // ECMA-262 13.3.2 Variable Statement
    
        function parseVariableIdentifier(kind) {
            var token, node = new Node();
    
            token = lex();
    
            if (token.type === Token.Keyword && token.value === 'yield') {
                if (strict) {
                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
                } if (!state.allowYield) {
                    throwUnexpectedToken(token);
                }
            } else if (token.type !== Token.Identifier) {
                if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
                } else {
                    if (strict || token.value !== 'let' || kind !== 'var') {
                        throwUnexpectedToken(token);
                    }
                }
            } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {
                tolerateUnexpectedToken(token);
            }
    
            return node.finishIdentifier(token.value);
        }
    
        function parseVariableDeclaration(options) {
            var init = null, id, node = new Node(), params = [];
    
            id = parsePattern(params, 'var');
    
            // ECMA-262 12.2.1
            if (strict && isRestrictedWord(id.name)) {
                tolerateError(Messages.StrictVarName);
            }
    
            if (match('=')) {
                lex();
                init = isolateCoverGrammar(parseAssignmentExpression);
            } else if (id.type !== Syntax.Identifier && !options.inFor) {
                expect('=');
            }
    
            return node.finishVariableDeclarator(id, init);
        }
    
        function parseVariableDeclarationList(options) {
            var list = [];
    
            do {
                list.push(parseVariableDeclaration({ inFor: options.inFor }));
                if (!match(',')) {
                    break;
                }
                lex();
            } while (startIndex < length);
    
            return list;
        }
    
        function parseVariableStatement(node) {
            var declarations;
    
            expectKeyword('var');
    
            declarations = parseVariableDeclarationList({ inFor: false });
    
            consumeSemicolon();
    
            return node.finishVariableDeclaration(declarations);
        }
    
        // ECMA-262 13.3.1 Let and Const Declarations
    
        function parseLexicalBinding(kind, options) {
            var init = null, id, node = new Node(), params = [];
    
            id = parsePattern(params, kind);
    
            // ECMA-262 12.2.1
            if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
                tolerateError(Messages.StrictVarName);
            }
    
            if (kind === 'const') {
                if (!matchKeyword('in') && !matchContextualKeyword('of')) {
                    expect('=');
                    init = isolateCoverGrammar(parseAssignmentExpression);
                }
            } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
                expect('=');
                init = isolateCoverGrammar(parseAssignmentExpression);
            }
    
            return node.finishVariableDeclarator(id, init);
        }
    
        function parseBindingList(kind, options) {
            var list = [];
    
            do {
                list.push(parseLexicalBinding(kind, options));
                if (!match(',')) {
                    break;
                }
                lex();
            } while (startIndex < length);
    
            return list;
        }
    
        function parseLexicalDeclaration(options) {
            var kind, declarations, node = new Node();
    
            kind = lex().value;
            assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
    
            declarations = parseBindingList(kind, options);
    
            consumeSemicolon();
    
            return node.finishLexicalDeclaration(declarations, kind);
        }
    
        function parseRestElement(params) {
            var param, node = new Node();
    
            lex();
    
            if (match('{')) {
                throwError(Messages.ObjectPatternAsRestParameter);
            }
    
            params.push(lookahead);
    
            param = parseVariableIdentifier();
    
            if (match('=')) {
                throwError(Messages.DefaultRestParameter);
            }
    
            if (!match(')')) {
                throwError(Messages.ParameterAfterRestParameter);
            }
    
            return node.finishRestElement(param);
        }
    
        // ECMA-262 13.4 Empty Statement
    
        function parseEmptyStatement(node) {
            expect(';');
            return node.finishEmptyStatement();
        }
    
        // ECMA-262 12.4 Expression Statement
    
        function parseExpressionStatement(node) {
            var expr = parseExpression();
            consumeSemicolon();
            return node.finishExpressionStatement(expr);
        }
    
        // ECMA-262 13.6 If statement
    
        function parseIfStatement(node) {
            var test, consequent, alternate;
    
            expectKeyword('if');
    
            expect('(');
    
            test = parseExpression();
    
            expect(')');
    
            consequent = parseStatement();
    
            if (matchKeyword('else')) {
                lex();
                alternate = parseStatement();
            } else {
                alternate = null;
            }
    
            return node.finishIfStatement(test, consequent, alternate);
        }
    
        // ECMA-262 13.7 Iteration Statements
    
        function parseDoWhileStatement(node) {
            var body, test, oldInIteration;
    
            expectKeyword('do');
    
            oldInIteration = state.inIteration;
            state.inIteration = true;
    
            body = parseStatement();
    
            state.inIteration = oldInIteration;
    
            expectKeyword('while');
    
            expect('(');
    
            test = parseExpression();
    
            expect(')');
    
            if (match(';')) {
                lex();
            }
    
            return node.finishDoWhileStatement(body, test);
        }
    
        function parseWhileStatement(node) {
            var test, body, oldInIteration;
    
            expectKeyword('while');
    
            expect('(');
    
            test = parseExpression();
    
            expect(')');
    
            oldInIteration = state.inIteration;
            state.inIteration = true;
    
            body = parseStatement();
    
            state.inIteration = oldInIteration;
    
            return node.finishWhileStatement(test, body);
        }
    
        function parseForStatement(node) {
            var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
                body, oldInIteration, previousAllowIn = state.allowIn;
    
            init = test = update = null;
            forIn = true;
    
            expectKeyword('for');
    
            expect('(');
    
            if (match(';')) {
                lex();
            } else {
                if (matchKeyword('var')) {
                    init = new Node();
                    lex();
    
                    state.allowIn = false;
                    declarations = parseVariableDeclarationList({ inFor: true });
                    state.allowIn = previousAllowIn;
    
                    if (declarations.length === 1 && matchKeyword('in')) {
                        init = init.finishVariableDeclaration(declarations);
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                        init = init.finishVariableDeclaration(declarations);
                        lex();
                        left = init;
                        right = parseAssignmentExpression();
                        init = null;
                        forIn = false;
                    } else {
                        init = init.finishVariableDeclaration(declarations);
                        expect(';');
                    }
                } else if (matchKeyword('const') || matchKeyword('let')) {
                    init = new Node();
                    kind = lex().value;
    
                    state.allowIn = false;
                    declarations = parseBindingList(kind, {inFor: true});
                    state.allowIn = previousAllowIn;
    
                    if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseAssignmentExpression();
                        init = null;
                        forIn = false;
                    } else {
                        consumeSemicolon();
                        init = init.finishLexicalDeclaration(declarations, kind);
                    }
                } else {
                    initStartToken = lookahead;
                    state.allowIn = false;
                    init = inheritCoverGrammar(parseAssignmentExpression);
                    state.allowIn = previousAllowIn;
    
                    if (matchKeyword('in')) {
                        if (!isAssignmentTarget) {
                            tolerateError(Messages.InvalidLHSInForIn);
                        }
    
                        lex();
                        reinterpretExpressionAsPattern(init);
                        left = init;
                        right = parseExpression();
                        init = null;
                    } else if (matchContextualKeyword('of')) {
                        if (!isAssignmentTarget) {
                            tolerateError(Messages.InvalidLHSInForLoop);
                        }
    
                        lex();
                        reinterpretExpressionAsPattern(init);
                        left = init;
                        right = parseAssignmentExpression();
                        init = null;
                        forIn = false;
                    } else {
                        if (match(',')) {
                            initSeq = [init];
                            while (match(',')) {
                                lex();
                                initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
                            }
                            init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
                        }
                        expect(';');
                    }
                }
            }
    
            if (typeof left === 'undefined') {
    
                if (!match(';')) {
                    test = parseExpression();
                }
                expect(';');
    
                if (!match(')')) {
                    update = parseExpression();
                }
            }
    
            expect(')');
    
            oldInIteration = state.inIteration;
            state.inIteration = true;
    
            body = isolateCoverGrammar(parseStatement);
    
            state.inIteration = oldInIteration;
    
            return (typeof left === 'undefined') ?
                    node.finishForStatement(init, test, update, body) :
                    forIn ? node.finishForInStatement(left, right, body) :
                        node.finishForOfStatement(left, right, body);
        }
    
        // ECMA-262 13.8 The continue statement
    
        function parseContinueStatement(node) {
            var label = null, key;
    
            expectKeyword('continue');
    
            // Optimize the most common form: 'continue;'.
            if (source.charCodeAt(startIndex) === 0x3B) {
                lex();
    
                if (!state.inIteration) {
                    throwError(Messages.IllegalContinue);
                }
    
                return node.finishContinueStatement(null);
            }
    
            if (hasLineTerminator) {
                if (!state.inIteration) {
                    throwError(Messages.IllegalContinue);
                }
    
                return node.finishContinueStatement(null);
            }
    
            if (lookahead.type === Token.Identifier) {
                label = parseVariableIdentifier();
    
                key = '$' + label.name;
                if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                    throwError(Messages.UnknownLabel, label.name);
                }
            }
    
            consumeSemicolon();
    
            if (label === null && !state.inIteration) {
                throwError(Messages.IllegalContinue);
            }
    
            return node.finishContinueStatement(label);
        }
    
        // ECMA-262 13.9 The break statement
    
        function parseBreakStatement(node) {
            var label = null, key;
    
            expectKeyword('break');
    
            // Catch the very common case first: immediately a semicolon (U+003B).
            if (source.charCodeAt(lastIndex) === 0x3B) {
                lex();
    
                if (!(state.inIteration || state.inSwitch)) {
                    throwError(Messages.IllegalBreak);
                }
    
                return node.finishBreakStatement(null);
            }
    
            if (hasLineTerminator) {
                if (!(state.inIteration || state.inSwitch)) {
                    throwError(Messages.IllegalBreak);
                }
    
                return node.finishBreakStatement(null);
            }
    
            if (lookahead.type === Token.Identifier) {
                label = parseVariableIdentifier();
    
                key = '$' + label.name;
                if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                    throwError(Messages.UnknownLabel, label.name);
                }
            }
    
            consumeSemicolon();
    
            if (label === null && !(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }
    
            return node.finishBreakStatement(label);
        }
    
        // ECMA-262 13.10 The return statement
    
        function parseReturnStatement(node) {
            var argument = null;
    
            expectKeyword('return');
    
            if (!state.inFunctionBody) {
                tolerateError(Messages.IllegalReturn);
            }
    
            // 'return' followed by a space and an identifier is very common.
            if (source.charCodeAt(lastIndex) === 0x20) {
                if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
                    argument = parseExpression();
                    consumeSemicolon();
                    return node.finishReturnStatement(argument);
                }
            }
    
            if (hasLineTerminator) {
                // HACK
                return node.finishReturnStatement(null);
            }
    
            if (!match(';')) {
                if (!match('}') && lookahead.type !== Token.EOF) {
                    argument = parseExpression();
                }
            }
    
            consumeSemicolon();
    
            return node.finishReturnStatement(argument);
        }
    
        // ECMA-262 13.11 The with statement
    
        function parseWithStatement(node) {
            var object, body;
    
            if (strict) {
                tolerateError(Messages.StrictModeWith);
            }
    
            expectKeyword('with');
    
            expect('(');
    
            object = parseExpression();
    
            expect(')');
    
            body = parseStatement();
    
            return node.finishWithStatement(object, body);
        }
    
        // ECMA-262 13.12 The switch statement
    
        function parseSwitchCase() {
            var test, consequent = [], statement, node = new Node();
    
            if (matchKeyword('default')) {
                lex();
                test = null;
            } else {
                expectKeyword('case');
                test = parseExpression();
            }
            expect(':');
    
            while (startIndex < length) {
                if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                    break;
                }
                statement = parseStatementListItem();
                consequent.push(statement);
            }
    
            return node.finishSwitchCase(test, consequent);
        }
    
        function parseSwitchStatement(node) {
            var discriminant, cases, clause, oldInSwitch, defaultFound;
    
            expectKeyword('switch');
    
            expect('(');
    
            discriminant = parseExpression();
    
            expect(')');
    
            expect('{');
    
            cases = [];
    
            if (match('}')) {
                lex();
                return node.finishSwitchStatement(discriminant, cases);
            }
    
            oldInSwitch = state.inSwitch;
            state.inSwitch = true;
            defaultFound = false;
    
            while (startIndex < length) {
                if (match('}')) {
                    break;
                }
                clause = parseSwitchCase();
                if (clause.test === null) {
                    if (defaultFound) {
                        throwError(Messages.MultipleDefaultsInSwitch);
                    }
                    defaultFound = true;
                }
                cases.push(clause);
            }
    
            state.inSwitch = oldInSwitch;
    
            expect('}');
    
            return node.finishSwitchStatement(discriminant, cases);
        }
    
        // ECMA-262 13.14 The throw statement
    
        function parseThrowStatement(node) {
            var argument;
    
            expectKeyword('throw');
    
            if (hasLineTerminator) {
                throwError(Messages.NewlineAfterThrow);
            }
    
            argument = parseExpression();
    
            consumeSemicolon();
    
            return node.finishThrowStatement(argument);
        }
    
        // ECMA-262 13.15 The try statement
    
        function parseCatchClause() {
            var param, params = [], paramMap = {}, key, i, body, node = new Node();
    
            expectKeyword('catch');
    
            expect('(');
            if (match(')')) {
                throwUnexpectedToken(lookahead);
            }
    
            param = parsePattern(params);
            for (i = 0; i < params.length; i++) {
                key = '$' + params[i].value;
                if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                    tolerateError(Messages.DuplicateBinding, params[i].value);
                }
                paramMap[key] = true;
            }
    
            // ECMA-262 12.14.1
            if (strict && isRestrictedWord(param.name)) {
                tolerateError(Messages.StrictCatchVariable);
            }
    
            expect(')');
            body = parseBlock();
            return node.finishCatchClause(param, body);
        }
    
        function parseTryStatement(node) {
            var block, handler = null, finalizer = null;
    
            expectKeyword('try');
    
            block = parseBlock();
    
            if (matchKeyword('catch')) {
                handler = parseCatchClause();
            }
    
            if (matchKeyword('finally')) {
                lex();
                finalizer = parseBlock();
            }
    
            if (!handler && !finalizer) {
                throwError(Messages.NoCatchOrFinally);
            }
    
            return node.finishTryStatement(block, handler, finalizer);
        }
    
        // ECMA-262 13.16 The debugger statement
    
        function parseDebuggerStatement(node) {
            expectKeyword('debugger');
    
            consumeSemicolon();
    
            return node.finishDebuggerStatement();
        }
    
        // 13 Statements
    
        function parseStatement() {
            var type = lookahead.type,
                expr,
                labeledBody,
                key,
                node;
    
            if (type === Token.EOF) {
                throwUnexpectedToken(lookahead);
            }
    
            if (type === Token.Punctuator && lookahead.value === '{') {
                return parseBlock();
            }
            isAssignmentTarget = isBindingElement = true;
            node = new Node();
    
            if (type === Token.Punctuator) {
                switch (lookahead.value) {
                case ';':
                    return parseEmptyStatement(node);
                case '(':
                    return parseExpressionStatement(node);
                default:
                    break;
                }
            } else if (type === Token.Keyword) {
                switch (lookahead.value) {
                case 'break':
                    return parseBreakStatement(node);
                case 'continue':
                    return parseContinueStatement(node);
                case 'debugger':
                    return parseDebuggerStatement(node);
                case 'do':
                    return parseDoWhileStatement(node);
                case 'for':
                    return parseForStatement(node);
                case 'function':
                    return parseFunctionDeclaration(node);
                case 'if':
                    return parseIfStatement(node);
                case 'return':
                    return parseReturnStatement(node);
                case 'switch':
                    return parseSwitchStatement(node);
                case 'throw':
                    return parseThrowStatement(node);
                case 'try':
                    return parseTryStatement(node);
                case 'var':
                    return parseVariableStatement(node);
                case 'while':
                    return parseWhileStatement(node);
                case 'with':
                    return parseWithStatement(node);
                default:
                    break;
                }
            }
    
            expr = parseExpression();
    
            // ECMA-262 12.12 Labelled Statements
            if ((expr.type === Syntax.Identifier) && match(':')) {
                lex();
    
                key = '$' + expr.name;
                if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                    throwError(Messages.Redeclaration, 'Label', expr.name);
                }
    
                state.labelSet[key] = true;
                labeledBody = parseStatement();
                delete state.labelSet[key];
                return node.finishLabeledStatement(expr, labeledBody);
            }
    
            consumeSemicolon();
    
            return node.finishExpressionStatement(expr);
        }
    
        // ECMA-262 14.1 Function Definition
    
        function parseFunctionSourceElements() {
            var statement, body = [], token, directive, firstRestricted,
                oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
                node = new Node();
    
            expect('{');
    
            while (startIndex < length) {
                if (lookahead.type !== Token.StringLiteral) {
                    break;
                }
                token = lookahead;
    
                statement = parseStatementListItem();
                body.push(statement);
                if (statement.expression.type !== Syntax.Literal) {
                    // this is not directive
                    break;
                }
                directive = source.slice(token.start + 1, token.end - 1);
                if (directive === 'use strict') {
                    strict = true;
                    if (firstRestricted) {
                        tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                    }
                } else {
                    if (!firstRestricted && token.octal) {
                        firstRestricted = token;
                    }
                }
            }
    
            oldLabelSet = state.labelSet;
            oldInIteration = state.inIteration;
            oldInSwitch = state.inSwitch;
            oldInFunctionBody = state.inFunctionBody;
            oldParenthesisCount = state.parenthesizedCount;
    
            state.labelSet = {};
            state.inIteration = false;
            state.inSwitch = false;
            state.inFunctionBody = true;
            state.parenthesizedCount = 0;
    
            while (startIndex < length) {
                if (match('}')) {
                    break;
                }
                body.push(parseStatementListItem());
            }
    
            expect('}');
    
            state.labelSet = oldLabelSet;
            state.inIteration = oldInIteration;
            state.inSwitch = oldInSwitch;
            state.inFunctionBody = oldInFunctionBody;
            state.parenthesizedCount = oldParenthesisCount;
    
            return node.finishBlockStatement(body);
        }
    
        function validateParam(options, param, name) {
            var key = '$' + name;
            if (strict) {
                if (isRestrictedWord(name)) {
                    options.stricted = param;
                    options.message = Messages.StrictParamName;
                }
                if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                    options.stricted = param;
                    options.message = Messages.StrictParamDupe;
                }
            } else if (!options.firstRestricted) {
                if (isRestrictedWord(name)) {
                    options.firstRestricted = param;
                    options.message = Messages.StrictParamName;
                } else if (isStrictModeReservedWord(name)) {
                    options.firstRestricted = param;
                    options.message = Messages.StrictReservedWord;
                } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                    options.stricted = param;
                    options.message = Messages.StrictParamDupe;
                }
            }
            options.paramSet[key] = true;
        }
    
        function parseParam(options) {
            var token, param, params = [], i, def;
    
            token = lookahead;
            if (token.value === '...') {
                param = parseRestElement(params);
                validateParam(options, param.argument, param.argument.name);
                options.params.push(param);
                options.defaults.push(null);
                return false;
            }
    
            param = parsePatternWithDefault(params);
            for (i = 0; i < params.length; i++) {
                validateParam(options, params[i], params[i].value);
            }
    
            if (param.type === Syntax.AssignmentPattern) {
                def = param.right;
                param = param.left;
                ++options.defaultCount;
            }
    
            options.params.push(param);
            options.defaults.push(def);
    
            return !match(')');
        }
    
        function parseParams(firstRestricted) {
            var options;
    
            options = {
                params: [],
                defaultCount: 0,
                defaults: [],
                firstRestricted: firstRestricted
            };
    
            expect('(');
    
            if (!match(')')) {
                options.paramSet = {};
                while (startIndex < length) {
                    if (!parseParam(options)) {
                        break;
                    }
                    expect(',');
                }
            }
    
            expect(')');
    
            if (options.defaultCount === 0) {
                options.defaults = [];
            }
    
            return {
                params: options.params,
                defaults: options.defaults,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
            };
        }
    
        function parseFunctionDeclaration(node, identifierIsOptional) {
            var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
                isGenerator, previousAllowYield;
    
            previousAllowYield = state.allowYield;
    
            expectKeyword('function');
    
            isGenerator = match('*');
            if (isGenerator) {
                lex();
            }
    
            if (!identifierIsOptional || !match('(')) {
                token = lookahead;
                id = parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                    }
                } else {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictFunctionName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    }
                }
            }
    
            state.allowYield = !isGenerator;
            tmp = parseParams(firstRestricted);
            params = tmp.params;
            defaults = tmp.defaults;
            stricted = tmp.stricted;
            firstRestricted = tmp.firstRestricted;
            if (tmp.message) {
                message = tmp.message;
            }
    
    
            previousStrict = strict;
            body = parseFunctionSourceElements();
            if (strict && firstRestricted) {
                throwUnexpectedToken(firstRestricted, message);
            }
            if (strict && stricted) {
                tolerateUnexpectedToken(stricted, message);
            }
    
            strict = previousStrict;
            state.allowYield = previousAllowYield;
    
            return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
        }
    
        function parseFunctionExpression() {
            var token, id = null, stricted, firstRestricted, message, tmp,
                params = [], defaults = [], body, previousStrict, node = new Node(),
                isGenerator, previousAllowYield;
    
            previousAllowYield = state.allowYield;
    
            expectKeyword('function');
    
            isGenerator = match('*');
            if (isGenerator) {
                lex();
            }
    
            state.allowYield = !isGenerator;
            if (!match('(')) {
                token = lookahead;
                id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                    }
                } else {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictFunctionName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    }
                }
            }
    
            tmp = parseParams(firstRestricted);
            params = tmp.params;
            defaults = tmp.defaults;
            stricted = tmp.stricted;
            firstRestricted = tmp.firstRestricted;
            if (tmp.message) {
                message = tmp.message;
            }
    
            previousStrict = strict;
            body = parseFunctionSourceElements();
            if (strict && firstRestricted) {
                throwUnexpectedToken(firstRestricted, message);
            }
            if (strict && stricted) {
                tolerateUnexpectedToken(stricted, message);
            }
            strict = previousStrict;
            state.allowYield = previousAllowYield;
    
            return node.finishFunctionExpression(id, params, defaults, body, isGenerator);
        }
    
        // ECMA-262 14.5 Class Definitions
    
        function parseClassBody() {
            var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;
    
            classBody = new Node();
    
            expect('{');
            body = [];
            while (!match('}')) {
                if (match(';')) {
                    lex();
                } else {
                    method = new Node();
                    token = lookahead;
                    isStatic = false;
                    computed = match('[');
                    if (match('*')) {
                        lex();
                    } else {
                        key = parseObjectPropertyKey();
                        if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {
                            token = lookahead;
                            isStatic = true;
                            computed = match('[');
                            if (match('*')) {
                                lex();
                            } else {
                                key = parseObjectPropertyKey();
                            }
                        }
                    }
                    method = tryParseMethodDefinition(token, key, computed, method);
                    if (method) {
                        method['static'] = isStatic; // jscs:ignore requireDotNotation
                        if (method.kind === 'init') {
                            method.kind = 'method';
                        }
                        if (!isStatic) {
                            if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
                                if (method.kind !== 'method' || !method.method || method.value.generator) {
                                    throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                                }
                                if (hasConstructor) {
                                    throwUnexpectedToken(token, Messages.DuplicateConstructor);
                                } else {
                                    hasConstructor = true;
                                }
                                method.kind = 'constructor';
                            }
                        } else {
                            if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
                                throwUnexpectedToken(token, Messages.StaticPrototype);
                            }
                        }
                        method.type = Syntax.MethodDefinition;
                        delete method.method;
                        delete method.shorthand;
                        body.push(method);
                    } else {
                        throwUnexpectedToken(lookahead);
                    }
                }
            }
            lex();
            return classBody.finishClassBody(body);
        }
    
        function parseClassDeclaration(identifierIsOptional) {
            var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
            strict = true;
    
            expectKeyword('class');
    
            if (!identifierIsOptional || lookahead.type === Token.Identifier) {
                id = parseVariableIdentifier();
            }
    
            if (matchKeyword('extends')) {
                lex();
                superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
            }
            classBody = parseClassBody();
            strict = previousStrict;
    
            return classNode.finishClassDeclaration(id, superClass, classBody);
        }
    
        function parseClassExpression() {
            var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
            strict = true;
    
            expectKeyword('class');
    
            if (lookahead.type === Token.Identifier) {
                id = parseVariableIdentifier();
            }
    
            if (matchKeyword('extends')) {
                lex();
                superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
            }
            classBody = parseClassBody();
            strict = previousStrict;
    
            return classNode.finishClassExpression(id, superClass, classBody);
        }
    
        // ECMA-262 15.2 Modules
    
        function parseModuleSpecifier() {
            var node = new Node();
    
            if (lookahead.type !== Token.StringLiteral) {
                throwError(Messages.InvalidModuleSpecifier);
            }
            return node.finishLiteral(lex());
        }
    
        // ECMA-262 15.2.3 Exports
    
        function parseExportSpecifier() {
            var exported, local, node = new Node(), def;
            if (matchKeyword('default')) {
                // export {default} from 'something';
                def = new Node();
                lex();
                local = def.finishIdentifier('default');
            } else {
                local = parseVariableIdentifier();
            }
            if (matchContextualKeyword('as')) {
                lex();
                exported = parseNonComputedProperty();
            }
            return node.finishExportSpecifier(local, exported);
        }
    
        function parseExportNamedDeclaration(node) {
            var declaration = null,
                isExportFromIdentifier,
                src = null, specifiers = [];
    
            // non-default export
            if (lookahead.type === Token.Keyword) {
                // covers:
                // export var f = 1;
                switch (lookahead.value) {
                    case 'let':
                    case 'const':
                    case 'var':
                    case 'class':
                    case 'function':
                        declaration = parseStatementListItem();
                        return node.finishExportNamedDeclaration(declaration, specifiers, null);
                }
            }
    
            expect('{');
            while (!match('}')) {
                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
                specifiers.push(parseExportSpecifier());
                if (!match('}')) {
                    expect(',');
                    if (match('}')) {
                        break;
                    }
                }
            }
            expect('}');
    
            if (matchContextualKeyword('from')) {
                // covering:
                // export {default} from 'foo';
                // export {foo} from 'foo';
                lex();
                src = parseModuleSpecifier();
                consumeSemicolon();
            } else if (isExportFromIdentifier) {
                // covering:
                // export {default}; // missing fromClause
                throwError(lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            } else {
                // cover
                // export {foo};
                consumeSemicolon();
            }
            return node.finishExportNamedDeclaration(declaration, specifiers, src);
        }
    
        function parseExportDefaultDeclaration(node) {
            var declaration = null,
                expression = null;
    
            // covers:
            // export default ...
            expectKeyword('default');
    
            if (matchKeyword('function')) {
                // covers:
                // export default function foo () {}
                // export default function () {}
                declaration = parseFunctionDeclaration(new Node(), true);
                return node.finishExportDefaultDeclaration(declaration);
            }
            if (matchKeyword('class')) {
                declaration = parseClassDeclaration(true);
                return node.finishExportDefaultDeclaration(declaration);
            }
    
            if (matchContextualKeyword('from')) {
                throwError(Messages.UnexpectedToken, lookahead.value);
            }
    
            // covers:
            // export default {};
            // export default [];
            // export default (1 + 2);
            if (match('{')) {
                expression = parseObjectInitializer();
            } else if (match('[')) {
                expression = parseArrayInitializer();
            } else {
                expression = parseAssignmentExpression();
            }
            consumeSemicolon();
            return node.finishExportDefaultDeclaration(expression);
        }
    
        function parseExportAllDeclaration(node) {
            var src;
    
            // covers:
            // export * from 'foo';
            expect('*');
            if (!matchContextualKeyword('from')) {
                throwError(lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            }
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
    
            return node.finishExportAllDeclaration(src);
        }
    
        function parseExportDeclaration() {
            var node = new Node();
            if (state.inFunctionBody) {
                throwError(Messages.IllegalExportDeclaration);
            }
    
            expectKeyword('export');
    
            if (matchKeyword('default')) {
                return parseExportDefaultDeclaration(node);
            }
            if (match('*')) {
                return parseExportAllDeclaration(node);
            }
            return parseExportNamedDeclaration(node);
        }
    
        // ECMA-262 15.2.2 Imports
    
        function parseImportSpecifier() {
            // import {<foo as bar>} ...;
            var local, imported, node = new Node();
    
            imported = parseNonComputedProperty();
            if (matchContextualKeyword('as')) {
                lex();
                local = parseVariableIdentifier();
            }
    
            return node.finishImportSpecifier(local, imported);
        }
    
        function parseNamedImports() {
            var specifiers = [];
            // {foo, bar as bas}
            expect('{');
            while (!match('}')) {
                specifiers.push(parseImportSpecifier());
                if (!match('}')) {
                    expect(',');
                    if (match('}')) {
                        break;
                    }
                }
            }
            expect('}');
            return specifiers;
        }
    
        function parseImportDefaultSpecifier() {
            // import <foo> ...;
            var local, node = new Node();
    
            local = parseNonComputedProperty();
    
            return node.finishImportDefaultSpecifier(local);
        }
    
        function parseImportNamespaceSpecifier() {
            // import <* as foo> ...;
            var local, node = new Node();
    
            expect('*');
            if (!matchContextualKeyword('as')) {
                throwError(Messages.NoAsAfterImportNamespace);
            }
            lex();
            local = parseNonComputedProperty();
    
            return node.finishImportNamespaceSpecifier(local);
        }
    
        function parseImportDeclaration() {
            var specifiers = [], src, node = new Node();
    
            if (state.inFunctionBody) {
                throwError(Messages.IllegalImportDeclaration);
            }
    
            expectKeyword('import');
    
            if (lookahead.type === Token.StringLiteral) {
                // import 'foo';
                src = parseModuleSpecifier();
            } else {
    
                if (match('{')) {
                    // import {bar}
                    specifiers = specifiers.concat(parseNamedImports());
                } else if (match('*')) {
                    // import * as foo
                    specifiers.push(parseImportNamespaceSpecifier());
                } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {
                    // import foo
                    specifiers.push(parseImportDefaultSpecifier());
                    if (match(',')) {
                        lex();
                        if (match('*')) {
                            // import foo, * as foo
                            specifiers.push(parseImportNamespaceSpecifier());
                        } else if (match('{')) {
                            // import foo, {bar}
                            specifiers = specifiers.concat(parseNamedImports());
                        } else {
                            throwUnexpectedToken(lookahead);
                        }
                    }
                } else {
                    throwUnexpectedToken(lex());
                }
    
                if (!matchContextualKeyword('from')) {
                    throwError(lookahead.value ?
                            Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
                }
                lex();
                src = parseModuleSpecifier();
            }
    
            consumeSemicolon();
            return node.finishImportDeclaration(specifiers, src);
        }
    
        // ECMA-262 15.1 Scripts
    
        function parseScriptBody() {
            var statement, body = [], token, directive, firstRestricted;
    
            while (startIndex < length) {
                token = lookahead;
                if (token.type !== Token.StringLiteral) {
                    break;
                }
    
                statement = parseStatementListItem();
                body.push(statement);
                if (statement.expression.type !== Syntax.Literal) {
                    // this is not directive
                    break;
                }
                directive = source.slice(token.start + 1, token.end - 1);
                if (directive === 'use strict') {
                    strict = true;
                    if (firstRestricted) {
                        tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                    }
                } else {
                    if (!firstRestricted && token.octal) {
                        firstRestricted = token;
                    }
                }
            }
    
            while (startIndex < length) {
                statement = parseStatementListItem();
                /* istanbul ignore if */
                if (typeof statement === 'undefined') {
                    break;
                }
                body.push(statement);
            }
            return body;
        }
    
        function parseProgram() {
            var body, node;
    
            peek();
            node = new Node();
    
            body = parseScriptBody();
            return node.finishProgram(body, state.sourceType);
        }
    
        function filterTokenLocation() {
            var i, entry, token, tokens = [];
    
            for (i = 0; i < extra.tokens.length; ++i) {
                entry = extra.tokens[i];
                token = {
                    type: entry.type,
                    value: entry.value
                };
                if (entry.regex) {
                    token.regex = {
                        pattern: entry.regex.pattern,
                        flags: entry.regex.flags
                    };
                }
                if (extra.range) {
                    token.range = entry.range;
                }
                if (extra.loc) {
                    token.loc = entry.loc;
                }
                tokens.push(token);
            }
    
            extra.tokens = tokens;
        }
    
        function tokenize(code, options) {
            var toString,
                tokens;
    
            toString = String;
            if (typeof code !== 'string' && !(code instanceof String)) {
                code = toString(code);
            }
    
            source = code;
            index = 0;
            lineNumber = (source.length > 0) ? 1 : 0;
            lineStart = 0;
            startIndex = index;
            startLineNumber = lineNumber;
            startLineStart = lineStart;
            length = source.length;
            lookahead = null;
            state = {
                allowIn: true,
                allowYield: true,
                labelSet: {},
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                lastCommentStart: -1,
                curlyStack: []
            };
    
            extra = {};
    
            // Options matching.
            options = options || {};
    
            // Of course we collect tokens here.
            options.tokens = true;
            extra.tokens = [];
            extra.tokenize = true;
            // The following two fields are necessary to compute the Regex tokens.
            extra.openParenToken = -1;
            extra.openCurlyToken = -1;
    
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
    
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
    
            try {
                peek();
                if (lookahead.type === Token.EOF) {
                    return extra.tokens;
                }
    
                lex();
                while (lookahead.type !== Token.EOF) {
                    try {
                        lex();
                    } catch (lexError) {
                        if (extra.errors) {
                            recordError(lexError);
                            // We have to break on the first error
                            // to avoid infinite loops.
                            break;
                        } else {
                            throw lexError;
                        }
                    }
                }
    
                filterTokenLocation();
                tokens = extra.tokens;
                if (typeof extra.comments !== 'undefined') {
                    tokens.comments = extra.comments;
                }
                if (typeof extra.errors !== 'undefined') {
                    tokens.errors = extra.errors;
                }
            } catch (e) {
                throw e;
            } finally {
                extra = {};
            }
            return tokens;
        }
    
        function parse(code, options) {
            var program, toString;
    
            toString = String;
            if (typeof code !== 'string' && !(code instanceof String)) {
                code = toString(code);
            }
    
            source = code;
            index = 0;
            lineNumber = (source.length > 0) ? 1 : 0;
            lineStart = 0;
            startIndex = index;
            startLineNumber = lineNumber;
            startLineStart = lineStart;
            length = source.length;
            lookahead = null;
            state = {
                allowIn: true,
                allowYield: true,
                labelSet: {},
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                lastCommentStart: -1,
                curlyStack: [],
                sourceType: 'script'
            };
            strict = false;
    
            extra = {};
            if (typeof options !== 'undefined') {
                extra.range = (typeof options.range === 'boolean') && options.range;
                extra.loc = (typeof options.loc === 'boolean') && options.loc;
                extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;
    
                if (extra.loc && options.source !== null && options.source !== undefined) {
                    extra.source = toString(options.source);
                }
    
                if (typeof options.tokens === 'boolean' && options.tokens) {
                    extra.tokens = [];
                }
                if (typeof options.comment === 'boolean' && options.comment) {
                    extra.comments = [];
                }
                if (typeof options.tolerant === 'boolean' && options.tolerant) {
                    extra.errors = [];
                }
                if (extra.attachComment) {
                    extra.range = true;
                    extra.comments = [];
                    extra.bottomRightStack = [];
                    extra.trailingComments = [];
                    extra.leadingComments = [];
                }
                if (options.sourceType === 'module') {
                    // very restrictive condition for now
                    state.sourceType = options.sourceType;
                    strict = true;
                }
            }
    
            try {
                program = parseProgram();
                if (typeof extra.comments !== 'undefined') {
                    program.comments = extra.comments;
                }
                if (typeof extra.tokens !== 'undefined') {
                    filterTokenLocation();
                    program.tokens = extra.tokens;
                }
                if (typeof extra.errors !== 'undefined') {
                    program.errors = extra.errors;
                }
            } catch (e) {
                throw e;
            } finally {
                extra = {};
            }
    
            return program;
        }
    
        // Sync with *.json manifests.
        exports.version = '2.6.0';
    
        exports.tokenize = tokenize;
    
        exports.parse = parse;
    
        // Deep copy.
        /* istanbul ignore next */
        exports.Syntax = (function () {
            var name, types = {};
    
            if (typeof Object.create === 'function') {
                types = Object.create(null);
            }
    
            for (name in Syntax) {
                if (Syntax.hasOwnProperty(name)) {
                    types[name] = Syntax[name];
                }
            }
    
            if (typeof Object.freeze === 'function') {
                Object.freeze(types);
            }
    
            return types;
        }());
    
    }));
    /* vim: set sw=4 ts=4 et tw=80 : */
    
  provide("esprima", module.exports);
}(global));

// pakmanager:source-map/lib/base64
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    {
      var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
    
      /**
       * Encode an integer in the range of 0 to 63 to a single base 64 digit.
       */
      exports.encode = function (number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };
    
      /**
       * Decode a single base 64 character code digit to an integer. Returns -1 on
       * failure.
       */
      exports.decode = function (charCode) {
        var bigA = 65;     // 'A'
        var bigZ = 90;     // 'Z'
    
        var littleA = 97;  // 'a'
        var littleZ = 122; // 'z'
    
        var zero = 48;     // '0'
        var nine = 57;     // '9'
    
        var plus = 43;     // '+'
        var slash = 47;    // '/'
    
        var littleOffset = 26;
        var numberOffset = 52;
    
        // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
        if (bigA <= charCode && charCode <= bigZ) {
          return (charCode - bigA);
        }
    
        // 26 - 51: abcdefghijklmnopqrstuvwxyz
        if (littleA <= charCode && charCode <= littleZ) {
          return (charCode - littleA + littleOffset);
        }
    
        // 52 - 61: 0123456789
        if (zero <= charCode && charCode <= nine) {
          return (charCode - zero + numberOffset);
        }
    
        // 62: +
        if (charCode == plus) {
          return 62;
        }
    
        // 63: /
        if (charCode == slash) {
          return 63;
        }
    
        // Invalid base64 digit.
        return -1;
      };
    }
    
  provide("source-map/lib/base64", module.exports);
}(global));

// pakmanager:source-map/lib/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    {
      /**
       * This is a helper function for getting values from parameter/options
       * objects.
       *
       * @param args The object we are extracting values from
       * @param name The name of the property we are getting.
       * @param defaultValue An optional value to return if the property is missing
       * from the object. If this is not specified and the property is missing, an
       * error will be thrown.
       */
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
    
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
    
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
    
      function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
    
      /**
       * Normalizes a path, or the path portion of a URL:
       *
       * - Replaces consequtive slashes with one slash.
       * - Removes unnecessary '.' parts.
       * - Removes unnecessary '<dir>/..' parts.
       *
       * Based on code in the Node.js 'path' core module.
       *
       * @param aPath The path or url to normalize.
       */
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
    
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === '.') {
            parts.splice(i, 1);
          } else if (part === '..') {
            up++;
          } else if (up > 0) {
            if (part === '') {
              // The first part is blank if the path is absolute. Trying to go
              // above the root is a no-op. Therefore we can remove all '..' parts
              // directly after the root.
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join('/');
    
        if (path === '') {
          path = isAbsolute ? '/' : '.';
        }
    
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
    
      /**
       * Joins two paths/URLs.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be joined with the root.
       *
       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
       *   first.
       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
       *   is updated with the result and aRoot is returned. Otherwise the result
       *   is returned.
       *   - If aPath is absolute, the result is aPath.
       *   - Otherwise the two paths are joined with a slash.
       * - Joining for example 'http://' and 'www.example.com' is also supported.
       */
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || '/';
        }
    
        // `join(foo, '//www.example.org')`
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
    
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
    
        // `join('http://', 'www.example.com')`
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
    
        var joined = aPath.charAt(0) === '/'
          ? aPath
          : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
    
      exports.isAbsolute = function (aPath) {
        return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
      };
    
      /**
       * Make a path relative to a URL or another path.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be made relative to aRoot.
       */
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
    
        aRoot = aRoot.replace(/\/$/, '');
    
        // It is possible for the path to be above the root. In this case, simply
        // checking whether the root is a prefix of the path won't work. Instead, we
        // need to remove components from the root one by one, until either we find
        // a prefix that fits, or we run out of components to remove.
        var level = 0;
        while (aPath.indexOf(aRoot + '/') !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
    
          // If the only part of the root that is left is the scheme (i.e. http://,
          // file:///, etc.), one or more slashes (/), or simply nothing at all, we
          // have exhausted all components, so the path is not relative to the root.
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
    
          ++level;
        }
    
        // Make sure we add a "../" for each component we removed from the root.
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
    
      /**
       * Because behavior goes wacky when you set `__proto__` on objects, we
       * have to prefix all the strings in our set with an arbitrary character.
       *
       * See https://github.com/mozilla/source-map/pull/31 and
       * https://github.com/mozilla/source-map/issues/30
       *
       * @param String aStr
       */
      function toSetString(aStr) {
        return '$' + aStr;
      }
      exports.toSetString = toSetString;
    
      function fromSetString(aStr) {
        return aStr.substr(1);
      }
      exports.fromSetString = fromSetString;
    
      /**
       * Comparator between two mappings where the original positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same original source/line/column, but different generated
       * line and column the same. Useful when searching for a mapping with a
       * stubbed out mapping.
       */
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = mappingA.source - mappingB.source;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
    
        return mappingA.name - mappingB.name;
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
    
      /**
       * Comparator between two mappings with deflated source and name indices where
       * the generated positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same generated line and column, but different
       * source/name/original line and column the same. Useful when searching for a
       * mapping with a stubbed out mapping.
       */
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
    
        cmp = mappingA.source - mappingB.source;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
    
        return mappingA.name - mappingB.name;
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
    
        if (aStr1 > aStr2) {
          return 1;
        }
    
        return -1;
      }
    
      /**
       * Comparator between two mappings with inflated source and name strings where
       * the generated positions are compared.
       */
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
    
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    }
    
  provide("source-map/lib/util", module.exports);
}(global));

// pakmanager:source-map/lib/base64-vlq
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     *
     * Based on the Base 64 VLQ implementation in Closure Compiler:
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
     *
     * Copyright 2011 The Closure Compiler Authors. All rights reserved.
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *  * Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     *  * Redistributions in binary form must reproduce the above
     *    copyright notice, this list of conditions and the following
     *    disclaimer in the documentation and/or other materials provided
     *    with the distribution.
     *  * Neither the name of Google Inc. nor the names of its
     *    contributors may be used to endorse or promote products derived
     *    from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    {
      var base64 =  require('source-map/lib/base64');
    
      // A single base 64 digit can contain 6 bits of data. For the base 64 variable
      // length quantities we use in the source map spec, the first bit is the sign,
      // the next four bits are the actual value, and the 6th bit is the
      // continuation bit. The continuation bit tells us whether there are more
      // digits in this value following this digit.
      //
      //   Continuation
      //   |    Sign
      //   |    |
      //   V    V
      //   101011
    
      var VLQ_BASE_SHIFT = 5;
    
      // binary: 100000
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    
      // binary: 011111
      var VLQ_BASE_MASK = VLQ_BASE - 1;
    
      // binary: 100000
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
    
      /**
       * Converts from a two-complement value to a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
       */
      function toVLQSigned(aValue) {
        return aValue < 0
          ? ((-aValue) << 1) + 1
          : (aValue << 1) + 0;
      }
    
      /**
       * Converts to a two-complement value from a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
       */
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative
          ? -shifted
          : shifted;
      }
    
      /**
       * Returns the base 64 VLQ encoded value.
       */
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
    
        var vlq = toVLQSigned(aValue);
    
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
    
        return encoded;
      };
    
      /**
       * Decodes the next base 64 VLQ value from the given string and returns the
       * value and the rest of the string via the out parameter.
       */
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
    
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
    
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
    
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
    
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    }
    
  provide("source-map/lib/base64-vlq", module.exports);
}(global));

// pakmanager:source-map/lib/array-set
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    {
      var util =  require('source-map/lib/util');
    
      /**
       * A data structure which is a combination of an array and a set. Adding a new
       * member is O(1), testing for membership is O(1), and finding the index of an
       * element is O(1). Removing elements from the set is not supported. Only
       * strings are supported for membership.
       */
      function ArraySet() {
        this._array = [];
        this._set = {};
      }
    
      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
    
      /**
       * Return how many unique items are in this ArraySet. If duplicates have been
       * added, than those do not count towards the size.
       *
       * @returns Number
       */
      ArraySet.prototype.size = function ArraySet_size() {
        return Object.getOwnPropertyNames(this._set).length;
      };
    
      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = util.toSetString(aStr);
        var isDuplicate = this._set.hasOwnProperty(sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set[sStr] = idx;
        }
      };
    
      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        var sStr = util.toSetString(aStr);
        return this._set.hasOwnProperty(sStr);
      };
    
      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        var sStr = util.toSetString(aStr);
        if (this._set.hasOwnProperty(sStr)) {
          return this._set[sStr];
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
    
      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error('No element indexed by ' + aIdx);
      };
    
      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
    
      exports.ArraySet = ArraySet;
    }
    
  provide("source-map/lib/array-set", module.exports);
}(global));

// pakmanager:source-map/lib/mapping-list
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2014 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    {
      var util =  require('source-map/lib/util');
    
      /**
       * Determine whether mappingB is after mappingA with respect to generated
       * position.
       */
      function generatedPositionAfter(mappingA, mappingB) {
        // Optimized for most common case
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA ||
               util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
    
      /**
       * A data structure to provide a sorted view of accumulated mappings in a
       * performance conscious manner. It trades a neglibable overhead in general
       * case for a large speedup in case of mappings being added in order.
       */
      function MappingList() {
        this._array = [];
        this._sorted = true;
        // Serves as infimum
        this._last = {generatedLine: -1, generatedColumn: 0};
      }
    
      /**
       * Iterate through internal items. This method takes the same arguments that
       * `Array.prototype.forEach` takes.
       *
       * NOTE: The order of the mappings is NOT guaranteed.
       */
      MappingList.prototype.unsortedForEach =
        function MappingList_forEach(aCallback, aThisArg) {
          this._array.forEach(aCallback, aThisArg);
        };
    
      /**
       * Add the given source mapping.
       *
       * @param Object aMapping
       */
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
    
      /**
       * Returns the flat, sorted array of mappings. The mappings are sorted by
       * generated position.
       *
       * WARNING: This method returns internal data without copying, for
       * performance. The return value must NOT be mutated, and should be treated as
       * an immutable borrow. If you want to take ownership, you must make your own
       * copy.
       */
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
    
      exports.MappingList = MappingList;
    }
    
  provide("source-map/lib/mapping-list", module.exports);
}(global));

// pakmanager:source-map/lib/binary-search
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    {
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
    
      /**
       * Recursive implementation of binary search.
       *
       * @param aLow Indices here and lower do not contain the needle.
       * @param aHigh Indices here and higher do not contain the needle.
       * @param aNeedle The element being searched for.
       * @param aHaystack The non-empty array being searched.
       * @param aCompare Function which takes two elements and returns -1, 0, or 1.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       */
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        // This function terminates when one of the following is true:
        //
        //   1. We find the exact element we are looking for.
        //
        //   2. We did not find the exact element, but we can return the index of
        //      the next-closest element.
        //
        //   3. We did not find the exact element, and there is no next-closest
        //      element than the one we are searching for, so we return -1.
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          // Found the element we are looking for.
          return mid;
        }
        else if (cmp > 0) {
          // Our needle is greater than aHaystack[mid].
          if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
    
          // The exact needle element was not found in this haystack. Determine if
          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        }
        else {
          // Our needle is less than aHaystack[mid].
          if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
    
          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
    
      /**
       * This is an implementation of binary search which will always try and return
       * the index of the closest element if there is no exact hit. This is because
       * mappings between original and generated line/col pairs are single points,
       * and there is an implicit region between each of them, so a miss just means
       * that you aren't on the very start of a region.
       *
       * @param aNeedle The element you are looking for.
       * @param aHaystack The array that is being searched.
       * @param aCompare A function which takes the needle and an element in the
       *     array and returns -1, 0, or 1 depending on whether the needle is less
       *     than, equal to, or greater than the element, respectively.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
       */
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
    
        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                    aCompare, aBias || exports.GREATEST_LOWER_BOUND);
        if (index < 0) {
          return -1;
        }
    
        // We have found either the exact element, or the next-closest element than
        // the one we are searching for. However, there may be more than one such
        // element. Make sure we always return the smallest of these.
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
    
        return index;
      };
    }
    
  provide("source-map/lib/binary-search", module.exports);
}(global));

// pakmanager:source-map/lib/quick-sort
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    {
      // It turns out that some (most?) JavaScript engines don't self-host
      // `Array.prototype.sort`. This makes sense because C++ will likely remain
      // faster than JS when doing raw CPU-intensive sorting. However, when using a
      // custom comparator function, calling back and forth between the VM's C++ and
      // JIT'd JS is rather slow *and* loses JIT type information, resulting in
      // worse generated code for the comparator function than would be optimal. In
      // fact, when sorting with a comparator, these costs outweigh the benefits of
      // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
      // a ~3500ms mean speed-up in `bench/bench.html`.
    
      /**
       * Swap the elements indexed by `x` and `y` in the array `ary`.
       *
       * @param {Array} ary
       *        The array.
       * @param {Number} x
       *        The index of the first item.
       * @param {Number} y
       *        The index of the second item.
       */
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
    
      /**
       * Returns a random integer within the range `low .. high` inclusive.
       *
       * @param {Number} low
       *        The lower bound on the range.
       * @param {Number} high
       *        The upper bound on the range.
       */
      function randomIntInRange(low, high) {
        return Math.round(low + (Math.random() * (high - low)));
      }
    
      /**
       * The Quick Sort algorithm.
       *
       * @param {Array} ary
       *        An array to sort.
       * @param {function} comparator
       *        Function to use to compare two items.
       * @param {Number} p
       *        Start index of the array
       * @param {Number} r
       *        End index of the array
       */
      function doQuickSort(ary, comparator, p, r) {
        // If our lower bound is less than our upper bound, we (1) partition the
        // array into two pieces and (2) recurse on each half. If it is not, this is
        // the empty array and our base case.
    
        if (p < r) {
          // (1) Partitioning.
          //
          // The partitioning chooses a pivot between `p` and `r` and moves all
          // elements that are less than or equal to the pivot to the before it, and
          // all the elements that are greater than it after it. The effect is that
          // once partition is done, the pivot is in the exact place it will be when
          // the array is put in sorted order, and it will not need to be moved
          // again. This runs in O(n) time.
    
          // Always choose a random pivot so that an input array which is reverse
          // sorted does not cause O(n^2) running time.
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
    
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
    
          // Immediately after `j` is incremented in this loop, the following hold
          // true:
          //
          //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
          //
          //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
          for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
    
          swap(ary, i + 1, j);
          var q = i + 1;
    
          // (2) Recurse on each half.
    
          doQuickSort(ary, comparator, p, q - 1);
          doQuickSort(ary, comparator, q + 1, r);
        }
      }
    
      /**
       * Sort the given array in-place with the given comparator function.
       *
       * @param {Array} ary
       *        An array to sort.
       * @param {function} comparator
       *        Function to use to compare two items.
       */
      exports.quickSort = function (ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };
    }
    
  provide("source-map/lib/quick-sort", module.exports);
}(global));

// pakmanager:source-map/lib/source-map-generator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    {
      var base64VLQ =  require('source-map/lib/base64-vlq');
      var util =  require('source-map/lib/util');
      var ArraySet =  require('source-map/lib/array-set').ArraySet;
      var MappingList =  require('source-map/lib/mapping-list').MappingList;
    
      /**
       * An instance of the SourceMapGenerator represents a source map which is
       * being built incrementally. You may pass an object with the following
       * properties:
       *
       *   - file: The filename of the generated source.
       *   - sourceRoot: A root for all relative URLs in this source map.
       */
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, 'file', null);
        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
    
      SourceMapGenerator.prototype._version = 3;
    
      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      SourceMapGenerator.fromSourceMap =
        function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
          });
          aSourceMapConsumer.eachMapping(function (mapping) {
            var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
              }
            };
    
            if (mapping.source != null) {
              newMapping.source = mapping.source;
              if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
              }
    
              newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
              };
    
              if (mapping.name != null) {
                newMapping.name = mapping.name;
              }
            }
    
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
    
      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      SourceMapGenerator.prototype.addMapping =
        function SourceMapGenerator_addMapping(aArgs) {
          var generated = util.getArg(aArgs, 'generated');
          var original = util.getArg(aArgs, 'original', null);
          var source = util.getArg(aArgs, 'source', null);
          var name = util.getArg(aArgs, 'name', null);
    
          if (!this._skipValidation) {
            this._validateMapping(generated, original, source, name);
          }
    
          if (source != null && !this._sources.has(source)) {
            this._sources.add(source);
          }
    
          if (name != null && !this._names.has(name)) {
            this._names.add(name);
          }
    
          this._mappings.add({
            generatedLine: generated.line,
            generatedColumn: generated.column,
            originalLine: original != null && original.line,
            originalColumn: original != null && original.column,
            source: source,
            name: name
          });
        };
    
      /**
       * Set the source content for a source file.
       */
      SourceMapGenerator.prototype.setSourceContent =
        function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
          var source = aSourceFile;
          if (this._sourceRoot != null) {
            source = util.relative(this._sourceRoot, source);
          }
    
          if (aSourceContent != null) {
            // Add the source content to the _sourcesContents map.
            // Create a new _sourcesContents map if the property is null.
            if (!this._sourcesContents) {
              this._sourcesContents = {};
            }
            this._sourcesContents[util.toSetString(source)] = aSourceContent;
          } else if (this._sourcesContents) {
            // Remove the source file from the _sourcesContents map.
            // If the _sourcesContents map is empty, set the property to null.
            delete this._sourcesContents[util.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
    
      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */
      SourceMapGenerator.prototype.applySourceMap =
        function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
          var sourceFile = aSourceFile;
          // If aSourceFile is omitted, we will use the file property of the SourceMap
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
              throw new Error(
                'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
                'or the source map\'s "file" property. Both were omitted.'
              );
            }
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          // Make "sourceFile" relative if an absolute Url is passed.
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          // Applying the SourceMap can add and remove items from the sources and
          // the names array.
          var newSources = new ArraySet();
          var newNames = new ArraySet();
    
          // Find mappings for the "sourceFile"
          this._mappings.unsortedForEach(function (mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              // Check if it can be mapped by the source map, then update the mapping.
              var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
              });
              if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                  mapping.source = util.join(aSourceMapPath, mapping.source)
                }
                if (sourceRoot != null) {
                  mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                  mapping.name = original.name;
                }
              }
            }
    
            var source = mapping.source;
            if (source != null && !newSources.has(source)) {
              newSources.add(source);
            }
    
            var name = mapping.name;
            if (name != null && !newNames.has(name)) {
              newNames.add(name);
            }
    
          }, this);
          this._sources = newSources;
          this._names = newNames;
    
          // Copy sourcesContents of applied map.
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
              }
              if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              this.setSourceContent(sourceFile, content);
            }
          }, this);
        };
    
      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      SourceMapGenerator.prototype._validateMapping =
        function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                    aName) {
          if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
              && aGenerated.line > 0 && aGenerated.column >= 0
              && !aOriginal && !aSource && !aName) {
            // Case 1.
            return;
          }
          else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
                   && aOriginal && 'line' in aOriginal && 'column' in aOriginal
                   && aGenerated.line > 0 && aGenerated.column >= 0
                   && aOriginal.line > 0 && aOriginal.column >= 0
                   && aSource) {
            // Cases 2 and 3.
            return;
          }
          else {
            throw new Error('Invalid mapping: ' + JSON.stringify({
              generated: aGenerated,
              source: aSource,
              original: aOriginal,
              name: aName
            }));
          }
        };
    
      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      SourceMapGenerator.prototype._serializeMappings =
        function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = '';
          var mapping;
          var nameIdx;
          var sourceIdx;
    
          var mappings = this._mappings.toArray();
          for (var i = 0, len = mappings.length; i < len; i++) {
            mapping = mappings[i];
    
            if (mapping.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping.generatedLine !== previousGeneratedLine) {
                result += ';';
                previousGeneratedLine++;
              }
            }
            else {
              if (i > 0) {
                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                  continue;
                }
                result += ',';
              }
            }
    
            result += base64VLQ.encode(mapping.generatedColumn
                                       - previousGeneratedColumn);
            previousGeneratedColumn = mapping.generatedColumn;
    
            if (mapping.source != null) {
              sourceIdx = this._sources.indexOf(mapping.source);
              result += base64VLQ.encode(sourceIdx - previousSource);
              previousSource = sourceIdx;
    
              // lines are stored 0-based in SourceMap spec version 3
              result += base64VLQ.encode(mapping.originalLine - 1
                                         - previousOriginalLine);
              previousOriginalLine = mapping.originalLine - 1;
    
              result += base64VLQ.encode(mapping.originalColumn
                                         - previousOriginalColumn);
              previousOriginalColumn = mapping.originalColumn;
    
              if (mapping.name != null) {
                nameIdx = this._names.indexOf(mapping.name);
                result += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
              }
            }
          }
    
          return result;
        };
    
      SourceMapGenerator.prototype._generateSourcesContent =
        function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
          return aSources.map(function (source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot != null) {
              source = util.relative(aSourceRoot, source);
            }
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                        key)
              ? this._sourcesContents[key]
              : null;
          }, this);
        };
    
      /**
       * Externalize the source map.
       */
      SourceMapGenerator.prototype.toJSON =
        function SourceMapGenerator_toJSON() {
          var map = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
          if (this._file != null) {
            map.file = this._file;
          }
          if (this._sourceRoot != null) {
            map.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
          }
    
          return map;
        };
    
      /**
       * Render the source map being generated to a string.
       */
      SourceMapGenerator.prototype.toString =
        function SourceMapGenerator_toString() {
          return JSON.stringify(this.toJSON());
        };
    
      exports.SourceMapGenerator = SourceMapGenerator;
    }
    
  provide("source-map/lib/source-map-generator", module.exports);
}(global));

// pakmanager:source-map/lib/source-map-consumer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    {
      var util =  require('source-map/lib/util');
      var binarySearch =  require('source-map/lib/binary-search');
      var ArraySet =  require('source-map/lib/array-set').ArraySet;
      var base64VLQ =  require('source-map/lib/base64-vlq');
      var quickSort =  require('source-map/lib/quick-sort').quickSort;
    
      function SourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        return sourceMap.sections != null
          ? new IndexedSourceMapConsumer(sourceMap)
          : new BasicSourceMapConsumer(sourceMap);
      }
    
      SourceMapConsumer.fromSourceMap = function(aSourceMap) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
      }
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      SourceMapConsumer.prototype._version = 3;
    
      // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.
    
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
        get: function () {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__generatedMappings;
        }
      });
    
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
        get: function () {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__originalMappings;
        }
      });
    
      SourceMapConsumer.prototype._charIsMappingSeparator =
        function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
          var c = aStr.charAt(index);
          return c === ";" || c === ",";
        };
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      SourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          throw new Error("Subclasses must implement _parseMappings");
        };
    
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
    
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    
      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      SourceMapConsumer.prototype.eachMapping =
        function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
          var context = aContext || null;
          var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    
          var mappings;
          switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
          }
    
          var sourceRoot = this.sourceRoot;
          mappings.map(function (mapping) {
            var source = mapping.source === null ? null : this._sources.at(mapping.source);
            if (source != null && sourceRoot != null) {
              source = util.join(sourceRoot, source);
            }
            return {
              source: source,
              generatedLine: mapping.generatedLine,
              generatedColumn: mapping.generatedColumn,
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name: mapping.name === null ? null : this._names.at(mapping.name)
            };
          }, this).forEach(aCallback, context);
        };
    
      /**
       * Returns all generated line and column information for the original source,
       * line, and column provided. If no column is provided, returns all mappings
       * corresponding to a either the line we are searching for or the next
       * closest line that has any mappings. Otherwise, returns all mappings
       * corresponding to the given line and either the column we are searching for
       * or the next closest column that has any offsets.
       *
       * The only argument is an object with the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: Optional. the column number in the original source.
       *
       * and an array of objects is returned, each with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      SourceMapConsumer.prototype.allGeneratedPositionsFor =
        function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
          var line = util.getArg(aArgs, 'line');
    
          // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
          // returns the index of the closest mapping less than the needle. By
          // setting needle.originalColumn to 0, we thus find the last mapping for
          // the given line, provided such a mapping exists.
          var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: line,
            originalColumn: util.getArg(aArgs, 'column', 0)
          };
    
          if (this.sourceRoot != null) {
            needle.source = util.relative(this.sourceRoot, needle.source);
          }
          if (!this._sources.has(needle.source)) {
            return [];
          }
          needle.source = this._sources.indexOf(needle.source);
    
          var mappings = [];
    
          var index = this._findMapping(needle,
                                        this._originalMappings,
                                        "originalLine",
                                        "originalColumn",
                                        util.compareByOriginalPositions,
                                        binarySearch.LEAST_UPPER_BOUND);
          if (index >= 0) {
            var mapping = this._originalMappings[index];
    
            if (aArgs.column === undefined) {
              var originalLine = mapping.originalLine;
    
              // Iterate until either we run out of mappings, or we run into
              // a mapping for a different line than the one we found. Since
              // mappings are sorted, this is guaranteed to find all mappings for
              // the line we found.
              while (mapping && mapping.originalLine === originalLine) {
                mappings.push({
                  line: util.getArg(mapping, 'generatedLine', null),
                  column: util.getArg(mapping, 'generatedColumn', null),
                  lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
    
                mapping = this._originalMappings[++index];
              }
            } else {
              var originalColumn = mapping.originalColumn;
    
              // Iterate until either we run out of mappings, or we run into
              // a mapping for a different line than the one we were searching for.
              // Since mappings are sorted, this is guaranteed to find all mappings for
              // the line we are searching for.
              while (mapping &&
                     mapping.originalLine === line &&
                     mapping.originalColumn == originalColumn) {
                mappings.push({
                  line: util.getArg(mapping, 'generatedLine', null),
                  column: util.getArg(mapping, 'generatedColumn', null),
                  lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
    
                mapping = this._originalMappings[++index];
              }
            }
          }
    
          return mappings;
        };
    
      exports.SourceMapConsumer = SourceMapConsumer;
    
      /**
       * A BasicSourceMapConsumer instance represents a parsed source map which we can
       * query for information about the original file positions by giving it a file
       * position in the generated source.
       *
       * The only parameter is the raw source map (either as a JSON string, or
       * already parsed to an object). According to the spec, source maps have the
       * following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - sources: An array of URLs to the original source files.
       *   - names: An array of identifiers which can be referrenced by individual mappings.
       *   - sourceRoot: Optional. The URL root from which all sources are relative.
       *   - sourcesContent: Optional. An array of contents of the original source files.
       *   - mappings: A string of base64 VLQs which contain the actual mappings.
       *   - file: Optional. The generated file this source map is associated with.
       *
       * Here is an example source map, taken from the source map spec[0]:
       *
       *     {
       *       version : 3,
       *       file: "out.js",
       *       sourceRoot : "",
       *       sources: ["foo.js", "bar.js"],
       *       names: ["src", "maps", "are", "fun"],
       *       mappings: "AA,AB;;ABCDE;"
       *     }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
       */
      function BasicSourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        var version = util.getArg(sourceMap, 'version');
        var sources = util.getArg(sourceMap, 'sources');
        // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
        // requires the array) to play nice here.
        var names = util.getArg(sourceMap, 'names', []);
        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
        var mappings = util.getArg(sourceMap, 'mappings');
        var file = util.getArg(sourceMap, 'file', null);
    
        // Once again, Sass deviates from the spec and supplies the version as a
        // string rather than a number, so we use loose equality checking here.
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
    
        sources = sources
          // Some source maps produce relative source paths like "./foo.js" instead of
          // "foo.js".  Normalize these first so that future comparisons will succeed.
          // See bugzil.la/1090768.
          .map(util.normalize)
          // Always ensure that absolute sources are internally stored relative to
          // the source root, if the source root is absolute. Not doing this would
          // be particularly problematic when the source root is a prefix of the
          // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
          .map(function (source) {
            return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
              ? util.relative(sourceRoot, source)
              : source;
          });
    
        // Pass `true` below to allow duplicate names and sources. While source maps
        // are intended to be compressed and deduplicated, the TypeScript compiler
        // sometimes generates source maps with duplicates in them. See Github issue
        // #72 and bugzil.la/889492.
        this._names = ArraySet.fromArray(names, true);
        this._sources = ArraySet.fromArray(sources, true);
    
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this.file = file;
      }
    
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    
      /**
       * Create a BasicSourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @returns BasicSourceMapConsumer
       */
      BasicSourceMapConsumer.fromSourceMap =
        function SourceMapConsumer_fromSourceMap(aSourceMap) {
          var smc = Object.create(BasicSourceMapConsumer.prototype);
    
          var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
          var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
          smc.sourceRoot = aSourceMap._sourceRoot;
          smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                                  smc.sourceRoot);
          smc.file = aSourceMap._file;
    
          // Because we are modifying the entries (by converting string sources and
          // names to indices into the sources and names ArraySets), we have to make
          // a copy of the entry or else bad things happen. Shared mutable state
          // strikes again! See github issue #191.
    
          var generatedMappings = aSourceMap._mappings.toArray().slice();
          var destGeneratedMappings = smc.__generatedMappings = [];
          var destOriginalMappings = smc.__originalMappings = [];
    
          for (var i = 0, length = generatedMappings.length; i < length; i++) {
            var srcMapping = generatedMappings[i];
            var destMapping = new Mapping;
            destMapping.generatedLine = srcMapping.generatedLine;
            destMapping.generatedColumn = srcMapping.generatedColumn;
    
            if (srcMapping.source) {
              destMapping.source = sources.indexOf(srcMapping.source);
              destMapping.originalLine = srcMapping.originalLine;
              destMapping.originalColumn = srcMapping.originalColumn;
    
              if (srcMapping.name) {
                destMapping.name = names.indexOf(srcMapping.name);
              }
    
              destOriginalMappings.push(destMapping);
            }
    
            destGeneratedMappings.push(destMapping);
          }
    
          quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    
          return smc;
        };
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      BasicSourceMapConsumer.prototype._version = 3;
    
      /**
       * The list of original sources.
       */
      Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
        get: function () {
          return this._sources.toArray().map(function (s) {
            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
          }, this);
        }
      });
    
      /**
       * Provide the JIT with a nice shape / hidden class.
       */
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      BasicSourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          var generatedLine = 1;
          var previousGeneratedColumn = 0;
          var previousOriginalLine = 0;
          var previousOriginalColumn = 0;
          var previousSource = 0;
          var previousName = 0;
          var length = aStr.length;
          var index = 0;
          var cachedSegments = {};
          var temp = {};
          var originalMappings = [];
          var generatedMappings = [];
          var mapping, str, segment, end, value;
    
          while (index < length) {
            if (aStr.charAt(index) === ';') {
              generatedLine++;
              index++;
              previousGeneratedColumn = 0;
            }
            else if (aStr.charAt(index) === ',') {
              index++;
            }
            else {
              mapping = new Mapping();
              mapping.generatedLine = generatedLine;
    
              // Because each offset is encoded relative to the previous one,
              // many segments often have the same encoding. We can exploit this
              // fact by caching the parsed variable length fields of each segment,
              // allowing us to avoid a second parse if we encounter the same
              // segment again.
              for (end = index; end < length; end++) {
                if (this._charIsMappingSeparator(aStr, end)) {
                  break;
                }
              }
              str = aStr.slice(index, end);
    
              segment = cachedSegments[str];
              if (segment) {
                index += str.length;
              } else {
                segment = [];
                while (index < end) {
                  base64VLQ.decode(aStr, index, temp);
                  value = temp.value;
                  index = temp.rest;
                  segment.push(value);
                }
    
                if (segment.length === 2) {
                  throw new Error('Found a source, but no line and column');
                }
    
                if (segment.length === 3) {
                  throw new Error('Found a source and line, but no column');
                }
    
                cachedSegments[str] = segment;
              }
    
              // Generated column.
              mapping.generatedColumn = previousGeneratedColumn + segment[0];
              previousGeneratedColumn = mapping.generatedColumn;
    
              if (segment.length > 1) {
                // Original source.
                mapping.source = previousSource + segment[1];
                previousSource += segment[1];
    
                // Original line.
                mapping.originalLine = previousOriginalLine + segment[2];
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;
    
                // Original column.
                mapping.originalColumn = previousOriginalColumn + segment[3];
                previousOriginalColumn = mapping.originalColumn;
    
                if (segment.length > 4) {
                  // Original name.
                  mapping.name = previousName + segment[4];
                  previousName += segment[4];
                }
              }
    
              generatedMappings.push(mapping);
              if (typeof mapping.originalLine === 'number') {
                originalMappings.push(mapping);
              }
            }
          }
    
          quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
          this.__generatedMappings = generatedMappings;
    
          quickSort(originalMappings, util.compareByOriginalPositions);
          this.__originalMappings = originalMappings;
        };
    
      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */
      BasicSourceMapConsumer.prototype._findMapping =
        function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                               aColumnName, aComparator, aBias) {
          // To return the position we are searching for, we must first find the
          // mapping for the given position and then return the opposite position it
          // points to. Because the mappings are sorted, we can use binary search to
          // find the best mapping.
    
          if (aNeedle[aLineName] <= 0) {
            throw new TypeError('Line must be greater than or equal to 1, got '
                                + aNeedle[aLineName]);
          }
          if (aNeedle[aColumnName] < 0) {
            throw new TypeError('Column must be greater than or equal to 0, got '
                                + aNeedle[aColumnName]);
          }
    
          return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        };
    
      /**
       * Compute the last column for each generated mapping. The last column is
       * inclusive.
       */
      BasicSourceMapConsumer.prototype.computeColumnSpans =
        function SourceMapConsumer_computeColumnSpans() {
          for (var index = 0; index < this._generatedMappings.length; ++index) {
            var mapping = this._generatedMappings[index];
    
            // Mappings do not contain a field for the last generated columnt. We
            // can come up with an optimistic estimate, however, by assuming that
            // mappings are contiguous (i.e. given two consecutive mappings, the
            // first mapping ends where the second one starts).
            if (index + 1 < this._generatedMappings.length) {
              var nextMapping = this._generatedMappings[index + 1];
    
              if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
              }
            }
    
            // The last mapping for each line spans the entire line.
            mapping.lastGeneratedColumn = Infinity;
          }
        };
    
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */
      BasicSourceMapConsumer.prototype.originalPositionFor =
        function SourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
    
          var index = this._findMapping(
            needle,
            this._generatedMappings,
            "generatedLine",
            "generatedColumn",
            util.compareByGeneratedPositionsDeflated,
            util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
          );
    
          if (index >= 0) {
            var mapping = this._generatedMappings[index];
    
            if (mapping.generatedLine === needle.generatedLine) {
              var source = util.getArg(mapping, 'source', null);
              if (source !== null) {
                source = this._sources.at(source);
                if (this.sourceRoot != null) {
                  source = util.join(this.sourceRoot, source);
                }
              }
              var name = util.getArg(mapping, 'name', null);
              if (name !== null) {
                name = this._names.at(name);
              }
              return {
                source: source,
                line: util.getArg(mapping, 'originalLine', null),
                column: util.getArg(mapping, 'originalColumn', null),
                name: name
              };
            }
          }
    
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        };
    
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
        function BasicSourceMapConsumer_hasContentsOfAllSources() {
          if (!this.sourcesContent) {
            return false;
          }
          return this.sourcesContent.length >= this._sources.size() &&
            !this.sourcesContent.some(function (sc) { return sc == null; });
        };
    
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * availible.
       */
      BasicSourceMapConsumer.prototype.sourceContentFor =
        function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          if (!this.sourcesContent) {
            return null;
          }
    
          if (this.sourceRoot != null) {
            aSource = util.relative(this.sourceRoot, aSource);
          }
    
          if (this._sources.has(aSource)) {
            return this.sourcesContent[this._sources.indexOf(aSource)];
          }
    
          var url;
          if (this.sourceRoot != null
              && (url = util.urlParse(this.sourceRoot))) {
            // XXX: file:// URIs and absolute paths lead to unexpected behavior for
            // many users. We can help them out when they expect file:// URIs to
            // behave like it would if they were running a local HTTP server. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
            var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
            if (url.scheme == "file"
                && this._sources.has(fileUriAbsPath)) {
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
            }
    
            if ((!url.path || url.path == "/")
                && this._sources.has("/" + aSource)) {
              return this.sourcesContent[this._sources.indexOf("/" + aSource)];
            }
          }
    
          // This function is used recursively from
          // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
          // don't want to throw if we can't find the source - we just want to
          // return null, so we provide a flag to exit gracefully.
          if (nullOnMissing) {
            return null;
          }
          else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
    
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      BasicSourceMapConsumer.prototype.generatedPositionFor =
        function SourceMapConsumer_generatedPositionFor(aArgs) {
          var source = util.getArg(aArgs, 'source');
          if (this.sourceRoot != null) {
            source = util.relative(this.sourceRoot, source);
          }
          if (!this._sources.has(source)) {
            return {
              line: null,
              column: null,
              lastColumn: null
            };
          }
          source = this._sources.indexOf(source);
    
          var needle = {
            source: source,
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: util.getArg(aArgs, 'column')
          };
    
          var index = this._findMapping(
            needle,
            this._originalMappings,
            "originalLine",
            "originalColumn",
            util.compareByOriginalPositions,
            util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
          );
    
          if (index >= 0) {
            var mapping = this._originalMappings[index];
    
            if (mapping.source === needle.source) {
              return {
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
              };
            }
          }
    
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        };
    
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    
      /**
       * An IndexedSourceMapConsumer instance represents a parsed source map which
       * we can query for information. It differs from BasicSourceMapConsumer in
       * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
       * input.
       *
       * The only parameter is a raw source map (either as a JSON string, or already
       * parsed to an object). According to the spec for indexed source maps, they
       * have the following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - file: Optional. The generated file this source map is associated with.
       *   - sections: A list of section definitions.
       *
       * Each value under the "sections" field has two fields:
       *   - offset: The offset into the original specified at which this section
       *       begins to apply, defined as an object with a "line" and "column"
       *       field.
       *   - map: A source map definition. This source map could also be indexed,
       *       but doesn't have to be.
       *
       * Instead of the "map" field, it's also possible to have a "url" field
       * specifying a URL to retrieve a source map from, but that's currently
       * unsupported.
       *
       * Here's an example source map, taken from the source map spec[0], but
       * modified to omit a section which uses the "url" field.
       *
       *  {
       *    version : 3,
       *    file: "app.js",
       *    sections: [{
       *      offset: {line:100, column:10},
       *      map: {
       *        version : 3,
       *        file: "section.js",
       *        sources: ["foo.js", "bar.js"],
       *        names: ["src", "maps", "are", "fun"],
       *        mappings: "AAAA,E;;ABCDE;"
       *      }
       *    }],
       *  }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
       */
      function IndexedSourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        var version = util.getArg(sourceMap, 'version');
        var sections = util.getArg(sourceMap, 'sections');
    
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
    
        this._sources = new ArraySet();
        this._names = new ArraySet();
    
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function (s) {
          if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
          }
          var offset = util.getArg(s, 'offset');
          var offsetLine = util.getArg(offset, 'line');
          var offsetColumn = util.getArg(offset, 'column');
    
          if (offsetLine < lastOffset.line ||
              (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
          }
          lastOffset = offset;
    
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, 'map'))
          }
        });
      }
    
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      IndexedSourceMapConsumer.prototype._version = 3;
    
      /**
       * The list of original sources.
       */
      Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
        get: function () {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        }
      });
    
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */
      IndexedSourceMapConsumer.prototype.originalPositionFor =
        function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
    
          // Find the section containing the generated position we're trying to map
          // to an original position.
          var sectionIndex = binarySearch.search(needle, this._sections,
            function(needle, section) {
              var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
              if (cmp) {
                return cmp;
              }
    
              return (needle.generatedColumn -
                      section.generatedOffset.generatedColumn);
            });
          var section = this._sections[sectionIndex];
    
          if (!section) {
            return {
              source: null,
              line: null,
              column: null,
              name: null
            };
          }
    
          return section.consumer.originalPositionFor({
            line: needle.generatedLine -
              (section.generatedOffset.generatedLine - 1),
            column: needle.generatedColumn -
              (section.generatedOffset.generatedLine === needle.generatedLine
               ? section.generatedOffset.generatedColumn - 1
               : 0),
            bias: aArgs.bias
          });
        };
    
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
        function IndexedSourceMapConsumer_hasContentsOfAllSources() {
          return this._sections.every(function (s) {
            return s.consumer.hasContentsOfAllSources();
          });
        };
    
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      IndexedSourceMapConsumer.prototype.sourceContentFor =
        function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
    
            var content = section.consumer.sourceContentFor(aSource, true);
            if (content) {
              return content;
            }
          }
          if (nullOnMissing) {
            return null;
          }
          else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
    
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      IndexedSourceMapConsumer.prototype.generatedPositionFor =
        function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
    
            // Only consider this section if the requested source is in the list of
            // sources of the consumer.
            if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
              continue;
            }
            var generatedPosition = section.consumer.generatedPositionFor(aArgs);
            if (generatedPosition) {
              var ret = {
                line: generatedPosition.line +
                  (section.generatedOffset.generatedLine - 1),
                column: generatedPosition.column +
                  (section.generatedOffset.generatedLine === generatedPosition.line
                   ? section.generatedOffset.generatedColumn - 1
                   : 0)
              };
              return ret;
            }
          }
    
          return {
            line: null,
            column: null
          };
        };
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      IndexedSourceMapConsumer.prototype._parseMappings =
        function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          this.__generatedMappings = [];
          this.__originalMappings = [];
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var sectionMappings = section.consumer._generatedMappings;
            for (var j = 0; j < sectionMappings.length; j++) {
              var mapping = sectionMappings[i];
    
              var source = section.consumer._sources.at(mapping.source);
              if (section.consumer.sourceRoot !== null) {
                source = util.join(section.consumer.sourceRoot, source);
              }
              this._sources.add(source);
              source = this._sources.indexOf(source);
    
              var name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
    
              // The mappings coming from the consumer for the section have
              // generated positions relative to the start of the section, so we
              // need to offset them to be relative to the start of the concatenated
              // generated file.
              var adjustedMapping = {
                source: source,
                generatedLine: mapping.generatedLine +
                  (section.generatedOffset.generatedLine - 1),
                generatedColumn: mapping.column +
                  (section.generatedOffset.generatedLine === mapping.generatedLine)
                  ? section.generatedOffset.generatedColumn - 1
                  : 0,
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: name
              };
    
              this.__generatedMappings.push(adjustedMapping);
              if (typeof adjustedMapping.originalLine === 'number') {
                this.__originalMappings.push(adjustedMapping);
              }
            }
          }
    
          quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
          quickSort(this.__originalMappings, util.compareByOriginalPositions);
        };
    
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    }
    
  provide("source-map/lib/source-map-consumer", module.exports);
}(global));

// pakmanager:source-map/lib/source-node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    {
      var SourceMapGenerator =  require('source-map/lib/source-map-generator').SourceMapGenerator;
      var util =  require('source-map/lib/util');
    
      // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
      // operating systems these days (capturing the result).
      var REGEX_NEWLINE = /(\r?\n)/;
    
      // Newline character code for charCodeAt() comparisons
      var NEWLINE_CODE = 10;
    
      // Private symbol for identifying `SourceNode`s when multiple versions of
      // the source-map library are loaded. This MUST NOT CHANGE across
      // versions!
      var isSourceNode = "$$$isSourceNode$$$";
    
      /**
       * SourceNodes provide a way to abstract over interpolating/concatenating
       * snippets of generated JavaScript source code while maintaining the line and
       * column information associated with the original source code.
       *
       * @param aLine The original line number.
       * @param aColumn The original column number.
       * @param aSource The original source's filename.
       * @param aChunks Optional. An array of strings which are snippets of
       *        generated JS, or other SourceNodes.
       * @param aName The original identifier.
       */
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }
    
      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */
      SourceNode.fromStringWithSourceMap =
        function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
          // The SourceNode we want to fill with the generated code
          // and the SourceMap
          var node = new SourceNode();
    
          // All even indices of this array are one line of the generated code,
          // while all odd indices are the newlines between two adjacent lines
          // (since `REGEX_NEWLINE` captures its match).
          // Processed fragments are removed from this array, by calling `shiftNextLine`.
          var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
          var shiftNextLine = function() {
            var lineContents = remainingLines.shift();
            // The last line of a file might not have a newline.
            var newLine = remainingLines.shift() || "";
            return lineContents + newLine;
          };
    
          // We need to remember the position of "remainingLines"
          var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    
          // The generate SourceNodes we need a code range.
          // To extract it current and last mapping is used.
          // Here we store the last mapping.
          var lastMapping = null;
    
          aSourceMapConsumer.eachMapping(function (mapping) {
            if (lastMapping !== null) {
              // We add the code from "lastMapping" to "mapping":
              // First check if there is a new line in between.
              if (lastGeneratedLine < mapping.generatedLine) {
                var code = "";
                // Associate first line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
                // The remaining code is added without mapping
              } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[0];
                var code = nextLine.substr(0, mapping.generatedColumn -
                                              lastGeneratedColumn);
                remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                    lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
                // No more remaining code, continue
                lastMapping = mapping;
                return;
              }
            }
            // We add the generated code until the first mapping
            // to the SourceNode without any mapping.
            // Each line is added as separate string.
            while (lastGeneratedLine < mapping.generatedLine) {
              node.add(shiftNextLine());
              lastGeneratedLine++;
            }
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              node.add(nextLine.substr(0, mapping.generatedColumn));
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            lastMapping = mapping;
          }, this);
          // We have processed all mappings.
          if (remainingLines.length > 0) {
            if (lastMapping) {
              // Associate the remaining code in the current line with "lastMapping"
              addMappingWithCode(lastMapping, shiftNextLine());
            }
            // and add the remaining lines without any mapping
            node.add(remainingLines.join(""));
          }
    
          // Copy sourcesContent into SourceNode
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
              }
              node.setSourceContent(sourceFile, content);
            }
          });
    
          return node;
    
          function addMappingWithCode(mapping, code) {
            if (mapping === null || mapping.source === undefined) {
              node.add(code);
            } else {
              var source = aRelativePath
                ? util.join(aRelativePath, mapping.source)
                : mapping.source;
              node.add(new SourceNode(mapping.originalLine,
                                      mapping.originalColumn,
                                      source,
                                      code,
                                      mapping.name));
            }
          }
        };
    
      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        }
        else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length-1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        }
        else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          }
          else {
            if (chunk !== '') {
              aFn(chunk, { source: this.source,
                           line: this.line,
                           column: this.column,
                           name: this.name });
            }
          }
        }
      };
    
      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len-1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
    
      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        }
        else if (typeof lastChild === 'string') {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        }
        else {
          this.children.push(''.replace(aPattern, aReplacement));
        }
        return this;
      };
    
      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      SourceNode.prototype.setSourceContent =
        function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        };
    
      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walkSourceContents =
        function SourceNode_walkSourceContents(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i][isSourceNode]) {
              this.children[i].walkSourceContents(aFn);
            }
          }
    
          var sources = Object.keys(this.sourceContents);
          for (var i = 0, len = sources.length; i < len; i++) {
            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
          }
        };
    
      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };
    
      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function (chunk, original) {
          generated.code += chunk;
          if (original.source !== null
              && original.line !== null
              && original.column !== null) {
            if(lastOriginalSource !== original.source
               || lastOriginalLine !== original.line
               || lastOriginalColumn !== original.column
               || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              // Mappings end at eol
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
    
        return { code: generated.code, map: map };
      };
    
      exports.SourceNode = SourceNode;
    }
    
  provide("source-map/lib/source-node", module.exports);
}(global));

// pakmanager:source-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * Copyright 2009-2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE.txt or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    exports.SourceMapGenerator =  require('source-map/lib/source-map-generator').SourceMapGenerator;
    exports.SourceMapConsumer =  require('source-map/lib/source-map-consumer').SourceMapConsumer;
    exports.SourceNode =  require('source-map/lib/source-node').SourceNode;
    
  provide("source-map", module.exports);
}(global));

// pakmanager:center-align
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * center-align <https://github.com/jonschlinkert/center-align>
     *
     * Copycenter (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var align = require('align-text');
    
    module.exports = function centerAlign(val) {
      return align(val, function (len, longest) {
        return Math.floor((longest - len) / 2);
      });
    };
    
  provide("center-align", module.exports);
}(global));

// pakmanager:right-align
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * right-align <https://github.com/jonschlinkert/right-align>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var align = require('align-text');
    
    module.exports = function rightAlign(val) {
      return align(val, function (len, longest) {
        return longest - len;
      });
    };
    
  provide("right-align", module.exports);
}(global));

// pakmanager:lcid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var invertKv = require('invert-kv');
    var all = require('./lcid.json');
    var inverted = invertKv(all);
    
    exports.from = function (lcidCode) {
    	if (typeof lcidCode !== 'number') {
    		throw new TypeError('Expected a number');
    	}
    
    	return inverted[lcidCode];
    };
    
    exports.to = function (localeId) {
    	if (typeof localeId !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return all[localeId];
    };
    
    exports.all = all;
    
  provide("lcid", module.exports);
}(global));

// pakmanager:align-text
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * align-text <https://github.com/jonschlinkert/align-text>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var typeOf = require('kind-of');
    var repeat = require('repeat-string');
    var longest = require('longest');
    
    module.exports = function alignText(val, fn) {
      var lines, type = typeOf(val);
    
      if (type === 'array') {
        lines = val;
      } else if (type === 'string') {
        lines = val.split(/(?:\r\n|\n)/);
      } else {
        throw new TypeError('align-text expects a string or array.');
      }
    
      var fnType = typeOf(fn);
      var len = lines.length;
      var max = longest(lines);
      var res = [], i = 0;
    
      while (len--) {
        var line = String(lines[i++]);
        var diff;
    
        if (fnType === 'function') {
          diff = fn(line.length, max.length, line, lines, i);
        } else if (fnType === 'number') {
          diff = fn;
        } else {
          diff = max.length - line.length;
        }
    
        if (typeOf(diff) === 'number') {
          res.push(repeat(' ', diff) + line);
        } else if (typeOf(diff) === 'object') {
          var result = repeat(diff.character || ' ', diff.indent || 0);
          res.push((diff.prefix || '') + result + line);
        }
      }
    
      if (type === 'array') return res;
      return res.join('\n');
    };
    
  provide("align-text", module.exports);
}(global));

// pakmanager:invert-kv
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (obj) {
    	if (typeof obj !== 'object') {
    		throw new TypeError('Expected an object');
    	}
    
    	var ret = {};
    
    	for (var key in obj) {
    		var val = obj[key];
    		ret[val] = key;
    	}
    
    	return ret;
    };
    
  provide("invert-kv", module.exports);
}(global));

// pakmanager:kind-of
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isBuffer = require('is-buffer');
    var toString = Object.prototype.toString;
    
    /**
     * Get the native `typeof` a value.
     *
     * @param  {*} `val`
     * @return {*} Native javascript type
     */
    
    module.exports = function kindOf(val) {
      // primitivies
      if (typeof val === 'undefined') {
        return 'undefined';
      }
      if (val === null) {
        return 'null';
      }
      if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
      }
      if (typeof val === 'string' || val instanceof String) {
        return 'string';
      }
      if (typeof val === 'number' || val instanceof Number) {
        return 'number';
      }
    
      // functions
      if (typeof val === 'function' || val instanceof Function) {
        return 'function';
      }
    
      // array
      if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
      }
    
      // check for instances of RegExp and Date before calling `toString`
      if (val instanceof RegExp) {
        return 'regexp';
      }
      if (val instanceof Date) {
        return 'date';
      }
    
      // other objects
      var type = toString.call(val);
    
      if (type === '[object RegExp]') {
        return 'regexp';
      }
      if (type === '[object Date]') {
        return 'date';
      }
      if (type === '[object Arguments]') {
        return 'arguments';
      }
    
      // buffer
      if (typeof Buffer !== 'undefined' && isBuffer(val)) {
        return 'buffer';
      }
    
      // es6: Map, WeakMap, Set, WeakSet
      if (type === '[object Set]') {
        return 'set';
      }
      if (type === '[object WeakSet]') {
        return 'weakset';
      }
      if (type === '[object Map]') {
        return 'map';
      }
      if (type === '[object WeakMap]') {
        return 'weakmap';
      }
      if (type === '[object Symbol]') {
        return 'symbol';
      }
    
      // must be a plain object
      return 'object';
    };
    
  provide("kind-of", module.exports);
}(global));

// pakmanager:longest
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * longest <https://github.com/jonschlinkert/longest>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function(arr) {
      if (!arr) {
        return null;
      }
    
      var len = arr.length;
      if (!len) {
        return null;
      }
    
      var c = 0;
      var i = 0;
      var ele;
      var elen;
      var res;
    
      for (; i < len; i++) {
        ele = arr[i].toString();
        elen = ele.length;
    
        if (elen > c) {
          res = ele;
          c = elen;
        }
      }
    
      return res;
    };
    
  provide("longest", module.exports);
}(global));

// pakmanager:repeat-string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * repeat-string <https://github.com/jonschlinkert/repeat-string>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    /**
     * Expose `repeat`
     */
    
    module.exports = repeat;
    
    /**
     * Repeat the given `string` the specified `number`
     * of times.
     *
     * **Example:**
     *
     * ```js
     * var repeat =  require('repeat-string');
     * repeat('A', 5);
     * //=> AAAAA
     * ```
     *
     * @param {String} `string` The string to repeat
     * @param {Number} `number` The number of times to repeat the string
     * @return {String} Repeated string
     * @api public
     */
    
    function repeat(str, num) {
      if (typeof str !== 'string') {
        throw new TypeError('repeat-string expects a string.');
      }
    
      if (num === 1) return str;
      if (num === 2) return str + str;
    
      var max = str.length * num;
      if (cache !== str || typeof cache === 'undefined') {
        cache = str;
        res = '';
      }
    
      while (max > res.length && num > 0) {
        if (num & 1) {
          res += str;
        }
    
        num >>= 1;
        if (!num) break;
        str += str;
      }
    
      return res.substr(0, max);
    }
    
    /**
     * Results cache
     */
    
    var res = '';
    var cache;
    
  provide("repeat-string", module.exports);
}(global));

// pakmanager:is-buffer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Determine if an object is Buffer
     *
     * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * License:  MIT
     *
     * `npm install is-buffer`
     */
    
    module.exports = function (obj) {
      return !!(
        obj != null &&
        obj.constructor &&
        typeof obj.constructor.isBuffer === 'function' &&
        obj.constructor.isBuffer(obj)
      )
    }
    
  provide("is-buffer", module.exports);
}(global));

// pakmanager:delayed-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream').Stream;
    var util = require('util');
    
    module.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
    
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
    
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
    
      delayedStream.source = source;
    
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
    
      source.on('error', function() {});
      if (delayedStream.pauseStream) {
        source.pause();
      }
    
      return delayedStream;
    };
    
    Object.defineProperty(DelayedStream.prototype, 'readable', {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
    
      this.source.resume();
    };
    
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    
    DelayedStream.prototype.release = function() {
      this._released = true;
    
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
    
      if (args[0] === 'data') {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
    
      this._bufferedEvents.push(args);
    };
    
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
    
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
    
      this._maxDataSizeExceeded = true;
      var message =
        'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
      this.emit('error', new Error(message));
    };
    
  provide("delayed-stream", module.exports);
}(global));

// pakmanager:mime-db
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mime-db
     * Copyright(c) 2014 Jonathan Ong
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = require('./db.json')
    
  provide("mime-db", module.exports);
}(global));

// pakmanager:boom
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Http = require('http');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.wrap = function (error, statusCode, message) {
    
        Hoek.assert(error instanceof Error, 'Cannot wrap non-Error object');
        return (error.isBoom ? error : internals.initialize(error, statusCode || 500, message));
    };
    
    
    exports.create = function (statusCode, message, data) {
    
        var error = new Error(message ? message : undefined);       // Avoids settings null message
        error.data = data || null;
        internals.initialize(error, statusCode);
        return error;
    };
    
    
    internals.initialize = function (error, statusCode, message) {
    
        var numberCode = parseInt(statusCode, 10);
        Hoek.assert(!isNaN(numberCode) && numberCode >= 400, 'First argument must be a number (400+):', statusCode);
    
        error.isBoom = true;
        error.isServer = numberCode >= 500;
    
        if (!error.hasOwnProperty('data')) {
            error.data = null;
        }
    
        error.output = {
            statusCode: numberCode,
            payload: {},
            headers: {}
        };
    
        error.reformat = internals.reformat;
        error.reformat();
    
        if (!message &&
            !error.message) {
    
            message = error.output.payload.error;
        }
    
        if (message) {
            error.message = (message + (error.message ? ': ' + error.message : ''));
        }
    
        return error;
    };
    
    
    internals.reformat = function () {
    
        this.output.payload.statusCode = this.output.statusCode;
        this.output.payload.error = Http.STATUS_CODES[this.output.statusCode] || 'Unknown';
    
        if (this.output.statusCode === 500) {
            this.output.payload.message = 'An internal server error occurred';              // Hide actual error from user
        }
        else if (this.message) {
            this.output.payload.message = this.message;
        }
    };
    
    
    // 4xx Client Errors
    
    exports.badRequest = function (message, data) {
    
        return exports.create(400, message, data);
    };
    
    
    exports.unauthorized = function (message, scheme, attributes) {          // Or function (message, wwwAuthenticate[])
    
        var err = exports.create(401, message);
    
        if (!scheme) {
            return err;
        }
    
        var wwwAuthenticate = '';
        var i = 0;
        var il = 0;
    
        if (typeof scheme === 'string') {
    
            // function (message, scheme, attributes)
    
            wwwAuthenticate = scheme;
    
            if (attributes || message) {
                err.output.payload.attributes = {};
            }
    
            if (attributes) {
                var names = Object.keys(attributes);
                for (i = 0, il = names.length; i < il; ++i) {
                    var name = names[i];
                    if (i) {
                        wwwAuthenticate += ',';
                    }
    
                    var value = attributes[name];
                    if (value === null ||
                        value === undefined) {              // Value can be zero
    
                        value = '';
                    }
                    wwwAuthenticate += ' ' + name + '="' + Hoek.escapeHeaderAttribute(value.toString()) + '"';
                    err.output.payload.attributes[name] = value;
                }
            }
    
            if (message) {
                if (attributes) {
                    wwwAuthenticate += ',';
                }
                wwwAuthenticate += ' error="' + Hoek.escapeHeaderAttribute(message) + '"';
                err.output.payload.attributes.error = message;
            }
            else {
                err.isMissing = true;
            }
        }
        else {
    
            // function (message, wwwAuthenticate[])
    
            var wwwArray = scheme;
            for (i = 0, il = wwwArray.length; i < il; ++i) {
                if (i) {
                    wwwAuthenticate += ', ';
                }
    
                wwwAuthenticate += wwwArray[i];
            }
        }
    
        err.output.headers['WWW-Authenticate'] = wwwAuthenticate;
    
        return err;
    };
    
    
    exports.forbidden = function (message, data) {
    
        return exports.create(403, message, data);
    };
    
    
    exports.notFound = function (message, data) {
    
        return exports.create(404, message, data);
    };
    
    
    exports.methodNotAllowed = function (message, data) {
    
        return exports.create(405, message, data);
    };
    
    
    exports.notAcceptable = function (message, data) {
    
        return exports.create(406, message, data);
    };
    
    
    exports.proxyAuthRequired = function (message, data) {
    
        return exports.create(407, message, data);
    };
    
    
    exports.clientTimeout = function (message, data) {
    
        return exports.create(408, message, data);
    };
    
    
    exports.conflict = function (message, data) {
    
        return exports.create(409, message, data);
    };
    
    
    exports.resourceGone = function (message, data) {
    
        return exports.create(410, message, data);
    };
    
    
    exports.lengthRequired = function (message, data) {
    
        return exports.create(411, message, data);
    };
    
    
    exports.preconditionFailed = function (message, data) {
    
        return exports.create(412, message, data);
    };
    
    
    exports.entityTooLarge = function (message, data) {
    
        return exports.create(413, message, data);
    };
    
    
    exports.uriTooLong = function (message, data) {
    
        return exports.create(414, message, data);
    };
    
    
    exports.unsupportedMediaType = function (message, data) {
    
        return exports.create(415, message, data);
    };
    
    
    exports.rangeNotSatisfiable = function (message, data) {
    
        return exports.create(416, message, data);
    };
    
    
    exports.expectationFailed = function (message, data) {
    
        return exports.create(417, message, data);
    };
    
    exports.badData = function (message, data) {
    
        return exports.create(422, message, data);
    };
    
    
    exports.tooManyRequests = function (message, data) {
    
        return exports.create(429, message, data);
    };
    
    
    // 5xx Server Errors
    
    exports.internal = function (message, data, statusCode) {
    
        var error = (data instanceof Error ? exports.wrap(data, statusCode, message) : exports.create(statusCode || 500, message));
    
        if (data instanceof Error === false) {
            error.data = data;
        }
    
        return error;
    };
    
    
    exports.notImplemented = function (message, data) {
    
        return exports.internal(message, data, 501);
    };
    
    
    exports.badGateway = function (message, data) {
    
        return exports.internal(message, data, 502);
    };
    
    
    exports.serverTimeout = function (message, data) {
    
        return exports.internal(message, data, 503);
    };
    
    
    exports.gatewayTimeout = function (message, data) {
    
        return exports.internal(message, data, 504);
    };
    
    
    exports.badImplementation = function (message, data) {
    
        var err = exports.internal(message, data, 500);
        err.isDeveloperError = true;
        return err;
    };
    
  provide("boom", module.exports);
}(global));

// pakmanager:ansi-styles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function assembleStyles () {
    	var styles = {
    		modifiers: {
    			reset: [0, 0],
    			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
    			dim: [2, 22],
    			italic: [3, 23],
    			underline: [4, 24],
    			inverse: [7, 27],
    			hidden: [8, 28],
    			strikethrough: [9, 29]
    		},
    		colors: {
    			black: [30, 39],
    			red: [31, 39],
    			green: [32, 39],
    			yellow: [33, 39],
    			blue: [34, 39],
    			magenta: [35, 39],
    			cyan: [36, 39],
    			white: [37, 39],
    			gray: [90, 39]
    		},
    		bgColors: {
    			bgBlack: [40, 49],
    			bgRed: [41, 49],
    			bgGreen: [42, 49],
    			bgYellow: [43, 49],
    			bgBlue: [44, 49],
    			bgMagenta: [45, 49],
    			bgCyan: [46, 49],
    			bgWhite: [47, 49]
    		}
    	};
    
    	// fix humans
    	styles.colors.grey = styles.colors.gray;
    
    	Object.keys(styles).forEach(function (groupName) {
    		var group = styles[groupName];
    
    		Object.keys(group).forEach(function (styleName) {
    			var style = group[styleName];
    
    			styles[styleName] = group[styleName] = {
    				open: '\u001b[' + style[0] + 'm',
    				close: '\u001b[' + style[1] + 'm'
    			};
    		});
    
    		Object.defineProperty(styles, groupName, {
    			value: group,
    			enumerable: false
    		});
    	});
    
    	return styles;
    }
    
    Object.defineProperty(module, 'exports', {
    	enumerable: true,
    	get: assembleStyles
    });
    
  provide("ansi-styles", module.exports);
}(global));

// pakmanager:escape-string-regexp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    
    module.exports = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(matchOperatorsRe,  '\\$&');
    };
    
  provide("escape-string-regexp", module.exports);
}(global));

// pakmanager:has-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var ansiRegex = require('ansi-regex');
    var re = new RegExp(ansiRegex().source); // remove the `g` flag
    module.exports = re.test.bind(re);
    
  provide("has-ansi", module.exports);
}(global));

// pakmanager:strip-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var ansiRegex = require('ansi-regex')();
    
    module.exports = function (str) {
    	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
    };
    
  provide("strip-ansi", module.exports);
}(global));

// pakmanager:supports-color
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var hasFlag = require('has-flag');
    
    var support = function (level) {
    	if (level === 0) {
    		return false;
    	}
    
    	return {
    		level: level,
    		hasBasic: true,
    		has256: level >= 2,
    		has16m: level >= 3
    	};
    };
    
    var supportLevel = (function () {
    	if (hasFlag('no-color') ||
    		hasFlag('no-colors') ||
    		hasFlag('color=false')) {
    		return 0;
    	}
    
    	if (hasFlag('color=16m') ||
    		hasFlag('color=full') ||
    		hasFlag('color=truecolor')) {
    		return 3;
    	}
    
    	if (hasFlag('color=256')) {
    		return 2;
    	}
    
    	if (hasFlag('color') ||
    		hasFlag('colors') ||
    		hasFlag('color=true') ||
    		hasFlag('color=always')) {
    		return 1;
    	}
    
    	if ('electron' in process.versions) {
    		return 0;
    	}
    
    	if (process.stdout && !process.stdout.isTTY) {
    		return 0;
    	}
    
    	if (process.platform === 'win32') {
    		return 1;
    	}
    
    	if ('COLORTERM' in process.env) {
    		return 1;
    	}
    
    	if (process.env.TERM === 'dumb') {
    		return 0;
    	}
    
    	if (/^xterm-256(?:color)?/.test(process.env.TERM)) {
    		return 2;
    	}
    
    	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    		return 1;
    	}
    
    	return 0;
    })();
    
    if (supportLevel === 0 && 'FORCE_COLOR' in process.env) {
    	supportLevel = 1;
    }
    
    module.exports = process && support(supportLevel);
    
  provide("supports-color", module.exports);
}(global));

// pakmanager:graceful-readlink
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
      , lstat = fs.lstatSync;
    
    exports.readlinkSync = function (p) {
      if (lstat(p).isSymbolicLink()) {
        return fs.readlinkSync(p);
      } else {
        return p;
      }
    };
    
    
    
  provide("graceful-readlink", module.exports);
}(global));

// pakmanager:generate-function
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util')
    
    var INDENT_START = /[\{\[]/
    var INDENT_END = /[\}\]]/
    
    module.exports = function() {
      var lines = []
      var indent = 0
    
      var push = function(str) {
        var spaces = ''
        while (spaces.length < indent*2) spaces += '  '
        lines.push(spaces+str)
      }
    
      var line = function(fmt) {
        if (!fmt) return line
    
        if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {
          indent--
          push(util.format.apply(util, arguments))
          indent++
          return line
        }
        if (INDENT_START.test(fmt[fmt.length-1])) {
          push(util.format.apply(util, arguments))
          indent++
          return line
        }
        if (INDENT_END.test(fmt.trim()[0])) {
          indent--
          push(util.format.apply(util, arguments))
          return line
        }
    
        push(util.format.apply(util, arguments))
        return line
      }
    
      line.toString = function() {
        return lines.join('\n')
      }
    
      line.toFunction = function(scope) {
        var src = 'return ('+line.toString()+')'
    
        var keys = Object.keys(scope || {}).map(function(key) {
          return key
        })
    
        var vals = keys.map(function(key) {
          return scope[key]
        })
    
        return Function.apply(null, keys.concat(src)).apply(null, vals)
      }
    
      if (arguments.length) line.apply(null, arguments)
    
      return line
    }
    
  provide("generate-function", module.exports);
}(global));

// pakmanager:generate-object-property
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isProperty = require('is-property')
    
    var gen = function(obj, prop) {
      return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'
    }
    
    gen.valid = isProperty
    gen.property = function (prop) {
     return isProperty(prop) ? prop : JSON.stringify(prop)
    }
    
    module.exports = gen
    
  provide("generate-object-property", module.exports);
}(global));

// pakmanager:jsonpointer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var untilde = function(str) {
      return str.replace(/~./g, function(m) {
        switch (m) {
          case "~0":
            return "~";
          case "~1":
            return "/";
        }
        throw new Error("Invalid tilde escape: " + m);
      });
    }
    
    var traverse = function(obj, pointer, value) {
      // assert(isArray(pointer))
      var part = untilde(pointer.shift());
      if(!obj.hasOwnProperty(part)) {
        return null;
      }
      if(pointer.length !== 0) { // keep traversin!
        return traverse(obj[part], pointer, value);
      }
      // we're done
      if(typeof value === "undefined") {
        // just reading
        return obj[part];
      }
      // set new value, return old value
      var old_value = obj[part];
      if(value === null) {
        delete obj[part];
      } else {
        obj[part] = value;
      }
      return old_value;
    }
    
    var validate_input = function(obj, pointer) {
      if(typeof obj !== "object") {
        throw new Error("Invalid input object.");
      }
    
      if(pointer === "") {
        return [];
      }
    
      if(!pointer) {
        throw new Error("Invalid JSON pointer.");
      }
    
      pointer = pointer.split("/");
      var first = pointer.shift();
      if (first !== "") {
        throw new Error("Invalid JSON pointer.");
      }
    
      return pointer;
    }
    
    var get = function(obj, pointer) {
      pointer = validate_input(obj, pointer);
      if (pointer.length === 0) {
        return obj;
      }
      return traverse(obj, pointer);
    }
    
    var set = function(obj, pointer, value) {
      pointer = validate_input(obj, pointer);
      if (pointer.length === 0) {
        throw new Error("Invalid JSON pointer for set.")
      }
      return traverse(obj, pointer, value);
    }
    
    exports.get = get
    exports.set = set
    
  provide("jsonpointer", module.exports);
}(global));

// pakmanager:typedarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var undefined = (void 0); // Paranoia
    
    // Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
    // create, and consume so much memory, that the browser appears frozen.
    var MAX_ARRAY_LENGTH = 1e5;
    
    // Approximations of internal ECMAScript conversion functions
    var ECMAScript = (function() {
      // Stash a copy in case other scripts modify these
      var opts = Object.prototype.toString,
          ophop = Object.prototype.hasOwnProperty;
    
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) { return opts.call(v).replace(/^\[object *|\]$/g, ''); },
        HasProperty: function(o, p) { return p in o; },
        HasOwnProperty: function(o, p) { return ophop.call(o, p); },
        IsCallable: function(o) { return typeof o === 'function'; },
        ToInt32: function(v) { return v >> 0; },
        ToUint32: function(v) { return v >>> 0; }
      };
    }());
    
    // Snapshot intrinsics
    var LN2 = Math.LN2,
        abs = Math.abs,
        floor = Math.floor,
        log = Math.log,
        min = Math.min,
        pow = Math.pow,
        round = Math.round;
    
    // ES5: lock down object properties
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1) {
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    
    // emulate ES5 getter/setter API using legacy APIs
    // http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
    // (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
    // note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
    var defineProp
    if (Object.defineProperty && (function() {
          try {
            Object.defineProperty({}, 'x', {});
            return true;
          } catch (e) {
            return false;
          }
        })()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = function(o, p, desc) {
        if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
        if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
        if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }
        return o;
      };
    }
    
    var getOwnPropNames = Object.getOwnPropertyNames || function (o) {
      if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    
    // ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
    // for index in 0 ... obj.length
    function makeArrayAccessors(obj) {
      if (!defineProp) { return; }
    
      if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");
    
      function makeArrayAccessor(index) {
        defineProp(obj, index, {
          'get': function() { return obj._getter(index); },
          'set': function(v) { obj._setter(index, v); },
          enumerable: true,
          configurable: false
        });
      }
    
      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }
    
    // Internal conversion functions:
    //    pack<Type>()   - take a number (interpreted as Type), output a byte array
    //    unpack<Type>() - take a byte array, output a Type-like number
    
    function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
    function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }
    
    function packI8(n) { return [n & 0xff]; }
    function unpackI8(bytes) { return as_signed(bytes[0], 8); }
    
    function packU8(n) { return [n & 0xff]; }
    function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }
    
    function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }
    
    function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
    function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }
    
    function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
    function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }
    
    function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
    function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }
    
    function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
    function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }
    
    function packIEEE754(v, ebits, fbits) {
    
      var bias = (1 << (ebits - 1)) - 1,
          s, e, f, ln,
          i, bits, str, bytes;
    
      function roundToEven(n) {
        var w = floor(n), f = n - w;
        if (f < 0.5)
          return w;
        if (f > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }
    
      // Compute sign, exponent, fraction
      if (v !== v) {
        // NaN
        // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
        e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
      } else if (v === 0) {
        e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
      } else {
        s = v < 0;
        v = abs(v);
    
        if (v >= pow(2, 1 - bias)) {
          e = min(floor(log(v) / LN2), 1023);
          f = roundToEven(v / pow(2, e) * pow(2, fbits));
          if (f / pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            // Overflow
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            // Normalized
            e = e + bias;
            f = f - pow(2, fbits);
          }
        } else {
          // Denormalized
          e = 0;
          f = roundToEven(v / pow(2, 1 - bias - fbits));
        }
      }
    
      // Pack sign, exponent, fraction
      bits = [];
      for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
      for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join('');
    
      // Bits to bytes
      bytes = [];
      while (str.length) {
        bytes.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes;
    }
    
    function unpackIEEE754(bytes, ebits, fbits) {
    
      // Bytes to bits
      var bits = [], i, j, b, str,
          bias, s, e, f;
    
      for (i = bytes.length; i; i -= 1) {
        b = bytes[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0); b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join('');
    
      // Unpack sign, exponent, fraction
      bias = (1 << (ebits - 1)) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
    
      // Produce number
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        // Normalized
        return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
      } else if (f !== 0) {
        // Denormalized
        return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }
    
    function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
    function packF64(v) { return packIEEE754(v, 11, 52); }
    function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
    function packF32(v) { return packIEEE754(v, 8, 23); }
    
    
    //
    // 3 The ArrayBuffer Type
    //
    
    (function() {
    
      /** @constructor */
      var ArrayBuffer = function ArrayBuffer(length) {
        length = ECMAScript.ToInt32(length);
        if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');
    
        this.byteLength = length;
        this._bytes = [];
        this._bytes.length = length;
    
        var i;
        for (i = 0; i < this.byteLength; i += 1) {
          this._bytes[i] = 0;
        }
    
        configureProperties(this);
      };
    
      exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;
    
      //
      // 4 The ArrayBufferView Type
      //
    
      // NOTE: this constructor is not exported
      /** @constructor */
      var ArrayBufferView = function ArrayBufferView() {
        //this.buffer = null;
        //this.byteOffset = 0;
        //this.byteLength = 0;
      };
    
      //
      // 5 The Typed Array View Types
      //
    
      function makeConstructor(bytesPerElement, pack, unpack) {
        // Each TypedArray type requires a distinct constructor instance with
        // identical logic, which this produces.
    
        var ctor;
        ctor = function(buffer, byteOffset, length) {
          var array, sequence, i, s;
    
          if (!arguments.length || typeof arguments[0] === 'number') {
            // Constructor(unsigned long length)
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');
    
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {
            // Constructor(TypedArray array)
            array = arguments[0];
    
            this.length = array.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
    
            for (i = 0; i < this.length; i += 1) {
              this._setter(i, array._getter(i));
            }
          } else if (typeof arguments[0] === 'object' &&
                     !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
            // Constructor(sequence<type> array)
            sequence = arguments[0];
    
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
    
            for (i = 0; i < this.length; i += 1) {
              s = sequence[i];
              this._setter(i, Number(s));
            }
          } else if (typeof arguments[0] === 'object' &&
                     (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
            // Constructor(ArrayBuffer buffer,
            //             optional unsigned long byteOffset, optional unsigned long length)
            this.buffer = buffer;
    
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
    
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              // The given byteOffset must be a multiple of the element
              // size of the specific type, otherwise an exception is raised.
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
    
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
    
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
    
            if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
    
          this.constructor = ctor;
    
          configureProperties(this);
          makeArrayAccessors(this);
        };
    
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
    
        // getter type (unsigned long index);
        ctor.prototype._getter = function(index) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
    
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined;
          }
    
          var bytes = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
               i < this.BYTES_PER_ELEMENT;
               i += 1, o += 1) {
            bytes.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes);
        };
    
        // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
        ctor.prototype.get = ctor.prototype._getter;
    
        // setter void (unsigned long index, type value);
        ctor.prototype._setter = function(index, value) {
          if (arguments.length < 2) throw new SyntaxError("Not enough arguments");
    
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined;
          }
    
          var bytes = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
               i < this.BYTES_PER_ELEMENT;
               i += 1, o += 1) {
            this.buffer._bytes[o] = bytes[i];
          }
        };
    
        // void set(TypedArray array, optional unsigned long offset);
        // void set(sequence<type> array, optional unsigned long offset);
        ctor.prototype.set = function(index, value) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len,
              i, s, d,
              byteOffset, byteLength, tmp;
    
          if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
            // void set(TypedArray array, optional unsigned long offset);
            array = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
    
            if (offset + array.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
    
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;
    
            if (array.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array.byteOffset, d = byteOffset;
                   i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
            // void set(sequence<type> array, optional unsigned long offset);
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
    
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
    
            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
    
        // TypedArray subarray(long begin, optional long end);
        ctor.prototype.subarray = function(start, end) {
          function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
    
          start = ECMAScript.ToInt32(start);
          end = ECMAScript.ToInt32(end);
    
          if (arguments.length < 1) { start = 0; }
          if (arguments.length < 2) { end = this.length; }
    
          if (start < 0) { start = this.length + start; }
          if (end < 0) { end = this.length + end; }
    
          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);
    
          var len = end - start;
          if (len < 0) {
            len = 0;
          }
    
          return new this.constructor(
            this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
        };
    
        return ctor;
      }
    
      var Int8Array = makeConstructor(1, packI8, unpackI8);
      var Uint8Array = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array = makeConstructor(2, packI16, unpackI16);
      var Uint16Array = makeConstructor(2, packU16, unpackU16);
      var Int32Array = makeConstructor(4, packI32, unpackI32);
      var Uint32Array = makeConstructor(4, packU32, unpackU32);
      var Float32Array = makeConstructor(4, packF32, unpackF32);
      var Float64Array = makeConstructor(8, packF64, unpackF64);
    
      exports.Int8Array = exports.Int8Array || Int8Array;
      exports.Uint8Array = exports.Uint8Array || Uint8Array;
      exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
      exports.Int16Array = exports.Int16Array || Int16Array;
      exports.Uint16Array = exports.Uint16Array || Uint16Array;
      exports.Int32Array = exports.Int32Array || Int32Array;
      exports.Uint32Array = exports.Uint32Array || Uint32Array;
      exports.Float32Array = exports.Float32Array || Float32Array;
      exports.Float64Array = exports.Float64Array || Float64Array;
    }());
    
    //
    // 6 The DataView View Type
    //
    
    (function() {
      function r(array, index) {
        return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
      }
    
      var IS_BIG_ENDIAN = (function() {
        var u16array = new(exports.Uint16Array)([0x1234]),
            u8array = new(exports.Uint8Array)(u16array.buffer);
        return r(u8array, 0) === 0x12;
      }());
    
      // Constructor(ArrayBuffer buffer,
      //             optional unsigned long byteOffset,
      //             optional unsigned long byteLength)
      /** @constructor */
      var DataView = function DataView(buffer, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer = new exports.ArrayBuffer(0);
        } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {
          throw new TypeError("TypeError");
        }
    
        this.buffer = buffer || new exports.ArrayBuffer(0);
    
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
    
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
    
        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
    
        configureProperties(this);
      };
    
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
    
          byteOffset = ECMAScript.ToUint32(byteOffset);
    
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
    
          var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
              bytes = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(uint8Array, i));
          }
    
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
    
          return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
        };
      }
    
      DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
      DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
      DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
      DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
      DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
      DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
      DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
      DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);
    
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
    
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
    
          // Get bytes
          var typeArray = new arrayType([value]),
              byteArray = new exports.Uint8Array(typeArray.buffer),
              bytes = [], i, byteView;
    
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(byteArray, i));
          }
    
          // Flip if necessary
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
    
          // Write them
          byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes);
        };
      }
    
      DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
      DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
      DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
      DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
      DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
      DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
      DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
      DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);
    
      exports.DataView = exports.DataView || DataView;
    
    }());
    
  provide("typedarray", module.exports);
}(global));

// pakmanager:acorn
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
    // A recursive descent parser operates by defining functions for all
    // syntactic elements, and recursively calling those, each function
    // advancing the input stream and returning an AST node. Precedence
    // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
    // instead of `(!x)[1]` is handled by the fact that the parser
    // function that parses unary prefix operators is called first, and
    // in turn calls the function that parses `[]` subscripts  that
    // way, it'll receive the node for `x[1]` already parsed, and wraps
    // *that* in the unary operator node.
    //
    // Acorn uses an [operator precedence parser][opp] to handle binary
    // operator precedence, because it is much more compact than using
    // the technique outlined above, which uses different, nesting
    // functions to specify precedence, for all of the ten binary
    // precedence levels that JavaScript defines.
    //
    // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
    
    "use strict";
    
    var _tokentype = _dereq_("./tokentype");
    
    var _state = _dereq_("./state");
    
    var _identifier = _dereq_("./identifier");
    
    var _util = _dereq_("./util");
    
    var pp = _state.Parser.prototype;
    
    // Check if property name clashes with already added.
    // Object/class getters and setters are not allowed to clash 
    // either with each other or with an init property  and in
    // strict mode, init properties are also not allowed to be repeated.
    
    pp.checkPropClash = function (prop, propHash) {
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
      var key = prop.key,
          name = undefined;
      switch (key.type) {
        case "Identifier":
          name = key.name;break;
        case "Literal":
          name = String(key.value);break;
        default:
          return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
          propHash.proto = true;
        }
        return;
      }
      var other = undefined;
      if (_util.has(propHash, name)) {
        other = propHash[name];
        var isGetSet = kind !== "init";
        if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    
    // ### Expression parsing
    
    // These nest, from the most general expression type at the top to
    // 'atomic', nondivisible expression types at the bottom. Most of
    // the functions will simply let the function(s) below them parse,
    // and, *if* the syntactic construct they handle is present, wrap
    // the AST node that the inner parser gave them in another node.
    
    // Parse a full expression. The optional arguments are used to
    // forbid the `in` operator (in for loops initalization expressions)
    // and provide reference for storing '=' operator inside shorthand
    // property assignment in contexts where both object expression
    // and object pattern might appear (so it's possible to raise
    // delayed syntax error at correct position).
    
    pp.parseExpression = function (noIn, refShorthandDefaultPos) {
      var startPos = this.start,
          startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
      if (this.type === _tokentype.types.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
        return this.finishNode(node, "SequenceExpression");
      }
      return expr;
    };
    
    // Parse an assignment expression. This includes applications of
    // operators like `+=`.
    
    pp.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse) {
      if (this.type == _tokentype.types._yield && this.inGenerator) return this.parseYield();
    
      var failOnShorthandAssign = undefined;
      if (!refShorthandDefaultPos) {
        refShorthandDefaultPos = { start: 0 };
        failOnShorthandAssign = true;
      } else {
        failOnShorthandAssign = false;
      }
      var startPos = this.start,
          startLoc = this.startLoc;
      if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
      var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos);
      if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
      if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
        refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly
        this.checkLVal(left);
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression");
      } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }
      return left;
    };
    
    // Parse a ternary conditional (`?:`) operator.
    
    pp.parseMaybeConditional = function (noIn, refShorthandDefaultPos) {
      var startPos = this.start,
          startLoc = this.startLoc;
      var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
      if (this.eat(_tokentype.types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(_tokentype.types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    };
    
    // Start the precedence parser.
    
    pp.parseExprOps = function (noIn, refShorthandDefaultPos) {
      var startPos = this.start,
          startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
      return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
    };
    
    // Parse binary operators with the operator precedence parsing
    // algorithm. `left` is the left-hand side of the operator.
    // `minPrec` provides context that allows the function to stop and
    // defer further parser to one of its callers when it encounters an
    // operator that has a lower precedence than the set it is parsing.
    
    pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.type.binop;
      if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
        if (prec > minPrec) {
          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.value;
          var op = this.type;
          this.next();
          var startPos = this.start,
              startLoc = this.startLoc;
          node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
          this.finishNode(node, op === _tokentype.types.logicalOR || op === _tokentype.types.logicalAND ? "LogicalExpression" : "BinaryExpression");
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
      }
      return left;
    };
    
    // Parse unary operators, both prefix and postfix.
    
    pp.parseMaybeUnary = function (refShorthandDefaultPos) {
      if (this.type.prefix) {
        var node = this.startNode(),
            update = this.type === _tokentype.types.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary();
        if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
        if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
        return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      }
      var startPos = this.start,
          startLoc = this.startLoc;
      var expr = this.parseExprSubscripts(refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.prefix = false;
        node.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node, "UpdateExpression");
      }
      return expr;
    };
    
    // Parse call, dot, and `[]`-subscript expressions.
    
    pp.parseExprSubscripts = function (refShorthandDefaultPos) {
      var startPos = this.start,
          startLoc = this.startLoc;
      var expr = this.parseExprAtom(refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
      return this.parseSubscripts(expr, startPos, startLoc);
    };
    
    pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
      for (;;) {
        if (this.eat(_tokentype.types.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.property = this.parseIdent(true);
          node.computed = false;
          base = this.finishNode(node, "MemberExpression");
        } else if (this.eat(_tokentype.types.bracketL)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.property = this.parseExpression();
          node.computed = true;
          this.expect(_tokentype.types.bracketR);
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.arguments = this.parseExprList(_tokentype.types.parenR, false);
          base = this.finishNode(node, "CallExpression");
        } else if (this.type === _tokentype.types.backQuote) {
          var node = this.startNodeAt(startPos, startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate();
          base = this.finishNode(node, "TaggedTemplateExpression");
        } else {
          return base;
        }
      }
    };
    
    // Parse an atomic expression  either a single token that is an
    // expression, an expression started by a keyword like `function` or
    // `new`, or an expression wrapped in punctuation like `()`, `[]`,
    // or `{}`.
    
    pp.parseExprAtom = function (refShorthandDefaultPos) {
      var node = undefined,
          canBeArrow = this.potentialArrowAt == this.start;
      switch (this.type) {
        case _tokentype.types._super:
          if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");
        case _tokentype.types._this:
          var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
          node = this.startNode();
          this.next();
          return this.finishNode(node, type);
    
        case _tokentype.types._yield:
          if (this.inGenerator) this.unexpected();
    
        case _tokentype.types.name:
          var startPos = this.start,
              startLoc = this.startLoc;
          var id = this.parseIdent(this.type !== _tokentype.types.name);
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
          return id;
    
        case _tokentype.types.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = { pattern: value.pattern, flags: value.flags };
          return node;
    
        case _tokentype.types.num:case _tokentype.types.string:
          return this.parseLiteral(this.value);
    
        case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
          node = this.startNode();
          node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
    
        case _tokentype.types.parenL:
          return this.parseParenAndDistinguishExpression(canBeArrow);
    
        case _tokentype.types.bracketL:
          node = this.startNode();
          this.next();
          // check whether this is array comprehension or regular array
          if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
            return this.parseComprehension(node, false);
          }
          node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refShorthandDefaultPos);
          return this.finishNode(node, "ArrayExpression");
    
        case _tokentype.types.braceL:
          return this.parseObj(false, refShorthandDefaultPos);
    
        case _tokentype.types._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, false);
    
        case _tokentype.types._class:
          return this.parseClass(this.startNode(), false);
    
        case _tokentype.types._new:
          return this.parseNew();
    
        case _tokentype.types.backQuote:
          return this.parseTemplate();
    
        default:
          this.unexpected();
      }
    };
    
    pp.parseLiteral = function (value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      this.next();
      return this.finishNode(node, "Literal");
    };
    
    pp.parseParenExpression = function () {
      this.expect(_tokentype.types.parenL);
      var val = this.parseExpression();
      this.expect(_tokentype.types.parenR);
      return val;
    };
    
    pp.parseParenAndDistinguishExpression = function (canBeArrow) {
      var startPos = this.start,
          startLoc = this.startLoc,
          val = undefined;
      if (this.options.ecmaVersion >= 6) {
        this.next();
    
        if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
          return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);
        }
    
        var innerStartPos = this.start,
            innerStartLoc = this.startLoc;
        var exprList = [],
            first = true;
        var refShorthandDefaultPos = { start: 0 },
            spreadStart = undefined,
            innerParenStart = undefined;
        while (this.type !== _tokentype.types.parenR) {
          first ? first = false : this.expect(_tokentype.types.comma);
          if (this.type === _tokentype.types.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRest()));
            break;
          } else {
            if (this.type === _tokentype.types.parenL && !innerParenStart) {
              innerParenStart = this.start;
            }
            exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem));
          }
        }
        var innerEndPos = this.start,
            innerEndLoc = this.startLoc;
        this.expect(_tokentype.types.parenR);
    
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
          if (innerParenStart) this.unexpected(innerParenStart);
          return this.parseParenArrowList(startPos, startLoc, exprList);
        }
    
        if (!exprList.length) this.unexpected(this.lastTokStart);
        if (spreadStart) this.unexpected(spreadStart);
        if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
    
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
    
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    
    pp.parseParenItem = function (item) {
      return item;
    };
    
    pp.parseParenArrowList = function (startPos, startLoc, exprList) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
    };
    
    // New's precedence is slightly tricky. It must allow its argument
    // to be a `[]` or dot subscript expression, but not a call  at
    // least, not without wrapping it in parentheses. Thus, it uses the
    
    var empty = [];
    
    pp.parseNew = function () {
      var node = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
        node.meta = meta;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
        return this.finishNode(node, "MetaProperty");
      }
      var startPos = this.start,
          startLoc = this.startLoc;
      node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
      if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
      return this.finishNode(node, "NewExpression");
    };
    
    // Parse template expression.
    
    pp.parseTemplateElement = function () {
      var elem = this.startNode();
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
      this.next();
      elem.tail = this.type === _tokentype.types.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    
    pp.parseTemplate = function () {
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement();
      node.quasis = [curElt];
      while (!curElt.tail) {
        this.expect(_tokentype.types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(_tokentype.types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement());
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral");
    };
    
    // Parse an object literal or binding pattern.
    
    pp.parseObj = function (isPattern, refShorthandDefaultPos) {
      var node = this.startNode(),
          first = true,
          propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(_tokentype.types.braceR)) {
        if (!first) {
          this.expect(_tokentype.types.comma);
          if (this.afterTrailingComma(_tokentype.types.braceR)) break;
        } else first = false;
    
        var prop = this.startNode(),
            isGenerator = undefined,
            startPos = undefined,
            startLoc = undefined;
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refShorthandDefaultPos) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
        }
        this.parsePropertyName(prop);
        this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos);
        this.checkPropClash(prop, propHash);
        node.properties.push(this.finishNode(prop, "Property"));
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    
    pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos) {
      if (this.eat(_tokentype.types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
        if (isPattern) this.unexpected();
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator);
      } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
        if (isGenerator || isPattern) this.unexpected();
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        prop.kind = "init";
        if (isPattern) {
          if (this.isKeyword(prop.key.name) || this.strict && (_identifier.reservedWords.strictBind(prop.key.name) || _identifier.reservedWords.strict(prop.key.name)) || !this.options.allowReserved && this.isReservedWord(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else if (this.type === _tokentype.types.eq && refShorthandDefaultPos) {
          if (!refShorthandDefaultPos.start) refShorthandDefaultPos.start = this.start;
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else {
          prop.value = prop.key;
        }
        prop.shorthand = true;
      } else this.unexpected();
    };
    
    pp.parsePropertyName = function (prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(_tokentype.types.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(_tokentype.types.bracketR);
          return prop.key;
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
    };
    
    // Initialize empty function node.
    
    pp.initFunction = function (node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) {
        node.generator = false;
        node.expression = false;
      }
    };
    
    // Parse object or class method.
    
    pp.parseMethod = function (isGenerator) {
      var node = this.startNode();
      this.initFunction(node);
      this.expect(_tokentype.types.parenL);
      node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
      var allowExpressionBody = undefined;
      if (this.options.ecmaVersion >= 6) {
        node.generator = isGenerator;
      }
      this.parseFunctionBody(node, false);
      return this.finishNode(node, "FunctionExpression");
    };
    
    // Parse arrow function expression with given parameters.
    
    pp.parseArrowExpression = function (node, params) {
      this.initFunction(node);
      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true);
      return this.finishNode(node, "ArrowFunctionExpression");
    };
    
    // Parse function body and check parameters.
    
    pp.parseFunctionBody = function (node, allowExpression) {
      var isExpression = allowExpression && this.type !== _tokentype.types.braceL;
    
      if (isExpression) {
        node.body = this.parseMaybeAssign();
        node.expression = true;
      } else {
        // Start a new scope with regard to labels and the `inFunction`
        // flag (restore them to their old value afterwards).
        var oldInFunc = this.inFunction,
            oldInGen = this.inGenerator,
            oldLabels = this.labels;
        this.inFunction = true;this.inGenerator = node.generator;this.labels = [];
        node.body = this.parseBlock(true);
        node.expression = false;
        this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;
      }
    
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
        var nameHash = {},
            oldStrict = this.strict;
        this.strict = true;
        if (node.id) this.checkLVal(node.id, true);
        for (var i = 0; i < node.params.length; i++) {
          this.checkLVal(node.params[i], true, nameHash);
        }this.strict = oldStrict;
      }
    };
    
    // Parses a comma-separated list of expressions, and returns them as
    // an array. `close` is the token type that ends the list, and
    // `allowEmpty` can be turned on to allow subsequent commas with
    // nothing in between them to be parsed as `null` (which is needed
    // for array literals).
    
    pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {
      var elts = [],
          first = true;
      while (!this.eat(close)) {
        if (!first) {
          this.expect(_tokentype.types.comma);
          if (allowTrailingComma && this.afterTrailingComma(close)) break;
        } else first = false;
    
        var elt = undefined;
        if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refShorthandDefaultPos);else elt = this.parseMaybeAssign(false, refShorthandDefaultPos);
        elts.push(elt);
      }
      return elts;
    };
    
    // Parse the next token as an identifier. If `liberal` is true (used
    // when parsing properties), it will also convert keywords into
    // identifiers.
    
    pp.parseIdent = function (liberal) {
      var node = this.startNode();
      if (liberal && this.options.allowReserved == "never") liberal = false;
      if (this.type === _tokentype.types.name) {
        if (!liberal && (!this.options.allowReserved && this.isReservedWord(this.value) || this.strict && _identifier.reservedWords.strict(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1))) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
        node.name = this.value;
      } else if (liberal && this.type.keyword) {
        node.name = this.type.keyword;
      } else {
        this.unexpected();
      }
      this.next();
      return this.finishNode(node, "Identifier");
    };
    
    // Parses yield expression inside generator.
    
    pp.parseYield = function () {
      var node = this.startNode();
      this.next();
      if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(_tokentype.types.star);
        node.argument = this.parseMaybeAssign();
      }
      return this.finishNode(node, "YieldExpression");
    };
    
    // Parses array and generator comprehensions.
    
    pp.parseComprehension = function (node, isGenerator) {
      node.blocks = [];
      while (this.type === _tokentype.types._for) {
        var block = this.startNode();
        this.next();
        this.expect(_tokentype.types.parenL);
        block.left = this.parseBindingAtom();
        this.checkLVal(block.left, true);
        this.expectContextual("of");
        block.right = this.parseExpression();
        this.expect(_tokentype.types.parenR);
        node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
      }
      node.filter = this.eat(_tokentype.types._if) ? this.parseParenExpression() : null;
      node.body = this.parseExpression();
      this.expect(isGenerator ? _tokentype.types.parenR : _tokentype.types.bracketR);
      node.generator = isGenerator;
      return this.finishNode(node, "ComprehensionExpression");
    };
    
    },{"./identifier":2,"./state":10,"./tokentype":14,"./util":15}],2:[function(_dereq_,module,exports){
    // This is a trick taken from Esprima. It turns out that, on
    // non-Chrome browsers, to check whether a string is in a set, a
    // predicate containing a big ugly `switch` statement is faster than
    // a regular expression, and on Chrome the two are about on par.
    // This function uses `eval` (non-lexical) to produce such a
    // predicate from a space-separated string of words.
    //
    // It starts by sorting the words by length.
    
    "use strict";
    
    exports.__esModule = true;
    exports.isIdentifierStart = isIdentifierStart;
    exports.isIdentifierChar = isIdentifierChar;
    function makePredicate(words) {
      words = words.split(" ");
      var f = "",
          cats = [];
      out: for (var i = 0; i < words.length; ++i) {
        for (var j = 0; j < cats.length; ++j) {
          if (cats[j][0].length == words[i].length) {
            cats[j].push(words[i]);
            continue out;
          }
        }cats.push([words[i]]);
      }
      function compareTo(arr) {
        if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
        f += "switch(str){";
        for (var i = 0; i < arr.length; ++i) {
          f += "case " + JSON.stringify(arr[i]) + ":";
        }f += "return true}return false;";
      }
    
      // When there are more than three length categories, an outer
      // switch first dispatches on the lengths, to save on comparisons.
    
      if (cats.length > 3) {
        cats.sort(function (a, b) {
          return b.length - a.length;
        });
        f += "switch(str.length){";
        for (var i = 0; i < cats.length; ++i) {
          var cat = cats[i];
          f += "case " + cat[0].length + ":";
          compareTo(cat);
        }
        f += "}"
    
        // Otherwise, simply generate a flat `switch` statement.
    
        ;
      } else {
        compareTo(words);
      }
      return new Function("str", f);
    }
    
    // Reserved word lists for various dialects of the language
    
    var reservedWords = {
      3: makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),
      5: makePredicate("class enum extends super const export import"),
      6: makePredicate("enum await"),
      strict: makePredicate("implements interface let package private protected public static yield"),
      strictBind: makePredicate("eval arguments")
    };
    
    exports.reservedWords = reservedWords;
    // And the keywords
    
    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    
    var keywords = {
      5: makePredicate(ecma5AndLessKeywords),
      6: makePredicate(ecma5AndLessKeywords + " let const class extends export import yield super")
    };
    
    exports.keywords = keywords;
    // ## Character categories
    
    // Big ugly regular expressions that match characters in the
    // whitespace, identifier, and identifier-start categories. These
    // are only applied when a character is found to actually have a
    // code point above 128.
    // Generated by `tools/generate-identifier-regex.js`.
    
    var nonASCIIidentifierStartChars = "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
    var nonASCIIidentifierChars = "-------------------------------------------------------------------------------------------------------------------------------------------------";
    
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    
    // These are a run-length and offset encoded representation of the
    // >0xffff code points that are a valid part of identifiers. The
    // offset starts at 0x10000, and each pair of numbers represents an
    // offset to the next range, and then a size of the range. They were
    // generated by tools/generate-identifier-regex.js
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];
    
    // This has a complexity linear to the value of the code. The
    // assumption is that looking up astral identifier characters is
    // rare.
    function isInAstralSet(code, set) {
      var pos = 0x10000;
      for (var i = 0; i < set.length; i += 2) {
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
      }
    }
    
    // Test whether a given character code starts an identifier.
    
    function isIdentifierStart(code, astral) {
      if (code < 65) return code === 36;
      if (code < 91) return true;
      if (code < 97) return code === 95;
      if (code < 123) return true;
      if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
      if (astral === false) return false;
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    
    // Test whether a given character is part of an identifier.
    
    function isIdentifierChar(code, astral) {
      if (code < 48) return code === 36;
      if (code < 58) return true;
      if (code < 65) return false;
      if (code < 91) return true;
      if (code < 97) return code === 95;
      if (code < 123) return true;
      if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
      if (astral === false) return false;
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    
    },{}],3:[function(_dereq_,module,exports){
    // Acorn is a tiny, fast JavaScript parser written in JavaScript.
    //
    // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
    // various contributors and released under an MIT license.
    //
    // Git repositories for Acorn are available at
    //
    //     http://marijnhaverbeke.nl/git/acorn
    //     https://github.com/marijnh/acorn.git
    //
    // Please use the [github bug tracker][ghbt] to report issues.
    //
    // [ghbt]: https://github.com/marijnh/acorn/issues
    //
    // This file defines the main parser interface. The library also comes
    // with a [error-tolerant parser][dammit] and an
    // [abstract syntax tree walker][walk], defined in other files.
    //
    // [dammit]: acorn_loose.js
    // [walk]: util/walk.js
    
    "use strict";
    
    exports.__esModule = true;
    exports.parse = parse;
    exports.parseExpressionAt = parseExpressionAt;
    exports.tokenizer = tokenizer;
    
    var _state = _dereq_("./state");
    
    var _options = _dereq_("./options");
    
    _dereq_("./parseutil");
    
    _dereq_("./statement");
    
    _dereq_("./lval");
    
    _dereq_("./expression");
    
    _dereq_("./location");
    
    exports.Parser = _state.Parser;
    exports.plugins = _state.plugins;
    exports.defaultOptions = _options.defaultOptions;
    
    var _locutil = _dereq_("./locutil");
    
    exports.Position = _locutil.Position;
    exports.SourceLocation = _locutil.SourceLocation;
    exports.getLineInfo = _locutil.getLineInfo;
    
    var _node = _dereq_("./node");
    
    exports.Node = _node.Node;
    
    var _tokentype = _dereq_("./tokentype");
    
    exports.TokenType = _tokentype.TokenType;
    exports.tokTypes = _tokentype.types;
    
    var _tokencontext = _dereq_("./tokencontext");
    
    exports.TokContext = _tokencontext.TokContext;
    exports.tokContexts = _tokencontext.types;
    
    var _identifier = _dereq_("./identifier");
    
    exports.isIdentifierChar = _identifier.isIdentifierChar;
    exports.isIdentifierStart = _identifier.isIdentifierStart;
    
    var _tokenize = _dereq_("./tokenize");
    
    exports.Token = _tokenize.Token;
    
    var _whitespace = _dereq_("./whitespace");
    
    exports.isNewLine = _whitespace.isNewLine;
    exports.lineBreak = _whitespace.lineBreak;
    exports.lineBreakG = _whitespace.lineBreakG;
    var version = "2.4.0";
    
    exports.version = version;
    // The main exported interface (under `self.acorn` when in the
    // browser) is a `parse` function that takes a code string and
    // returns an abstract syntax tree as specified by [Mozilla parser
    // API][api].
    //
    // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
    
    function parse(input, options) {
      return new _state.Parser(options, input).parse();
    }
    
    // This function tries to parse a single expression at a given
    // offset in a string. Useful for parsing mixed-language formats
    // that embed JavaScript expressions.
    
    function parseExpressionAt(input, pos, options) {
      var p = new _state.Parser(options, input, pos);
      p.nextToken();
      return p.parseExpression();
    }
    
    // Acorn is organized as a tokenizer and a recursive-descent parser.
    // The `tokenize` export provides an interface to the tokenizer.
    
    function tokenizer(input, options) {
      return new _state.Parser(options, input);
    }
    
    },{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(_dereq_,module,exports){
    "use strict";
    
    var _state = _dereq_("./state");
    
    var _locutil = _dereq_("./locutil");
    
    var pp = _state.Parser.prototype;
    
    // This function is used to raise exceptions on parse errors. It
    // takes an offset integer (into the current `input`) to indicate
    // the location of the error, attaches the position to the end
    // of the error message, and then raises a `SyntaxError` with that
    // message.
    
    pp.raise = function (pos, message) {
      var loc = _locutil.getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
      throw err;
    };
    
    pp.curPosition = function () {
      if (this.options.locations) {
        return new _locutil.Position(this.curLine, this.pos - this.lineStart);
      }
    };
    
    },{"./locutil":5,"./state":10}],5:[function(_dereq_,module,exports){
    "use strict";
    
    exports.__esModule = true;
    exports.getLineInfo = getLineInfo;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var _whitespace = _dereq_("./whitespace");
    
    // These are used when `options.locations` is on, for the
    // `startLoc` and `endLoc` properties.
    
    var Position = (function () {
      function Position(line, col) {
        _classCallCheck(this, Position);
    
        this.line = line;
        this.column = col;
      }
    
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
    
      return Position;
    })();
    
    exports.Position = Position;
    
    var SourceLocation = function SourceLocation(p, start, end) {
      _classCallCheck(this, SourceLocation);
    
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) this.source = p.sourceFile;
    };
    
    exports.SourceLocation = SourceLocation;
    
    // The `getLineInfo` function is mostly useful when the
    // `locations` option is off (for performance reasons) and you
    // want to find the line/column position for a given character
    // offset. `input` should be the code string that the offset refers
    // into.
    
    function getLineInfo(input, offset) {
      for (var line = 1, cur = 0;;) {
        _whitespace.lineBreakG.lastIndex = cur;
        var match = _whitespace.lineBreakG.exec(input);
        if (match && match.index < offset) {
          ++line;
          cur = match.index + match[0].length;
        } else {
          return new Position(line, offset - cur);
        }
      }
    }
    
    },{"./whitespace":16}],6:[function(_dereq_,module,exports){
    "use strict";
    
    var _tokentype = _dereq_("./tokentype");
    
    var _state = _dereq_("./state");
    
    var _identifier = _dereq_("./identifier");
    
    var _util = _dereq_("./util");
    
    var pp = _state.Parser.prototype;
    
    // Convert existing expression atom to assignable pattern
    // if possible.
    
    pp.toAssignable = function (node, isBinding) {
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
            break;
    
          case "ObjectExpression":
            node.type = "ObjectPattern";
            for (var i = 0; i < node.properties.length; i++) {
              var prop = node.properties[i];
              if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
              this.toAssignable(prop.value, isBinding);
            }
            break;
    
          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, isBinding);
            break;
    
          case "AssignmentExpression":
            if (node.operator === "=") {
              node.type = "AssignmentPattern";
              delete node.operator;
            } else {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            break;
    
          case "ParenthesizedExpression":
            node.expression = this.toAssignable(node.expression, isBinding);
            break;
    
          case "MemberExpression":
            if (!isBinding) break;
    
          default:
            this.raise(node.start, "Assigning to rvalue");
        }
      }
      return node;
    };
    
    // Convert list of expression atoms to binding list.
    
    pp.toAssignableList = function (exprList, isBinding) {
      var end = exprList.length;
      if (end) {
        var last = exprList[end - 1];
        if (last && last.type == "RestElement") {
          --end;
        } else if (last && last.type == "SpreadElement") {
          last.type = "RestElement";
          var arg = last.argument;
          this.toAssignable(arg, isBinding);
          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
          --end;
        }
      }
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) this.toAssignable(elt, isBinding);
      }
      return exprList;
    };
    
    // Parses spread element.
    
    pp.parseSpread = function (refShorthandDefaultPos) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(refShorthandDefaultPos);
      return this.finishNode(node, "SpreadElement");
    };
    
    pp.parseRest = function () {
      var node = this.startNode();
      this.next();
      node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();
      return this.finishNode(node, "RestElement");
    };
    
    // Parses lvalue (assignable) atom.
    
    pp.parseBindingAtom = function () {
      if (this.options.ecmaVersion < 6) return this.parseIdent();
      switch (this.type) {
        case _tokentype.types.name:
          return this.parseIdent();
    
        case _tokentype.types.bracketL:
          var node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
          return this.finishNode(node, "ArrayPattern");
    
        case _tokentype.types.braceL:
          return this.parseObj(true);
    
        default:
          this.unexpected();
      }
    };
    
    pp.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
      var elts = [],
          first = true;
      while (!this.eat(close)) {
        if (first) first = false;else this.expect(_tokentype.types.comma);
        if (allowEmpty && this.type === _tokentype.types.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
          break;
        } else if (this.type === _tokentype.types.ellipsis) {
          var rest = this.parseRest();
          this.parseBindingListItem(rest);
          elts.push(rest);
          this.expect(close);
          break;
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts;
    };
    
    pp.parseBindingListItem = function (param) {
      return param;
    };
    
    // Parses assignment pattern around given atom if possible.
    
    pp.parseMaybeDefault = function (startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern");
    };
    
    // Verify that a node is an lval  something that can be assigned
    // to.
    
    pp.checkLVal = function (expr, isBinding, checkClashes) {
      switch (expr.type) {
        case "Identifier":
          if (this.strict && (_identifier.reservedWords.strictBind(expr.name) || _identifier.reservedWords.strict(expr.name))) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          if (checkClashes) {
            if (_util.has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash in strict mode");
            checkClashes[expr.name] = true;
          }
          break;
    
        case "MemberExpression":
          if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
          break;
    
        case "ObjectPattern":
          for (var i = 0; i < expr.properties.length; i++) {
            this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
          }break;
    
        case "ArrayPattern":
          for (var i = 0; i < expr.elements.length; i++) {
            var elem = expr.elements[i];
            if (elem) this.checkLVal(elem, isBinding, checkClashes);
          }
          break;
    
        case "AssignmentPattern":
          this.checkLVal(expr.left, isBinding, checkClashes);
          break;
    
        case "RestElement":
          this.checkLVal(expr.argument, isBinding, checkClashes);
          break;
    
        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, isBinding, checkClashes);
          break;
    
        default:
          this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    
    },{"./identifier":2,"./state":10,"./tokentype":14,"./util":15}],7:[function(_dereq_,module,exports){
    "use strict";
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var _state = _dereq_("./state");
    
    var _locutil = _dereq_("./locutil");
    
    var Node = function Node(parser, pos, loc) {
      _classCallCheck(this, Node);
    
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
      if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
      if (parser.options.ranges) this.range = [pos, 0];
    };
    
    exports.Node = Node;
    
    // Start an AST node, attaching a start offset.
    
    var pp = _state.Parser.prototype;
    
    pp.startNode = function () {
      return new Node(this, this.start, this.startLoc);
    };
    
    pp.startNodeAt = function (pos, loc) {
      return new Node(this, pos, loc);
    };
    
    // Finish an AST node, adding `type` and `end` properties.
    
    function finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      if (this.options.locations) node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      return node;
    }
    
    pp.finishNode = function (node, type) {
      return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    
    // Finish node at given position
    
    pp.finishNodeAt = function (node, type, pos, loc) {
      return finishNodeAt.call(this, node, type, pos, loc);
    };
    
    },{"./locutil":5,"./state":10}],8:[function(_dereq_,module,exports){
    "use strict";
    
    exports.__esModule = true;
    exports.getOptions = getOptions;
    
    var _util = _dereq_("./util");
    
    var _locutil = _dereq_("./locutil");
    
    // A second optional argument can be given to further configure
    // the parser process. These options are recognized:
    
    var defaultOptions = {
      // `ecmaVersion` indicates the ECMAScript version to parse. Must
      // be either 3, or 5, or 6. This influences support for strict
      // mode, the set of reserved words, support for getters and
      // setters and other features.
      ecmaVersion: 5,
      // Source type ("script" or "module") for different semantics
      sourceType: "script",
      // `onInsertedSemicolon` can be a callback that will be called
      // when a semicolon is automatically inserted. It will be passed
      // th position of the comma as an offset, and if `locations` is
      // enabled, it is given the location as a `{line, column}` object
      // as second argument.
      onInsertedSemicolon: null,
      // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
      // trailing commas.
      onTrailingComma: null,
      // By default, reserved words are not enforced. Disable
      // `allowReserved` to enforce them. When this option has the
      // value "never", reserved words and keywords can also not be
      // used as property names.
      allowReserved: true,
      // When enabled, a return at the top level is not considered an
      // error.
      allowReturnOutsideFunction: false,
      // When enabled, import/export statements are not constrained to
      // appearing at the top of the program.
      allowImportExportEverywhere: false,
      // When enabled, hashbang directive in the beginning of file
      // is allowed and treated as a line comment.
      allowHashBang: false,
      // When `locations` is on, `loc` properties holding objects with
      // `start` and `end` properties in `{line, column}` form (with
      // line being 1-based and column 0-based) will be attached to the
      // nodes.
      locations: false,
      // A function can be passed as `onToken` option, which will
      // cause Acorn to call that function with object in the same
      // format as tokenize() returns. Note that you are not
      // allowed to call the parser from the callbackthat will
      // corrupt its internal state.
      onToken: null,
      // A function can be passed as `onComment` option, which will
      // cause Acorn to call that function with `(block, text, start,
      // end)` parameters whenever a comment is skipped. `block` is a
      // boolean indicating whether this is a block (`/* */`) comment,
      // `text` is the content of the comment, and `start` and `end` are
      // character offsets that denote the start and end of the comment.
      // When the `locations` option is on, two more parameters are
      // passed, the full `{line, column}` locations of the start and
      // end of the comments. Note that you are not allowed to call the
      // parser from the callbackthat will corrupt its internal state.
      onComment: null,
      // Nodes have their start and end characters offsets recorded in
      // `start` and `end` properties (directly on the node, rather than
      // the `loc` object, which holds line/column data. To also add a
      // [semi-standardized][range] `range` property holding a `[start,
      // end]` array with the same numbers, set the `ranges` option to
      // `true`.
      //
      // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
      ranges: false,
      // It is possible to parse multiple files into a single AST by
      // passing the tree produced by parsing the first file as
      // `program` option in subsequent parses. This will add the
      // toplevel forms of the parsed file to the `Program` (top) node
      // of an existing parse tree.
      program: null,
      // When `locations` is on, you can pass this to record the source
      // file in every node's `loc` object.
      sourceFile: null,
      // This value, if given, is stored in every node, whether
      // `locations` is on or off.
      directSourceFile: null,
      // When enabled, parenthesized expressions are represented by
      // (non-standard) ParenthesizedExpression nodes
      preserveParens: false,
      plugins: {}
    };
    
    exports.defaultOptions = defaultOptions;
    // Interpret and default an options object
    
    function getOptions(opts) {
      var options = {};
      for (var opt in defaultOptions) {
        options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
      }if (_util.isArray(options.onToken)) {
        (function () {
          var tokens = options.onToken;
          options.onToken = function (token) {
            return tokens.push(token);
          };
        })();
      }
      if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
    
      return options;
    }
    
    function pushComment(options, array) {
      return function (block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start: start,
          end: end
        };
        if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
        if (options.ranges) comment.range = [start, end];
        array.push(comment);
      };
    }
    
    },{"./locutil":5,"./util":15}],9:[function(_dereq_,module,exports){
    "use strict";
    
    var _tokentype = _dereq_("./tokentype");
    
    var _state = _dereq_("./state");
    
    var _whitespace = _dereq_("./whitespace");
    
    var pp = _state.Parser.prototype;
    
    // ## Parser utilities
    
    // Test whether a statement node is the string literal `"use strict"`.
    
    pp.isUseStrict = function (stmt) {
      return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
    };
    
    // Predicate that tests whether the next token is of the given
    // type, and if yes, consumes it as a side effect.
    
    pp.eat = function (type) {
      if (this.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    
    // Tests whether parsed token is a contextual keyword.
    
    pp.isContextual = function (name) {
      return this.type === _tokentype.types.name && this.value === name;
    };
    
    // Consumes contextual keyword if possible.
    
    pp.eatContextual = function (name) {
      return this.value === name && this.eat(_tokentype.types.name);
    };
    
    // Asserts that following token is given contextual keyword.
    
    pp.expectContextual = function (name) {
      if (!this.eatContextual(name)) this.unexpected();
    };
    
    // Test whether a semicolon can be inserted at the current position.
    
    pp.canInsertSemicolon = function () {
      return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    
    pp.insertSemicolon = function () {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        return true;
      }
    };
    
    // Consume a semicolon, or, failing that, see if we are allowed to
    // pretend that there is a semicolon at this position.
    
    pp.semicolon = function () {
      if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
    };
    
    pp.afterTrailingComma = function (tokType) {
      if (this.type == tokType) {
        if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        this.next();
        return true;
      }
    };
    
    // Expect a token of a given type. If found, consume it, otherwise,
    // raise an unexpected token error.
    
    pp.expect = function (type) {
      this.eat(type) || this.unexpected();
    };
    
    // Raise an unexpected token error.
    
    pp.unexpected = function (pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    
    },{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(_dereq_,module,exports){
    "use strict";
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var _identifier = _dereq_("./identifier");
    
    var _tokentype = _dereq_("./tokentype");
    
    var _whitespace = _dereq_("./whitespace");
    
    var _options = _dereq_("./options");
    
    // Registered plugins
    var plugins = {};
    
    exports.plugins = plugins;
    
    var Parser = (function () {
      function Parser(options, input, startPos) {
        _classCallCheck(this, Parser);
    
        this.options = _options.getOptions(options);
        this.sourceFile = this.options.sourceFile;
        this.isKeyword = _identifier.keywords[this.options.ecmaVersion >= 6 ? 6 : 5];
        this.isReservedWord = _identifier.reservedWords[this.options.ecmaVersion];
        this.input = String(input);
    
        // Used to signal to callers of `readWord1` whether the word
        // contained any escape sequences. This is needed because words with
        // escape sequences must not be interpreted as keywords.
        this.containsEsc = false;
    
        // Load plugins
        this.loadPlugins(this.options.plugins);
    
        // Set up token state
    
        // The current position of the tokenizer in the input.
        if (startPos) {
          this.pos = startPos;
          this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
          this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
    
        // Properties of the current token:
        // Its type
        this.type = _tokentype.types.eof;
        // For tokens that include more information than their type, the value
        this.value = null;
        // Its start and end offset
        this.start = this.end = this.pos;
        // And, if locations are used, the {line, column} object
        // corresponding to those offsets
        this.startLoc = this.endLoc = this.curPosition();
    
        // Position information for the previous token
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
    
        // The context stack is used to superficially track syntactic
        // context to predict whether a regular expression is allowed in a
        // given position.
        this.context = this.initialContext();
        this.exprAllowed = true;
    
        // Figure out if it's a module code.
        this.strict = this.inModule = this.options.sourceType === "module";
    
        // Used to signify the start of a potential arrow function
        this.potentialArrowAt = -1;
    
        // Flags to track whether we are in a function, a generator.
        this.inFunction = this.inGenerator = false;
        // Labels in scope.
        this.labels = [];
    
        // If enabled, skip leading hashbang line.
        if (this.pos === 0 && this.options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
      }
    
      Parser.prototype.extend = function extend(name, f) {
        this[name] = f(this[name]);
      };
    
      Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
        for (var _name in pluginConfigs) {
          var plugin = plugins[_name];
          if (!plugin) throw new Error("Plugin '" + _name + "' not found");
          plugin(this, pluginConfigs[_name]);
        }
      };
    
      Parser.prototype.parse = function parse() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
    
      return Parser;
    })();
    
    exports.Parser = Parser;
    
    },{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(_dereq_,module,exports){
    "use strict";
    
    var _tokentype = _dereq_("./tokentype");
    
    var _state = _dereq_("./state");
    
    var _whitespace = _dereq_("./whitespace");
    
    var pp = _state.Parser.prototype;
    
    // ### Statement parsing
    
    // Parse a program. Initializes the parser, reads any number of
    // statements, and wraps them in a Program node.  Optionally takes a
    // `program` argument.  If present, the statements will be appended
    // to its body instead of creating a new node.
    
    pp.parseTopLevel = function (node) {
      var first = true;
      if (!node.body) node.body = [];
      while (this.type !== _tokentype.types.eof) {
        var stmt = this.parseStatement(true, true);
        node.body.push(stmt);
        if (first) {
          if (this.isUseStrict(stmt)) this.setStrict(true);
          first = false;
        }
      }
      this.next();
      if (this.options.ecmaVersion >= 6) {
        node.sourceType = this.options.sourceType;
      }
      return this.finishNode(node, "Program");
    };
    
    var loopLabel = { kind: "loop" },
        switchLabel = { kind: "switch" };
    
    // Parse a single statement.
    //
    // If expecting a statement and finding a slash operator, parse a
    // regular expression literal. This is to handle cases like
    // `if (foo) /blah/.exec(foo)`, where looking at the previous token
    // does not help.
    
    pp.parseStatement = function (declaration, topLevel) {
      var starttype = this.type,
          node = this.startNode();
    
      // Most types of statements are recognized by the keyword they
      // start with. Many are trivial to parse, some require a bit of
      // complexity.
    
      switch (starttype) {
        case _tokentype.types._break:case _tokentype.types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case _tokentype.types._debugger:
          return this.parseDebuggerStatement(node);
        case _tokentype.types._do:
          return this.parseDoStatement(node);
        case _tokentype.types._for:
          return this.parseForStatement(node);
        case _tokentype.types._function:
          if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
          return this.parseFunctionStatement(node);
        case _tokentype.types._class:
          if (!declaration) this.unexpected();
          return this.parseClass(node, true);
        case _tokentype.types._if:
          return this.parseIfStatement(node);
        case _tokentype.types._return:
          return this.parseReturnStatement(node);
        case _tokentype.types._switch:
          return this.parseSwitchStatement(node);
        case _tokentype.types._throw:
          return this.parseThrowStatement(node);
        case _tokentype.types._try:
          return this.parseTryStatement(node);
        case _tokentype.types._let:case _tokentype.types._const:
          if (!declaration) this.unexpected(); // NOTE: falls through to _var
        case _tokentype.types._var:
          return this.parseVarStatement(node, starttype);
        case _tokentype.types._while:
          return this.parseWhileStatement(node);
        case _tokentype.types._with:
          return this.parseWithStatement(node);
        case _tokentype.types.braceL:
          return this.parseBlock();
        case _tokentype.types.semi:
          return this.parseEmptyStatement(node);
        case _tokentype.types._export:
        case _tokentype.types._import:
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
            if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
          }
          return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);
    
        // If the statement does not start with a statement keyword or a
        // brace, it's an ExpressionStatement or LabeledStatement. We
        // simply start parsing an expression, and afterwards, if the
        // next token is a colon and the expression was a simple
        // Identifier node, we switch to interpreting it as a label.
        default:
          var maybeName = this.value,
              expr = this.parseExpression();
          if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
      }
    };
    
    pp.parseBreakContinueStatement = function (node, keyword) {
      var isBreak = keyword == "break";
      this.next();
      if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
        node.label = this.parseIdent();
        this.semicolon();
      }
    
      // Verify that there is an actual destination to break or
      // continue to.
      for (var i = 0; i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }
      if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    
    pp.parseDebuggerStatement = function (node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };
    
    pp.parseDoStatement = function (node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement(false);
      this.labels.pop();
      this.expect(_tokentype.types._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
      return this.finishNode(node, "DoWhileStatement");
    };
    
    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
    // loop is non-trivial. Basically, we have to parse the init `var`
    // statement or expression, disallowing the `in` operator (see
    // the second parameter to `parseExpression`), and then check
    // whether the next token is `in` or `of`. When there is no init
    // part (semicolon immediately after the opening parenthesis), it
    // is a regular `for` loop.
    
    pp.parseForStatement = function (node) {
      this.next();
      this.labels.push(loopLabel);
      this.expect(_tokentype.types.parenL);
      if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
      if (this.type === _tokentype.types._var || this.type === _tokentype.types._let || this.type === _tokentype.types._const) {
        var _init = this.startNode(),
            varKind = this.type;
        this.next();
        this.parseVar(_init, true, varKind);
        this.finishNode(_init, "VariableDeclaration");
        if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== _tokentype.types._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
        return this.parseFor(node, _init);
      }
      var refShorthandDefaultPos = { start: 0 };
      var init = this.parseExpression(true, refShorthandDefaultPos);
      if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
        this.toAssignable(init);
        this.checkLVal(init);
        return this.parseForIn(node, init);
      } else if (refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }
      return this.parseFor(node, init);
    };
    
    pp.parseFunctionStatement = function (node) {
      this.next();
      return this.parseFunction(node, true);
    };
    
    pp.parseIfStatement = function (node) {
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement(false);
      node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
      return this.finishNode(node, "IfStatement");
    };
    
    pp.parseReturnStatement = function (node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
      this.next();
    
      // In `return` (and `break`/`continue`), the keywords with
      // optional arguments, we eagerly look for a semicolon or the
      // possibility to insert one.
    
      if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
        node.argument = this.parseExpression();this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");
    };
    
    pp.parseSwitchStatement = function (node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(_tokentype.types.braceL);
      this.labels.push(switchLabel);
    
      // Statements under must be grouped (by label) in SwitchCase
      // nodes. `cur` is used to keep the node that we are currently
      // adding statements to.
    
      for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
        if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
          var isCase = this.type === _tokentype.types._case;
          if (cur) this.finishNode(cur, "SwitchCase");
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
            sawDefault = true;
            cur.test = null;
          }
          this.expect(_tokentype.types.colon);
        } else {
          if (!cur) this.unexpected();
          cur.consequent.push(this.parseStatement(true));
        }
      }
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next(); // Closing brace
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };
    
    pp.parseThrowStatement = function (node) {
      this.next();
      if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };
    
    // Reused empty array added for node fields that are always empty.
    
    var empty = [];
    
    pp.parseTryStatement = function (node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === _tokentype.types._catch) {
        var clause = this.startNode();
        this.next();
        this.expect(_tokentype.types.parenL);
        clause.param = this.parseBindingAtom();
        this.checkLVal(clause.param, true);
        this.expect(_tokentype.types.parenR);
        clause.guard = null;
        clause.body = this.parseBlock();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.guardedHandlers = empty;
      node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
      return this.finishNode(node, "TryStatement");
    };
    
    pp.parseVarStatement = function (node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };
    
    pp.parseWhileStatement = function (node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement(false);
      this.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };
    
    pp.parseWithStatement = function (node) {
      if (this.strict) this.raise(this.start, "'with' in strict mode");
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement(false);
      return this.finishNode(node, "WithStatement");
    };
    
    pp.parseEmptyStatement = function (node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };
    
    pp.parseLabeledStatement = function (node, maybeName, expr) {
      for (var i = 0; i < this.labels.length; ++i) {
        if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
      for (var i = this.labels.length - 1; i >= 0; i--) {
        var label = this.labels[i];
        if (label.statementStart == node.start) {
          label.statementStart = this.start;
          label.kind = kind;
        } else break;
      }
      this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
      node.body = this.parseStatement(true);
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };
    
    pp.parseExpressionStatement = function (node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };
    
    // Parse a semicolon-enclosed block of statements, handling `"use
    // strict"` declarations when `allowStrict` is true (used for
    // function bodies).
    
    pp.parseBlock = function (allowStrict) {
      var node = this.startNode(),
          first = true,
          oldStrict = undefined;
      node.body = [];
      this.expect(_tokentype.types.braceL);
      while (!this.eat(_tokentype.types.braceR)) {
        var stmt = this.parseStatement(true);
        node.body.push(stmt);
        if (first && allowStrict && this.isUseStrict(stmt)) {
          oldStrict = this.strict;
          this.setStrict(this.strict = true);
        }
        first = false;
      }
      if (oldStrict === false) this.setStrict(false);
      return this.finishNode(node, "BlockStatement");
    };
    
    // Parse a regular `for` loop. The disambiguation code in
    // `parseStatement` will already have parsed the init statement or
    // expression.
    
    pp.parseFor = function (node, init) {
      node.init = init;
      this.expect(_tokentype.types.semi);
      node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
      this.expect(_tokentype.types.semi);
      node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
      this.expect(_tokentype.types.parenR);
      node.body = this.parseStatement(false);
      this.labels.pop();
      return this.finishNode(node, "ForStatement");
    };
    
    // Parse a `for`/`in` and `for`/`of` loop, which are almost
    // same from parser's perspective.
    
    pp.parseForIn = function (node, init) {
      var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
      this.next();
      node.left = init;
      node.right = this.parseExpression();
      this.expect(_tokentype.types.parenR);
      node.body = this.parseStatement(false);
      this.labels.pop();
      return this.finishNode(node, type);
    };
    
    // Parse a list of variable declarations.
    
    pp.parseVar = function (node, isFor, kind) {
      node.declarations = [];
      node.kind = kind.keyword;
      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl);
        if (this.eat(_tokentype.types.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === _tokentype.types._const && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(_tokentype.types.comma)) break;
      }
      return node;
    };
    
    pp.parseVarId = function (decl) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, true);
    };
    
    // Parse a function declaration or literal (depending on the
    // `isStatement` parameter).
    
    pp.parseFunction = function (node, isStatement, allowExpressionBody) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
      if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody);
      return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
    };
    
    pp.parseFunctionParams = function (node) {
      this.expect(_tokentype.types.parenL);
      node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
    };
    
    // Parse a class declaration or literal (depending on the
    // `isStatement` parameter).
    
    pp.parseClass = function (node, isStatement) {
      this.next();
      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(_tokentype.types.braceL);
      while (!this.eat(_tokentype.types.braceR)) {
        if (this.eat(_tokentype.types.semi)) continue;
        var method = this.startNode();
        var isGenerator = this.eat(_tokentype.types.star);
        var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
        this.parsePropertyName(method);
        method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
        if (method["static"]) {
          if (isGenerator) this.unexpected();
          isGenerator = this.eat(_tokentype.types.star);
          this.parsePropertyName(method);
        }
        method.kind = "method";
        var isGetSet = false;
        if (!method.computed) {
          var key = method.key;
    
          if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
            isGetSet = true;
            method.kind = key.name;
            key = this.parsePropertyName(method);
          }
          if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
            if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
            if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
            if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
            method.kind = "constructor";
            hadConstructor = true;
          }
        }
        this.parseClassMethod(classBody, method, isGenerator);
        if (isGetSet) {
          var paramCount = method.kind === "get" ? 0 : 1;
          if (method.value.params.length !== paramCount) {
            var start = method.value.start;
            if (method.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
          }
        }
      }
      node.body = this.finishNode(classBody, "ClassBody");
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    
    pp.parseClassMethod = function (classBody, method, isGenerator) {
      method.value = this.parseMethod(isGenerator);
      classBody.body.push(this.finishNode(method, "MethodDefinition"));
    };
    
    pp.parseClassId = function (node, isStatement) {
      node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
    };
    
    pp.parseClassSuper = function (node) {
      node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
    };
    
    // Parses module export declaration.
    
    pp.parseExport = function (node) {
      this.next();
      // export * from '...'
      if (this.eat(_tokentype.types.star)) {
        this.expectContextual("from");
        node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      }
      if (this.eat(_tokentype.types._default)) {
        // export default ...
        var expr = this.parseMaybeAssign();
        var needsSemi = true;
        if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") {
          needsSemi = false;
          if (expr.id) {
            expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
          }
        }
        node.declaration = expr;
        if (needsSemi) this.semicolon();
        return this.finishNode(node, "ExportDefaultDeclaration");
      }
      // export var|const|let|function|class ...
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseStatement(true);
        node.specifiers = [];
        node.source = null;
      } else {
        // export { x, y as z } [from '...']
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers();
        if (this.eatContextual("from")) {
          node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
        } else {
          node.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration");
    };
    
    pp.shouldParseExportStatement = function () {
      return this.type.keyword;
    };
    
    // Parses a comma-separated list of module exports.
    
    pp.parseExportSpecifiers = function () {
      var nodes = [],
          first = true;
      // export { x, y as z } [from '...']
      this.expect(_tokentype.types.braceL);
      while (!this.eat(_tokentype.types.braceR)) {
        if (!first) {
          this.expect(_tokentype.types.comma);
          if (this.afterTrailingComma(_tokentype.types.braceR)) break;
        } else first = false;
    
        var node = this.startNode();
        node.local = this.parseIdent(this.type === _tokentype.types._default);
        node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }
      return nodes;
    };
    
    // Parses import declaration.
    
    pp.parseImport = function (node) {
      this.next();
      // import '...'
      if (this.type === _tokentype.types.string) {
        node.specifiers = empty;
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };
    
    // Parses a comma-separated list of module imports.
    
    pp.parseImportSpecifiers = function () {
      var nodes = [],
          first = true;
      if (this.type === _tokentype.types.name) {
        // import defaultObj, { x, y as z } from '...'
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLVal(node.local, true);
        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
        if (!this.eat(_tokentype.types.comma)) return nodes;
      }
      if (this.type === _tokentype.types.star) {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLVal(node.local, true);
        nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
        return nodes;
      }
      this.expect(_tokentype.types.braceL);
      while (!this.eat(_tokentype.types.braceR)) {
        if (!first) {
          this.expect(_tokentype.types.comma);
          if (this.afterTrailingComma(_tokentype.types.braceR)) break;
        } else first = false;
    
        var node = this.startNode();
        node.imported = this.parseIdent(true);
        node.local = this.eatContextual("as") ? this.parseIdent() : node.imported;
        this.checkLVal(node.local, true);
        nodes.push(this.finishNode(node, "ImportSpecifier"));
      }
      return nodes;
    };
    
    },{"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(_dereq_,module,exports){
    // The algorithm used to determine whether a regexp can appear at a
    // given point in the program is loosely based on sweet.js' approach.
    // See https://github.com/mozilla/sweet.js/wiki/design
    
    "use strict";
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var _state = _dereq_("./state");
    
    var _tokentype = _dereq_("./tokentype");
    
    var _whitespace = _dereq_("./whitespace");
    
    var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
      _classCallCheck(this, TokContext);
    
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
    };
    
    exports.TokContext = TokContext;
    var types = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", true),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function (p) {
        return p.readTmplToken();
      }),
      f_expr: new TokContext("function", true)
    };
    
    exports.types = types;
    var pp = _state.Parser.prototype;
    
    pp.initialContext = function () {
      return [types.b_stat];
    };
    
    pp.braceIsBlock = function (prevType) {
      if (prevType === _tokentype.types.colon) {
        var _parent = this.curContext();
        if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
      }
      if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
      if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
      return !this.exprAllowed;
    };
    
    pp.updateContext = function (prevType) {
      var update = undefined,
          type = this.type;
      if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
    };
    
    // Token-specific context update code
    
    _tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
      if (this.context.length == 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (out === types.b_stat && this.curContext() === types.f_expr) {
        this.context.pop();
        this.exprAllowed = false;
      } else if (out === types.b_tmpl) {
        this.exprAllowed = true;
      } else {
        this.exprAllowed = !out.isExpr;
      }
    };
    
    _tokentype.types.braceL.updateContext = function (prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
      this.exprAllowed = true;
    };
    
    _tokentype.types.dollarBraceL.updateContext = function () {
      this.context.push(types.b_tmpl);
      this.exprAllowed = true;
    };
    
    _tokentype.types.parenL.updateContext = function (prevType) {
      var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
      this.context.push(statementParens ? types.p_stat : types.p_expr);
      this.exprAllowed = true;
    };
    
    _tokentype.types.incDec.updateContext = function () {};
    
    _tokentype.types._function.updateContext = function () {
      if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
      this.exprAllowed = false;
    };
    
    _tokentype.types.backQuote.updateContext = function () {
      if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
      this.exprAllowed = false;
    };
    
    // tokExprAllowed stays unchanged
    
    },{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(_dereq_,module,exports){
    "use strict";
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var _identifier = _dereq_("./identifier");
    
    var _tokentype = _dereq_("./tokentype");
    
    var _state = _dereq_("./state");
    
    var _locutil = _dereq_("./locutil");
    
    var _whitespace = _dereq_("./whitespace");
    
    // Object type used to represent tokens. Note that normally, tokens
    // simply exist as properties on the parser object. This is only
    // used for the onToken callback and the external tokenizer.
    
    var Token = function Token(p) {
      _classCallCheck(this, Token);
    
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
      if (p.options.ranges) this.range = [p.start, p.end];
    };
    
    exports.Token = Token;
    
    // ## Tokenizer
    
    var pp = _state.Parser.prototype;
    
    // Are we running under Rhino?
    var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";
    
    // Move to the next token
    
    pp.next = function () {
      if (this.options.onToken) this.options.onToken(new Token(this));
    
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    
    pp.getToken = function () {
      this.next();
      return new Token(this);
    };
    
    // If we're in an ES6 environment, make parsers iterable
    if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
      var self = this;
      return { next: function next() {
          var token = self.getToken();
          return {
            done: token.type === _tokentype.types.eof,
            value: token
          };
        } };
    };
    
    // Toggle strict mode. Re-reads the next number or string to please
    // pedantic tests (`"use strict"; 010;` should fail).
    
    pp.setStrict = function (strict) {
      this.strict = strict;
      if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
      this.pos = this.start;
      if (this.options.locations) {
        while (this.pos < this.lineStart) {
          this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
          --this.curLine;
        }
      }
      this.nextToken();
    };
    
    pp.curContext = function () {
      return this.context[this.context.length - 1];
    };
    
    // Read a single token, updating the parser object's token-related
    // properties.
    
    pp.nextToken = function () {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) this.skipSpace();
    
      this.start = this.pos;
      if (this.options.locations) this.startLoc = this.curPosition();
      if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);
    
      if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
    };
    
    pp.readToken = function (code) {
      // Identifier or keyword. '\uXXXX' sequences are allowed in
      // identifiers, so '\' also dispatches to that.
      if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();
    
      return this.getTokenFromCode(code);
    };
    
    pp.fullCharCodeAtPos = function () {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 0xd7ff || code >= 0xe000) return code;
      var next = this.input.charCodeAt(this.pos + 1);
      return (code << 10) + next - 0x35fdc00;
    };
    
    pp.skipBlockComment = function () {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos,
          end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
      this.pos = end + 2;
      if (this.options.locations) {
        _whitespace.lineBreakG.lastIndex = start;
        var match = undefined;
        while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
          ++this.curLine;
          this.lineStart = match.index + match[0].length;
        }
      }
      if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
    };
    
    pp.skipLineComment = function (startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
        ++this.pos;
        ch = this.input.charCodeAt(this.pos);
      }
      if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
    };
    
    // Called at the start of the parse and after every token. Skips
    // whitespace and comments, and.
    
    pp.skipSpace = function () {
      loop: while (this.pos < this.input.length) {
        var ch = this.input.charCodeAt(this.pos);
        switch (ch) {
          case 32:case 160:
            // ' '
            ++this.pos;
            break;
          case 13:
            if (this.input.charCodeAt(this.pos + 1) === 10) {
              ++this.pos;
            }
          case 10:case 8232:case 8233:
            ++this.pos;
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            break;
          case 47:
            // '/'
            switch (this.input.charCodeAt(this.pos + 1)) {
              case 42:
                // '*'
                this.skipBlockComment();
                break;
              case 47:
                this.skipLineComment(2);
                break;
              default:
                break loop;
            }
            break;
          default:
            if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
              ++this.pos;
            } else {
              break loop;
            }
        }
      }
    };
    
    // Called at the end of every token. Sets `end`, `val`, and
    // maintains `context` and `exprAllowed`, and skips the space after
    // the token, so that the next one's `start` will point at the
    // right position.
    
    pp.finishToken = function (type, val) {
      this.end = this.pos;
      if (this.options.locations) this.endLoc = this.curPosition();
      var prevType = this.type;
      this.type = type;
      this.value = val;
    
      this.updateContext(prevType);
    };
    
    // ### Token reading
    
    // This is the function that is called to fetch the next token. It
    // is somewhat obscure, because it works in character codes rather
    // than characters, and because operator parsing has been inlined
    // into it.
    //
    // All in the name of speed.
    //
    pp.readToken_dot = function () {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) return this.readNumber(true);
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        // 46 = dot '.'
        this.pos += 3;
        return this.finishToken(_tokentype.types.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(_tokentype.types.dot);
      }
    };
    
    pp.readToken_slash = function () {
      // '/'
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;return this.readRegexp();
      }
      if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
      return this.finishOp(_tokentype.types.slash, 1);
    };
    
    pp.readToken_mult_modulo = function (code) {
      // '%*'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
      return this.finishOp(code === 42 ? _tokentype.types.star : _tokentype.types.modulo, 1);
    };
    
    pp.readToken_pipe_amp = function (code) {
      // '|&'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
      if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
      return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
    };
    
    pp.readToken_caret = function () {
      // '^'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
      return this.finishOp(_tokentype.types.bitwiseXOR, 1);
    };
    
    pp.readToken_plus_min = function (code) {
      // '+-'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
          // A `-->` line comment
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(_tokentype.types.incDec, 2);
      }
      if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
      return this.finishOp(_tokentype.types.plusMin, 1);
    };
    
    pp.readToken_lt_gt = function (code) {
      // '<>'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
        return this.finishOp(_tokentype.types.bitShift, size);
      }
      if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
        if (this.inModule) this.unexpected();
        // `<!--`, an XML-style comment that should be interpreted as a line comment
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
      return this.finishOp(_tokentype.types.relational, size);
    };
    
    pp.readToken_eq_excl = function (code) {
      // '=!'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        // '=>'
        this.pos += 2;
        return this.finishToken(_tokentype.types.arrow);
      }
      return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
    };
    
    pp.getTokenFromCode = function (code) {
      switch (code) {
        // The interpretation of a dot depends on whether it is followed
        // by a digit or another two dots.
        case 46:
          // '.'
          return this.readToken_dot();
    
        // Punctuation tokens.
        case 40:
          ++this.pos;return this.finishToken(_tokentype.types.parenL);
        case 41:
          ++this.pos;return this.finishToken(_tokentype.types.parenR);
        case 59:
          ++this.pos;return this.finishToken(_tokentype.types.semi);
        case 44:
          ++this.pos;return this.finishToken(_tokentype.types.comma);
        case 91:
          ++this.pos;return this.finishToken(_tokentype.types.bracketL);
        case 93:
          ++this.pos;return this.finishToken(_tokentype.types.bracketR);
        case 123:
          ++this.pos;return this.finishToken(_tokentype.types.braceL);
        case 125:
          ++this.pos;return this.finishToken(_tokentype.types.braceR);
        case 58:
          ++this.pos;return this.finishToken(_tokentype.types.colon);
        case 63:
          ++this.pos;return this.finishToken(_tokentype.types.question);
    
        case 96:
          // '`'
          if (this.options.ecmaVersion < 6) break;
          ++this.pos;
          return this.finishToken(_tokentype.types.backQuote);
    
        case 48:
          // '0'
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
            if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
          }
        // Anything else beginning with a digit is an integer, octal
        // number, or float.
        case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
          // 1-9
          return this.readNumber(false);
    
        // Quotes produce strings.
        case 34:case 39:
          // '"', "'"
          return this.readString(code);
    
        // Operators are parsed inline in tiny state machines. '=' (61) is
        // often referred to. `finishOp` simply skips the amount of
        // characters it is given as second argument, and returns a token
        // of the type given by its first argument.
    
        case 47:
          // '/'
          return this.readToken_slash();
    
        case 37:case 42:
          // '%*'
          return this.readToken_mult_modulo(code);
    
        case 124:case 38:
          // '|&'
          return this.readToken_pipe_amp(code);
    
        case 94:
          // '^'
          return this.readToken_caret();
    
        case 43:case 45:
          // '+-'
          return this.readToken_plus_min(code);
    
        case 60:case 62:
          // '<>'
          return this.readToken_lt_gt(code);
    
        case 61:case 33:
          // '=!'
          return this.readToken_eq_excl(code);
    
        case 126:
          // '~'
          return this.finishOp(_tokentype.types.prefix, 1);
      }
    
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    
    pp.finishOp = function (type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str);
    };
    
    // Parse a regular expression. Some context-awareness is necessary,
    // since a '/' inside a '[]' set does not end the expression.
    
    function tryCreateRegexp(src, flags, throwErrorAt) {
      try {
        return new RegExp(src, flags);
      } catch (e) {
        if (throwErrorAt !== undefined) {
          if (e instanceof SyntaxError) this.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
          this.raise(e);
        }
      }
    }
    
    var regexpUnicodeSupport = !!tryCreateRegexp("", "u");
    
    pp.readRegexp = function () {
      var _this = this;
    
      var escaped = undefined,
          inClass = undefined,
          start = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
        var ch = this.input.charAt(this.pos);
        if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
        if (!escaped) {
          if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
          escaped = ch === "\\";
        } else escaped = false;
        ++this.pos;
      }
      var content = this.input.slice(start, this.pos);
      ++this.pos;
      // Need to use `readWord1` because '\uXXXX' sequences are allowed
      // here (don't ask).
      var mods = this.readWord1();
      var tmp = content;
      if (mods) {
        var validFlags = /^[gmsiy]*$/;
        if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
        if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
        if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
          // Replace each astral symbol and every Unicode escape sequence that
          // possibly represents an astral symbol or a paired surrogate with a
          // single ASCII symbol to avoid throwing on regular expressions that
          // are only valid in combination with the `/u` flag.
          // Note: replacing with the ASCII symbol `x` might cause false
          // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
          // perfectly valid pattern that is equivalent to `[a-b]`, but it would
          // be replaced by `[x-b]` which throws an error.
          tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (match, code, offset) {
            code = Number("0x" + code);
            if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
            return "x";
          });
          tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
        }
      }
      // Detect invalid regular expressions.
      var value = null;
      // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
      // so don't do detection if we are running under Rhino
      if (!isRhino) {
        tryCreateRegexp(tmp, undefined, start);
        // Get a regular expression object for this pattern-flag pair, or `null` in
        // case the current environment doesn't support the flags it uses.
        value = tryCreateRegexp(content, mods);
      }
      return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
    };
    
    // Read an integer in the given radix. Return null if zero digits
    // were read, the integer value otherwise. When `len` is given, this
    // will return `null` unless the integer has exactly `len` digits.
    
    pp.readInt = function (radix, len) {
      var start = this.pos,
          total = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.pos),
            val = undefined;
        if (code >= 97) val = code - 97 + 10; // a
        else if (code >= 65) val = code - 65 + 10; // A
        else if (code >= 48 && code <= 57) val = code - 48; // 0-9
        else val = Infinity;
        if (val >= radix) break;
        ++this.pos;
        total = total * radix + val;
      }
      if (this.pos === start || len != null && this.pos - start !== len) return null;
    
      return total;
    };
    
    pp.readRadixNumber = function (radix) {
      this.pos += 2; // 0x
      var val = this.readInt(radix);
      if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
      if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
      return this.finishToken(_tokentype.types.num, val);
    };
    
    // Read an integer, octal integer, or floating-point number.
    
    pp.readNumber = function (startsWithDot) {
      var start = this.pos,
          isFloat = false,
          octal = this.input.charCodeAt(this.pos) === 48;
      if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
      var next = this.input.charCodeAt(this.pos);
      if (next === 46) {
        // '.'
        ++this.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.pos);
      }
      if (next === 69 || next === 101) {
        // 'eE'
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) ++this.pos; // '+-'
        if (this.readInt(10) === null) this.raise(start, "Invalid number");
        isFloat = true;
      }
      if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
    
      var str = this.input.slice(start, this.pos),
          val = undefined;
      if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
      return this.finishToken(_tokentype.types.num, val);
    };
    
    // Read a string value, interpreting backslash-escapes.
    
    pp.readCodePoint = function () {
      var ch = this.input.charCodeAt(this.pos),
          code = undefined;
    
      if (ch === 123) {
        if (this.options.ecmaVersion < 6) this.unexpected();
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    
    function codePointToString(code) {
      // UTF-16 Decoding
      if (code <= 0xFFFF) return String.fromCharCode(code);
      code -= 0x10000;
      return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
    }
    
    pp.readString = function (quote) {
      var out = "",
          chunkStart = ++this.pos;
      for (;;) {
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) break;
        if (ch === 92) {
          // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else {
          if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(_tokentype.types.string, out);
    };
    
    // Reads template string tokens.
    
    pp.readTmplToken = function () {
      var out = "",
          chunkStart = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          // '`', '${'
          if (this.pos === this.start && this.type === _tokentype.types.template) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(_tokentype.types.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(_tokentype.types.backQuote);
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(_tokentype.types.template, out);
        }
        if (ch === 92) {
          // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (_whitespace.isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    
    // Used to read escaped characters
    
    pp.readEscapedChar = function (inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
        case 110:
          return "\n"; // 'n' -> '\n'
        case 114:
          return "\r"; // 'r' -> '\r'
        case 120:
          return String.fromCharCode(this.readHexChar(2)); // 'x'
        case 117:
          return codePointToString(this.readCodePoint()); // 'u'
        case 116:
          return "\t"; // 't' -> '\t'
        case 98:
          return "\b"; // 'b' -> '\b'
        case 118:
          return "\u000b"; // 'v' -> '\u000b'
        case 102:
          return "\f"; // 'f' -> '\f'
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
        case 10:
          // ' \n'
          if (this.options.locations) {
            this.lineStart = this.pos;++this.curLine;
          }
          return "";
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            if (octal > 0 && (this.strict || inTemplate)) {
              this.raise(this.pos - 2, "Octal literal in strict mode");
            }
            this.pos += octalStr.length - 1;
            return String.fromCharCode(octal);
          }
          return String.fromCharCode(ch);
      }
    };
    
    // Used to read character escape sequences ('\x', '\u', '\U').
    
    pp.readHexChar = function (len) {
      var codePos = this.pos;
      var n = this.readInt(16, len);
      if (n === null) this.raise(codePos, "Bad character escape sequence");
      return n;
    };
    
    // Read an identifier, and return it as a string. Sets `this.containsEsc`
    // to whether the word contained a '\u' escape.
    //
    // Incrementally adds only escaped chars, adding other chunks as-is
    // as a micro-optimization.
    
    pp.readWord1 = function () {
      this.containsEsc = false;
      var word = "",
          first = true,
          chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (_identifier.isIdentifierChar(ch, astral)) {
          this.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) {
          // "\"
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) != 117) // "u"
            this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
          word += codePointToString(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    
    // Read an identifier or keyword token. Will check for reserved
    // words when necessary.
    
    pp.readWord = function () {
      var word = this.readWord1();
      var type = _tokentype.types.name;
      if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.isKeyword(word)) type = _tokentype.keywords[word];
      return this.finishToken(type, word);
    };
    
    },{"./identifier":2,"./locutil":5,"./state":10,"./tokentype":14,"./whitespace":16}],14:[function(_dereq_,module,exports){
    // ## Token types
    
    // The assignment of fine-grained, information-carrying type objects
    // allows the tokenizer to store the information it has about a
    // token in a way that is very cheap for the parser to look up.
    
    // All token type variables start with an underscore, to make them
    // easy to recognize.
    
    // The `beforeExpr` property is used to disambiguate between regular
    // expressions and divisions. It is set on all token types that can
    // be followed by an expression (thus, a slash after them would be a
    // regular expression).
    //
    // `isLoop` marks a keyword as starting a loop, which is important
    // to know when parsing a label, in order to allow or disallow
    // continue jumps to that label.
    
    "use strict";
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var TokenType = function TokenType(label) {
      var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    
      _classCallCheck(this, TokenType);
    
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    
    exports.TokenType = TokenType;
    
    function binop(name, prec) {
      return new TokenType(name, { beforeExpr: true, binop: prec });
    }
    var beforeExpr = { beforeExpr: true },
        startsExpr = { startsExpr: true };
    
    var types = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      eof: new TokenType("eof"),
    
      // Punctuation token types.
      bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
    
      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator.
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.
    
      eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=", 6),
      relational: binop("</>", 7),
      bitShift: binop("<</>>", 8),
      plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10)
    };
    
    exports.types = types;
    // Map keyword names to token types.
    
    var keywords = {};
    
    exports.keywords = keywords;
    // Succinct definitions of keyword token types
    function kw(name) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    
      options.keyword = name;
      keywords[name] = types["_" + name] = new TokenType(name, options);
    }
    
    kw("break");
    kw("case", beforeExpr);
    kw("catch");
    kw("continue");
    kw("debugger");
    kw("default", beforeExpr);
    kw("do", { isLoop: true });
    kw("else", beforeExpr);
    kw("finally");
    kw("for", { isLoop: true });
    kw("function", startsExpr);
    kw("if");
    kw("return", beforeExpr);
    kw("switch");
    kw("throw", beforeExpr);
    kw("try");
    kw("var");
    kw("let");
    kw("const");
    kw("while", { isLoop: true });
    kw("with");
    kw("new", { beforeExpr: true, startsExpr: true });
    kw("this", startsExpr);
    kw("super", startsExpr);
    kw("class");
    kw("extends", beforeExpr);
    kw("export");
    kw("import");
    kw("yield", { beforeExpr: true, startsExpr: true });
    kw("null", startsExpr);
    kw("true", startsExpr);
    kw("false", startsExpr);
    kw("in", { beforeExpr: true, binop: 7 });
    kw("instanceof", { beforeExpr: true, binop: 7 });
    kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
    kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
    kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });
    
    },{}],15:[function(_dereq_,module,exports){
    "use strict";
    
    exports.__esModule = true;
    exports.isArray = isArray;
    exports.has = has;
    
    function isArray(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    }
    
    // Checks if an object has a property.
    
    function has(obj, propName) {
      return Object.prototype.hasOwnProperty.call(obj, propName);
    }
    
    },{}],16:[function(_dereq_,module,exports){
    // Matches a whole line break (where CRLF is considered a single
    // line break). Used to count lines.
    
    "use strict";
    
    exports.__esModule = true;
    exports.isNewLine = isNewLine;
    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    exports.lineBreak = lineBreak;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    
    exports.lineBreakG = lineBreakG;
    
    function isNewLine(code) {
      return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
    }
    
    var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    exports.nonASCIIwhitespace = nonASCIIwhitespace;
    
    },{}]},{},[3])(3)
    });
  provide("acorn", module.exports);
}(global));

// pakmanager:foreach
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    
    module.exports = function forEach (obj, fn, ctx) {
        if (toString.call(fn) !== '[object Function]') {
            throw new TypeError('iterator must be a function');
        }
        var l = obj.length;
        if (l === +l) {
            for (var i = 0; i < l; i++) {
                fn.call(ctx, obj[i], i, obj);
            }
        } else {
            for (var k in obj) {
                if (hasOwn.call(obj, k)) {
                    fn.call(ctx, obj[k], k, obj);
                }
            }
        }
    };
    
    
  provide("foreach", module.exports);
}(global));

// pakmanager:object-keys/isArguments
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var toStr = Object.prototype.toString;
    
    module.exports = function isArguments(value) {
    	var str = toStr.call(value);
    	var isArgs = str === '[object Arguments]';
    	if (!isArgs) {
    		isArgs = str !== '[object Array]' &&
    			value !== null &&
    			typeof value === 'object' &&
    			typeof value.length === 'number' &&
    			value.length >= 0 &&
    			toStr.call(value.callee) === '[object Function]';
    	}
    	return isArgs;
    };
    
  provide("object-keys/isArguments", module.exports);
}(global));

// pakmanager:object-keys
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    // modified from https://github.com/es-shims/es5-shim
    var has = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var slice = Array.prototype.slice;
    var isArgs =  require('object-keys/isArguments');
    var hasDontEnumBug = !({ 'toString': null }).propertyIsEnumerable('toString');
    var hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype');
    var dontEnums = [
    	'toString',
    	'toLocaleString',
    	'valueOf',
    	'hasOwnProperty',
    	'isPrototypeOf',
    	'propertyIsEnumerable',
    	'constructor'
    ];
    var equalsConstructorPrototype = function (o) {
    	var ctor = o.constructor;
    	return ctor && ctor.prototype === o;
    };
    var blacklistedKeys = {
    	$window: true,
    	$console: true,
    	$parent: true,
    	$self: true,
    	$frames: true,
    	$webkitIndexedDB: true,
    	$webkitStorageInfo: true
    };
    var hasAutomationEqualityBug = (function () {
    	/* global window */
    	if (typeof window === 'undefined') { return false; }
    	for (var k in window) {
    		if (!blacklistedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
    			try {
    				equalsConstructorPrototype(window[k]);
    			} catch (e) {
    				return true;
    			}
    		}
    	}
    	return false;
    }());
    var equalsConstructorPrototypeIfNotBuggy = function (o) {
    	/* global window */
    	if (typeof window === 'undefined' && !hasAutomationEqualityBug) {
    		return equalsConstructorPrototype(o);
    	}
    	try {
    		return equalsConstructorPrototype(o);
    	} catch (e) {
    		return false;
    	}
    };
    
    var keysShim = function keys(object) {
    	var isObject = object !== null && typeof object === 'object';
    	var isFunction = toStr.call(object) === '[object Function]';
    	var isArguments = isArgs(object);
    	var isString = isObject && toStr.call(object) === '[object String]';
    	var theKeys = [];
    
    	if (!isObject && !isFunction && !isArguments) {
    		throw new TypeError('Object.keys called on a non-object');
    	}
    
    	var skipProto = hasProtoEnumBug && isFunction;
    	if (isString && object.length > 0 && !has.call(object, 0)) {
    		for (var i = 0; i < object.length; ++i) {
    			theKeys.push(String(i));
    		}
    	}
    
    	if (isArguments && object.length > 0) {
    		for (var j = 0; j < object.length; ++j) {
    			theKeys.push(String(j));
    		}
    	} else {
    		for (var name in object) {
    			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
    				theKeys.push(String(name));
    			}
    		}
    	}
    
    	if (hasDontEnumBug) {
    		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
    
    		for (var k = 0; k < dontEnums.length; ++k) {
    			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
    				theKeys.push(dontEnums[k]);
    			}
    		}
    	}
    	return theKeys;
    };
    
    keysShim.shim = function shimObjectKeys() {
    	if (!Object.keys) {
    		Object.keys = keysShim;
    	} else {
    		var keysWorksWithArguments = (function () {
    			// Safari 5.0 bug
    			return (Object.keys(arguments) || '').length === 2;
    		}(1, 2));
    		if (!keysWorksWithArguments) {
    			var originalKeys = Object.keys;
    			Object.keys = function keys(object) {
    				if (isArgs(object)) {
    					return originalKeys(slice.call(object));
    				} else {
    					return originalKeys(object);
    				}
    			};
    		}
    	}
    	return Object.keys || keysShim;
    };
    
    module.exports = keysShim;
    
  provide("object-keys", module.exports);
}(global));

// pakmanager:function-bind
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = '[object Function]';
    
    module.exports = function bind(that) {
        var target = this;
        if (typeof target !== 'function' || toStr.call(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
    
        var binder = function () {
            if (this instanceof bound) {
                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;
            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );
            }
        };
    
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }
    
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
    
        if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
    
        return bound;
    };
    
    
  provide("function-bind", module.exports);
}(global));

// pakmanager:buffer-equal
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Buffer = require('buffer').Buffer; // for use with browserify
    
    module.exports = function (a, b) {
        if (!Buffer.isBuffer(a)) return undefined;
        if (!Buffer.isBuffer(b)) return undefined;
        if (typeof a.equals === 'function') return a.equals(b);
        if (a.length !== b.length) return false;
        
        for (var i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return false;
        }
        
        return true;
    };
    
  provide("buffer-equal", module.exports);
}(global));

// pakmanager:minimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (args, opts) {
        if (!opts) opts = {};
        
        var flags = { bools : {}, strings : {}, unknownFn: null };
    
        if (typeof opts['unknown'] === 'function') {
            flags.unknownFn = opts['unknown'];
        }
    
        if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
          flags.allBools = true;
        } else {
          [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
              flags.bools[key] = true;
          });
        }
        
        var aliases = {};
        Object.keys(opts.alias || {}).forEach(function (key) {
            aliases[key] = [].concat(opts.alias[key]);
            aliases[key].forEach(function (x) {
                aliases[x] = [key].concat(aliases[key].filter(function (y) {
                    return x !== y;
                }));
            });
        });
    
        [].concat(opts.string).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            if (aliases[key]) {
                flags.strings[aliases[key]] = true;
            }
         });
    
        var defaults = opts['default'] || {};
        
        var argv = { _ : [] };
        Object.keys(flags.bools).forEach(function (key) {
            setArg(key, defaults[key] === undefined ? false : defaults[key]);
        });
        
        var notFlags = [];
    
        if (args.indexOf('--') !== -1) {
            notFlags = args.slice(args.indexOf('--')+1);
            args = args.slice(0, args.indexOf('--'));
        }
    
        function argDefined(key, arg) {
            return (flags.allBools && /^--[^=]+$/.test(arg)) ||
                flags.strings[key] || flags.bools[key] || aliases[key];
        }
    
        function setArg (key, val, arg) {
            if (arg && flags.unknownFn && !argDefined(key, arg)) {
                if (flags.unknownFn(arg) === false) return;
            }
    
            var value = !flags.strings[key] && isNumber(val)
                ? Number(val) : val
            ;
            setKey(argv, key.split('.'), value);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), value);
            });
        }
    
        function setKey (obj, keys, value) {
            var o = obj;
            keys.slice(0,-1).forEach(function (key) {
                if (o[key] === undefined) o[key] = {};
                o = o[key];
            });
    
            var key = keys[keys.length - 1];
            if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
                o[key] = value;
            }
            else if (Array.isArray(o[key])) {
                o[key].push(value);
            }
            else {
                o[key] = [ o[key], value ];
            }
        }
        
        function aliasIsBoolean(key) {
          return aliases[key].some(function (x) {
              return flags.bools[x];
          });
        }
    
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            
            if (/^--.+=/.test(arg)) {
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
                var key = m[1];
                var value = m[2];
                if (flags.bools[key]) {
                    value = value !== 'false';
                }
                setArg(key, value, arg);
            }
            else if (/^--no-.+/.test(arg)) {
                var key = arg.match(/^--no-(.+)/)[1];
                setArg(key, false, arg);
            }
            else if (/^--.+/.test(arg)) {
                var key = arg.match(/^--(.+)/)[1];
                var next = args[i + 1];
                if (next !== undefined && !/^-/.test(next)
                && !flags.bools[key]
                && !flags.allBools
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, next, arg);
                    i++;
                }
                else if (/^(true|false)$/.test(next)) {
                    setArg(key, next === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
            else if (/^-[^-]+/.test(arg)) {
                var letters = arg.slice(1,-1).split('');
                
                var broken = false;
                for (var j = 0; j < letters.length; j++) {
                    var next = arg.slice(j+2);
                    
                    if (next === '-') {
                        setArg(letters[j], next, arg)
                        continue;
                    }
                    
                    if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                        setArg(letters[j], next.split('=')[1], arg);
                        broken = true;
                        break;
                    }
                    
                    if (/[A-Za-z]/.test(letters[j])
                    && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                        setArg(letters[j], next, arg);
                        broken = true;
                        break;
                    }
                    
                    if (letters[j+1] && letters[j+1].match(/\W/)) {
                        setArg(letters[j], arg.slice(j+2), arg);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                    }
                }
                
                var key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                    && !flags.bools[key]
                    && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                        setArg(key, args[i+1], arg);
                        i++;
                    }
                    else if (args[i+1] && /true|false/.test(args[i+1])) {
                        setArg(key, args[i+1] === 'true', arg);
                        i++;
                    }
                    else {
                        setArg(key, flags.strings[key] ? '' : true, arg);
                    }
                }
            }
            else {
                if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                    argv._.push(
                        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                    );
                }
                if (opts.stopEarly) {
                    argv._.push.apply(argv._, args.slice(i + 1));
                    break;
                }
            }
        }
        
        Object.keys(defaults).forEach(function (key) {
            if (!hasKey(argv, key.split('.'))) {
                setKey(argv, key.split('.'), defaults[key]);
                
                (aliases[key] || []).forEach(function (x) {
                    setKey(argv, x.split('.'), defaults[key]);
                });
            }
        });
        
        if (opts['--']) {
            argv['--'] = new Array();
            notFlags.forEach(function(key) {
                argv['--'].push(key);
            });
        }
        else {
            notFlags.forEach(function(key) {
                argv._.push(key);
            });
        }
    
        return argv;
    };
    
    function hasKey (obj, keys) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            o = (o[key] || {});
        });
    
        var key = keys[keys.length - 1];
        return key in o;
    }
    
    function isNumber (x) {
        if (typeof x === 'number') return true;
        if (/^0x[0-9a-f]+$/i.test(x)) return true;
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    
    
  provide("minimist", module.exports);
}(global));

// pakmanager:through2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Transform = require('readable-stream/transform')
      , inherits  = require('util').inherits
      , xtend     = require('xtend')
    
    function DestroyableTransform(opts) {
      Transform.call(this, opts)
      this._destroyed = false
    }
    
    inherits(DestroyableTransform, Transform)
    
    DestroyableTransform.prototype.destroy = function(err) {
      if (this._destroyed) return
      this._destroyed = true
      
      var self = this
      process.nextTick(function() {
        if (err)
          self.emit('error', err)
        self.emit('close')
      })
    }
    
    // a noop _transform function
    function noop (chunk, enc, callback) {
      callback(null, chunk)
    }
    
    
    // create a new export function, used by both the main export and
    // the .ctor export, contains common logic for dealing with arguments
    function through2 (construct) {
      return function (options, transform, flush) {
        if (typeof options == 'function') {
          flush     = transform
          transform = options
          options   = {}
        }
    
        if (typeof transform != 'function')
          transform = noop
    
        if (typeof flush != 'function')
          flush = null
    
        return construct(options, transform, flush)
      }
    }
    
    
    // main export, just make me a transform stream!
    module.exports = through2(function (options, transform, flush) {
      var t2 = new DestroyableTransform(options)
    
      t2._transform = transform
    
      if (flush)
        t2._flush = flush
    
      return t2
    })
    
    
    // make me a reusable prototype that I can `new`, or implicitly `new`
    // with a constructor call
    module.exports.ctor = through2(function (options, transform, flush) {
      function Through2 (override) {
        if (!(this instanceof Through2))
          return new Through2(override)
    
        this.options = xtend(options, override)
    
        DestroyableTransform.call(this, this.options)
      }
    
      inherits(Through2, DestroyableTransform)
    
      Through2.prototype._transform = transform
    
      if (flush)
        Through2.prototype._flush = flush
    
      return Through2
    })
    
    
    module.exports.obj = through2(function (options, transform, flush) {
      var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))
    
      t2._transform = transform
    
      if (flush)
        t2._flush = flush
    
      return t2
    })
    
  provide("through2", module.exports);
}(global));

// pakmanager:escodegen
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
      Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
      Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
      Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
      Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
      Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
      Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
      Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
      Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
      Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
      Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
      Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    
    /*global exports:true, require:true, global:true*/
    (function () {
        'use strict';
    
        var Syntax,
            Precedence,
            BinaryPrecedence,
            SourceNode,
            estraverse,
            esutils,
            isArray,
            base,
            indent,
            json,
            renumber,
            hexadecimal,
            quotes,
            escapeless,
            newline,
            space,
            parentheses,
            semicolons,
            safeConcatenation,
            directive,
            extra,
            parse,
            sourceMap,
            sourceCode,
            preserveBlankLines,
            FORMAT_MINIFY,
            FORMAT_DEFAULTS;
    
        estraverse = require('estraverse');
        esutils = require('esutils');
    
        Syntax = estraverse.Syntax;
    
        // Generation is done by generateExpression.
        function isExpression(node) {
            return CodeGenerator.Expression.hasOwnProperty(node.type);
        }
    
        // Generation is done by generateStatement.
        function isStatement(node) {
            return CodeGenerator.Statement.hasOwnProperty(node.type);
        }
    
        Precedence = {
            Sequence: 0,
            Yield: 1,
            Await: 1,
            Assignment: 1,
            Conditional: 2,
            ArrowFunction: 2,
            LogicalOR: 3,
            LogicalAND: 4,
            BitwiseOR: 5,
            BitwiseXOR: 6,
            BitwiseAND: 7,
            Equality: 8,
            Relational: 9,
            BitwiseSHIFT: 10,
            Additive: 11,
            Multiplicative: 12,
            Unary: 13,
            Postfix: 14,
            Call: 15,
            New: 16,
            TaggedTemplate: 17,
            Member: 18,
            Primary: 19
        };
    
        BinaryPrecedence = {
            '||': Precedence.LogicalOR,
            '&&': Precedence.LogicalAND,
            '|': Precedence.BitwiseOR,
            '^': Precedence.BitwiseXOR,
            '&': Precedence.BitwiseAND,
            '==': Precedence.Equality,
            '!=': Precedence.Equality,
            '===': Precedence.Equality,
            '!==': Precedence.Equality,
            'is': Precedence.Equality,
            'isnt': Precedence.Equality,
            '<': Precedence.Relational,
            '>': Precedence.Relational,
            '<=': Precedence.Relational,
            '>=': Precedence.Relational,
            'in': Precedence.Relational,
            'instanceof': Precedence.Relational,
            '<<': Precedence.BitwiseSHIFT,
            '>>': Precedence.BitwiseSHIFT,
            '>>>': Precedence.BitwiseSHIFT,
            '+': Precedence.Additive,
            '-': Precedence.Additive,
            '*': Precedence.Multiplicative,
            '%': Precedence.Multiplicative,
            '/': Precedence.Multiplicative
        };
    
        //Flags
        var F_ALLOW_IN = 1,
            F_ALLOW_CALL = 1 << 1,
            F_ALLOW_UNPARATH_NEW = 1 << 2,
            F_FUNC_BODY = 1 << 3,
            F_DIRECTIVE_CTX = 1 << 4,
            F_SEMICOLON_OPT = 1 << 5;
    
        //Expression flag sets
        //NOTE: Flag order:
        // F_ALLOW_IN
        // F_ALLOW_CALL
        // F_ALLOW_UNPARATH_NEW
        var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
            E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
            E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
            E_TFF = F_ALLOW_IN,
            E_FFT = F_ALLOW_UNPARATH_NEW,
            E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
    
        //Statement flag sets
        //NOTE: Flag order:
        // F_ALLOW_IN
        // F_FUNC_BODY
        // F_DIRECTIVE_CTX
        // F_SEMICOLON_OPT
        var S_TFFF = F_ALLOW_IN,
            S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
            S_FFFF = 0x00,
            S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
            S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
    
        function getDefaultOptions() {
            // default options
            return {
                indent: null,
                base: null,
                parse: null,
                comment: false,
                format: {
                    indent: {
                        style: '    ',
                        base: 0,
                        adjustMultilineComment: false
                    },
                    newline: '\n',
                    space: ' ',
                    json: false,
                    renumber: false,
                    hexadecimal: false,
                    quotes: 'single',
                    escapeless: false,
                    compact: false,
                    parentheses: true,
                    semicolons: true,
                    safeConcatenation: false,
                    preserveBlankLines: false
                },
                moz: {
                    comprehensionExpressionStartsWithAssignment: false,
                    starlessGenerator: false
                },
                sourceMap: null,
                sourceMapRoot: null,
                sourceMapWithCode: false,
                directive: false,
                raw: true,
                verbatim: null,
                sourceCode: null
            };
        }
    
        function stringRepeat(str, num) {
            var result = '';
    
            for (num |= 0; num > 0; num >>>= 1, str += str) {
                if (num & 1) {
                    result += str;
                }
            }
    
            return result;
        }
    
        isArray = Array.isArray;
        if (!isArray) {
            isArray = function isArray(array) {
                return Object.prototype.toString.call(array) === '[object Array]';
            };
        }
    
        function hasLineTerminator(str) {
            return (/[\r\n]/g).test(str);
        }
    
        function endsWithLineTerminator(str) {
            var len = str.length;
            return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
        }
    
        function merge(target, override) {
            var key;
            for (key in override) {
                if (override.hasOwnProperty(key)) {
                    target[key] = override[key];
                }
            }
            return target;
        }
    
        function updateDeeply(target, override) {
            var key, val;
    
            function isHashObject(target) {
                return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
            }
    
            for (key in override) {
                if (override.hasOwnProperty(key)) {
                    val = override[key];
                    if (isHashObject(val)) {
                        if (isHashObject(target[key])) {
                            updateDeeply(target[key], val);
                        } else {
                            target[key] = updateDeeply({}, val);
                        }
                    } else {
                        target[key] = val;
                    }
                }
            }
            return target;
        }
    
        function generateNumber(value) {
            var result, point, temp, exponent, pos;
    
            if (value !== value) {
                throw new Error('Numeric literal whose value is NaN');
            }
            if (value < 0 || (value === 0 && 1 / value < 0)) {
                throw new Error('Numeric literal whose value is negative');
            }
    
            if (value === 1 / 0) {
                return json ? 'null' : renumber ? '1e400' : '1e+400';
            }
    
            result = '' + value;
            if (!renumber || result.length < 3) {
                return result;
            }
    
            point = result.indexOf('.');
            if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
                point = 0;
                result = result.slice(1);
            }
            temp = result;
            result = result.replace('e+', 'e');
            exponent = 0;
            if ((pos = temp.indexOf('e')) > 0) {
                exponent = +temp.slice(pos + 1);
                temp = temp.slice(0, pos);
            }
            if (point >= 0) {
                exponent -= temp.length - point - 1;
                temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
            }
            pos = 0;
            while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
                --pos;
            }
            if (pos !== 0) {
                exponent -= pos;
                temp = temp.slice(0, pos);
            }
            if (exponent !== 0) {
                temp += 'e' + exponent;
            }
            if ((temp.length < result.length ||
                        (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                    +temp === value) {
                result = temp;
            }
    
            return result;
        }
    
        // Generate valid RegExp expression.
        // This function is based on https://github.com/Constellation/iv Engine
    
        function escapeRegExpCharacter(ch, previousIsBackslash) {
            // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
            if ((ch & ~1) === 0x2028) {
                return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
            } else if (ch === 10 || ch === 13) {  // \n, \r
                return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
            }
            return String.fromCharCode(ch);
        }
    
        function generateRegExp(reg) {
            var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
    
            result = reg.toString();
    
            if (reg.source) {
                // extract flag from toString result
                match = result.match(/\/([^/]*)$/);
                if (!match) {
                    return result;
                }
    
                flags = match[1];
                result = '';
    
                characterInBrack = false;
                previousIsBackslash = false;
                for (i = 0, iz = reg.source.length; i < iz; ++i) {
                    ch = reg.source.charCodeAt(i);
    
                    if (!previousIsBackslash) {
                        if (characterInBrack) {
                            if (ch === 93) {  // ]
                                characterInBrack = false;
                            }
                        } else {
                            if (ch === 47) {  // /
                                result += '\\';
                            } else if (ch === 91) {  // [
                                characterInBrack = true;
                            }
                        }
                        result += escapeRegExpCharacter(ch, previousIsBackslash);
                        previousIsBackslash = ch === 92;  // \
                    } else {
                        // if new RegExp("\\\n') is provided, create /\n/
                        result += escapeRegExpCharacter(ch, previousIsBackslash);
                        // prevent like /\\[/]/
                        previousIsBackslash = false;
                    }
                }
    
                return '/' + result + '/' + flags;
            }
    
            return result;
        }
    
        function escapeAllowedCharacter(code, next) {
            var hex;
    
            if (code === 0x08  /* \b */) {
                return '\\b';
            }
    
            if (code === 0x0C  /* \f */) {
                return '\\f';
            }
    
            if (code === 0x09  /* \t */) {
                return '\\t';
            }
    
            hex = code.toString(16).toUpperCase();
            if (json || code > 0xFF) {
                return '\\u' + '0000'.slice(hex.length) + hex;
            } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
                return '\\0';
            } else if (code === 0x000B  /* \v */) { // '\v'
                return '\\x0B';
            } else {
                return '\\x' + '00'.slice(hex.length) + hex;
            }
        }
    
        function escapeDisallowedCharacter(code) {
            if (code === 0x5C  /* \ */) {
                return '\\\\';
            }
    
            if (code === 0x0A  /* \n */) {
                return '\\n';
            }
    
            if (code === 0x0D  /* \r */) {
                return '\\r';
            }
    
            if (code === 0x2028) {
                return '\\u2028';
            }
    
            if (code === 0x2029) {
                return '\\u2029';
            }
    
            throw new Error('Incorrectly classified character');
        }
    
        function escapeDirective(str) {
            var i, iz, code, quote;
    
            quote = quotes === 'double' ? '"' : '\'';
            for (i = 0, iz = str.length; i < iz; ++i) {
                code = str.charCodeAt(i);
                if (code === 0x27  /* ' */) {
                    quote = '"';
                    break;
                } else if (code === 0x22  /* " */) {
                    quote = '\'';
                    break;
                } else if (code === 0x5C  /* \ */) {
                    ++i;
                }
            }
    
            return quote + str + quote;
        }
    
        function escapeString(str) {
            var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
    
            for (i = 0, len = str.length; i < len; ++i) {
                code = str.charCodeAt(i);
                if (code === 0x27  /* ' */) {
                    ++singleQuotes;
                } else if (code === 0x22  /* " */) {
                    ++doubleQuotes;
                } else if (code === 0x2F  /* / */ && json) {
                    result += '\\';
                } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                    result += escapeDisallowedCharacter(code);
                    continue;
                } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20  /* SP */ || !json && !escapeless && (code < 0x20  /* SP */ || code > 0x7E  /* ~ */))) {
                    result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                    continue;
                }
                result += String.fromCharCode(code);
            }
    
            single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
            quote = single ? '\'' : '"';
    
            if (!(single ? singleQuotes : doubleQuotes)) {
                return quote + result + quote;
            }
    
            str = result;
            result = quote;
    
            for (i = 0, len = str.length; i < len; ++i) {
                code = str.charCodeAt(i);
                if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                    result += '\\';
                }
                result += String.fromCharCode(code);
            }
    
            return result + quote;
        }
    
        /**
         * flatten an array to a string, where the array can contain
         * either strings or nested arrays
         */
        function flattenToString(arr) {
            var i, iz, elem, result = '';
            for (i = 0, iz = arr.length; i < iz; ++i) {
                elem = arr[i];
                result += isArray(elem) ? flattenToString(elem) : elem;
            }
            return result;
        }
    
        /**
         * convert generated to a SourceNode when source maps are enabled.
         */
        function toSourceNodeWhenNeeded(generated, node) {
            if (!sourceMap) {
                // with no source maps, generated is either an
                // array or a string.  if an array, flatten it.
                // if a string, just return it
                if (isArray(generated)) {
                    return flattenToString(generated);
                } else {
                    return generated;
                }
            }
            if (node == null) {
                if (generated instanceof SourceNode) {
                    return generated;
                } else {
                    node = {};
                }
            }
            if (node.loc == null) {
                return new SourceNode(null, null, sourceMap, generated, node.name || null);
            }
            return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
        }
    
        function noEmptySpace() {
            return (space) ? space : ' ';
        }
    
        function join(left, right) {
            var leftSource,
                rightSource,
                leftCharCode,
                rightCharCode;
    
            leftSource = toSourceNodeWhenNeeded(left).toString();
            if (leftSource.length === 0) {
                return [right];
            }
    
            rightSource = toSourceNodeWhenNeeded(right).toString();
            if (rightSource.length === 0) {
                return [left];
            }
    
            leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
            rightCharCode = rightSource.charCodeAt(0);
    
            if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
                esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||
                leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
                return [left, noEmptySpace(), right];
            } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                    esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
                return [left, right];
            }
            return [left, space, right];
        }
    
        function addIndent(stmt) {
            return [base, stmt];
        }
    
        function withIndent(fn) {
            var previousBase;
            previousBase = base;
            base += indent;
            fn(base);
            base = previousBase;
        }
    
        function calculateSpaces(str) {
            var i;
            for (i = str.length - 1; i >= 0; --i) {
                if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                    break;
                }
            }
            return (str.length - 1) - i;
        }
    
        function adjustMultilineComment(value, specialBase) {
            var array, i, len, line, j, spaces, previousBase, sn;
    
            array = value.split(/\r\n|[\r\n]/);
            spaces = Number.MAX_VALUE;
    
            // first line doesn't have indentation
            for (i = 1, len = array.length; i < len; ++i) {
                line = array[i];
                j = 0;
                while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                    ++j;
                }
                if (spaces > j) {
                    spaces = j;
                }
            }
    
            if (typeof specialBase !== 'undefined') {
                // pattern like
                // {
                //   var t = 20;  /*
                //                 * this is comment
                //                 */
                // }
                previousBase = base;
                if (array[1][spaces] === '*') {
                    specialBase += ' ';
                }
                base = specialBase;
            } else {
                if (spaces & 1) {
                    // /*
                    //  *
                    //  */
                    // If spaces are odd number, above pattern is considered.
                    // We waste 1 space.
                    --spaces;
                }
                previousBase = base;
            }
    
            for (i = 1, len = array.length; i < len; ++i) {
                sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
                array[i] = sourceMap ? sn.join('') : sn;
            }
    
            base = previousBase;
    
            return array.join('\n');
        }
    
        function generateComment(comment, specialBase) {
            if (comment.type === 'Line') {
                if (endsWithLineTerminator(comment.value)) {
                    return '//' + comment.value;
                } else {
                    // Always use LineTerminator
                    var result = '//' + comment.value;
                    if (!preserveBlankLines) {
                        result += '\n';
                    }
                    return result;
                }
            }
            if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
                return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
            }
            return '/*' + comment.value + '*/';
        }
    
        function addComments(stmt, result) {
            var i, len, comment, save, tailingToStatement, specialBase, fragment,
                extRange, range, prevRange, prefix, infix, suffix, count;
    
            if (stmt.leadingComments && stmt.leadingComments.length > 0) {
                save = result;
    
                if (preserveBlankLines) {
                    comment = stmt.leadingComments[0];
                    result = [];
    
                    extRange = comment.extendedRange;
                    range = comment.range;
    
                    prefix = sourceCode.substring(extRange[0], range[0]);
                    count = (prefix.match(/\n/g) || []).length;
                    if (count > 0) {
                        result.push(stringRepeat('\n', count));
                        result.push(addIndent(generateComment(comment)));
                    } else {
                        result.push(prefix);
                        result.push(generateComment(comment));
                    }
    
                    prevRange = range;
    
                    for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
                        comment = stmt.leadingComments[i];
                        range = comment.range;
    
                        infix = sourceCode.substring(prevRange[1], range[0]);
                        count = (infix.match(/\n/g) || []).length;
                        result.push(stringRepeat('\n', count));
                        result.push(addIndent(generateComment(comment)));
    
                        prevRange = range;
                    }
    
                    suffix = sourceCode.substring(range[1], extRange[1]);
                    count = (suffix.match(/\n/g) || []).length;
                    result.push(stringRepeat('\n', count));
                } else {
                    comment = stmt.leadingComments[0];
                    result = [];
                    if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                        result.push('\n');
                    }
                    result.push(generateComment(comment));
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push('\n');
                    }
    
                    for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                        comment = stmt.leadingComments[i];
                        fragment = [generateComment(comment)];
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                            fragment.push('\n');
                        }
                        result.push(addIndent(fragment));
                    }
                }
    
                result.push(addIndent(save));
            }
    
            if (stmt.trailingComments) {
    
                if (preserveBlankLines) {
                    comment = stmt.trailingComments[0];
                    extRange = comment.extendedRange;
                    range = comment.range;
    
                    prefix = sourceCode.substring(extRange[0], range[0]);
                    count = (prefix.match(/\n/g) || []).length;
    
                    if (count > 0) {
                        result.push(stringRepeat('\n', count));
                        result.push(addIndent(generateComment(comment)));
                    } else {
                        result.push(prefix);
                        result.push(generateComment(comment));
                    }
                } else {
                    tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                    specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
                    for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                        comment = stmt.trailingComments[i];
                        if (tailingToStatement) {
                            // We assume target like following script
                            //
                            // var t = 20;  /**
                            //               * This is comment of t
                            //               */
                            if (i === 0) {
                                // first case
                                result = [result, indent];
                            } else {
                                result = [result, specialBase];
                            }
                            result.push(generateComment(comment, specialBase));
                        } else {
                            result = [result, addIndent(generateComment(comment))];
                        }
                        if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result = [result, '\n'];
                        }
                    }
                }
            }
    
            return result;
        }
    
        function generateBlankLines(start, end, result) {
            var j, newlineCount = 0;
    
            for (j = start; j < end; j++) {
                if (sourceCode[j] === '\n') {
                    newlineCount++;
                }
            }
    
            for (j = 1; j < newlineCount; j++) {
                result.push(newline);
            }
        }
    
        function parenthesize(text, current, should) {
            if (current < should) {
                return ['(', text, ')'];
            }
            return text;
        }
    
        function generateVerbatimString(string) {
            var i, iz, result;
            result = string.split(/\r\n|\n/);
            for (i = 1, iz = result.length; i < iz; i++) {
                result[i] = newline + base + result[i];
            }
            return result;
        }
    
        function generateVerbatim(expr, precedence) {
            var verbatim, result, prec;
            verbatim = expr[extra.verbatim];
    
            if (typeof verbatim === 'string') {
                result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
            } else {
                // verbatim is object
                result = generateVerbatimString(verbatim.content);
                prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
                result = parenthesize(result, prec, precedence);
            }
    
            return toSourceNodeWhenNeeded(result, expr);
        }
    
        function CodeGenerator() {
        }
    
        // Helpers.
    
        CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
            var result, noLeadingComment, that = this;
    
            noLeadingComment = !extra.comment || !stmt.leadingComments;
    
            if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
                return [space, this.generateStatement(stmt, flags)];
            }
    
            if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
                return ';';
            }
    
            withIndent(function () {
                result = [
                    newline,
                    addIndent(that.generateStatement(stmt, flags))
                ];
            });
    
            return result;
        };
    
        CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
            var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
            if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
                return [result, space];
            }
            if (ends) {
                return [result, base];
            }
            return [result, newline, base];
        };
    
        function generateIdentifier(node) {
            return toSourceNodeWhenNeeded(node.name, node);
        }
    
        function generateAsyncPrefix(node, spaceRequired) {
            return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
        }
    
        function generateStarSuffix(node) {
            var isGenerator = node.generator && !extra.moz.starlessGenerator;
            return isGenerator ? '*' + space : '';
        }
    
        function generateMethodPrefix(prop) {
            var func = prop.value;
            if (func.async) {
                return generateAsyncPrefix(func, !prop.computed);
            } else {
                // avoid space before method name
                return generateStarSuffix(func) ? '*' : '';
            }
        }
    
        CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
            if (node.type === Syntax.Identifier) {
                return generateIdentifier(node);
            }
            return this.generateExpression(node, precedence, flags);
        };
    
        CodeGenerator.prototype.generateFunctionParams = function (node) {
            var i, iz, result, hasDefault;
    
            hasDefault = false;
    
            if (node.type === Syntax.ArrowFunctionExpression &&
                    !node.rest && (!node.defaults || node.defaults.length === 0) &&
                    node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
                // arg => { } case
                result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
            } else {
                result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
                result.push('(');
                if (node.defaults) {
                    hasDefault = true;
                }
                for (i = 0, iz = node.params.length; i < iz; ++i) {
                    if (hasDefault && node.defaults[i]) {
                        // Handle default values.
                        result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
                    } else {
                        result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
                    }
                    if (i + 1 < iz) {
                        result.push(',' + space);
                    }
                }
    
                if (node.rest) {
                    if (node.params.length) {
                        result.push(',' + space);
                    }
                    result.push('...');
                    result.push(generateIdentifier(node.rest));
                }
    
                result.push(')');
            }
    
            return result;
        };
    
        CodeGenerator.prototype.generateFunctionBody = function (node) {
            var result, expr;
    
            result = this.generateFunctionParams(node);
    
            if (node.type === Syntax.ArrowFunctionExpression) {
                result.push(space);
                result.push('=>');
            }
    
            if (node.expression) {
                result.push(space);
                expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
                if (expr.toString().charAt(0) === '{') {
                    expr = ['(', expr, ')'];
                }
                result.push(expr);
            } else {
                result.push(this.maybeBlock(node.body, S_TTFF));
            }
    
            return result;
        };
    
        CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
            var result = ['for' + space + '('], that = this;
            withIndent(function () {
                if (stmt.left.type === Syntax.VariableDeclaration) {
                    withIndent(function () {
                        result.push(stmt.left.kind + noEmptySpace());
                        result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
                    });
                } else {
                    result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
                }
    
                result = join(result, operator);
                result = [join(
                    result,
                    that.generateExpression(stmt.right, Precedence.Sequence, E_TTT)
                ), ')'];
            });
            result.push(this.maybeBlock(stmt.body, flags));
            return result;
        };
    
        CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
            var result = [];
    
            if (computed) {
                result.push('[');
            }
    
            result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));
            if (computed) {
                result.push(']');
            }
    
            return result;
        };
    
        CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
            if (Precedence.Assignment < precedence) {
                flags |= F_ALLOW_IN;
            }
    
            return parenthesize(
                [
                    this.generateExpression(left, Precedence.Call, flags),
                    space + operator + space,
                    this.generateExpression(right, Precedence.Assignment, flags)
                ],
                Precedence.Assignment,
                precedence
            );
        };
    
        CodeGenerator.prototype.semicolon = function (flags) {
            if (!semicolons && flags & F_SEMICOLON_OPT) {
                return '';
            }
            return ';';
        };
    
        // Statements.
    
        CodeGenerator.Statement = {
    
            BlockStatement: function (stmt, flags) {
                var range, content, result = ['{', newline], that = this;
    
                withIndent(function () {
                    // handle functions without any code
                    if (stmt.body.length === 0 && preserveBlankLines) {
                        range = stmt.range;
                        if (range[1] - range[0] > 2) {
                            content = sourceCode.substring(range[0] + 1, range[1] - 1);
                            if (content[0] === '\n') {
                                result = ['{'];
                            }
                            result.push(content);
                        }
                    }
    
                    var i, iz, fragment, bodyFlags;
                    bodyFlags = S_TFFF;
                    if (flags & F_FUNC_BODY) {
                        bodyFlags |= F_DIRECTIVE_CTX;
                    }
    
                    for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                        if (preserveBlankLines) {
                            // handle spaces before the first line
                            if (i === 0) {
                                if (stmt.body[0].leadingComments) {
                                    range = stmt.body[0].leadingComments[0].extendedRange;
                                    content = sourceCode.substring(range[0], range[1]);
                                    if (content[0] === '\n') {
                                        result = ['{'];
                                    }
                                }
                                if (!stmt.body[0].leadingComments) {
                                    generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                                }
                            }
    
                            // handle spaces between lines
                            if (i > 0) {
                                if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {
                                    generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                                }
                            }
                        }
    
                        if (i === iz - 1) {
                            bodyFlags |= F_SEMICOLON_OPT;
                        }
    
                        if (stmt.body[i].leadingComments && preserveBlankLines) {
                            fragment = that.generateStatement(stmt.body[i], bodyFlags);
                        } else {
                            fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                        }
    
                        result.push(fragment);
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                            if (preserveBlankLines && i < iz - 1) {
                                // don't add a new line if there are leading coments
                                // in the next statement
                                if (!stmt.body[i + 1].leadingComments) {
                                    result.push(newline);
                                }
                            } else {
                                result.push(newline);
                            }
                        }
    
                        if (preserveBlankLines) {
                            // handle spaces after the last line
                            if (i === iz - 1) {
                                if (!stmt.body[i].trailingComments) {
                                    generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                                }
                            }
                        }
                    }
                });
    
                result.push(addIndent('}'));
                return result;
            },
    
            BreakStatement: function (stmt, flags) {
                if (stmt.label) {
                    return 'break ' + stmt.label.name + this.semicolon(flags);
                }
                return 'break' + this.semicolon(flags);
            },
    
            ContinueStatement: function (stmt, flags) {
                if (stmt.label) {
                    return 'continue ' + stmt.label.name + this.semicolon(flags);
                }
                return 'continue' + this.semicolon(flags);
            },
    
            ClassBody: function (stmt, flags) {
                var result = [ '{', newline], that = this;
    
                withIndent(function (indent) {
                    var i, iz;
    
                    for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                        result.push(indent);
                        result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
                        if (i + 1 < iz) {
                            result.push(newline);
                        }
                    }
                });
    
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }
                result.push(base);
                result.push('}');
                return result;
            },
    
            ClassDeclaration: function (stmt, flags) {
                var result, fragment;
                result  = ['class ' + stmt.id.name];
                if (stmt.superClass) {
                    fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Assignment, E_TTT));
                    result = join(result, fragment);
                }
                result.push(space);
                result.push(this.generateStatement(stmt.body, S_TFFT));
                return result;
            },
    
            DirectiveStatement: function (stmt, flags) {
                if (extra.raw && stmt.raw) {
                    return stmt.raw + this.semicolon(flags);
                }
                return escapeDirective(stmt.directive) + this.semicolon(flags);
            },
    
            DoWhileStatement: function (stmt, flags) {
                // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
                var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
                result = this.maybeBlockSuffix(stmt.body, result);
                return join(result, [
                    'while' + space + '(',
                    this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')' + this.semicolon(flags)
                ]);
            },
    
            CatchClause: function (stmt, flags) {
                var result, that = this;
                withIndent(function () {
                    var guard;
    
                    result = [
                        'catch' + space + '(',
                        that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                        ')'
                    ];
    
                    if (stmt.guard) {
                        guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                        result.splice(2, 0, ' if ', guard);
                    }
                });
                result.push(this.maybeBlock(stmt.body, S_TFFF));
                return result;
            },
    
            DebuggerStatement: function (stmt, flags) {
                return 'debugger' + this.semicolon(flags);
            },
    
            EmptyStatement: function (stmt, flags) {
                return ';';
            },
    
            ExportDeclaration: function (stmt, flags) {
                var result = [ 'export' ], bodyFlags, that = this;
    
                bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;
    
                // export default HoistableDeclaration[Default]
                // export default AssignmentExpression[In] ;
                if (stmt['default']) {
                    result = join(result, 'default');
                    if (isStatement(stmt.declaration)) {
                        result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
                    } else {
                        result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
                    }
                    return result;
                }
    
                // export VariableStatement
                // export Declaration[Default]
                if (stmt.declaration) {
                    return join(result, this.generateStatement(stmt.declaration, bodyFlags));
                }
    
                // export * FromClause ;
                // export ExportClause[NoReference] FromClause ;
                // export ExportClause ;
                if (stmt.specifiers) {
                    if (stmt.specifiers.length === 0) {
                        result = join(result, '{' + space + '}');
                    } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                        result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
                    } else {
                        result = join(result, '{');
                        withIndent(function (indent) {
                            var i, iz;
                            result.push(newline);
                            for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                                result.push(indent);
                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                if (i + 1 < iz) {
                                    result.push(',' + newline);
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base + '}');
                    }
    
                    if (stmt.source) {
                        result = join(result, [
                            'from' + space,
                            // ModuleSpecifier
                            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                            this.semicolon(flags)
                        ]);
                    } else {
                        result.push(this.semicolon(flags));
                    }
                }
                return result;
            },
    
            ExportDefaultDeclaration: function (stmt, flags) {
                 stmt.default = true;
                 return this.ExportDeclaration(stmt, flags);
            },
    
            ExportNamedDeclaration: function (stmt, flags) {
                return this.ExportDeclaration(stmt, flags);
            },
    
            ExpressionStatement: function (stmt, flags) {
                var result, fragment;
    
                function isClassPrefixed(fragment) {
                    var code;
                    if (fragment.slice(0, 5) !== 'class') {
                        return false;
                    }
                    code = fragment.charCodeAt(5);
                    return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
                }
    
                function isFunctionPrefixed(fragment) {
                    var code;
                    if (fragment.slice(0, 8) !== 'function') {
                        return false;
                    }
                    code = fragment.charCodeAt(8);
                    return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
                }
    
                function isAsyncPrefixed(fragment) {
                    var code, i, iz;
                    if (fragment.slice(0, 5) !== 'async') {
                        return false;
                    }
                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
                        return false;
                    }
                    for (i = 6, iz = fragment.length; i < iz; ++i) {
                        if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
                            break;
                        }
                    }
                    if (i === iz) {
                        return false;
                    }
                    if (fragment.slice(i, i + 8) !== 'function') {
                        return false;
                    }
                    code = fragment.charCodeAt(i + 8);
                    return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
                }
    
                result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
                // 12.4 '{', 'function', 'class' is not allowed in this position.
                // wrap expression with parentheses
                fragment = toSourceNodeWhenNeeded(result).toString();
                if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression
                        isClassPrefixed(fragment) ||
                        isFunctionPrefixed(fragment) ||
                        isAsyncPrefixed(fragment) ||
                        (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                    result = ['(', result, ')' + this.semicolon(flags)];
                } else {
                    result.push(this.semicolon(flags));
                }
                return result;
            },
    
            ImportDeclaration: function (stmt, flags) {
                // ES6: 15.2.1 valid import declarations:
                //     - import ImportClause FromClause ;
                //     - import ModuleSpecifier ;
                var result, cursor, that = this;
    
                // If no ImportClause is present,
                // this should be `import ModuleSpecifier` so skip `from`
                // ModuleSpecifier is StringLiteral.
                if (stmt.specifiers.length === 0) {
                    // import ModuleSpecifier ;
                    return [
                        'import',
                        space,
                        // ModuleSpecifier
                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                        this.semicolon(flags)
                    ];
                }
    
                // import ImportClause FromClause ;
                result = [
                    'import'
                ];
                cursor = 0;
    
                // ImportedBinding
                if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
                    result = join(result, [
                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                    ]);
                    ++cursor;
                }
    
                if (stmt.specifiers[cursor]) {
                    if (cursor !== 0) {
                        result.push(',');
                    }
    
                    if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                        // NameSpaceImport
                        result = join(result, [
                                space,
                                this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                        ]);
                    } else {
                        // NamedImports
                        result.push(space + '{');
    
                        if ((stmt.specifiers.length - cursor) === 1) {
                            // import { ... } from "...";
                            result.push(space);
                            result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                            result.push(space + '}' + space);
                        } else {
                            // import {
                            //    ...,
                            //    ...,
                            // } from "...";
                            withIndent(function (indent) {
                                var i, iz;
                                result.push(newline);
                                for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                                    result.push(indent);
                                    result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                    if (i + 1 < iz) {
                                        result.push(',' + newline);
                                    }
                                }
                            });
                            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                                result.push(newline);
                            }
                            result.push(base + '}' + space);
                        }
                    }
                }
    
                result = join(result, [
                    'from' + space,
                    // ModuleSpecifier
                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                    this.semicolon(flags)
                ]);
                return result;
            },
    
            VariableDeclarator: function (stmt, flags) {
                var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;
                if (stmt.init) {
                    return [
                        this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
                        space,
                        '=',
                        space,
                        this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
                    ];
                }
                return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
            },
    
            VariableDeclaration: function (stmt, flags) {
                // VariableDeclarator is typed as Statement,
                // but joined with comma (not LineTerminator).
                // So if comment is attached to target node, we should specialize.
                var result, i, iz, node, bodyFlags, that = this;
    
                result = [ stmt.kind ];
    
                bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;
    
                function block() {
                    node = stmt.declarations[0];
                    if (extra.comment && node.leadingComments) {
                        result.push('\n');
                        result.push(addIndent(that.generateStatement(node, bodyFlags)));
                    } else {
                        result.push(noEmptySpace());
                        result.push(that.generateStatement(node, bodyFlags));
                    }
    
                    for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                        node = stmt.declarations[i];
                        if (extra.comment && node.leadingComments) {
                            result.push(',' + newline);
                            result.push(addIndent(that.generateStatement(node, bodyFlags)));
                        } else {
                            result.push(',' + space);
                            result.push(that.generateStatement(node, bodyFlags));
                        }
                    }
                }
    
                if (stmt.declarations.length > 1) {
                    withIndent(block);
                } else {
                    block();
                }
    
                result.push(this.semicolon(flags));
    
                return result;
            },
    
            ThrowStatement: function (stmt, flags) {
                return [join(
                    'throw',
                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
                ), this.semicolon(flags)];
            },
    
            TryStatement: function (stmt, flags) {
                var result, i, iz, guardedHandlers;
    
                result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
                result = this.maybeBlockSuffix(stmt.block, result);
    
                if (stmt.handlers) {
                    // old interface
                    for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
                        result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
                        if (stmt.finalizer || i + 1 !== iz) {
                            result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                        }
                    }
                } else {
                    guardedHandlers = stmt.guardedHandlers || [];
    
                    for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
                        result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
                        if (stmt.finalizer || i + 1 !== iz) {
                            result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                        }
                    }
    
                    // new interface
                    if (stmt.handler) {
                        if (isArray(stmt.handler)) {
                            for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                                result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                                if (stmt.finalizer || i + 1 !== iz) {
                                    result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                                }
                            }
                        } else {
                            result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                            if (stmt.finalizer) {
                                result = this.maybeBlockSuffix(stmt.handler.body, result);
                            }
                        }
                    }
                }
                if (stmt.finalizer) {
                    result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
                }
                return result;
            },
    
            SwitchStatement: function (stmt, flags) {
                var result, fragment, i, iz, bodyFlags, that = this;
                withIndent(function () {
                    result = [
                        'switch' + space + '(',
                        that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
                        ')' + space + '{' + newline
                    ];
                });
                if (stmt.cases) {
                    bodyFlags = S_TFFF;
                    for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
                        if (i === iz - 1) {
                            bodyFlags |= F_SEMICOLON_OPT;
                        }
                        fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                        result.push(fragment);
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                            result.push(newline);
                        }
                    }
                }
                result.push(addIndent('}'));
                return result;
            },
    
            SwitchCase: function (stmt, flags) {
                var result, fragment, i, iz, bodyFlags, that = this;
                withIndent(function () {
                    if (stmt.test) {
                        result = [
                            join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                            ':'
                        ];
                    } else {
                        result = ['default:'];
                    }
    
                    i = 0;
                    iz = stmt.consequent.length;
                    if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
                        fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                        result.push(fragment);
                        i = 1;
                    }
    
                    if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push(newline);
                    }
    
                    bodyFlags = S_TFFF;
                    for (; i < iz; ++i) {
                        if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                            bodyFlags |= F_SEMICOLON_OPT;
                        }
                        fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                        result.push(fragment);
                        if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                            result.push(newline);
                        }
                    }
                });
                return result;
            },
    
            IfStatement: function (stmt, flags) {
                var result, bodyFlags, semicolonOptional, that = this;
                withIndent(function () {
                    result = [
                        'if' + space + '(',
                        that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                        ')'
                    ];
                });
                semicolonOptional = flags & F_SEMICOLON_OPT;
                bodyFlags = S_TFFF;
                if (semicolonOptional) {
                    bodyFlags |= F_SEMICOLON_OPT;
                }
                if (stmt.alternate) {
                    result.push(this.maybeBlock(stmt.consequent, S_TFFF));
                    result = this.maybeBlockSuffix(stmt.consequent, result);
                    if (stmt.alternate.type === Syntax.IfStatement) {
                        result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
                    } else {
                        result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
                    }
                } else {
                    result.push(this.maybeBlock(stmt.consequent, bodyFlags));
                }
                return result;
            },
    
            ForStatement: function (stmt, flags) {
                var result, that = this;
                withIndent(function () {
                    result = ['for' + space + '('];
                    if (stmt.init) {
                        if (stmt.init.type === Syntax.VariableDeclaration) {
                            result.push(that.generateStatement(stmt.init, S_FFFF));
                        } else {
                            // F_ALLOW_IN becomes false.
                            result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                            result.push(';');
                        }
                    } else {
                        result.push(';');
                    }
    
                    if (stmt.test) {
                        result.push(space);
                        result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                        result.push(';');
                    } else {
                        result.push(';');
                    }
    
                    if (stmt.update) {
                        result.push(space);
                        result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                        result.push(')');
                    } else {
                        result.push(')');
                    }
                });
    
                result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
                return result;
            },
    
            ForInStatement: function (stmt, flags) {
                return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
            },
    
            ForOfStatement: function (stmt, flags) {
                return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
            },
    
            LabeledStatement: function (stmt, flags) {
                return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
            },
    
            Program: function (stmt, flags) {
                var result, fragment, i, iz, bodyFlags;
                iz = stmt.body.length;
                result = [safeConcatenation && iz > 0 ? '\n' : ''];
                bodyFlags = S_TFTF;
                for (i = 0; i < iz; ++i) {
                    if (!safeConcatenation && i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
    
                    if (preserveBlankLines) {
                        // handle spaces before the first line
                        if (i === 0) {
                            if (!stmt.body[0].leadingComments) {
                                generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                            }
                        }
    
                        // handle spaces between lines
                        if (i > 0) {
                            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                            }
                        }
                    }
    
                    fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
                    result.push(fragment);
                    if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        if (preserveBlankLines) {
                            if (!stmt.body[i + 1].leadingComments) {
                                result.push(newline);
                            }
                        } else {
                            result.push(newline);
                        }
                    }
    
                    if (preserveBlankLines) {
                        // handle spaces after the last line
                        if (i === iz - 1) {
                            if (!stmt.body[i].trailingComments) {
                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                            }
                        }
                    }
                }
                return result;
            },
    
            FunctionDeclaration: function (stmt, flags) {
                return [
                    generateAsyncPrefix(stmt, true),
                    'function',
                    generateStarSuffix(stmt) || noEmptySpace(),
                    generateIdentifier(stmt.id),
                    this.generateFunctionBody(stmt)
                ];
            },
    
            ReturnStatement: function (stmt, flags) {
                if (stmt.argument) {
                    return [join(
                        'return',
                        this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
                    ), this.semicolon(flags)];
                }
                return ['return' + this.semicolon(flags)];
            },
    
            WhileStatement: function (stmt, flags) {
                var result, that = this;
                withIndent(function () {
                    result = [
                        'while' + space + '(',
                        that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                        ')'
                    ];
                });
                result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
                return result;
            },
    
            WithStatement: function (stmt, flags) {
                var result, that = this;
                withIndent(function () {
                    result = [
                        'with' + space + '(',
                        that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
                        ')'
                    ];
                });
                result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
                return result;
            }
    
        };
    
        merge(CodeGenerator.prototype, CodeGenerator.Statement);
    
        // Expressions.
    
        CodeGenerator.Expression = {
    
            SequenceExpression: function (expr, precedence, flags) {
                var result, i, iz;
                if (Precedence.Sequence < precedence) {
                    flags |= F_ALLOW_IN;
                }
                result = [];
                for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
                    result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
                    if (i + 1 < iz) {
                        result.push(',' + space);
                    }
                }
                return parenthesize(result, Precedence.Sequence, precedence);
            },
    
            AssignmentExpression: function (expr, precedence, flags) {
                return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
            },
    
            ArrowFunctionExpression: function (expr, precedence, flags) {
                return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
            },
    
            ConditionalExpression: function (expr, precedence, flags) {
                if (Precedence.Conditional < precedence) {
                    flags |= F_ALLOW_IN;
                }
                return parenthesize(
                    [
                        this.generateExpression(expr.test, Precedence.LogicalOR, flags),
                        space + '?' + space,
                        this.generateExpression(expr.consequent, Precedence.Assignment, flags),
                        space + ':' + space,
                        this.generateExpression(expr.alternate, Precedence.Assignment, flags)
                    ],
                    Precedence.Conditional,
                    precedence
                );
            },
    
            LogicalExpression: function (expr, precedence, flags) {
                return this.BinaryExpression(expr, precedence, flags);
            },
    
            BinaryExpression: function (expr, precedence, flags) {
                var result, currentPrecedence, fragment, leftSource;
                currentPrecedence = BinaryPrecedence[expr.operator];
    
                if (currentPrecedence < precedence) {
                    flags |= F_ALLOW_IN;
                }
    
                fragment = this.generateExpression(expr.left, currentPrecedence, flags);
    
                leftSource = fragment.toString();
    
                if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
                    result = [fragment, noEmptySpace(), expr.operator];
                } else {
                    result = join(fragment, expr.operator);
                }
    
                fragment = this.generateExpression(expr.right, currentPrecedence + 1, flags);
    
                if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
                expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                    // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                    result.push(noEmptySpace());
                    result.push(fragment);
                } else {
                    result = join(result, fragment);
                }
    
                if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
                    return ['(', result, ')'];
                }
                return parenthesize(result, currentPrecedence, precedence);
            },
    
            CallExpression: function (expr, precedence, flags) {
                var result, i, iz;
                // F_ALLOW_UNPARATH_NEW becomes false.
                result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
                result.push('(');
                for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
    
                if (!(flags & F_ALLOW_CALL)) {
                    return ['(', result, ')'];
                }
                return parenthesize(result, Precedence.Call, precedence);
            },
    
            NewExpression: function (expr, precedence, flags) {
                var result, length, i, iz, itemFlags;
                length = expr['arguments'].length;
    
                // F_ALLOW_CALL becomes false.
                // F_ALLOW_UNPARATH_NEW may become false.
                itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;
    
                result = join(
                    'new',
                    this.generateExpression(expr.callee, Precedence.New, itemFlags)
                );
    
                if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
                    result.push('(');
                    for (i = 0, iz = length; i < iz; ++i) {
                        result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                        if (i + 1 < iz) {
                            result.push(',' + space);
                        }
                    }
                    result.push(')');
                }
    
                return parenthesize(result, Precedence.New, precedence);
            },
    
            MemberExpression: function (expr, precedence, flags) {
                var result, fragment;
    
                // F_ALLOW_UNPARATH_NEW becomes false.
                result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];
    
                if (expr.computed) {
                    result.push('[');
                    result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
                    result.push(']');
                } else {
                    if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                        fragment = toSourceNodeWhenNeeded(result).toString();
                        // When the following conditions are all true,
                        //   1. No floating point
                        //   2. Don't have exponents
                        //   3. The last character is a decimal digit
                        //   4. Not hexadecimal OR octal number literal
                        // we should add a floating point.
                        if (
                                fragment.indexOf('.') < 0 &&
                                !/[eExX]/.test(fragment) &&
                                esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                                !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                                ) {
                            result.push('.');
                        }
                    }
                    result.push('.');
                    result.push(generateIdentifier(expr.property));
                }
    
                return parenthesize(result, Precedence.Member, precedence);
            },
    
            UnaryExpression: function (expr, precedence, flags) {
                var result, fragment, rightCharCode, leftSource, leftCharCode;
                fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
    
                if (space === '') {
                    result = join(expr.operator, fragment);
                } else {
                    result = [expr.operator];
                    if (expr.operator.length > 2) {
                        // delete, void, typeof
                        // get `typeof []`, not `typeof[]`
                        result = join(result, fragment);
                    } else {
                        // Prevent inserting spaces between operator and argument if it is unnecessary
                        // like, `!cond`
                        leftSource = toSourceNodeWhenNeeded(result).toString();
                        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                        rightCharCode = fragment.toString().charCodeAt(0);
    
                        if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                                (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {
                            result.push(noEmptySpace());
                            result.push(fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                }
                return parenthesize(result, Precedence.Unary, precedence);
            },
    
            YieldExpression: function (expr, precedence, flags) {
                var result;
                if (expr.delegate) {
                    result = 'yield*';
                } else {
                    result = 'yield';
                }
                if (expr.argument) {
                    result = join(
                        result,
                        this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
                    );
                }
                return parenthesize(result, Precedence.Yield, precedence);
            },
    
            AwaitExpression: function (expr, precedence, flags) {
                var result = join(
                    expr.all ? 'await*' : 'await',
                    this.generateExpression(expr.argument, Precedence.Await, E_TTT)
                );
                return parenthesize(result, Precedence.Await, precedence);
            },
    
            UpdateExpression: function (expr, precedence, flags) {
                if (expr.prefix) {
                    return parenthesize(
                        [
                            expr.operator,
                            this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
                        ],
                        Precedence.Unary,
                        precedence
                    );
                }
                return parenthesize(
                    [
                        this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
                        expr.operator
                    ],
                    Precedence.Postfix,
                    precedence
                );
            },
    
            FunctionExpression: function (expr, precedence, flags) {
                var result = [
                    generateAsyncPrefix(expr, true),
                    'function'
                ];
                if (expr.id) {
                    result.push(generateStarSuffix(expr) || noEmptySpace());
                    result.push(generateIdentifier(expr.id));
                } else {
                    result.push(generateStarSuffix(expr) || space);
                }
                result.push(this.generateFunctionBody(expr));
                return result;
            },
    
            ExportBatchSpecifier: function (expr, precedence, flags) {
                return '*';
            },
    
            ArrayPattern: function (expr, precedence, flags) {
                return this.ArrayExpression(expr, precedence, flags, true);
            },
    
            ArrayExpression: function (expr, precedence, flags, isPattern) {
                var result, multiline, that = this;
                if (!expr.elements.length) {
                    return '[]';
                }
                multiline = isPattern ? false : expr.elements.length > 1;
                result = ['[', multiline ? newline : ''];
                withIndent(function (indent) {
                    var i, iz;
                    for (i = 0, iz = expr.elements.length; i < iz; ++i) {
                        if (!expr.elements[i]) {
                            if (multiline) {
                                result.push(indent);
                            }
                            if (i + 1 === iz) {
                                result.push(',');
                            }
                        } else {
                            result.push(multiline ? indent : '');
                            result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                        }
                        if (i + 1 < iz) {
                            result.push(',' + (multiline ? newline : space));
                        }
                    }
                });
                if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }
                result.push(multiline ? base : '');
                result.push(']');
                return result;
            },
    
            RestElement: function(expr, precedence, flags) {
                return '...' + this.generatePattern(expr.argument);
            },
    
            ClassExpression: function (expr, precedence, flags) {
                var result, fragment;
                result = ['class'];
                if (expr.id) {
                    result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
                }
                if (expr.superClass) {
                    fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Assignment, E_TTT));
                    result = join(result, fragment);
                }
                result.push(space);
                result.push(this.generateStatement(expr.body, S_TFFT));
                return result;
            },
    
            MethodDefinition: function (expr, precedence, flags) {
                var result, fragment;
                if (expr['static']) {
                    result = ['static' + space];
                } else {
                    result = [];
                }
                if (expr.kind === 'get' || expr.kind === 'set') {
                    fragment = [
                        join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
                        this.generateFunctionBody(expr.value)
                    ];
                } else {
                    fragment = [
                        generateMethodPrefix(expr),
                        this.generatePropertyKey(expr.key, expr.computed),
                        this.generateFunctionBody(expr.value)
                    ];
                }
                return join(result, fragment);
            },
    
            Property: function (expr, precedence, flags) {
                if (expr.kind === 'get' || expr.kind === 'set') {
                    return [
                        expr.kind, noEmptySpace(),
                        this.generatePropertyKey(expr.key, expr.computed),
                        this.generateFunctionBody(expr.value)
                    ];
                }
    
                if (expr.shorthand) {
                    return this.generatePropertyKey(expr.key, expr.computed);
                }
    
                if (expr.method) {
                    return [
                        generateMethodPrefix(expr),
                        this.generatePropertyKey(expr.key, expr.computed),
                        this.generateFunctionBody(expr.value)
                    ];
                }
    
                return [
                    this.generatePropertyKey(expr.key, expr.computed),
                    ':' + space,
                    this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
                ];
            },
    
            ObjectExpression: function (expr, precedence, flags) {
                var multiline, result, fragment, that = this;
    
                if (!expr.properties.length) {
                    return '{}';
                }
                multiline = expr.properties.length > 1;
    
                withIndent(function () {
                    fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
                });
    
                if (!multiline) {
                    // issues 4
                    // Do not transform from
                    //   dejavu.Class.declare({
                    //       method2: function () {}
                    //   });
                    // to
                    //   dejavu.Class.declare({method2: function () {
                    //       }});
                    if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        return [ '{', space, fragment, space, '}' ];
                    }
                }
    
                withIndent(function (indent) {
                    var i, iz;
                    result = [ '{', newline, indent, fragment ];
    
                    if (multiline) {
                        result.push(',' + newline);
                        for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                            result.push(indent);
                            result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                            if (i + 1 < iz) {
                                result.push(',' + newline);
                            }
                        }
                    }
                });
    
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }
                result.push(base);
                result.push('}');
                return result;
            },
    
            ObjectPattern: function (expr, precedence, flags) {
                var result, i, iz, multiline, property, that = this;
                if (!expr.properties.length) {
                    return '{}';
                }
    
                multiline = false;
                if (expr.properties.length === 1) {
                    property = expr.properties[0];
                    if (property.value.type !== Syntax.Identifier) {
                        multiline = true;
                    }
                } else {
                    for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                        property = expr.properties[i];
                        if (!property.shorthand) {
                            multiline = true;
                            break;
                        }
                    }
                }
                result = ['{', multiline ? newline : '' ];
    
                withIndent(function (indent) {
                    var i, iz;
                    for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                        result.push(multiline ? indent : '');
                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                        if (i + 1 < iz) {
                            result.push(',' + (multiline ? newline : space));
                        }
                    }
                });
    
                if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }
                result.push(multiline ? base : '');
                result.push('}');
                return result;
            },
    
            ThisExpression: function (expr, precedence, flags) {
                return 'this';
            },
    
            Super: function (expr, precedence, flags) {
                return 'super';
            },
    
            Identifier: function (expr, precedence, flags) {
                return generateIdentifier(expr);
            },
    
            ImportDefaultSpecifier: function (expr, precedence, flags) {
                return generateIdentifier(expr.id || expr.local);
            },
    
            ImportNamespaceSpecifier: function (expr, precedence, flags) {
                var result = ['*'];
                var id = expr.id || expr.local;
                if (id) {
                    result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));
                }
                return result;
            },
    
            ImportSpecifier: function (expr, precedence, flags) {
                return this.ExportSpecifier(expr, precedence, flags);
            },
    
            ExportSpecifier: function (expr, precedence, flags) {
                var result = [ (expr.id || expr.local).name ];
                if (expr.name) {
                    result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(expr.name));
                }
                return result;
            },
    
            Literal: function (expr, precedence, flags) {
                var raw;
                if (expr.hasOwnProperty('raw') && parse && extra.raw) {
                    try {
                        raw = parse(expr.raw).body[0].expression;
                        if (raw.type === Syntax.Literal) {
                            if (raw.value === expr.value) {
                                return expr.raw;
                            }
                        }
                    } catch (e) {
                        // not use raw property
                    }
                }
    
                if (expr.value === null) {
                    return 'null';
                }
    
                if (typeof expr.value === 'string') {
                    return escapeString(expr.value);
                }
    
                if (typeof expr.value === 'number') {
                    return generateNumber(expr.value);
                }
    
                if (typeof expr.value === 'boolean') {
                    return expr.value ? 'true' : 'false';
                }
    
                return generateRegExp(expr.value);
            },
    
            GeneratorExpression: function (expr, precedence, flags) {
                return this.ComprehensionExpression(expr, precedence, flags);
            },
    
            ComprehensionExpression: function (expr, precedence, flags) {
                // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
                // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6
    
                var result, i, iz, fragment, that = this;
                result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];
    
                if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                    fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                    result.push(fragment);
                }
    
                if (expr.blocks) {
                    withIndent(function () {
                        for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                            fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                            if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                                result = join(result, fragment);
                            } else {
                                result.push(fragment);
                            }
                        }
                    });
                }
    
                if (expr.filter) {
                    result = join(result, 'if' + space);
                    fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
                    result = join(result, [ '(', fragment, ')' ]);
                }
    
                if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                    fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
    
                    result = join(result, fragment);
                }
    
                result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');
                return result;
            },
    
            ComprehensionBlock: function (expr, precedence, flags) {
                var fragment;
                if (expr.left.type === Syntax.VariableDeclaration) {
                    fragment = [
                        expr.left.kind, noEmptySpace(),
                        this.generateStatement(expr.left.declarations[0], S_FFFF)
                    ];
                } else {
                    fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
                }
    
                fragment = join(fragment, expr.of ? 'of' : 'in');
                fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
    
                return [ 'for' + space + '(', fragment, ')' ];
            },
    
            SpreadElement: function (expr, precedence, flags) {
                return [
                    '...',
                    this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
                ];
            },
    
            TaggedTemplateExpression: function (expr, precedence, flags) {
                var itemFlags = E_TTF;
                if (!(flags & F_ALLOW_CALL)) {
                    itemFlags = E_TFF;
                }
                var result = [
                    this.generateExpression(expr.tag, Precedence.Call, itemFlags),
                    this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
                ];
                return parenthesize(result, Precedence.TaggedTemplate, precedence);
            },
    
            TemplateElement: function (expr, precedence, flags) {
                // Don't use "cooked". Since tagged template can use raw template
                // representation. So if we do so, it breaks the script semantics.
                return expr.value.raw;
            },
    
            TemplateLiteral: function (expr, precedence, flags) {
                var result, i, iz;
                result = [ '`' ];
                for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
                    result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
                    if (i + 1 < iz) {
                        result.push('${' + space);
                        result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                        result.push(space + '}');
                    }
                }
                result.push('`');
                return result;
            },
    
            ModuleSpecifier: function (expr, precedence, flags) {
                return this.Literal(expr, precedence, flags);
            }
    
        };
    
        merge(CodeGenerator.prototype, CodeGenerator.Expression);
    
        CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
            var result, type;
    
            type = expr.type || Syntax.Property;
    
            if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
                return generateVerbatim(expr, precedence);
            }
    
            result = this[type](expr, precedence, flags);
    
    
            if (extra.comment) {
                result = addComments(expr, result);
            }
            return toSourceNodeWhenNeeded(result, expr);
        };
    
        CodeGenerator.prototype.generateStatement = function (stmt, flags) {
            var result,
                fragment;
    
            result = this[stmt.type](stmt, flags);
    
            // Attach comments
    
            if (extra.comment) {
                result = addComments(stmt, result);
            }
    
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
                result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
            }
    
            return toSourceNodeWhenNeeded(result, stmt);
        };
    
        function generateInternal(node) {
            var codegen;
    
            codegen = new CodeGenerator();
            if (isStatement(node)) {
                return codegen.generateStatement(node, S_TFFF);
            }
    
            if (isExpression(node)) {
                return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
            }
    
            throw new Error('Unknown node type: ' + node.type);
        }
    
        function generate(node, options) {
            var defaultOptions = getDefaultOptions(), result, pair;
    
            if (options != null) {
                // Obsolete options
                //
                //   `options.indent`
                //   `options.base`
                //
                // Instead of them, we can use `option.format.indent`.
                if (typeof options.indent === 'string') {
                    defaultOptions.format.indent.style = options.indent;
                }
                if (typeof options.base === 'number') {
                    defaultOptions.format.indent.base = options.base;
                }
                options = updateDeeply(defaultOptions, options);
                indent = options.format.indent.style;
                if (typeof options.base === 'string') {
                    base = options.base;
                } else {
                    base = stringRepeat(indent, options.format.indent.base);
                }
            } else {
                options = defaultOptions;
                indent = options.format.indent.style;
                base = stringRepeat(indent, options.format.indent.base);
            }
            json = options.format.json;
            renumber = options.format.renumber;
            hexadecimal = json ? false : options.format.hexadecimal;
            quotes = json ? 'double' : options.format.quotes;
            escapeless = options.format.escapeless;
            newline = options.format.newline;
            space = options.format.space;
            if (options.format.compact) {
                newline = space = indent = base = '';
            }
            parentheses = options.format.parentheses;
            semicolons = options.format.semicolons;
            safeConcatenation = options.format.safeConcatenation;
            directive = options.directive;
            parse = json ? null : options.parse;
            sourceMap = options.sourceMap;
            sourceCode = options.sourceCode;
            preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
            extra = options;
    
            if (sourceMap) {
                if (!exports.browser) {
                    // We assume environment is node.js
                    // And prevent from including source-map by browserify
                    SourceNode = require('source-map').SourceNode;
                } else {
                    SourceNode = global.sourceMap.SourceNode;
                }
            }
    
            result = generateInternal(node);
    
            if (!sourceMap) {
                pair = {code: result.toString(), map: null};
                return options.sourceMapWithCode ? pair : pair.code;
            }
    
    
            pair = result.toStringWithSourceMap({
                file: options.file,
                sourceRoot: options.sourceMapRoot
            });
    
            if (options.sourceContent) {
                pair.map.setSourceContent(options.sourceMap,
                                          options.sourceContent);
            }
    
            if (options.sourceMapWithCode) {
                return pair;
            }
    
            return pair.map.toString();
        }
    
        FORMAT_MINIFY = {
            indent: {
                style: '',
                base: 0
            },
            renumber: true,
            hexadecimal: true,
            quotes: 'auto',
            escapeless: true,
            compact: true,
            parentheses: false,
            semicolons: false
        };
    
        FORMAT_DEFAULTS = getDefaultOptions().format;
    
        exports.version = require('./package.json').version;
        exports.generate = generate;
        exports.attachComments = estraverse.attachComments;
        exports.Precedence = updateDeeply({}, Precedence);
        exports.browser = false;
        exports.FORMAT_MINIFY = FORMAT_MINIFY;
        exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
    }());
    /* vim: set sw=4 ts=4 et tw=80 : */
    
  provide("escodegen", module.exports);
}(global));

// pakmanager:camelcase
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function () {
    	var str = [].map.call(arguments, function (str) {
    		return str.trim();
    	}).filter(function (str) {
    		return str.length;
    	}).join('-');
    
    	if (!str.length) {
    		return '';
    	}
    
    	if (str.length === 1 || !(/[_.\- ]+/).test(str) ) {
    		if (str[0] === str[0].toLowerCase() && str.slice(1) !== str.slice(1).toLowerCase()) {
    			return str;
    		}
    
    		return str.toLowerCase();
    	}
    
    	return str
    	.replace(/^[_.\- ]+/, '')
    	.toLowerCase()
    	.replace(/[_.\- ]+(\w|$)/g, function (m, p1) {
    		return p1.toUpperCase();
    	});
    };
    
  provide("camelcase", module.exports);
}(global));

// pakmanager:cliui
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrap = require('wordwrap'),
      align = {
        right: require('right-align'),
        center: require('center-align')
      },
      top = 0,
      right = 1,
      bottom = 2,
      left = 3
    
    function UI (opts) {
      this.width = opts.width
      this.wrap = opts.wrap
      this.rows = []
    }
    
    UI.prototype.span = function () {
      var cols = this.div.apply(this, arguments)
      cols.span = true
    }
    
    UI.prototype.div = function () {
      if (arguments.length === 0) this.div('')
      if (this.wrap && this._shouldApplyLayoutDSL.apply(this, arguments)) {
        return this._applyLayoutDSL(arguments[0])
      }
    
      var cols = []
    
      for (var i = 0, arg; (arg = arguments[i]) !== undefined; i++) {
        if (typeof arg === 'string') cols.push(this._colFromString(arg))
        else cols.push(arg)
      }
    
      this.rows.push(cols)
      return cols
    }
    
    UI.prototype._shouldApplyLayoutDSL = function () {
      return arguments.length === 1 && typeof arguments[0] === 'string' &&
        /[\t\n]/.test(arguments[0])
    }
    
    UI.prototype._applyLayoutDSL = function (str) {
      var _this = this,
        rows = str.split('\n'),
        leftColumnWidth = 0
    
      // simple heuristic for layout, make sure the
      // second column lines up along the left-hand.
      // don't allow the first column to take up more
      // than 50% of the screen.
      rows.forEach(function (row) {
        var columns = row.split('\t')
        if (columns.length > 1 && columns[0].length > leftColumnWidth) {
          leftColumnWidth = Math.min(
            Math.floor(_this.width * 0.5),
            columns[0].length
          )
        }
      })
    
      // generate a table:
      //  replacing ' ' with padding calculations.
      //  using the algorithmically generated width.
      rows.forEach(function (row) {
        var columns = row.split('\t')
        _this.div.apply(_this, columns.map(function (r, i) {
          return {
            text: r.trim(),
            padding: [0, r.match(/\s*$/)[0].length, 0, r.match(/^\s*/)[0].length],
            width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
          }
        }))
      })
    
      return this.rows[this.rows.length - 1]
    }
    
    UI.prototype._colFromString = function (str) {
      return {
        text: str
      }
    }
    
    UI.prototype.toString = function () {
      var _this = this,
        lines = []
    
      _this.rows.forEach(function (row, i) {
        _this.rowToString(row, lines)
      })
    
      // don't display any lines with the
      // hidden flag set.
      lines = lines.filter(function (line) {
        return !line.hidden
      })
    
      return lines.map(function (line) {
        return line.text
      }).join('\n')
    }
    
    UI.prototype.rowToString = function (row, lines) {
      var _this = this,
        paddingLeft,
        rrows = this._rasterize(row),
        str = '',
        ts,
        width,
        wrapWidth
    
      rrows.forEach(function (rrow, r) {
        str = ''
        rrow.forEach(function (col, c) {
          ts = '' // temporary string used during alignment/padding.
          width = row[c].width // the width with padding.
          wrapWidth = _this._negatePadding(row[c]) // the width without padding.
    
          for (var i = 0; i < Math.max(wrapWidth, col.length); i++) {
            ts += col.charAt(i) || ' '
          }
    
          // align the string within its column.
          if (row[c].align && row[c].align !== 'left' && _this.wrap) {
            ts = align[row[c].align](ts.trim() + '\n' + new Array(wrapWidth + 1).join(' '))
              .split('\n')[0]
            if (ts.length < wrapWidth) ts += new Array(width - ts.length).join(' ')
          }
    
          // add left/right padding and print string.
          paddingLeft = (row[c].padding || [0, 0, 0, 0])[left]
          if (paddingLeft) str += new Array(row[c].padding[left] + 1).join(' ')
          str += ts
          if (row[c].padding && row[c].padding[right]) str += new Array(row[c].padding[right] + 1).join(' ')
    
          // if prior row is span, try to render the
          // current row on the prior line.
          if (r === 0 && lines.length > 0) {
            str = _this._renderInline(str, lines[lines.length - 1], paddingLeft)
          }
        })
    
        // remove trailing whitespace.
        lines.push({
          text: str.replace(/ +$/, ''),
          span: row.span
        })
      })
    
      return lines
    }
    
    // if the full 'source' can render in
    // the target line, do so.
    UI.prototype._renderInline = function (source, previousLine, paddingLeft) {
      var target = previousLine.text,
        str = ''
    
      if (!previousLine.span) return source
    
      // if we're not applying wrapping logic,
      // just always append to the span.
      if (!this.wrap) {
        previousLine.hidden = true
        return target + source
      }
    
      for (var i = 0, tc, sc; i < Math.max(source.length, target.length); i++) {
        tc = target.charAt(i) || ' '
        sc = source.charAt(i) || ' '
        // we tried to overwrite a character in the other string.
        if (tc !== ' ' && sc !== ' ') return source
        // there is not enough whitespace to maintain padding.
        if (sc !== ' ' && i < paddingLeft + target.length) return source
        // :thumbsup:
        if (tc === ' ') str += sc
        else str += tc
      }
    
      previousLine.hidden = true
    
      return str
    }
    
    UI.prototype._rasterize = function (row) {
      var _this = this,
        i,
        rrow,
        rrows = [],
        widths = this._columnWidths(row),
        wrapped
    
      // word wrap all columns, and create
      // a data-structure that is easy to rasterize.
      row.forEach(function (col, c) {
        // leave room for left and right padding.
        col.width = widths[c]
        if (_this.wrap) wrapped = wrap.hard(_this._negatePadding(col))(col.text).split('\n')
        else wrapped = col.text.split('\n')
    
        // add top and bottom padding.
        if (col.padding) {
          for (i = 0; i < (col.padding[top] || 0); i++) wrapped.unshift('')
          for (i = 0; i < (col.padding[bottom] || 0); i++) wrapped.push('')
        }
    
        wrapped.forEach(function (str, r) {
          if (!rrows[r]) rrows.push([])
    
          rrow = rrows[r]
    
          for (var i = 0; i < c; i++) {
            if (rrow[i] === undefined) rrow.push('')
          }
          rrow.push(str)
        })
      })
    
      return rrows
    }
    
    UI.prototype._negatePadding = function (col) {
      var wrapWidth = col.width
      if (col.padding) wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)
      return wrapWidth
    }
    
    UI.prototype._columnWidths = function (row) {
      var _this = this,
        widths = [],
        unset = row.length,
        unsetWidth,
        remainingWidth = this.width
    
      // column widths can be set in config.
      row.forEach(function (col, i) {
        if (col.width) {
          unset--
          widths[i] = col.width
          remainingWidth -= col.width
        } else {
          widths[i] = undefined
        }
      })
    
      // any unset widths should be calculated.
      if (unset) unsetWidth = Math.floor(remainingWidth / unset)
      widths.forEach(function (w, i) {
        if (!_this.wrap) widths[i] = row[i].width || row[i].text.length
        else if (w === undefined) widths[i] = Math.max(unsetWidth, _minWidth(row[i]))
      })
    
      return widths
    }
    
    // calculates the minimum width of
    // a column, based on padding preferences.
    function _minWidth (col) {
      var padding = col.padding || []
    
      return 1 + (padding[left] || 0) + (padding[right] || 0)
    }
    
    module.exports = function (opts) {
      opts = opts || {}
    
      return new UI({
        width: (opts || {}).width || 80,
        wrap: typeof opts.wrap === 'boolean' ? opts.wrap : true
      })
    }
    
  provide("cliui", module.exports);
}(global));

// pakmanager:decamelize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (str, sep) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(/([a-z\d])([A-Z])/g, '$1' + (sep || '_') + '$2').toLowerCase();
    };
    
  provide("decamelize", module.exports);
}(global));

// pakmanager:os-locale
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var childProcess = require('child_process');
    var execFileSync = childProcess.execFileSync;
    var lcid = require('lcid');
    var defaultOpts = {spawn: true};
    var cache;
    
    function fallback() {
    	cache = 'en_US';
    	return cache;
    }
    
    function getEnvLocale(env) {
    	env = env || process.env;
    	var ret = env.LC_ALL || env.LC_MESSAGES || env.LANG || env.LANGUAGE;
    	cache = getLocale(ret);
    	return ret;
    }
    
    function parseLocale(x) {
    	var env = x.split('\n').reduce(function (env, def) {
    		def = def.split('=');
    		env[def[0]] = def[1];
    		return env;
    	}, {});
    	return getEnvLocale(env);
    }
    
    function getLocale(str) {
    	return (str && str.replace(/[.:].*/, '')) || fallback();
    }
    
    module.exports = function (opts, cb) {
    	if (typeof opts === 'function') {
    		cb = opts;
    		opts = defaultOpts;
    	} else {
    		opts = opts || defaultOpts;
    	}
    
    	if (cache || getEnvLocale() || opts.spawn === false) {
    		setImmediate(cb, null, cache);
    		return;
    	}
    
    	var getAppleLocale = function () {
    		childProcess.execFile('defaults', ['read', '-g', 'AppleLocale'], function (err, stdout) {
    			if (err) {
    				fallback();
    				return;
    			}
    
    			cache = stdout.trim() || fallback();
    			cb(null, cache);
    		});
    	};
    
    	if (process.platform === 'win32') {
    		childProcess.execFile('wmic', ['os', 'get', 'locale'], function (err, stdout) {
    			if (err) {
    				fallback();
    				return;
    			}
    
    			var lcidCode = parseInt(stdout.replace('Locale', ''), 16);
    			cache = lcid.from(lcidCode) || fallback();
    			cb(null, cache);
    		});
    	} else {
    		childProcess.execFile('locale', function (err, stdout) {
    			if (err) {
    				fallback();
    				return;
    			}
    
    			var res = parseLocale(stdout);
    
    			if (!res && process.platform === 'darwin') {
    				getAppleLocale();
    				return;
    			}
    
    			cache = getLocale(res);
    			cb(null, cache);
    		});
    	}
    };
    
    module.exports.sync = function (opts) {
    	opts = opts || defaultOpts;
    
    	if (cache || getEnvLocale() || !execFileSync || opts.spawn === false) {
    		return cache;
    	}
    
    	if (process.platform === 'win32') {
    		var stdout;
    
    		try {
    			stdout = execFileSync('wmic', ['os', 'get', 'locale'], {encoding: 'utf8'});
    		} catch (err) {
    			return fallback();
    		}
    
    		var lcidCode = parseInt(stdout.replace('Locale', ''), 16);
    		cache = lcid.from(lcidCode) || fallback();
    		return cache;
    	}
    
    	var res;
    
    	try {
    		res = parseLocale(execFileSync('locale', {encoding: 'utf8'}));
    	} catch (err) {}
    
    	if (!res && process.platform === 'darwin') {
    		try {
    			cache = execFileSync('defaults', ['read', '-g', 'AppleLocale'], {encoding: 'utf8'}).trim() || fallback();
    			return cache;
    		} catch (err) {
    			return fallback();
    		}
    	}
    
    	cache = getLocale(res);
    	return cache;
    };
    
  provide("os-locale", module.exports);
}(global));

// pakmanager:window-size
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * window-size <https://github.com/jonschlinkert/window-size>
     *
     * Copyright (c) 2014-2015 Jon Schlinkert
     * Licensed under the MIT license.
     */
    
    const tty = require('tty');
    
    module.exports = (function() {
      var width;
      var height;
    
      if(tty.isatty(1) && tty.isatty(2)) {
        if(process.stdout.getWindowSize) {
          width = process.stdout.getWindowSize(1)[0];
          height = process.stdout.getWindowSize(1)[1];
        } else if (tty.getWindowSize) {
          width = tty.getWindowSize()[1];
          height = tty.getWindowSize()[0];
        } else if (process.stdout.columns && process.stdout.rows) {
          height = process.stdout.columns;
          width = process.stdout.rows;
        }
      } else {
        new Error('window-size could not get size with tty or process.stdout.');
      }
    
      return {height: height, width: width};
    })();
  provide("window-size", module.exports);
}(global));

// pakmanager:y18n
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    var path = require('path')
    var util = require('util')
    
    function Y18N (opts) {
      // configurable options.
      opts = opts || {}
      this.directory = opts.directory || './locales'
      this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true
      this.locale = opts.locale || 'en'
      this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true
    
      // internal stuff.
      this.cache = {}
      this.writeQueue = []
    }
    
    Y18N.prototype.__ = function () {
      var args = Array.prototype.slice.call(arguments)
      var str = args.shift()
      var cb = function () {} // start with noop.
    
      if (typeof args[args.length - 1] === 'function') cb = args.pop()
      cb = cb || function () {} // noop.
    
      if (!this.cache[this.locale]) this._readLocaleFile()
    
      // we've observed a new string, update the language file.
      if (!this.cache[this.locale][str] && this.updateFiles) {
        this.cache[this.locale][str] = str
    
        // include the current directory and locale,
        // since these values could change before the
        // write is performed.
        this._enqueueWrite([this.directory, this.locale, cb])
      } else {
        cb()
      }
    
      return util.format.apply(util, [this.cache[this.locale][str] || str].concat(args))
    }
    
    Y18N.prototype._enqueueWrite = function (work) {
      this.writeQueue.push(work)
      if (this.writeQueue.length === 1) this._processWriteQueue()
    }
    
    Y18N.prototype._processWriteQueue = function () {
      var _this = this
      var work = this.writeQueue[0]
    
      // destructure the enqueued work.
      var directory = work[0]
      var locale = work[1]
      var cb = work[2]
    
      var languageFile = this._resolveLocaleFile(directory, locale)
      var serializedLocale = JSON.stringify(this.cache[locale], null, 2)
    
      fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
        _this.writeQueue.shift()
        if (_this.writeQueue.length > 0) _this._processWriteQueue()
        cb(err)
      })
    }
    
    Y18N.prototype._readLocaleFile = function () {
      var localeLookup = {}
      var languageFile = this._resolveLocaleFile(this.directory, this.locale)
    
      try {
        localeLookup = JSON.parse(fs.readFileSync(languageFile, 'utf-8'))
      } catch (err) {
        if (err instanceof SyntaxError) {
          err.message = 'syntax error in ' + languageFile
        }
    
        if (err.code === 'ENOENT') localeLookup = {}
        else throw err
      }
    
      this.cache[this.locale] = localeLookup
    }
    
    Y18N.prototype._resolveLocaleFile = function (directory, locale) {
      var file = path.resolve(directory, './', locale + '.json')
      if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
        // attempt fallback to language only
        var languageFile = path.resolve(directory, './', locale.split('_')[0] + '.json')
        if (this._fileExistsSync(languageFile)) file = languageFile
      }
      return file
    }
    
    // this only exists because fs.existsSync() "will be deprecated"
    // see https://nodejs.org/api/fs.html#fs_fs_existssync_path
    Y18N.prototype._fileExistsSync = function (file) {
      try {
        return fs.statSync(file).isFile()
      } catch (err) {
        return false
      }
    }
    
    Y18N.prototype.__n = function () {
      var args = Array.prototype.slice.call(arguments)
      var singular = args.shift()
      var plural = args.shift()
      var quantity = args.shift()
    
      var cb = function () {} // start with noop.
      if (typeof args[args.length - 1] === 'function') cb = args.pop()
    
      if (!this.cache[this.locale]) this._readLocaleFile()
    
      var str = quantity === 1 ? singular : plural
      if (this.cache[this.locale][singular]) {
        str = this.cache[this.locale][singular][quantity === 1 ? 'one' : 'other']
      }
    
      // we've observed a new string, update the language file.
      if (!this.cache[this.locale][singular] && this.updateFiles) {
        this.cache[this.locale][singular] = {
          one: singular,
          other: plural
        }
    
        // include the current directory and locale,
        // since these values could change before the
        // write is performed.
        this._enqueueWrite([this.directory, this.locale, cb])
      } else {
        cb()
      }
    
      // if a %d placeholder is provided, add quantity
      // to the arguments expanded by util.format.
      var values = [str]
      if (~str.indexOf('%d')) values.push(quantity)
    
      return util.format.apply(util, values.concat(args))
    }
    
    Y18N.prototype.setLocale = function (locale) {
      this.locale = locale
    }
    
    Y18N.prototype.getLocale = function () {
      return this.locale
    }
    
    Y18N.prototype.updateLocale = function (obj) {
      if (!this.cache[this.locale]) this._readLocaleFile()
    
      for (var key in obj) {
        this.cache[this.locale][key] = obj[key]
      }
    }
    
    module.exports = function (opts) {
      var y18n = new Y18N(opts)
    
      // bind all functions to y18n, so that
      // they can be used in isolation.
      for (var key in y18n) {
        if (typeof y18n[key] === 'function') {
          y18n[key] = y18n[key].bind(y18n)
        }
      }
    
      return y18n
    }
    
  provide("y18n", module.exports);
}(global));

// pakmanager:iota-array
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    function iota(n) {
      var result = new Array(n)
      for(var i=0; i<n; ++i) {
        result[i] = i
      }
      return result
    }
    
    module.exports = iota
  provide("iota-array", module.exports);
}(global));

// pakmanager:uniq
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    function unique_pred(list, compare) {
      var ptr = 1
        , len = list.length
        , a=list[0], b=list[0]
      for(var i=1; i<len; ++i) {
        b = a
        a = list[i]
        if(compare(a, b)) {
          if(i === ptr) {
            ptr++
            continue
          }
          list[ptr++] = a
        }
      }
      list.length = ptr
      return list
    }
    
    function unique_eq(list) {
      var ptr = 1
        , len = list.length
        , a=list[0], b = list[0]
      for(var i=1; i<len; ++i, b=a) {
        b = a
        a = list[i]
        if(a !== b) {
          if(i === ptr) {
            ptr++
            continue
          }
          list[ptr++] = a
        }
      }
      list.length = ptr
      return list
    }
    
    function unique(list, compare, sorted) {
      if(list.length === 0) {
        return list
      }
      if(compare) {
        if(!sorted) {
          list.sort(compare)
        }
        return unique_pred(list, compare)
      }
      if(!sorted) {
        list.sort()
      }
      return unique_eq(list)
    }
    
    module.exports = unique
    
  provide("uniq", module.exports);
}(global));

// pakmanager:async
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * async
     * https://github.com/caolan/async
     *
     * Copyright 2010-2014 Caolan McMahon
     * Released under the MIT license
     */
    (function () {
    
        var async = {};
        function noop() {}
        function identity(v) {
            return v;
        }
        function toBool(v) {
            return !!v;
        }
        function notId(v) {
            return !v;
        }
    
        // global on the server, window in the browser
        var previous_async;
    
        // Establish the root object, `window` (`self`) in the browser, `global`
        // on the server, or `this` in some virtual machines. We use `self`
        // instead of `window` for `WebWorker` support.
        var root = typeof self === 'object' && self.self === self && self ||
                typeof global === 'object' && global.global === global && global ||
                this;
    
        if (root != null) {
            previous_async = root.async;
        }
    
        async.noConflict = function () {
            root.async = previous_async;
            return async;
        };
    
        function only_once(fn) {
            return function() {
                if (fn === null) throw new Error("Callback was already called.");
                fn.apply(this, arguments);
                fn = null;
            };
        }
    
        function _once(fn) {
            return function() {
                if (fn === null) return;
                fn.apply(this, arguments);
                fn = null;
            };
        }
    
        //// cross-browser compatiblity functions ////
    
        var _toString = Object.prototype.toString;
    
        var _isArray = Array.isArray || function (obj) {
            return _toString.call(obj) === '[object Array]';
        };
    
        // Ported from underscore.js isObject
        var _isObject = function(obj) {
            var type = typeof obj;
            return type === 'function' || type === 'object' && !!obj;
        };
    
        function _isArrayLike(arr) {
            return _isArray(arr) || (
                // has a positive integer length property
                typeof arr.length === "number" &&
                arr.length >= 0 &&
                arr.length % 1 === 0
            );
        }
    
        function _each(coll, iterator) {
            return _isArrayLike(coll) ?
                _arrayEach(coll, iterator) :
                _forEachOf(coll, iterator);
        }
    
        function _arrayEach(arr, iterator) {
            var index = -1,
                length = arr.length;
    
            while (++index < length) {
                iterator(arr[index], index, arr);
            }
        }
    
        function _map(arr, iterator) {
            var index = -1,
                length = arr.length,
                result = Array(length);
    
            while (++index < length) {
                result[index] = iterator(arr[index], index, arr);
            }
            return result;
        }
    
        function _range(count) {
            return _map(Array(count), function (v, i) { return i; });
        }
    
        function _reduce(arr, iterator, memo) {
            _arrayEach(arr, function (x, i, a) {
                memo = iterator(memo, x, i, a);
            });
            return memo;
        }
    
        function _forEachOf(object, iterator) {
            _arrayEach(_keys(object), function (key) {
                iterator(object[key], key);
            });
        }
    
        function _indexOf(arr, item) {
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] === item) return i;
            }
            return -1;
        }
    
        var _keys = Object.keys || function (obj) {
            var keys = [];
            for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                    keys.push(k);
                }
            }
            return keys;
        };
    
        function _keyIterator(coll) {
            var i = -1;
            var len;
            var keys;
            if (_isArrayLike(coll)) {
                len = coll.length;
                return function next() {
                    i++;
                    return i < len ? i : null;
                };
            } else {
                keys = _keys(coll);
                len = keys.length;
                return function next() {
                    i++;
                    return i < len ? keys[i] : null;
                };
            }
        }
    
        // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
        // This accumulates the arguments passed into an array, after a given index.
        // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
        function _restParam(func, startIndex) {
            startIndex = startIndex == null ? func.length - 1 : +startIndex;
            return function() {
                var length = Math.max(arguments.length - startIndex, 0);
                var rest = Array(length);
                for (var index = 0; index < length; index++) {
                    rest[index] = arguments[index + startIndex];
                }
                switch (startIndex) {
                    case 0: return func.call(this, rest);
                    case 1: return func.call(this, arguments[0], rest);
                }
                // Currently unused but handle cases outside of the switch statement:
                // var args = Array(startIndex + 1);
                // for (index = 0; index < startIndex; index++) {
                //     args[index] = arguments[index];
                // }
                // args[startIndex] = rest;
                // return func.apply(this, args);
            };
        }
    
        function _withoutIndex(iterator) {
            return function (value, index, callback) {
                return iterator(value, callback);
            };
        }
    
        //// exported async module functions ////
    
        //// nextTick implementation with browser-compatible fallback ////
    
        // capture the global reference to guard against fakeTimer mocks
        var _setImmediate = typeof setImmediate === 'function' && setImmediate;
    
        var _delay = _setImmediate ? function(fn) {
            // not a direct alias for IE10 compatibility
            _setImmediate(fn);
        } : function(fn) {
            setTimeout(fn, 0);
        };
    
        if (typeof process === 'object' && typeof process.nextTick === 'function') {
            async.nextTick = process.nextTick;
        } else {
            async.nextTick = _delay;
        }
        async.setImmediate = _setImmediate ? _delay : async.nextTick;
    
    
        async.forEach =
        async.each = function (arr, iterator, callback) {
            return async.eachOf(arr, _withoutIndex(iterator), callback);
        };
    
        async.forEachSeries =
        async.eachSeries = function (arr, iterator, callback) {
            return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
        };
    
    
        async.forEachLimit =
        async.eachLimit = function (arr, limit, iterator, callback) {
            return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
        };
    
        async.forEachOf =
        async.eachOf = function (object, iterator, callback) {
            callback = _once(callback || noop);
            object = object || [];
            var size = _isArrayLike(object) ? object.length : _keys(object).length;
            var completed = 0;
            if (!size) {
                return callback(null);
            }
            _each(object, function (value, key) {
                iterator(object[key], key, only_once(done));
            });
            function done(err) {
                if (err) {
                    callback(err);
                }
                else {
                    completed += 1;
                    if (completed >= size) {
                        callback(null);
                    }
                }
            }
        };
    
        async.forEachOfSeries =
        async.eachOfSeries = function (obj, iterator, callback) {
            callback = _once(callback || noop);
            obj = obj || [];
            var nextKey = _keyIterator(obj);
            var key = nextKey();
            function iterate() {
                var sync = true;
                if (key === null) {
                    return callback(null);
                }
                iterator(obj[key], key, only_once(function (err) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        key = nextKey();
                        if (key === null) {
                            return callback(null);
                        } else {
                            if (sync) {
                                async.nextTick(iterate);
                            } else {
                                iterate();
                            }
                        }
                    }
                }));
                sync = false;
            }
            iterate();
        };
    
    
    
        async.forEachOfLimit =
        async.eachOfLimit = function (obj, limit, iterator, callback) {
            _eachOfLimit(limit)(obj, iterator, callback);
        };
    
        function _eachOfLimit(limit) {
    
            return function (obj, iterator, callback) {
                callback = _once(callback || noop);
                obj = obj || [];
                var nextKey = _keyIterator(obj);
                if (limit <= 0) {
                    return callback(null);
                }
                var done = false;
                var running = 0;
                var errored = false;
    
                (function replenish () {
                    if (done && running <= 0) {
                        return callback(null);
                    }
    
                    while (running < limit && !errored) {
                        var key = nextKey();
                        if (key === null) {
                            done = true;
                            if (running <= 0) {
                                callback(null);
                            }
                            return;
                        }
                        running += 1;
                        iterator(obj[key], key, only_once(function (err) {
                            running -= 1;
                            if (err) {
                                callback(err);
                                errored = true;
                            }
                            else {
                                replenish();
                            }
                        }));
                    }
                })();
            };
        }
    
    
        function doParallel(fn) {
            return function (obj, iterator, callback) {
                return fn(async.eachOf, obj, iterator, callback);
            };
        }
        function doParallelLimit(fn) {
            return function (obj, limit, iterator, callback) {
                return fn(_eachOfLimit(limit), obj, iterator, callback);
            };
        }
        function doSeries(fn) {
            return function (obj, iterator, callback) {
                return fn(async.eachOfSeries, obj, iterator, callback);
            };
        }
    
        function _asyncMap(eachfn, arr, iterator, callback) {
            callback = _once(callback || noop);
            var results = [];
            eachfn(arr, function (value, index, callback) {
                iterator(value, function (err, v) {
                    results[index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    
        async.map = doParallel(_asyncMap);
        async.mapSeries = doSeries(_asyncMap);
        async.mapLimit = doParallelLimit(_asyncMap);
    
        // reduce only has a series version, as doing reduce in parallel won't
        // work in many situations.
        async.inject =
        async.foldl =
        async.reduce = function (arr, memo, iterator, callback) {
            async.eachOfSeries(arr, function (x, i, callback) {
                iterator(memo, x, function (err, v) {
                    memo = v;
                    callback(err);
                });
            }, function (err) {
                callback(err || null, memo);
            });
        };
    
        async.foldr =
        async.reduceRight = function (arr, memo, iterator, callback) {
            var reversed = _map(arr, identity).reverse();
            async.reduce(reversed, memo, iterator, callback);
        };
    
        function _filter(eachfn, arr, iterator, callback) {
            var results = [];
            eachfn(arr, function (x, index, callback) {
                iterator(x, function (v) {
                    if (v) {
                        results.push({index: index, value: x});
                    }
                    callback();
                });
            }, function () {
                callback(_map(results.sort(function (a, b) {
                    return a.index - b.index;
                }), function (x) {
                    return x.value;
                }));
            });
        }
    
        async.select =
        async.filter = doParallel(_filter);
    
        async.selectLimit =
        async.filterLimit = doParallelLimit(_filter);
    
        async.selectSeries =
        async.filterSeries = doSeries(_filter);
    
        function _reject(eachfn, arr, iterator, callback) {
            _filter(eachfn, arr, function(value, cb) {
                iterator(value, function(v) {
                    cb(!v);
                });
            }, callback);
        }
        async.reject = doParallel(_reject);
        async.rejectLimit = doParallelLimit(_reject);
        async.rejectSeries = doSeries(_reject);
    
        function _createTester(eachfn, check, getResult) {
            return function(arr, limit, iterator, cb) {
                function done() {
                    if (cb) cb(getResult(false, void 0));
                }
                function iteratee(x, _, callback) {
                    if (!cb) return callback();
                    iterator(x, function (v) {
                        if (cb && check(v)) {
                            cb(getResult(true, x));
                            cb = iterator = false;
                        }
                        callback();
                    });
                }
                if (arguments.length > 3) {
                    eachfn(arr, limit, iteratee, done);
                } else {
                    cb = iterator;
                    iterator = limit;
                    eachfn(arr, iteratee, done);
                }
            };
        }
    
        async.any =
        async.some = _createTester(async.eachOf, toBool, identity);
    
        async.someLimit = _createTester(async.eachOfLimit, toBool, identity);
    
        async.all =
        async.every = _createTester(async.eachOf, notId, notId);
    
        async.everyLimit = _createTester(async.eachOfLimit, notId, notId);
    
        function _findGetResult(v, x) {
            return x;
        }
        async.detect = _createTester(async.eachOf, identity, _findGetResult);
        async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
        async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);
    
        async.sortBy = function (arr, iterator, callback) {
            async.map(arr, function (x, callback) {
                iterator(x, function (err, criteria) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        callback(null, {value: x, criteria: criteria});
                    }
                });
            }, function (err, results) {
                if (err) {
                    return callback(err);
                }
                else {
                    callback(null, _map(results.sort(comparator), function (x) {
                        return x.value;
                    }));
                }
    
            });
    
            function comparator(left, right) {
                var a = left.criteria, b = right.criteria;
                return a < b ? -1 : a > b ? 1 : 0;
            }
        };
    
        async.auto = function (tasks, callback) {
            callback = _once(callback || noop);
            var keys = _keys(tasks);
            var remainingTasks = keys.length;
            if (!remainingTasks) {
                return callback(null);
            }
    
            var results = {};
    
            var listeners = [];
            function addListener(fn) {
                listeners.unshift(fn);
            }
            function removeListener(fn) {
                var idx = _indexOf(listeners, fn);
                if (idx >= 0) listeners.splice(idx, 1);
            }
            function taskComplete() {
                remainingTasks--;
                _arrayEach(listeners.slice(0), function (fn) {
                    fn();
                });
            }
    
            addListener(function () {
                if (!remainingTasks) {
                    callback(null, results);
                }
            });
    
            _arrayEach(keys, function (k) {
                var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
                var taskCallback = _restParam(function(err, args) {
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    if (err) {
                        var safeResults = {};
                        _forEachOf(results, function(val, rkey) {
                            safeResults[rkey] = val;
                        });
                        safeResults[k] = args;
                        callback(err, safeResults);
                    }
                    else {
                        results[k] = args;
                        async.setImmediate(taskComplete);
                    }
                });
                var requires = task.slice(0, task.length - 1);
                // prevent dead-locks
                var len = requires.length;
                var dep;
                while (len--) {
                    if (!(dep = tasks[requires[len]])) {
                        throw new Error('Has inexistant dependency');
                    }
                    if (_isArray(dep) && _indexOf(dep, k) >= 0) {
                        throw new Error('Has cyclic dependencies');
                    }
                }
                function ready() {
                    return _reduce(requires, function (a, x) {
                        return (a && results.hasOwnProperty(x));
                    }, true) && !results.hasOwnProperty(k);
                }
                if (ready()) {
                    task[task.length - 1](taskCallback, results);
                }
                else {
                    addListener(listener);
                }
                function listener() {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                }
            });
        };
    
    
    
        async.retry = function(times, task, callback) {
            var DEFAULT_TIMES = 5;
            var DEFAULT_INTERVAL = 0;
    
            var attempts = [];
    
            var opts = {
                times: DEFAULT_TIMES,
                interval: DEFAULT_INTERVAL
            };
    
            function parseTimes(acc, t){
                if(typeof t === 'number'){
                    acc.times = parseInt(t, 10) || DEFAULT_TIMES;
                } else if(typeof t === 'object'){
                    acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                    acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
                } else {
                    throw new Error('Unsupported argument type for \'times\': ' + typeof t);
                }
            }
    
            var length = arguments.length;
            if (length < 1 || length > 3) {
                throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
            } else if (length <= 2 && typeof times === 'function') {
                callback = task;
                task = times;
            }
            if (typeof times !== 'function') {
                parseTimes(opts, times);
            }
            opts.callback = callback;
            opts.task = task;
    
            function wrappedTask(wrappedCallback, wrappedResults) {
                function retryAttempt(task, finalAttempt) {
                    return function(seriesCallback) {
                        task(function(err, result){
                            seriesCallback(!err || finalAttempt, {err: err, result: result});
                        }, wrappedResults);
                    };
                }
    
                function retryInterval(interval){
                    return function(seriesCallback){
                        setTimeout(function(){
                            seriesCallback(null);
                        }, interval);
                    };
                }
    
                while (opts.times) {
    
                    var finalAttempt = !(opts.times-=1);
                    attempts.push(retryAttempt(opts.task, finalAttempt));
                    if(!finalAttempt && opts.interval > 0){
                        attempts.push(retryInterval(opts.interval));
                    }
                }
    
                async.series(attempts, function(done, data){
                    data = data[data.length - 1];
                    (wrappedCallback || opts.callback)(data.err, data.result);
                });
            }
    
            // If a callback is passed, run this as a controll flow
            return opts.callback ? wrappedTask() : wrappedTask;
        };
    
        async.waterfall = function (tasks, callback) {
            callback = _once(callback || noop);
            if (!_isArray(tasks)) {
                var err = new Error('First argument to waterfall must be an array of functions');
                return callback(err);
            }
            if (!tasks.length) {
                return callback();
            }
            function wrapIterator(iterator) {
                return _restParam(function (err, args) {
                    if (err) {
                        callback.apply(null, [err].concat(args));
                    }
                    else {
                        var next = iterator.next();
                        if (next) {
                            args.push(wrapIterator(next));
                        }
                        else {
                            args.push(callback);
                        }
                        ensureAsync(iterator).apply(null, args);
                    }
                });
            }
            wrapIterator(async.iterator(tasks))();
        };
    
        function _parallel(eachfn, tasks, callback) {
            callback = callback || noop;
            var results = _isArrayLike(tasks) ? [] : {};
    
            eachfn(tasks, function (task, key, callback) {
                task(_restParam(function (err, args) {
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[key] = args;
                    callback(err);
                }));
            }, function (err) {
                callback(err, results);
            });
        }
    
        async.parallel = function (tasks, callback) {
            _parallel(async.eachOf, tasks, callback);
        };
    
        async.parallelLimit = function(tasks, limit, callback) {
            _parallel(_eachOfLimit(limit), tasks, callback);
        };
    
        async.series = function(tasks, callback) {
            _parallel(async.eachOfSeries, tasks, callback);
        };
    
        async.iterator = function (tasks) {
            function makeCallback(index) {
                function fn() {
                    if (tasks.length) {
                        tasks[index].apply(null, arguments);
                    }
                    return fn.next();
                }
                fn.next = function () {
                    return (index < tasks.length - 1) ? makeCallback(index + 1): null;
                };
                return fn;
            }
            return makeCallback(0);
        };
    
        async.apply = _restParam(function (fn, args) {
            return _restParam(function (callArgs) {
                return fn.apply(
                    null, args.concat(callArgs)
                );
            });
        });
    
        function _concat(eachfn, arr, fn, callback) {
            var result = [];
            eachfn(arr, function (x, index, cb) {
                fn(x, function (err, y) {
                    result = result.concat(y || []);
                    cb(err);
                });
            }, function (err) {
                callback(err, result);
            });
        }
        async.concat = doParallel(_concat);
        async.concatSeries = doSeries(_concat);
    
        async.whilst = function (test, iterator, callback) {
            callback = callback || noop;
            if (test()) {
                var next = _restParam(function(err, args) {
                    if (err) {
                        callback(err);
                    } else if (test.apply(this, args)) {
                        iterator(next);
                    } else {
                        callback(null);
                    }
                });
                iterator(next);
            } else {
                callback(null);
            }
        };
    
        async.doWhilst = function (iterator, test, callback) {
            var calls = 0;
            return async.whilst(function() {
                return ++calls <= 1 || test.apply(this, arguments);
            }, iterator, callback);
        };
    
        async.until = function (test, iterator, callback) {
            return async.whilst(function() {
                return !test.apply(this, arguments);
            }, iterator, callback);
        };
    
        async.doUntil = function (iterator, test, callback) {
            return async.doWhilst(iterator, function() {
                return !test.apply(this, arguments);
            }, callback);
        };
    
        async.during = function (test, iterator, callback) {
            callback = callback || noop;
    
            var next = _restParam(function(err, args) {
                if (err) {
                    callback(err);
                } else {
                    args.push(check);
                    test.apply(this, args);
                }
            });
    
            var check = function(err, truth) {
                if (err) {
                    callback(err);
                } else if (truth) {
                    iterator(next);
                } else {
                    callback(null);
                }
            };
    
            test(check);
        };
    
        async.doDuring = function (iterator, test, callback) {
            var calls = 0;
            async.during(function(next) {
                if (calls++ < 1) {
                    next(null, true);
                } else {
                    test.apply(this, arguments);
                }
            }, iterator, callback);
        };
    
        function _queue(worker, concurrency, payload) {
            if (concurrency == null) {
                concurrency = 1;
            }
            else if(concurrency === 0) {
                throw new Error('Concurrency must not be zero');
            }
            function _insert(q, data, pos, callback) {
                if (callback != null && typeof callback !== "function") {
                    throw new Error("task callback must be a function");
                }
                q.started = true;
                if (!_isArray(data)) {
                    data = [data];
                }
                if(data.length === 0 && q.idle()) {
                    // call drain immediately if there are no tasks
                    return async.setImmediate(function() {
                        q.drain();
                    });
                }
                _arrayEach(data, function(task) {
                    var item = {
                        data: task,
                        callback: callback || noop
                    };
    
                    if (pos) {
                        q.tasks.unshift(item);
                    } else {
                        q.tasks.push(item);
                    }
    
                    if (q.tasks.length === q.concurrency) {
                        q.saturated();
                    }
                });
                async.setImmediate(q.process);
            }
            function _next(q, tasks) {
                return function(){
                    workers -= 1;
                    var args = arguments;
                    _arrayEach(tasks, function (task) {
                        task.callback.apply(task, args);
                    });
                    if (q.tasks.length + workers === 0) {
                        q.drain();
                    }
                    q.process();
                };
            }
    
            var workers = 0;
            var q = {
                tasks: [],
                concurrency: concurrency,
                payload: payload,
                saturated: noop,
                empty: noop,
                drain: noop,
                started: false,
                paused: false,
                push: function (data, callback) {
                    _insert(q, data, false, callback);
                },
                kill: function () {
                    q.drain = noop;
                    q.tasks = [];
                },
                unshift: function (data, callback) {
                    _insert(q, data, true, callback);
                },
                process: function () {
                    if (!q.paused && workers < q.concurrency && q.tasks.length) {
                        while(workers < q.concurrency && q.tasks.length){
                            var tasks = q.payload ?
                                q.tasks.splice(0, q.payload) :
                                q.tasks.splice(0, q.tasks.length);
    
                            var data = _map(tasks, function (task) {
                                return task.data;
                            });
    
                            if (q.tasks.length === 0) {
                                q.empty();
                            }
                            workers += 1;
                            var cb = only_once(_next(q, tasks));
                            worker(data, cb);
                        }
                    }
                },
                length: function () {
                    return q.tasks.length;
                },
                running: function () {
                    return workers;
                },
                idle: function() {
                    return q.tasks.length + workers === 0;
                },
                pause: function () {
                    q.paused = true;
                },
                resume: function () {
                    if (q.paused === false) { return; }
                    q.paused = false;
                    var resumeCount = Math.min(q.concurrency, q.tasks.length);
                    // Need to call q.process once per concurrent
                    // worker to preserve full concurrency after pause
                    for (var w = 1; w <= resumeCount; w++) {
                        async.setImmediate(q.process);
                    }
                }
            };
            return q;
        }
    
        async.queue = function (worker, concurrency) {
            var q = _queue(function (items, cb) {
                worker(items[0], cb);
            }, concurrency, 1);
    
            return q;
        };
    
        async.priorityQueue = function (worker, concurrency) {
    
            function _compareTasks(a, b){
                return a.priority - b.priority;
            }
    
            function _binarySearch(sequence, item, compare) {
                var beg = -1,
                    end = sequence.length - 1;
                while (beg < end) {
                    var mid = beg + ((end - beg + 1) >>> 1);
                    if (compare(item, sequence[mid]) >= 0) {
                        beg = mid;
                    } else {
                        end = mid - 1;
                    }
                }
                return beg;
            }
    
            function _insert(q, data, priority, callback) {
                if (callback != null && typeof callback !== "function") {
                    throw new Error("task callback must be a function");
                }
                q.started = true;
                if (!_isArray(data)) {
                    data = [data];
                }
                if(data.length === 0) {
                    // call drain immediately if there are no tasks
                    return async.setImmediate(function() {
                        q.drain();
                    });
                }
                _arrayEach(data, function(task) {
                    var item = {
                        data: task,
                        priority: priority,
                        callback: typeof callback === 'function' ? callback : noop
                    };
    
                    q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
    
                    if (q.tasks.length === q.concurrency) {
                        q.saturated();
                    }
                    async.setImmediate(q.process);
                });
            }
    
            // Start with a normal queue
            var q = async.queue(worker, concurrency);
    
            // Override push to accept second parameter representing priority
            q.push = function (data, priority, callback) {
                _insert(q, data, priority, callback);
            };
    
            // Remove unshift function
            delete q.unshift;
    
            return q;
        };
    
        async.cargo = function (worker, payload) {
            return _queue(worker, 1, payload);
        };
    
        function _console_fn(name) {
            return _restParam(function (fn, args) {
                fn.apply(null, args.concat([_restParam(function (err, args) {
                    if (typeof console === 'object') {
                        if (err) {
                            if (console.error) {
                                console.error(err);
                            }
                        }
                        else if (console[name]) {
                            _arrayEach(args, function (x) {
                                console[name](x);
                            });
                        }
                    }
                })]));
            });
        }
        async.log = _console_fn('log');
        async.dir = _console_fn('dir');
        /*async.info = _console_fn('info');
        async.warn = _console_fn('warn');
        async.error = _console_fn('error');*/
    
        async.memoize = function (fn, hasher) {
            var memo = {};
            var queues = {};
            hasher = hasher || identity;
            var memoized = _restParam(function memoized(args) {
                var callback = args.pop();
                var key = hasher.apply(null, args);
                if (key in memo) {
                    async.nextTick(function () {
                        callback.apply(null, memo[key]);
                    });
                }
                else if (key in queues) {
                    queues[key].push(callback);
                }
                else {
                    queues[key] = [callback];
                    fn.apply(null, args.concat([_restParam(function (args) {
                        memo[key] = args;
                        var q = queues[key];
                        delete queues[key];
                        for (var i = 0, l = q.length; i < l; i++) {
                            q[i].apply(null, args);
                        }
                    })]));
                }
            });
            memoized.memo = memo;
            memoized.unmemoized = fn;
            return memoized;
        };
    
        async.unmemoize = function (fn) {
            return function () {
                return (fn.unmemoized || fn).apply(null, arguments);
            };
        };
    
        function _times(mapper) {
            return function (count, iterator, callback) {
                mapper(_range(count), iterator, callback);
            };
        }
    
        async.times = _times(async.map);
        async.timesSeries = _times(async.mapSeries);
        async.timesLimit = function (count, limit, iterator, callback) {
            return async.mapLimit(_range(count), limit, iterator, callback);
        };
    
        async.seq = function (/* functions... */) {
            var fns = arguments;
            return _restParam(function (args) {
                var that = this;
    
                var callback = args[args.length - 1];
                if (typeof callback == 'function') {
                    args.pop();
                } else {
                    callback = noop;
                }
    
                async.reduce(fns, args, function (newargs, fn, cb) {
                    fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
                        cb(err, nextargs);
                    })]));
                },
                function (err, results) {
                    callback.apply(that, [err].concat(results));
                });
            });
        };
    
        async.compose = function (/* functions... */) {
            return async.seq.apply(null, Array.prototype.reverse.call(arguments));
        };
    
    
        function _applyEach(eachfn) {
            return _restParam(function(fns, args) {
                var go = _restParam(function(args) {
                    var that = this;
                    var callback = args.pop();
                    return eachfn(fns, function (fn, _, cb) {
                        fn.apply(that, args.concat([cb]));
                    },
                    callback);
                });
                if (args.length) {
                    return go.apply(this, args);
                }
                else {
                    return go;
                }
            });
        }
    
        async.applyEach = _applyEach(async.eachOf);
        async.applyEachSeries = _applyEach(async.eachOfSeries);
    
    
        async.forever = function (fn, callback) {
            var done = only_once(callback || noop);
            var task = ensureAsync(fn);
            function next(err) {
                if (err) {
                    return done(err);
                }
                task(next);
            }
            next();
        };
    
        function ensureAsync(fn) {
            return _restParam(function (args) {
                var callback = args.pop();
                args.push(function () {
                    var innerArgs = arguments;
                    if (sync) {
                        async.setImmediate(function () {
                            callback.apply(null, innerArgs);
                        });
                    } else {
                        callback.apply(null, innerArgs);
                    }
                });
                var sync = true;
                fn.apply(this, args);
                sync = false;
            });
        }
    
        async.ensureAsync = ensureAsync;
    
        async.constant = _restParam(function(values) {
            var args = [null].concat(values);
            return function (callback) {
                return callback.apply(this, args);
            };
        });
    
        async.wrapSync =
        async.asyncify = function asyncify(func) {
            return _restParam(function (args) {
                var callback = args.pop();
                var result;
                try {
                    result = func.apply(this, args);
                } catch (e) {
                    return callback(e);
                }
                // if result is Promise object
                if (_isObject(result) && typeof result.then === "function") {
                    result.then(function(value) {
                        callback(null, value);
                    })["catch"](function(err) {
                        callback(err.message ? err : new Error(err));
                    });
                } else {
                    callback(null, result);
                }
            });
        };
    
        // Node.js
        if (typeof module === 'object' && module.exports) {
            module.exports = async;
        }
        // AMD / RequireJS
        else if (typeof define === 'function' && define.amd) {
            define([], function () {
                return async;
            });
        }
        // included directly via <script> tag
        else {
            root.async = async;
        }
    
    }());
    
  provide("async", module.exports);
}(global));

// pakmanager:combined-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util');
    var Stream = require('stream').Stream;
    var DelayedStream = require('delayed-stream');
    
    module.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
    
      this._released = false;
      this._streams = [];
      this._currentStream = null;
    }
    util.inherits(CombinedStream, Stream);
    
    CombinedStream.create = function(options) {
      var combinedStream = new this();
    
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
    
      return combinedStream;
    };
    
    CombinedStream.isStreamLike = function(stream) {
      return (typeof stream !== 'function')
        && (typeof stream !== 'string')
        && (typeof stream !== 'boolean')
        && (typeof stream !== 'number')
        && (!Buffer.isBuffer(stream));
    };
    
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
    
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams,
          });
          stream.on('data', this._checkDataSize.bind(this));
          stream = newStream;
        }
    
        this._handleErrors(stream);
    
        if (this.pauseStreams) {
          stream.pause();
        }
      }
    
      this._streams.push(stream);
      return this;
    };
    
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      var stream = this._streams.shift();
    
    
      if (typeof stream == 'undefined') {
        this.end();
        return;
      }
    
      if (typeof stream !== 'function') {
        this._pipeNext(stream);
        return;
      }
    
      var getStream = stream;
      getStream(function(stream) {
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
          stream.on('data', this._checkDataSize.bind(this));
          this._handleErrors(stream);
        }
    
        this._pipeNext(stream);
      }.bind(this));
    };
    
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
    
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on('end', this._getNext.bind(this));
        stream.pipe(this, {end: false});
        return;
      }
    
      var value = stream;
      this.write(value);
      this._getNext();
    };
    
    CombinedStream.prototype._handleErrors = function(stream) {
      var self = this;
      stream.on('error', function(err) {
        self._emitError(err);
      });
    };
    
    CombinedStream.prototype.write = function(data) {
      this.emit('data', data);
    };
    
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
    
      if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
      this.emit('pause');
    };
    
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
    
      if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
      this.emit('resume');
    };
    
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit('end');
    };
    
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit('close');
    };
    
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
    
      var message =
        'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
      this._emitError(new Error(message));
    };
    
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
    
      var self = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
    
        self.dataSize += stream.dataSize;
      });
    
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit('error', err);
    };
    
  provide("combined-stream", module.exports);
}(global));

// pakmanager:mime-types
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mime-types
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var db = require('mime-db')
    var extname = require('path').extname
    
    /**
     * Module variables.
     * @private
     */
    
    var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/
    var textTypeRegExp = /^text\//i
    
    /**
     * Module exports.
     * @public
     */
    
    exports.charset = charset
    exports.charsets = { lookup: charset }
    exports.contentType = contentType
    exports.extension = extension
    exports.extensions = Object.create(null)
    exports.lookup = lookup
    exports.types = Object.create(null)
    
    // Populate the extensions/types maps
    populateMaps(exports.extensions, exports.types)
    
    /**
     * Get the default charset for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */
    
    function charset(type) {
      if (!type || typeof type !== 'string') {
        return false
      }
    
      // TODO: use media-typer
      var match = extractTypeRegExp.exec(type)
      var mime = match && db[match[1].toLowerCase()]
    
      if (mime && mime.charset) {
        return mime.charset
      }
    
      // default text/* to utf-8
      if (match && textTypeRegExp.test(match[1])) {
        return 'UTF-8'
      }
    
      return false
    }
    
    /**
     * Create a full Content-Type header given a MIME type or extension.
     *
     * @param {string} str
     * @return {boolean|string}
     */
    
    function contentType(str) {
      // TODO: should this even be in this module?
      if (!str || typeof str !== 'string') {
        return false
      }
    
      var mime = str.indexOf('/') === -1
        ? exports.lookup(str)
        : str
    
      if (!mime) {
        return false
      }
    
      // TODO: use content-type or other module
      if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime)
        if (charset) mime += '; charset=' + charset.toLowerCase()
      }
    
      return mime
    }
    
    /**
     * Get the default extension for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */
    
    function extension(type) {
      if (!type || typeof type !== 'string') {
        return false
      }
    
      // TODO: use media-typer
      var match = extractTypeRegExp.exec(type)
    
      // get extensions
      var exts = match && exports.extensions[match[1].toLowerCase()]
    
      if (!exts || !exts.length) {
        return false
      }
    
      return exts[0]
    }
    
    /**
     * Lookup the MIME type for a file path/extension.
     *
     * @param {string} path
     * @return {boolean|string}
     */
    
    function lookup(path) {
      if (!path || typeof path !== 'string') {
        return false
      }
    
      // get the extension ("ext" or ".ext" or full path)
      var extension = extname('x.' + path)
        .toLowerCase()
        .substr(1)
    
      if (!extension) {
        return false
      }
    
      return exports.types[extension] || false
    }
    
    /**
     * Populate the extensions and types maps.
     * @private
     */
    
    function populateMaps(extensions, types) {
      // source preference (least -> most)
      var preference = ['nginx', 'apache', undefined, 'iana']
    
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type]
        var exts = mime.extensions
    
        if (!exts || !exts.length) {
          return
        }
    
        // mime -> extensions
        extensions[type] = exts
    
        // extension -> mime
        for (var i = 0; i < exts.length; i++) {
          var extension = exts[i]
    
          if (types[extension]) {
            var from = preference.indexOf(db[types[extension]].source)
            var to = preference.indexOf(mime.source)
    
            if (types[extension] !== 'application/octet-stream'
              && from > to || (from === to && types[extension].substr(0, 12) === 'application/')) {
              // skip the remapping
              continue
            }
          }
    
          // set the extension -> mime
          types[extension] = type
        }
      })
    }
    
  provide("mime-types", module.exports);
}(global));

// pakmanager:assert-plus
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright (c) 2012, Mark Cavage. All rights reserved.
    
    var assert = require('assert');
    var Stream = require('stream').Stream;
    var util = require('util');
    
    
    
    ///--- Globals
    
    var NDEBUG = process.env.NODE_NDEBUG || false;
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    
    
    
    ///--- Messages
    
    var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
    var TYPE_REQUIRED = '%s (%s) is required';
    
    
    
    ///--- Internal
    
    function capitalize(str) {
            return (str.charAt(0).toUpperCase() + str.slice(1));
    }
    
    function uncapitalize(str) {
            return (str.charAt(0).toLowerCase() + str.slice(1));
    }
    
    function _() {
            return (util.format.apply(util, arguments));
    }
    
    
    function _assert(arg, type, name, stackFunc) {
            if (!NDEBUG) {
                    name = name || type;
                    stackFunc = stackFunc || _assert.caller;
                    var t = typeof (arg);
    
                    if (t !== type) {
                            throw new assert.AssertionError({
                                    message: _(TYPE_REQUIRED, name, type),
                                    actual: t,
                                    expected: type,
                                    operator: '===',
                                    stackStartFunction: stackFunc
                            });
                    }
            }
    }
    
    
    function _instanceof(arg, type, name, stackFunc) {
            if (!NDEBUG) {
                    name = name || type;
                    stackFunc = stackFunc || _instanceof.caller;
    
                    if (!(arg instanceof type)) {
                            throw new assert.AssertionError({
                                    message: _(TYPE_REQUIRED, name, type.name),
                                    actual: _getClass(arg),
                                    expected: type.name,
                                    operator: 'instanceof',
                                    stackStartFunction: stackFunc
                            });
                    }
            }
    }
    
    function _getClass(object) {
            return (Object.prototype.toString.call(object).slice(8, -1));
    };
    
    
    
    ///--- API
    
    function array(arr, type, name) {
            if (!NDEBUG) {
                    name = name || type;
    
                    if (!Array.isArray(arr)) {
                            throw new assert.AssertionError({
                                    message: _(ARRAY_TYPE_REQUIRED, name, type),
                                    actual: typeof (arr),
                                    expected: 'array',
                                    operator: 'Array.isArray',
                                    stackStartFunction: array.caller
                            });
                    }
    
                    for (var i = 0; i < arr.length; i++) {
                            _assert(arr[i], type, name, array);
                    }
            }
    }
    
    
    function bool(arg, name) {
            _assert(arg, 'boolean', name, bool);
    }
    
    
    function buffer(arg, name) {
            if (!Buffer.isBuffer(arg)) {
                    throw new assert.AssertionError({
                            message: _(TYPE_REQUIRED, name || '', 'Buffer'),
                            actual: typeof (arg),
                            expected: 'buffer',
                            operator: 'Buffer.isBuffer',
                            stackStartFunction: buffer
                    });
            }
    }
    
    
    function func(arg, name) {
            _assert(arg, 'function', name);
    }
    
    
    function number(arg, name) {
            _assert(arg, 'number', name);
            if (!NDEBUG && (isNaN(arg) || !isFinite(arg))) {
                    throw new assert.AssertionError({
                            message: _(TYPE_REQUIRED, name, 'number'),
                            actual: arg,
                            expected: 'number',
                            operator: 'isNaN',
                            stackStartFunction: number
                    });
            }
    }
    
    
    function object(arg, name) {
            _assert(arg, 'object', name);
    }
    
    
    function stream(arg, name) {
            _instanceof(arg, Stream, name);
    }
    
    
    function date(arg, name) {
            _instanceof(arg, Date, name);
    }
    
    function regexp(arg, name) {
            _instanceof(arg, RegExp, name);
    }
    
    
    function string(arg, name) {
            _assert(arg, 'string', name);
    }
    
    
    function uuid(arg, name) {
            string(arg, name);
            if (!NDEBUG && !UUID_REGEXP.test(arg)) {
                    throw new assert.AssertionError({
                            message: _(TYPE_REQUIRED, name, 'uuid'),
                            actual: 'string',
                            expected: 'uuid',
                            operator: 'test',
                            stackStartFunction: uuid
                    });
            }
    }
    
    
    ///--- Exports
    
    module.exports = {
            bool: bool,
            buffer: buffer,
            date: date,
            func: func,
            number: number,
            object: object,
            regexp: regexp,
            stream: stream,
            string: string,
            uuid: uuid
    };
    
    
    Object.keys(module.exports).forEach(function (k) {
            if (k === 'buffer')
                    return;
    
            var name = 'arrayOf' + capitalize(k);
    
            if (k === 'bool')
                    k = 'boolean';
            if (k === 'func')
                    k = 'function';
            module.exports[name] = function (arg, name) {
                    array(arg, k, name);
            };
    });
    
    Object.keys(module.exports).forEach(function (k) {
            var _name = 'optional' + capitalize(k);
            var s = uncapitalize(k.replace('arrayOf', ''));
            if (s === 'bool')
                    s = 'boolean';
            if (s === 'func')
                    s = 'function';
    
            if (k.indexOf('arrayOf') !== -1) {
              module.exports[_name] = function (arg, name) {
                      if (!NDEBUG && arg !== undefined) {
                              array(arg, s, name);
                      }
              };
            } else {
              module.exports[_name] = function (arg, name) {
                      if (!NDEBUG && arg !== undefined) {
                              _assert(arg, s, name);
                      }
              };
            }
    });
    
    
    // Reexport built-in assertions
    Object.keys(assert).forEach(function (k) {
            if (k === 'AssertionError') {
                    module.exports[k] = assert[k];
                    return;
            }
    
            module.exports[k] = function () {
                    if (!NDEBUG) {
                            assert[k].apply(assert[k], arguments);
                    }
            };
    });
    
  provide("assert-plus", module.exports);
}(global));

// pakmanager:asn1/lib/ber/types
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    
    module.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9, // float
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
    
  provide("asn1/lib/ber/types", module.exports);
}(global));

// pakmanager:asn1/lib/ber/errors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    
    module.exports = {
    
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        e.name = 'InvalidAsn1Error';
        e.message = msg || '';
        return e;
      }
    
    };
    
  provide("asn1/lib/ber/errors", module.exports);
}(global));

// pakmanager:asn1/lib/ber/reader
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    var assert = require('assert');
    
    var ASN1 =  require('asn1/lib/ber/types');
    var errors =  require('asn1/lib/ber/errors');
    
    
    ///--- Globals
    
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    
    
    
    ///--- API
    
    function Reader(data) {
      if (!data || !Buffer.isBuffer(data))
        throw new TypeError('data must be a node Buffer');
    
      this._buf = data;
      this._size = data.length;
    
      // These hold the "current" state
      this._len = 0;
      this._offset = 0;
    
      var self = this;
      this.__defineGetter__('length', function() { return self._len; });
      this.__defineGetter__('offset', function() { return self._offset; });
      this.__defineGetter__('remain', function() {
        return self._size - self._offset;
      });
      this.__defineGetter__('buffer', function() {
        return self._buf.slice(self._offset);
      });
    }
    
    
    /**
     * Reads a single byte and advances offset; you can pass in `true` to make this
     * a "peek" operation (i.e., get the byte, but don't advance the offset).
     *
     * @param {Boolean} peek true means don't move offset.
     * @return {Number} the next byte, null if not enough data.
     */
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1)
        return null;
    
      var b = this._buf[this._offset] & 0xff;
    
      if (!peek)
        this._offset += 1;
    
      return b;
    };
    
    
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    
    
    /**
     * Reads a (potentially) variable length off the BER buffer.  This call is
     * not really meant to be called directly, as callers have to manipulate
     * the internal buffer afterwards.
     *
     * As a result of this call, you can call `Reader.length`, until the
     * next thing called that does a readLength.
     *
     * @return {Number} the amount of offset to advance the buffer.
     * @throws {InvalidAsn1Error} on bad ASN.1
     */
    Reader.prototype.readLength = function(offset) {
      if (offset === undefined)
        offset = this._offset;
    
      if (offset >= this._size)
        return null;
    
      var lenB = this._buf[offset++] & 0xff;
      if (lenB === null)
        return null;
    
      if ((lenB & 0x80) == 0x80) {
        lenB &= 0x7f;
    
        if (lenB == 0)
          throw newInvalidAsn1Error('Indefinite length not supported');
    
        if (lenB > 4)
          throw newInvalidAsn1Error('encoding too long');
    
        if (this._size - offset < lenB)
          return null;
    
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 0xff);
    
      } else {
        // Wasn't a variable length
        this._len = lenB;
      }
    
      return offset;
    };
    
    
    /**
     * Parses the next sequence in this BER buffer.
     *
     * To get the length of the sequence, call `Reader.length`.
     *
     * @return {Number} the sequence's tag.
     */
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== undefined && tag !== seq)
        throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                                  ': got 0x' + seq.toString(16));
    
      var o = this.readLength(this._offset + 1); // stored in `length`
      if (o === null)
        return null;
    
      this._offset = o;
      return seq;
    };
    
    
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    
    
    Reader.prototype.readBoolean = function() {
      return (this._readTag(ASN1.Boolean) === 0 ? false : true);
    };
    
    
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    
    
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
    
      var b = this.peek();
      if (b === null)
        return null;
    
      if (b !== tag)
        throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                                  ': got 0x' + b.toString(16));
    
      var o = this.readLength(this._offset + 1); // stored in `length`
    
      if (o === null)
        return null;
    
      if (this.length > this._size - o)
        return null;
    
      this._offset = o;
    
      if (this.length === 0)
        return retbuf ? new Buffer(0) : '';
    
      var str = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
    
      return retbuf ? str : str.toString('utf8');
    };
    
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
    
      var b = this.readString(tag, true);
      if (b === null)
        return null;
    
      var values = [];
      var value = 0;
    
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 0xff;
    
        value <<= 7;
        value += byte & 0x7f;
        if ((byte & 0x80) == 0) {
          values.push(value);
          value = 0;
        }
      }
    
      value = values.shift();
      values.unshift(value % 40);
      values.unshift((value / 40) >> 0);
    
      return values.join('.');
    };
    
    
    Reader.prototype._readTag = function(tag) {
      assert.ok(tag !== undefined);
    
      var b = this.peek();
    
      if (b === null)
        return null;
    
      if (b !== tag)
        throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                                  ': got 0x' + b.toString(16));
    
      var o = this.readLength(this._offset + 1); // stored in `length`
      if (o === null)
        return null;
    
      if (this.length > 4)
        throw newInvalidAsn1Error('Integer too long: ' + this.length);
    
      if (this.length > this._size - o)
        return null;
      this._offset = o;
    
      var fb = this._buf[this._offset];
      var value = 0;
    
      for (var i = 0; i < this.length; i++) {
        value <<= 8;
        value |= (this._buf[this._offset++] & 0xff);
      }
    
      if ((fb & 0x80) == 0x80 && i !== 4)
        value -= (1 << (i * 8));
    
      return value >> 0;
    };
    
    
    
    ///--- Exported API
    
    module.exports = Reader;
    
  provide("asn1/lib/ber/reader", module.exports);
}(global));

// pakmanager:asn1/lib/ber/writer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    var assert = require('assert');
    var ASN1 =  require('asn1/lib/ber/types');
    var errors =  require('asn1/lib/ber/errors');
    
    
    ///--- Globals
    
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    
    
    ///--- Helpers
    
    function merge(from, to) {
      assert.ok(from);
      assert.equal(typeof(from), 'object');
      assert.ok(to);
      assert.equal(typeof(to), 'object');
    
      var keys = Object.getOwnPropertyNames(from);
      keys.forEach(function(key) {
        if (to[key])
          return;
    
        var value = Object.getOwnPropertyDescriptor(from, key);
        Object.defineProperty(to, key, value);
      });
    
      return to;
    }
    
    
    
    ///--- API
    
    function Writer(options) {
      options = merge(DEFAULT_OPTS, options || {});
    
      this._buf = new Buffer(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
    
      // A list of offsets in the buffer where we need to insert
      // sequence tag/len pairs.
      this._seq = [];
    
      var self = this;
      this.__defineGetter__('buffer', function() {
        if (self._seq.length)
          throw new InvalidAsn1Error(self._seq.length + ' unended sequence(s)');
    
        return self._buf.slice(0, self._offset);
      });
    }
    
    
    Writer.prototype.writeByte = function(b) {
      if (typeof(b) !== 'number')
        throw new TypeError('argument must be a Number');
    
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    
    
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof(i) !== 'number')
        throw new TypeError('argument must be a Number');
      if (typeof(tag) !== 'number')
        tag = ASN1.Integer;
    
      var sz = 4;
    
      while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&
             (sz > 1)) {
        sz--;
        i <<= 8;
      }
    
      if (sz > 4)
        throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');
    
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
    
      while (sz-- > 0) {
        this._buf[this._offset++] = ((i & 0xff000000) >>> 24);
        i <<= 8;
      }
    
    };
    
    
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0x00);
    };
    
    
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof(i) !== 'number')
        throw new TypeError('argument must be a Number');
      if (typeof(tag) !== 'number')
        tag = ASN1.Enumeration;
    
      return this.writeInt(i, tag);
    };
    
    
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof(b) !== 'boolean')
        throw new TypeError('argument must be a Boolean');
      if (typeof(tag) !== 'number')
        tag = ASN1.Boolean;
    
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 0x01;
      this._buf[this._offset++] = b ? 0xff : 0x00;
    };
    
    
    Writer.prototype.writeString = function(s, tag) {
      if (typeof(s) !== 'string')
        throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
      if (typeof(tag) !== 'number')
        tag = ASN1.OctetString;
    
      var len = Buffer.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    
    
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof(tag) !== 'number')
        throw new TypeError('tag must be a number');
      if (!Buffer.isBuffer(buf))
        throw new TypeError('argument must be a buffer');
    
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    
    
    Writer.prototype.writeStringArray = function(strings) {
      if ((!strings instanceof Array))
        throw new TypeError('argument must be an Array[String]');
    
      var self = this;
      strings.forEach(function(s) {
        self.writeString(s);
      });
    };
    
    // This is really to solve DER cases, but whatever for now
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof(s) !== 'string')
        throw new TypeError('argument must be a string');
      if (typeof(tag) !== 'number')
        tag = ASN1.OID;
    
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error('argument is not a valid OID string');
    
      function encodeOctet(bytes, octet) {
        if (octet < 128) {
            bytes.push(octet);
        } else if (octet < 16384) {
            bytes.push((octet >>> 7) | 0x80);
            bytes.push(octet & 0x7F);
        } else if (octet < 2097152) {
          bytes.push((octet >>> 14) | 0x80);
          bytes.push(((octet >>> 7) | 0x80) & 0xFF);
          bytes.push(octet & 0x7F);
        } else if (octet < 268435456) {
          bytes.push((octet >>> 21) | 0x80);
          bytes.push(((octet >>> 14) | 0x80) & 0xFF);
          bytes.push(((octet >>> 7) | 0x80) & 0xFF);
          bytes.push(octet & 0x7F);
        } else {
          bytes.push(((octet >>> 28) | 0x80) & 0xFF);
          bytes.push(((octet >>> 21) | 0x80) & 0xFF);
          bytes.push(((octet >>> 14) | 0x80) & 0xFF);
          bytes.push(((octet >>> 7) | 0x80) & 0xFF);
          bytes.push(octet & 0x7F);
        }
      }
    
      var tmp = s.split('.');
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
    
      var self = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self.writeByte(b);
      });
    };
    
    
    Writer.prototype.writeLength = function(len) {
      if (typeof(len) !== 'number')
        throw new TypeError('argument must be a Number');
    
      this._ensure(4);
    
      if (len <= 0x7f) {
        this._buf[this._offset++] = len;
      } else if (len <= 0xff) {
        this._buf[this._offset++] = 0x81;
        this._buf[this._offset++] = len;
      } else if (len <= 0xffff) {
        this._buf[this._offset++] = 0x82;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 0xffffff) {
        this._buf[this._offset++] = 0x83;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
      }
    };
    
    Writer.prototype.startSequence = function(tag) {
      if (typeof(tag) !== 'number')
        tag = ASN1.Sequence | ASN1.Constructor;
    
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    
    
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
    
      if (len <= 0x7f) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 0xff) {
        this._shift(start, len, -1);
        this._buf[seq] = 0x81;
        this._buf[seq + 1] = len;
      } else if (len <= 0xffff) {
        this._buf[seq] = 0x82;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 0xffffff) {
        this._shift(start, len, 1);
        this._buf[seq] = 0x83;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw new InvalidAsn1Error('Sequence too long');
      }
    };
    
    
    Writer.prototype._shift = function(start, len, shift) {
      assert.ok(start !== undefined);
      assert.ok(len !== undefined);
      assert.ok(shift);
    
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    
    Writer.prototype._ensure = function(len) {
      assert.ok(len);
    
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
    
        var buf = new Buffer(sz);
    
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    
    
    
    ///--- Exported API
    
    module.exports = Writer;
    
  provide("asn1/lib/ber/writer", module.exports);
}(global));

// pakmanager:asn1/lib/ber/index
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    var errors =  require('asn1/lib/ber/errors');
    var types =  require('asn1/lib/ber/types');
    
    var Reader =  require('asn1/lib/ber/reader');
    var Writer =  require('asn1/lib/ber/writer');
    
    
    ///--- Exports
    
    module.exports = {
    
      Reader: Reader,
    
      Writer: Writer
    
    };
    
    for (var t in types) {
      if (types.hasOwnProperty(t))
        module.exports[t] = types[t];
    }
    for (var e in errors) {
      if (errors.hasOwnProperty(e))
        module.exports[e] = errors[e];
    }
    
  provide("asn1/lib/ber/index", module.exports);
}(global));

// pakmanager:asn1
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    // If you have no idea what ASN.1 or BER is, see this:
    // ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc
    
    var Ber =  require('asn1/lib/ber/index');
    
    
    
    ///--- Exported API
    
    module.exports = {
    
      Ber: Ber,
    
      BerReader: Ber.Reader,
    
      BerWriter: Ber.Writer
    
    };
    
  provide("asn1", module.exports);
}(global));

// pakmanager:ctype/ctf.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * ctf.js
     *
     * Understand and parse all of the different JSON formats of CTF data and
     * translate that into a series of node-ctype friendly pieces. The reason for
     * the abstraction is to handle different changes in the file format.
     *
     * We have to be careful here that we don't end up using a name that is already
     * a built in type.
     */
    var mod_assert = require('assert');
    var ASSERT = mod_assert.ok;
    
    var ctf_versions = [ '1.0' ];
    var ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];
    var ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',
        'uint32_t', 'float', 'double' ];
    
    function ctfParseInteger(entry, ctype)
    {
    	var name, sign, len, type;
    
    	name = entry['name'];
    	if (!('signed' in entry['integer']))
    		throw (new Error('Malformed CTF JSON: integer missing ' +
    		    'signed value'));
    
    
    	if (!('length' in entry['integer']))
    		throw (new Error('Malformed CTF JSON: integer missing ' +
    		    'length value'));
    
    	sign = entry['integer']['signed'];
    	len = entry['integer']['length'];
    	type = null;
    
    	if (sign && len == 1)
    		type = 'int8_t';
    	else if (len == 1)
    		type = 'uint8_t';
    	else if (sign && len == 2)
    		type = 'int16_t';
    	else if (len == 2)
    		type = 'uint16_t';
    	else if (sign && len == 4)
    		type = 'int32_t';
    	else if (len == 4)
    		type = 'uint32_t';
    	else if (sign && len == 8)
    		type = 'int64_t';
    	else if (len == 8)
    		type = 'uint64_t';
    
    	if (type === null)
    		throw (new Error('Malformed CTF JSON: integer has ' +
    		    'unsupported length and sign - ' + len + '/' + sign));
    
    	/*
    	 * This means that this is the same as one of our built in types. If
    	 * that's the case defining it would be an error. So instead of trying
    	 * to typedef it, we'll return here.
    	 */
    	if (name == type)
    		return;
    
    	if (name == 'char') {
    		ASSERT(type == 'int8_t');
    		return;
    	}
    
    	ctype.typedef(name, type);
    }
    
    function ctfParseFloat(entry, ctype)
    {
    	var name, len;
    
    	name = entry['name'];
    	if (!('length' in entry['float']))
    		throw (new Error('Malformed CTF JSON: float missing ' +
    		    'length value'));
    
    	len = entry['float']['length'];
    	if (len != 4 && len != 8)
    		throw (new Error('Malformed CTF JSON: float has invalid ' +
    		    'length value'));
    
    	if (len == 4) {
    		if (name == 'float')
    			return;
    		ctype.typedef(name, 'float');
    	} else if (len == 8) {
    		if (name == 'double')
    			return;
    		ctype.typedef(name, 'double');
    	}
    }
    
    function ctfParseTypedef(entry, ctype)
    {
    	var name, type, ii;
    
    	name = entry['name'];
    	if (typeof (entry['typedef']) != 'string')
    		throw (new Error('Malformed CTF JSON: typedef value in not ' +
    		    'a string'));
    
    	type = entry['typedef'];
    
    	/*
    	 * We need to ensure that we're not looking at type that's one of our
    	 * built in types. Traditionally in C a uint32_t would be a typedef to
    	 * some kind of integer. However, those size types are built ins.
    	 */
    	for (ii = 0; ii < ctf_deftypes.length; ii++) {
    		if (name == ctf_deftypes[ii])
    			return;
    	}
    
    	ctype.typedef(name, type);
    }
    
    function ctfParseStruct(entry, ctype)
    {
    	var name, type, ii, val, index, member, push;
    
    	member = [];
    	if (!Array.isArray(entry['struct']))
    		throw (new Error('Malformed CTF JSON: struct value is not ' +
    		    'an array'));
    
    	for (ii = 0; ii < entry['struct'].length; ii++) {
    		val = entry['struct'][ii];
    		if (!('name' in val))
    			throw (new Error('Malformed CTF JSON: struct member ' +
    			    'missing name'));
    
    		if (!('type' in val))
    			throw (new Error('Malformed CTF JSON: struct member ' +
    			    'missing type'));
    
    		if (typeof (val['name']) != 'string')
    			throw (new Error('Malformed CTF JSON: struct member ' +
    			    'name isn\'t a string'));
    
    		if (typeof (val['type']) != 'string')
    			throw (new Error('Malformed CTF JSON: struct member ' +
    			    'type isn\'t a string'));
    
    		/*
    		 * CTF version 2 specifies array names as <type> [<num>] where
    		 * as node-ctype does this as <type>[<num>].
    		 */
    		name = val['name'];
    		type = val['type'];
    		index = type.indexOf(' [');
    		if (index != -1) {
    			type = type.substring(0, index) +
    			    type.substring(index + 1, type.length);
    		}
    		push = {};
    		push[name] = { 'type': type };
    		member.push(push);
    	}
    
    	name = entry['name'];
    	ctype.typedef(name, member);
    }
    
    function ctfParseEntry(entry, ctype)
    {
    	var ii, found;
    
    	if (!('name' in entry))
    		throw (new Error('Malformed CTF JSON: entry missing "name" ' +
    		    'section'));
    
    	for (ii = 0; ii < ctf_entries.length; ii++) {
    		if (ctf_entries[ii] in entry)
    			found++;
    	}
    
    	if (found === 0)
    		throw (new Error('Malformed CTF JSON: found no entries'));
    
    	if (found >= 2)
    		throw (new Error('Malformed CTF JSON: found more than one ' +
    		    'entry'));
    
    	if ('integer' in entry) {
    		ctfParseInteger(entry, ctype);
    		return;
    	}
    
    	if ('float' in entry) {
    		ctfParseFloat(entry, ctype);
    		return;
    	}
    
    	if ('typedef' in entry) {
    		ctfParseTypedef(entry, ctype);
    		return;
    	}
    
    	if ('struct' in entry) {
    		ctfParseStruct(entry, ctype);
    		return;
    	}
    
    	ASSERT(false, 'shouldn\'t reach here');
    }
    
    function ctfParseJson(json, ctype)
    {
    	var version, ii;
    
    	ASSERT(json);
    	ASSERT(ctype);
    	if (!('metadata' in json))
    		throw (new Error('Invalid CTF JSON: missing metadata section'));
    
    	if (!('ctf2json_version' in json['metadata']))
    		throw (new Error('Invalid CTF JSON: missing ctf2json_version'));
    
    	version = json['metadata']['ctf2json_version'];
    	for (ii = 0; ii < ctf_versions.length; ii++) {
    		if (ctf_versions[ii] == version)
    			break;
    	}
    
    	if (ii == ctf_versions.length)
    		throw (new Error('Unsuported ctf2json_version: ' + version));
    
    	if (!('data' in json))
    		throw (new Error('Invalid CTF JSON: missing data section'));
    
    	if (!Array.isArray(json['data']))
    		throw (new Error('Malformed CTF JSON: data section is not ' +
    		    'an array'));
    
    	for (ii = 0; ii < json['data'].length; ii++)
    		ctfParseEntry(json['data'][ii], ctype);
    }
    
    exports.ctfParseJson = ctfParseJson;
    
  provide("ctype/ctf.js", module.exports);
}(global));

// pakmanager:ctype/ctio.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * rm - Feb 2011
     * ctio.js:
     *
     * A simple way to read and write simple ctypes. Of course, as you'll find the
     * code isn't as simple as it might appear. The following types are currently
     * supported in big and little endian formats:
     *
     * 	uint8_t			int8_t
     * 	uint16_t		int16_t
     * 	uint32_t		int32_t
     *	float (single precision IEEE 754)
     *	double (double precision IEEE 754)
     *
     * This is designed to work in Node and v8. It may in fact work in other
     * Javascript interpreters (that'd be pretty neat), but it hasn't been tested.
     * If you find that it does in fact work, that's pretty cool. Try and pass word
     * back to the original author.
     *
     * Note to the reader: If you're tabstop isn't set to 8, parts of this may look
     * weird.
     */
    
    /*
     * Numbers in Javascript have a secret: all numbers must be represented with an
     * IEEE-754 double. The double has a mantissa with a length of 52 bits with an
     * implicit one. Thus the range of integers that can be represented is limited
     * to the size of the mantissa, this makes reading and writing 64-bit integers
     * difficult, but far from impossible.
     *
     * Another side effect of this representation is what happens when you use the
     * bitwise operators, i.e. shift left, shift right, and, or, etc. In Javascript,
     * each operand and the result is cast to a signed 32-bit number. However, in
     * the case of >>> the values are cast to an unsigned number.
     */
    
    /*
     * A reminder on endian related issues:
     *
     * Big Endian: MSB -> First byte
     * Little Endian: MSB->Last byte
     */
    var mod_assert = require('assert');
    
    /*
     * An 8 bit unsigned integer involves doing no significant work.
     */
    function ruint8(buffer, endian, offset)
    {
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	return (buffer[offset]);
    }
    
    /*
     * For 16 bit unsigned numbers we can do all the casting that we want to do.
     */
    function rgint16(buffer, endian, offset)
    {
    	var val = 0;
    
    	if (endian == 'big') {
    		val = buffer[offset] << 8;
    		val |=  buffer[offset+1];
    	} else {
    		val = buffer[offset];
    		val |= buffer[offset+1] << 8;
    	}
    
    	return (val);
    
    }
    
    function ruint16(buffer, endian, offset)
    {
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 1 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	return (rgint16(buffer, endian, offset));
    }
    
    /*
     * Because most bitshifting is done using signed numbers, if we would go into
     * the realm where we use that 32nd bit, we'll end up going into the negative
     * range. i.e.:
     * > 200 << 24
     * -939524096
     *
     * Not the value you'd expect. To work around this, we end up having to do some
     * abuse of the JavaScript standard. in this case, we know that a >>> shift is
     * defined to cast our value to an *unsigned* 32-bit number. Because of that, we
     * use that instead to save us some additional math, though it does feel a
     * little weird and it isn't obvious as to why you woul dwant to do this at
     * first.
     */
    function rgint32(buffer, endian, offset)
    {
    	var val = 0;
    
    	if (endian == 'big') {
    		val = buffer[offset+1] << 16;
    		val |= buffer[offset+2] << 8;
    		val |= buffer[offset+3];
    		val = val + (buffer[offset] << 24 >>> 0);
    	} else {
    		val = buffer[offset+2] << 16;
    		val |= buffer[offset+1] << 8;
    		val |= buffer[offset];
    		val = val + (buffer[offset + 3] << 24 >>> 0);
    	}
    
    	return (val);
    }
    
    function ruint32(buffer, endian, offset)
    {
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	return (rgint32(buffer, endian, offset));
    }
    
    /*
     * Reads a 64-bit unsigned number. The astue observer will note that this
     * doesn't quite work. Javascript has chosen to only have numbers that can be
     * represented by a double. A double only has 52 bits of mantissa with an
     * implicit 1, thus we have up to 53 bits to represent an integer. However, 2^53
     * doesn't quite give us what we want. Isn't 53 bits enough for anyone? What
     * could you have possibly wanted to represent that was larger than that? Oh,
     * maybe a size? You mean we bypassed the 4 GB limit on file sizes, when did
     * that happen?
     *
     * To get around this egregious language issue, we're going to instead construct
     * an array of two 32 bit unsigned integers. Where arr[0] << 32 + arr[1] would
     * give the actual number. However, note that the above code probably won't
     * produce the desired results because of the way Javascript numbers are
     * doubles.
     */
    function rgint64(buffer, endian, offset)
    {
    	var val = new Array(2);
    
    	if (endian == 'big') {
    		val[0] = ruint32(buffer, endian, offset);
    		val[1] = ruint32(buffer, endian, offset+4);
    	} else {
    		val[0] = ruint32(buffer, endian, offset+4);
    		val[1] = ruint32(buffer, endian, offset);
    	}
    
    	return (val);
    }
    
    function ruint64(buffer, endian, offset)
    {
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 7 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	return (rgint64(buffer, endian, offset));
    }
    
    
    /*
     * Signed integer types, yay team! A reminder on how two's complement actually
     * works. The first bit is the signed bit, i.e. tells us whether or not the
     * number should be positive or negative. If the two's complement value is
     * positive, then we're done, as it's equivalent to the unsigned representation.
     *
     * Now if the number is positive, you're pretty much done, you can just leverage
     * the unsigned translations and return those. Unfortunately, negative numbers
     * aren't quite that straightforward.
     *
     * At first glance, one might be inclined to use the traditional formula to
     * translate binary numbers between the positive and negative values in two's
     * complement. (Though it doesn't quite work for the most negative value)
     * Mainly:
     *  - invert all the bits
     *  - add one to the result
     *
     * Of course, this doesn't quite work in Javascript. Take for example the value
     * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
     * course, Javascript will do the following:
     *
     * > ~0xff80
     * -65409
     *
     * Whoh there, Javascript, that's not quite right. But wait, according to
     * Javascript that's perfectly correct. When Javascript ends up seeing the
     * constant 0xff80, it has no notion that it is actually a signed number. It
     * assumes that we've input the unsigned value 0xff80. Thus, when it does the
     * binary negation, it casts it into a signed value, (positive 0xff80). Then
     * when you perform binary negation on that, it turns it into a negative number.
     *
     * Instead, we're going to have to use the following general formula, that works
     * in a rather Javascript friendly way. I'm glad we don't support this kind of
     * weird numbering scheme in the kernel.
     *
     * (BIT-MAX - (unsigned)val + 1) * -1
     *
     * The astute observer, may think that this doesn't make sense for 8-bit numbers
     * (really it isn't necessary for them). However, when you get 16-bit numbers,
     * you do. Let's go back to our prior example and see how this will look:
     *
     * (0xffff - 0xff80 + 1) * -1
     * (0x007f + 1) * -1
     * (0x0080) * -1
     *
     * Doing it this way ends up allowing us to treat it appropriately in
     * Javascript. Sigh, that's really quite ugly for what should just be a few bit
     * shifts, ~ and &.
     */
    
    /*
     * Endianness doesn't matter for 8-bit signed values. We could in fact optimize
     * this case because the more traditional methods work, but for consistency,
     * we'll keep doing this the same way.
     */
    function rsint8(buffer, endian, offset)
    {
    	var neg;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	neg = buffer[offset] & 0x80;
    	if (!neg)
    		return (buffer[offset]);
    
    	return ((0xff - buffer[offset] + 1) * -1);
    }
    
    /*
     * The 16-bit version requires a bit more effort. In this case, we can leverage
     * our unsigned code to generate the value we want to return.
     */
    function rsint16(buffer, endian, offset)
    {
    	var neg, val;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 1 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = rgint16(buffer, endian, offset);
    	neg = val & 0x8000;
    	if (!neg)
    		return (val);
    
    	return ((0xffff - val + 1) * -1);
    }
    
    /*
     * We really shouldn't leverage our 32-bit code here and instead utilize the
     * fact that we know that since these are signed numbers, we can do all the
     * shifting and binary anding to generate the 32-bit number. But, for
     * consistency we'll do the same. If we want to do otherwise, we should instead
     * make the 32 bit unsigned code do the optimization. But as long as there
     * aren't floats secretly under the hood for that, we /should/ be okay.
     */
    function rsint32(buffer, endian, offset)
    {
    	var neg, val;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = rgint32(buffer, endian, offset);
    	neg = val & 0x80000000;
    	if (!neg)
    		return (val);
    
    	return ((0xffffffff - val + 1) * -1);
    }
    
    /*
     * The signed version of this code suffers from all of the same problems of the
     * other 64 bit version.
     */
    function rsint64(buffer, endian, offset)
    {
    	var neg, val;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = rgint64(buffer, endian, offset);
    	neg = val[0] & 0x80000000;
    
    	if (!neg)
    		return (val);
    
    	val[0] = (0xffffffff - val[0]) * -1;
    	val[1] = (0xffffffff - val[1] + 1) * -1;
    
    	/*
    	 * If we had the key 0x8000000000000000, that would leave the lower 32
    	 * bits as 0xffffffff, however, since we're goint to add one, that would
    	 * actually leave the lower 32-bits as 0x100000000, which would break
    	 * our ability to write back a value that we received. To work around
    	 * this, if we actually get that value, we're going to bump the upper
    	 * portion by 1 and set this to zero.
    	 */
    	mod_assert.ok(val[1] <= 0x100000000);
    	if (val[1] == -0x100000000) {
    		val[1] = 0;
    		val[0]--;
    	}
    
    	return (val);
    }
    
    /*
     * We now move onto IEEE 754: The traditional form for floating point numbers
     * and what is secretly hiding at the heart of everything in this. I really hope
     * that someone is actually using this, as otherwise, this effort is probably
     * going to be more wasted.
     *
     * One might be tempted to use parseFloat here, but that wouldn't work at all
     * for several reasons. Mostly due to the way floats actually work, and
     * parseFloat only actually works in base 10. I don't see base 10 anywhere near
     * this file.
     *
     * In this case we'll implement the single and double precision versions. The
     * quadruple precision, while probably useful, wouldn't really be accepted by
     * Javascript, so let's not even waste our time.
     *
     * So let's review how this format looks like. A single precision value is 32
     * bits and has three parts:
     *   -  Sign bit
     *   -  Exponent (Using bias notation)
     *   -  Mantissa
     *
     * |s|eeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmm|
     * 31| 30-23  |  22    	-       0       |
     *
     * The exponent is stored in a biased input. The bias in this case 127.
     * Therefore, our exponent is equal to the 8-bit value - 127.
     *
     * By default, a number is normalized in IEEE, that means that the mantissa has
     * an implicit one that we don't see. So really the value stored is 1.m.
     * However, if the exponent is all zeros, then instead we have to shift
     * everything to the right one and there is no more implicit one.
     *
     * Special values:
     *  - Positive Infinity:
     *	Sign:		0
     *	Exponent: 	All 1s
     *	Mantissa:	0
     *  - Negative Infinity:
     *	Sign:		1
     *	Exponent: 	All 1s
     *	Mantissa:	0
     *  - NaN:
     *	Sign:		*
     *	Exponent: 	All 1s
     *	Mantissa:	non-zero
     *  - Zero:
     *	Sign:		*
     *	Exponent:	All 0s
     *	Mantissa:	0
     *
     * In the case of zero, the sign bit determines whether we get a positive or
     * negative zero. However, since Javascript cannot determine the difference
     * between the two: i.e. -0 == 0, we just always return 0.
     *
     */
    function rfloat(buffer, endian, offset)
    {
    	var bytes = [];
    	var sign, exponent, mantissa, val;
    	var bias = 127;
    	var maxexp = 0xff;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	/* Normalize the bytes to be in endian order */
    	if (endian == 'big') {
    		bytes[0] = buffer[offset];
    		bytes[1] = buffer[offset+1];
    		bytes[2] = buffer[offset+2];
    		bytes[3] = buffer[offset+3];
    	} else {
    		bytes[3] = buffer[offset];
    		bytes[2] = buffer[offset+1];
    		bytes[1] = buffer[offset+2];
    		bytes[0] = buffer[offset+3];
    	}
    
    	sign = bytes[0] & 0x80;
    	exponent = (bytes[0] & 0x7f) << 1;
    	exponent |= (bytes[1] & 0x80) >>> 7;
    	mantissa = (bytes[1] & 0x7f) << 16;
    	mantissa |= bytes[2] << 8;
    	mantissa |= bytes[3];
    
    	/* Check for special cases before we do general parsing */
    	if (!sign && exponent == maxexp && mantissa === 0)
    		return (Number.POSITIVE_INFINITY);
    
    	if (sign && exponent == maxexp && mantissa === 0)
    		return (Number.NEGATIVE_INFINITY);
    
    	if (exponent == maxexp && mantissa !== 0)
    		return (Number.NaN);
    
    	/*
    	 * Javascript really doesn't have support for positive or negative zero.
    	 * So we're not going to try and give it to you. That would be just
    	 * plain weird. Besides -0 == 0.
    	 */
    	if (exponent === 0 && mantissa === 0)
    		return (0);
    
    	/*
    	 * Now we can deal with the bias and the determine whether the mantissa
    	 * has the implicit one or not.
    	 */
    	exponent -= bias;
    	if (exponent == -bias) {
    		exponent++;
    		val = 0;
    	} else {
    		val = 1;
    	}
    
    	val = (val + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);
    
    	if (sign)
    		val *= -1;
    
    	return (val);
    }
    
    /*
     * Doubles in IEEE 754 are like their brothers except for a few changes and
     * increases in size:
     *   - The exponent is now 11 bits
     *   - The mantissa is now 52 bits
     *   - The bias is now 1023
     *
     * |s|eeeeeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|
     * 63| 62 - 52   | 	51		-			0     |
     * 63| 62 - 52   |      51              -                       0     |
     *
     * While the size has increased a fair amount, we're going to end up keeping the
     * same general formula for calculating the final value. As a reminder, this
     * formula is:
     *
     * (-1)^s * (n + m) * 2^(e-b)
     *
     * Where:
     *	s	is the sign bit
     *	n	is (exponent > 0) ? 1 : 0 -- Determines whether we're normalized
     *					     or not
     *	m	is the mantissa
     *	e	is the exponent specified
     *	b	is the bias for the exponent
     *
     */
    function rdouble(buffer, endian, offset)
    {
    	var bytes = [];
    	var sign, exponent, mantissa, val, lowmant;
    	var bias = 1023;
    	var maxexp = 0x7ff;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 7 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	/* Normalize the bytes to be in endian order */
    	if (endian == 'big') {
    		bytes[0] = buffer[offset];
    		bytes[1] = buffer[offset+1];
    		bytes[2] = buffer[offset+2];
    		bytes[3] = buffer[offset+3];
    		bytes[4] = buffer[offset+4];
    		bytes[5] = buffer[offset+5];
    		bytes[6] = buffer[offset+6];
    		bytes[7] = buffer[offset+7];
    	} else {
    		bytes[7] = buffer[offset];
    		bytes[6] = buffer[offset+1];
    		bytes[5] = buffer[offset+2];
    		bytes[4] = buffer[offset+3];
    		bytes[3] = buffer[offset+4];
    		bytes[2] = buffer[offset+5];
    		bytes[1] = buffer[offset+6];
    		bytes[0] = buffer[offset+7];
    	}
    
    	/*
    	 * We can construct the exponent and mantissa the same way as we did in
    	 * the case of a float, just increase the range of the exponent.
    	 */
    	sign = bytes[0] & 0x80;
    	exponent = (bytes[0] & 0x7f) << 4;
    	exponent |= (bytes[1] & 0xf0) >>> 4;
    
    	/*
    	 * This is going to be ugly but then again, we're dealing with IEEE 754.
    	 * This could probably be done as a node add on in a few lines of C++,
    	 * but oh we'll, we've made it this far so let's be native the rest of
    	 * the way...
    	 *
    	 * What we're going to do is break the mantissa into two parts, the
    	 * lower 24 bits and the upper 28 bits. We'll multiply the upper 28 bits
    	 * by the appropriate power and then add in the lower 24-bits. Not
    	 * really that great. It's pretty much a giant kludge to deal with
    	 * Javascript eccentricities around numbers.
    	 */
    	lowmant = bytes[7];
    	lowmant |= bytes[6] << 8;
    	lowmant |= bytes[5] << 16;
    	mantissa = bytes[4];
    	mantissa |= bytes[3] << 8;
    	mantissa |= bytes[2] << 16;
    	mantissa |= (bytes[1] & 0x0f) << 24;
    	mantissa *= Math.pow(2, 24); /* Equivalent to << 24, but JS compat */
    	mantissa += lowmant;
    
    	/* Check for special cases before we do general parsing */
    	if (!sign && exponent == maxexp && mantissa === 0)
    		return (Number.POSITIVE_INFINITY);
    
    	if (sign && exponent == maxexp && mantissa === 0)
    		return (Number.NEGATIVE_INFINITY);
    
    	if (exponent == maxexp && mantissa !== 0)
    		return (Number.NaN);
    
    	/*
    	 * Javascript really doesn't have support for positive or negative zero.
    	 * So we're not going to try and give it to you. That would be just
    	 * plain weird. Besides -0 == 0.
    	 */
    	if (exponent === 0 && mantissa === 0)
    		return (0);
    
    	/*
    	 * Now we can deal with the bias and the determine whether the mantissa
    	 * has the implicit one or not.
    	 */
    	exponent -= bias;
    	if (exponent == -bias) {
    		exponent++;
    		val = 0;
    	} else {
    		val = 1;
    	}
    
    	val = (val + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);
    
    	if (sign)
    		val *= -1;
    
    	return (val);
    }
    
    /*
     * Now that we have gone through the pain of reading the individual types, we're
     * probably going to want some way to write these back. None of this is going to
     * be good. But since we have Javascript numbers this should certainly be more
     * interesting. Though we can constrain this end a little bit more in what is
     * valid. For now, let's go back to our friends the unsigned value.
     */
    
    /*
     * Unsigned numbers seem deceptively easy. Here are the general steps and rules
     * that we are going to take:
     *   -  If the number is negative, throw an Error
     *   -  Truncate any floating point portion
     *   -  Take the modulus of the number in our base
     *   -  Write it out to the buffer in the endian format requested at the offset
     */
    
    /*
     * We have to make sure that the value is a valid integer. This means that it is
     * non-negative. It has no fractional component and that it does not exceed the
     * maximum allowed value.
     *
     *	value		The number to check for validity
     *
     *	max		The maximum value
     */
    function prepuint(value, max)
    {
    	if (typeof (value) != 'number')
    		throw (new (Error('cannot write a non-number as a number')));
    
    	if (value < 0)
    		throw (new Error('specified a negative value for writing an ' +
    		    'unsigned value'));
    
    	if (value > max)
    		throw (new Error('value is larger than maximum value for ' +
    		    'type'));
    
    	if (Math.floor(value) !== value)
    		throw (new Error('value has a fractional component'));
    
    	return (value);
    }
    
    /*
     * 8-bit version, classy. We can ignore endianness which is good.
     */
    function wuint8(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepuint(value, 0xff);
    	buffer[offset] = val;
    }
    
    /*
     * Pretty much the same as the 8-bit version, just this time we need to worry
     * about endian related issues.
     */
    function wgint16(val, endian, buffer, offset)
    {
    	if (endian == 'big') {
    		buffer[offset] = (val & 0xff00) >>> 8;
    		buffer[offset+1] = val & 0x00ff;
    	} else {
    		buffer[offset+1] = (val & 0xff00) >>> 8;
    		buffer[offset] = val & 0x00ff;
    	}
    }
    
    function wuint16(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 1 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepuint(value, 0xffff);
    	wgint16(val, endian, buffer, offset);
    }
    
    /*
     * The 32-bit version is going to have to be a little different unfortunately.
     * We can't quite bitshift to get the largest byte, because that would end up
     * getting us caught by the signed values.
     *
     * And yes, we do want to subtract out the lower part by default. This means
     * that when we do the division, it will be treated as a bit shift and we won't
     * end up generating a floating point value. If we did generate a floating point
     * value we'd have to truncate it intelligently, this saves us that problem and
     * may even be somewhat faster under the hood.
     */
    function wgint32(val, endian, buffer, offset)
    {
    	if (endian == 'big') {
    		buffer[offset] = (val - (val & 0x00ffffff)) / Math.pow(2, 24);
    		buffer[offset+1] = (val >>> 16) & 0xff;
    		buffer[offset+2] = (val >>> 8) & 0xff;
    		buffer[offset+3] = val & 0xff;
    	} else {
    		buffer[offset+3] = (val - (val & 0x00ffffff)) /
    		    Math.pow(2, 24);
    		buffer[offset+2] = (val >>> 16) & 0xff;
    		buffer[offset+1] = (val >>> 8) & 0xff;
    		buffer[offset] = val & 0xff;
    	}
    }
    
    function wuint32(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepuint(value, 0xffffffff);
    	wgint32(val, endian, buffer, offset);
    }
    
    /*
     * Unlike the other versions, we expect the value to be in the form of two
     * arrays where value[0] << 32 + value[1] would result in the value that we
     * want.
     */
    function wgint64(value, endian, buffer, offset)
    {
    	if (endian == 'big') {
    		wgint32(value[0], endian, buffer, offset);
    		wgint32(value[1], endian, buffer, offset+4);
    	} else {
    		wgint32(value[0], endian, buffer, offset+4);
    		wgint32(value[1], endian, buffer, offset);
    	}
    }
    
    function wuint64(value, endian, buffer, offset)
    {
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (!(value instanceof Array))
    		throw (new Error('value must be an array'));
    
    	if (value.length != 2)
    		throw (new Error('value must be an array of length 2'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 7 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	prepuint(value[0], 0xffffffff);
    	prepuint(value[1], 0xffffffff);
    	wgint64(value, endian, buffer, offset);
    }
    
    /*
     * We now move onto our friends in the signed number category. Unlike unsigned
     * numbers, we're going to have to worry a bit more about how we put values into
     * arrays. Since we are only worrying about signed 32-bit values, we're in
     * slightly better shape. Unfortunately, we really can't do our favorite binary
     * & in this system. It really seems to do the wrong thing. For example:
     *
     * > -32 & 0xff
     * 224
     *
     * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
     * this aren't treated as a signed number. Ultimately a bad thing.
     *
     * What we're going to want to do is basically create the unsigned equivalent of
     * our representation and pass that off to the wuint* functions. To do that
     * we're going to do the following:
     *
     *  - if the value is positive
     *	we can pass it directly off to the equivalent wuint
     *  - if the value is negative
     *	we do the following computation:
     *	mb + val + 1, where
     *	mb	is the maximum unsigned value in that byte size
     *	val	is the Javascript negative integer
     *
     *
     * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
     * you do out the computations:
     *
     * 0xffff - 128 + 1
     * 0xffff - 127
     * 0xff80
     *
     * You can then encode this value as the signed version. This is really rather
     * hacky, but it should work and get the job done which is our goal here.
     *
     * Thus the overall flow is:
     *   -  Truncate the floating point part of the number
     *   -  We don't have to take the modulus, because the unsigned versions will
     *   	take care of that for us. And we don't have to worry about that
     *   	potentially causing bad things to happen because of sign extension
     *   -  Pass it off to the appropriate unsigned version, potentially modifying
     *	the negative portions as necessary.
     */
    
    /*
     * A series of checks to make sure we actually have a signed 32-bit number
     */
    function prepsint(value, max, min)
    {
    	if (typeof (value) != 'number')
    		throw (new (Error('cannot write a non-number as a number')));
    
    	if (value > max)
    		throw (new Error('value larger than maximum allowed value'));
    
    	if (value < min)
    		throw (new Error('value smaller than minimum allowed value'));
    
    	if (Math.floor(value) !== value)
    		throw (new Error('value has a fractional component'));
    
    	return (value);
    }
    
    /*
     * The 8-bit version of the signed value. Overall, fairly straightforward.
     */
    function wsint8(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepsint(value, 0x7f, -0x80);
    	if (val >= 0)
    		wuint8(val, endian, buffer, offset);
    	else
    		wuint8(0xff + val + 1, endian, buffer, offset);
    }
    
    /*
     * The 16-bit version of the signed value. Also, fairly straightforward.
     */
    function wsint16(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 1 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepsint(value, 0x7fff, -0x8000);
    	if (val >= 0)
    		wgint16(val, endian, buffer, offset);
    	else
    		wgint16(0xffff + val + 1, endian, buffer, offset);
    
    }
    
    /*
     * We can do this relatively easily by leveraging the code used for 32-bit
     * unsigned code.
     */
    function wsint32(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepsint(value, 0x7fffffff, -0x80000000);
    	if (val >= 0)
    		wgint32(val, endian, buffer, offset);
    	else
    		wgint32(0xffffffff + val + 1, endian, buffer, offset);
    }
    
    /*
     * The signed 64 bit integer should by in the same format as when received.
     * Mainly it should ensure that the value is an array of two integers where
     * value[0] << 32 + value[1] is the desired number. Furthermore, the two values
     * need to be equal.
     */
    function wsint64(value, endian, buffer, offset)
    {
    	var vzpos, vopos;
    	var vals = new Array(2);
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (!(value instanceof Array))
    		throw (new Error('value must be an array'));
    
    	if (value.length != 2)
    		throw (new Error('value must be an array of length 2'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 7 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	/*
    	 * We need to make sure that we have the same sign on both values. The
    	 * hokiest way to to do this is to multiply the number by +inf. If we do
    	 * this, we'll get either +/-inf depending on the sign of the value.
    	 * Once we have this, we can compare it to +inf to see if the number is
    	 * positive or not.
    	 */
    	vzpos = (value[0] * Number.POSITIVE_INFINITY) ==
    	    Number.POSITIVE_INFINITY;
    	vopos = (value[1] * Number.POSITIVE_INFINITY) ==
    	    Number.POSITIVE_INFINITY;
    
    	/*
    	 * If either of these is zero, then we don't actually need this check.
    	 */
    	if (value[0] != 0 && value[1] != 0 && vzpos != vopos)
    		throw (new Error('Both entries in the array must have ' +
    		    'the same sign'));
    
    	/*
    	 * Doing verification for a signed 64-bit integer is actually a big
    	 * trickier than it appears. We can't quite use our standard techniques
    	 * because we need to compare both sets of values. The first value is
    	 * pretty straightforward. If the first value is beond the extremes than
    	 * we error out. However, the valid range of the second value varies
    	 * based on the first one. If the first value is negative, and *not* the
    	 * largest negative value, than it can be any integer within the range [
    	 * 0, 0xffffffff ]. If it is the largest negative number, it must be
    	 * zero.
    	 *
    	 * If the first number is positive, than it doesn't matter what the
    	 * value is. We just simply have to make sure we have a valid positive
    	 * integer.
    	 */
    	if (vzpos) {
    		prepuint(value[0], 0x7fffffff);
    		prepuint(value[1], 0xffffffff);
    	} else {
    		prepsint(value[0], 0, -0x80000000);
    		prepsint(value[1], 0, -0xffffffff);
    		if (value[0] == -0x80000000 && value[1] != 0)
    			throw (new Error('value smaller than minimum ' +
    			    'allowed value'));
    	}
    
    	/* Fix negative numbers */
    	if (value[0] < 0 || value[1] < 0) {
    		vals[0] = 0xffffffff - Math.abs(value[0]);
    		vals[1] = 0x100000000 - Math.abs(value[1]);
    		if (vals[1] == 0x100000000) {
    			vals[1] = 0;
    			vals[0]++;
    		}
    	} else {
    		vals[0] = value[0];
    		vals[1] = value[1];
    	}
    	wgint64(vals, endian, buffer, offset);
    }
    
    /*
     * Now we are moving onto the weirder of these, the float and double. For this
     * we're going to just have to do something that's pretty weird. First off, we
     * have no way to get at the underlying float representation, at least not
     * easily. But that doesn't mean we can't figure it out, we just have to use our
     * heads.
     *
     * One might propose to use Number.toString(2). Of course, this is not really
     * that good, because the ECMAScript 262 v3 Standard says the following Section
     * 15.7.4.2-Number.prototype.toString (radix):
     *
     * If radix is an integer from 2 to 36, but not 10, the result is a string, the
     * choice of which is implementation-dependent.
     *
     * Well that doesn't really help us one bit now does it? We could use the
     * standard base 10 version of the string, but that's just going to create more
     * errors as we end up trying to convert it back to a binary value. So, really
     * this just means we have to be non-lazy and parse the structure intelligently.
     *
     * First off, we can do the basic checks: NaN, positive and negative infinity.
     *
     * Now that those are done we can work backwards to generate the mantissa and
     * exponent.
     *
     * The first thing we need to do is determine the sign bit, easy to do, check
     * whether the value is less than 0. And convert the number to its absolute
     * value representation. Next, we need to determine if the value is less than
     * one or greater than or equal to one and from there determine what power was
     * used to get there. What follows is now specific to floats, though the general
     * ideas behind this will hold for doubles as well, but the exact numbers
     * involved will change.
     *
     * Once we have that power we can determine the exponent and the mantissa. Call
     * the value that has the number of bits to reach the power ebits. In the
     * general case they have the following values:
     *
     *	exponent	127 + ebits
     *	mantissa	value * 2^(23 - ebits) & 0x7fffff
     *
     * In the case where the value of ebits is <= -127 we are now in the case where
     * we no longer have normalized numbers. In this case the values take on the
     * following values:
     *
     * 	exponent	0
     *	mantissa	value * 2^149 & 0x7fffff
     *
     * Once we have the values for the sign, mantissa, and exponent. We reconstruct
     * the four bytes as follows:
     *
     *	byte0		sign bit and seven most significant bits from the exp
     *			sign << 7 | (exponent & 0xfe) >>> 1
     *
     *	byte1		lsb from the exponent and 7 top bits from the mantissa
     *			(exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16
     *
     *	byte2		bits 8-15 (zero indexing) from mantissa
     *			mantissa & 0xff00 >> 8
     *
     *	byte3		bits 0-7 from mantissa
     *			mantissa & 0xff
     *
     * Once we have this we have to assign them into the buffer in proper endian
     * order.
     */
    
    /*
     * Compute the log base 2 of the value. Now, someone who remembers basic
     * properties of logarithms will point out that we could use the change of base
     * formula for logs, and in fact that would be astute, because that's what we'll
     * do for now. It feels cleaner, albeit it may be less efficient than just
     * iterating and dividing by 2. We may want to come back and revisit that some
     * day.
     */
    function log2(value)
    {
    	return (Math.log(value) / Math.log(2));
    }
    
    /*
     * Helper to determine the exponent of the number we're looking at.
     */
    function intexp(value)
    {
    	return (Math.floor(log2(value)));
    }
    
    /*
     * Helper to determine the exponent of the fractional part of the value.
     */
    function fracexp(value)
    {
    	return (Math.floor(log2(value)));
    }
    
    function wfloat(value, endian, buffer, offset)
    {
    	var sign, exponent, mantissa, ebits;
    	var bytes = [];
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	if (isNaN(value)) {
    		sign = 0;
    		exponent = 0xff;
    		mantissa = 23;
    	} else if (value == Number.POSITIVE_INFINITY) {
    		sign = 0;
    		exponent = 0xff;
    		mantissa = 0;
    	} else if (value == Number.NEGATIVE_INFINITY) {
    		sign = 1;
    		exponent = 0xff;
    		mantissa = 0;
    	} else {
    		/* Well we have some work to do */
    
    		/* Thankfully the sign bit is trivial */
    		if (value < 0) {
    			sign = 1;
    			value = Math.abs(value);
    		} else {
    			sign = 0;
    		}
    
    		/* Use the correct function to determine number of bits */
    		if (value < 1)
    			ebits = fracexp(value);
    		else
    			ebits = intexp(value);
    
    		/* Time to deal with the issues surrounding normalization */
    		if (ebits <= -127) {
    			exponent = 0;
    			mantissa = (value * Math.pow(2, 149)) & 0x7fffff;
    		} else {
    			exponent = 127 + ebits;
    			mantissa = value * Math.pow(2, 23 - ebits);
    			mantissa &= 0x7fffff;
    		}
    	}
    
    	bytes[0] = sign << 7 | (exponent & 0xfe) >>> 1;
    	bytes[1] = (exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16;
    	bytes[2] = (mantissa & 0x00ff00) >>> 8;
    	bytes[3] = mantissa & 0x0000ff;
    
    	if (endian == 'big') {
    		buffer[offset] = bytes[0];
    		buffer[offset+1] = bytes[1];
    		buffer[offset+2] = bytes[2];
    		buffer[offset+3] = bytes[3];
    	} else {
    		buffer[offset] = bytes[3];
    		buffer[offset+1] = bytes[2];
    		buffer[offset+2] = bytes[1];
    		buffer[offset+3] = bytes[0];
    	}
    }
    
    /*
     * Now we move onto doubles. Doubles are similar to floats in pretty much all
     * ways except that the processing isn't quite as straightforward because we
     * can't always use shifting, i.e. we have > 32 bit values.
     *
     * We're going to proceed in an identical fashion to floats and utilize the same
     * helper functions. All that really is changing are the specific values that we
     * use to do the calculations. Thus, to review we have to do the following.
     *
     * First get the sign bit and convert the value to its absolute value
     * representation. Next, we determine the number of bits that we used to get to
     * the value, branching whether the value is greater than or less than 1. Once
     * we have that value which we will again call ebits, we have to do the
     * following in the general case:
     *
     *	exponent	1023 + ebits
     *	mantissa	[value * 2^(52 - ebits)] % 2^52
     *
     * In the case where the value of ebits <= -1023 we no longer use normalized
     * numbers, thus like with floats we have to do slightly different processing:
     *
     *	exponent	0
     *	mantissa	[value * 2^1074] % 2^52
     *
     * Once we have determined the sign, exponent and mantissa we can construct the
     * bytes as follows:
     *
     *	byte0		sign bit and seven most significant bits form the exp
     *			sign << 7 | (exponent & 0x7f0) >>> 4
     *
     *	byte1		Remaining 4 bits from the exponent and the four most
     *			significant bits from the mantissa 48-51
     *			(exponent & 0x00f) << 4 | mantissa >>> 48
     *
     *	byte2		Bits 40-47 from the mantissa
     *			(mantissa >>> 40) & 0xff
     *
     *	byte3		Bits 32-39 from the mantissa
     *			(mantissa >>> 32) & 0xff
     *
     *	byte4		Bits 24-31 from the mantissa
     *			(mantissa >>> 24) & 0xff
     *
     *	byte5		Bits 16-23 from the Mantissa
     *			(mantissa >>> 16) & 0xff
     *
     *	byte6		Bits 8-15 from the mantissa
     *			(mantissa >>> 8) & 0xff
     *
     *	byte7		Bits 0-7 from the mantissa
     *			mantissa & 0xff
     *
     * Now we can't quite do the right shifting that we want in bytes 1 - 3, because
     * we'll have extended too far and we'll lose those values when we try and do
     * the shift. Instead we have to use an alternate approach. To try and stay out
     * of floating point, what we'll do is say that mantissa -= bytes[4-7] and then
     * divide by 2^32. Once we've done that we can use binary arithmetic. Oof,
     * that's ugly, but it seems to avoid using floating point (just based on how v8
     * seems to be optimizing for base 2 arithmetic).
     */
    function wdouble(value, endian, buffer, offset)
    {
    	var sign, exponent, mantissa, ebits;
    	var bytes = [];
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    
    	if (offset + 7 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	if (isNaN(value)) {
    		sign = 0;
    		exponent = 0x7ff;
    		mantissa = 23;
    	} else if (value == Number.POSITIVE_INFINITY) {
    		sign = 0;
    		exponent = 0x7ff;
    		mantissa = 0;
    	} else if (value == Number.NEGATIVE_INFINITY) {
    		sign = 1;
    		exponent = 0x7ff;
    		mantissa = 0;
    	} else {
    		/* Well we have some work to do */
    
    		/* Thankfully the sign bit is trivial */
    		if (value < 0) {
    			sign = 1;
    			value = Math.abs(value);
    		} else {
    			sign = 0;
    		}
    
    		/* Use the correct function to determine number of bits */
    		if (value < 1)
    			ebits = fracexp(value);
    		else
    			ebits = intexp(value);
    
    		/*
    		 * This is a total hack to determine a denormalized value.
    		 * Unfortunately, we sometimes do not get a proper value for
    		 * ebits, i.e. we lose the values that would get rounded off.
    		 *
    		 *
    		 * The astute observer may wonder why we would be
    		 * multiplying by two Math.pows rather than just summing
    		 * them. Well, that's to get around a small bug in the
    		 * way v8 seems to implement the function. On occasion
    		 * doing:
    		 *
    		 * foo * Math.pow(2, 1023 + 51)
    		 *
    		 * Causes us to overflow to infinity, where as doing:
    		 *
    		 * foo * Math.pow(2, 1023) * Math.pow(2, 51)
    		 *
    		 * Does not cause us to overflow. Go figure.
    		 *
    		 */
    		if (value <= 2.225073858507201e-308 || ebits <= -1023) {
    			exponent = 0;
    			mantissa = value * Math.pow(2, 1023) * Math.pow(2, 51);
    			mantissa %= Math.pow(2, 52);
    		} else {
    			/*
    			 * We might have gotten fucked by our floating point
    			 * logarithm magic. This is rather crappy, but that's
    			 * our luck. If we just had a log base 2 or access to
    			 * the stupid underlying representation this would have
    			 * been much easier and we wouldn't have such stupid
    			 * kludges or hacks.
    			 */
    			if (ebits > 1023)
    				ebits = 1023;
    			exponent = 1023 + ebits;
    			mantissa = value * Math.pow(2, -ebits);
    			mantissa *= Math.pow(2, 52);
    			mantissa %= Math.pow(2, 52);
    		}
    	}
    
    	/* Fill the bytes in backwards to deal with the size issues */
    	bytes[7] = mantissa & 0xff;
    	bytes[6] = (mantissa >>> 8) & 0xff;
    	bytes[5] = (mantissa >>> 16) & 0xff;
    	mantissa = (mantissa - (mantissa & 0xffffff)) / Math.pow(2, 24);
    	bytes[4] = mantissa & 0xff;
    	bytes[3] = (mantissa >>> 8) & 0xff;
    	bytes[2] = (mantissa >>> 16) & 0xff;
    	bytes[1] = (exponent & 0x00f) << 4 | mantissa >>> 24;
    	bytes[0] = (sign << 7) | (exponent & 0x7f0) >>> 4;
    
    	if (endian == 'big') {
    		buffer[offset] = bytes[0];
    		buffer[offset+1] = bytes[1];
    		buffer[offset+2] = bytes[2];
    		buffer[offset+3] = bytes[3];
    		buffer[offset+4] = bytes[4];
    		buffer[offset+5] = bytes[5];
    		buffer[offset+6] = bytes[6];
    		buffer[offset+7] = bytes[7];
    	} else {
    		buffer[offset+7] = bytes[0];
    		buffer[offset+6] = bytes[1];
    		buffer[offset+5] = bytes[2];
    		buffer[offset+4] = bytes[3];
    		buffer[offset+3] = bytes[4];
    		buffer[offset+2] = bytes[5];
    		buffer[offset+1] = bytes[6];
    		buffer[offset] = bytes[7];
    	}
    }
    
    /*
     * Actually export our work above. One might argue that we shouldn't expose
     * these interfaces and just force people to use the higher level abstractions
     * around this work. However, unlike say other libraries we've come across, this
     * interface has several properties: it makes sense, it's simple, and it's
     * useful.
     */
    exports.ruint8 = ruint8;
    exports.ruint16 = ruint16;
    exports.ruint32 = ruint32;
    exports.ruint64 = ruint64;
    exports.wuint8 = wuint8;
    exports.wuint16 = wuint16;
    exports.wuint32 = wuint32;
    exports.wuint64 = wuint64;
    
    exports.rsint8 = rsint8;
    exports.rsint16 = rsint16;
    exports.rsint32 = rsint32;
    exports.rsint64 = rsint64;
    exports.wsint8 = wsint8;
    exports.wsint16 = wsint16;
    exports.wsint32 = wsint32;
    exports.wsint64 = wsint64;
    
    exports.rfloat = rfloat;
    exports.rdouble = rdouble;
    exports.wfloat = wfloat;
    exports.wdouble = wdouble;
    
  provide("ctype/ctio.js", module.exports);
}(global));

// pakmanager:ctype
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * rm - Feb 2011
     * ctype.js
     *
     * This module provides a simple abstraction towards reading and writing
     * different types of binary data. It is designed to use ctio.js and provide a
     * richer and more expressive API on top of it.
     *
     * By default we support the following as built in basic types:
     *	int8_t
     *	int16_t
     *	int32_t
     *	uint8_t
     *	uint16_t
     *	uint32_t
     *	uint64_t
     *	float
     *	double
     *	char
     *	char[]
     *
     * Each type is returned as a Number, with the exception of char and char[]
     * which are returned as Node Buffers. A char is considered a uint8_t.
     *
     * Requests to read and write data are specified as an array of JSON objects.
     * This is also the same way that one declares structs. Even if just a single
     * value is requested, it must be done as a struct. The array order determines
     * the order that we try and read values. Each entry has the following format
     * with values marked with a * being optional.
     *
     * { key: { type: /type/, value*: /value/, offset*: /offset/ }
     *
     * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
     * value. Value is defined when we're writing out data, otherwise it's ignored.
     *
     */
    
    var mod_ctf =  require('ctype/ctf.js');
    var mod_ctio =  require('ctype/ctio.js');
    var mod_assert = require('assert');
    
    /*
     * This is the set of basic types that we support.
     *
     *	read		The function to call to read in a value from a buffer
     *
     *	write		The function to call to write a value to a buffer
     *
     */
    var deftypes = {
        'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },
        'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },
        'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },
        'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },
        'int8_t': { read: ctReadSint8, write: ctWriteSint8 },
        'int16_t': { read: ctReadSint16, write: ctWriteSint16 },
        'int32_t': { read: ctReadSint32, write: ctWriteSint32 },
        'int64_t': { read: ctReadSint64, write: ctWriteSint64 },
        'float': { read: ctReadFloat, write: ctWriteFloat },
        'double': { read: ctReadDouble, write: ctWriteDouble },
        'char': { read: ctReadChar, write: ctWriteChar },
        'char[]': { read: ctReadCharArray, write: ctWriteCharArray }
    };
    
    /*
     * The following are wrappers around the CType IO low level API. They encode
     * knowledge about the size and return something in the expected format.
     */
    function ctReadUint8(endian, buffer, offset)
    {
    	var val = mod_ctio.ruint8(buffer, endian, offset);
    	return ({ value: val, size: 1 });
    }
    
    function ctReadUint16(endian, buffer, offset)
    {
    	var val = mod_ctio.ruint16(buffer, endian, offset);
    	return ({ value: val, size: 2 });
    }
    
    function ctReadUint32(endian, buffer, offset)
    {
    	var val = mod_ctio.ruint32(buffer, endian, offset);
    	return ({ value: val, size: 4 });
    }
    
    function ctReadUint64(endian, buffer, offset)
    {
    	var val = mod_ctio.ruint64(buffer, endian, offset);
    	return ({ value: val, size: 8 });
    }
    
    function ctReadSint8(endian, buffer, offset)
    {
    	var val = mod_ctio.rsint8(buffer, endian, offset);
    	return ({ value: val, size: 1 });
    }
    
    function ctReadSint16(endian, buffer, offset)
    {
    	var val = mod_ctio.rsint16(buffer, endian, offset);
    	return ({ value: val, size: 2 });
    }
    
    function ctReadSint32(endian, buffer, offset)
    {
    	var val = mod_ctio.rsint32(buffer, endian, offset);
    	return ({ value: val, size: 4 });
    }
    
    function ctReadSint64(endian, buffer, offset)
    {
    	var val = mod_ctio.rsint64(buffer, endian, offset);
    	return ({ value: val, size: 8 });
    }
    
    function ctReadFloat(endian, buffer, offset)
    {
    	var val = mod_ctio.rfloat(buffer, endian, offset);
    	return ({ value: val, size: 4 });
    }
    
    function ctReadDouble(endian, buffer, offset)
    {
    	var val = mod_ctio.rdouble(buffer, endian, offset);
    	return ({ value: val, size: 8 });
    }
    
    /*
     * Reads a single character into a node buffer
     */
    function ctReadChar(endian, buffer, offset)
    {
    	var res = new Buffer(1);
    	res[0] = mod_ctio.ruint8(buffer, endian, offset);
    	return ({ value: res, size: 1 });
    }
    
    function ctReadCharArray(length, endian, buffer, offset)
    {
    	var ii;
    	var res = new Buffer(length);
    
    	for (ii = 0; ii < length; ii++)
    		res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);
    
    	return ({ value: res, size: length });
    }
    
    function ctWriteUint8(value, endian, buffer, offset)
    {
    	mod_ctio.wuint8(value, endian, buffer, offset);
    	return (1);
    }
    
    function ctWriteUint16(value, endian, buffer, offset)
    {
    	mod_ctio.wuint16(value, endian, buffer, offset);
    	return (2);
    }
    
    function ctWriteUint32(value, endian, buffer, offset)
    {
    	mod_ctio.wuint32(value, endian, buffer, offset);
    	return (4);
    }
    
    function ctWriteUint64(value, endian, buffer, offset)
    {
    	mod_ctio.wuint64(value, endian, buffer, offset);
    	return (8);
    }
    
    function ctWriteSint8(value, endian, buffer, offset)
    {
    	mod_ctio.wsint8(value, endian, buffer, offset);
    	return (1);
    }
    
    function ctWriteSint16(value, endian, buffer, offset)
    {
    	mod_ctio.wsint16(value, endian, buffer, offset);
    	return (2);
    }
    
    function ctWriteSint32(value, endian, buffer, offset)
    {
    	mod_ctio.wsint32(value, endian, buffer, offset);
    	return (4);
    }
    
    function ctWriteSint64(value, endian, buffer, offset)
    {
    	mod_ctio.wsint64(value, endian, buffer, offset);
    	return (8);
    }
    
    function ctWriteFloat(value, endian, buffer, offset)
    {
    	mod_ctio.wfloat(value, endian, buffer, offset);
    	return (4);
    }
    
    function ctWriteDouble(value, endian, buffer, offset)
    {
    	mod_ctio.wdouble(value, endian, buffer, offset);
    	return (8);
    }
    
    /*
     * Writes a single character into a node buffer
     */
    function ctWriteChar(value, endian, buffer, offset)
    {
    	if (!(value instanceof Buffer))
    		throw (new Error('Input must be a buffer'));
    
    	mod_ctio.ruint8(value[0], endian, buffer, offset);
    	return (1);
    }
    
    /*
     * We're going to write 0s into the buffer if the string is shorter than the
     * length of the array.
     */
    function ctWriteCharArray(value, length, endian, buffer, offset)
    {
    	var ii;
    
    	if (!(value instanceof Buffer))
    		throw (new Error('Input must be a buffer'));
    
    	if (value.length > length)
    		throw (new Error('value length greater than array length'));
    
    	for (ii = 0; ii < value.length && ii < length; ii++)
    		mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);
    
    	for (; ii < length; ii++)
    		mod_ctio.wuint8(0, endian, offset + ii);
    
    
    	return (length);
    }
    
    /*
     * Each parser has their own set of types. We want to make sure that they each
     * get their own copy as they may need to modify it.
     */
    function ctGetBasicTypes()
    {
    	var ret = {};
    	var key;
    	for (key in deftypes)
    		ret[key] = deftypes[key];
    
    	return (ret);
    }
    
    /*
     * Given a string in the form of type[length] we want to split this into an
     * object that extracts that information. We want to note that we could possibly
     * have nested arrays so this should only check the furthest one. It may also be
     * the case that we have no [] pieces, in which case we just return the current
     * type.
     */
    function ctParseType(str)
    {
    	var begInd, endInd;
    	var type, len;
    	if (typeof (str) != 'string')
    		throw (new Error('type must be a Javascript string'));
    
    	endInd = str.lastIndexOf(']');
    	if (endInd == -1) {
    		if (str.lastIndexOf('[') != -1)
    			throw (new Error('found invalid type with \'[\' but ' +
    			    'no corresponding \']\''));
    
    		return ({ type: str });
    	}
    
    	begInd = str.lastIndexOf('[');
    	if (begInd == -1)
    		throw (new Error('found invalid type with \']\' but ' +
    		    'no corresponding \'[\''));
    
    	if (begInd >= endInd)
    		throw (new Error('malformed type, \']\' appears before \'[\''));
    
    	type = str.substring(0, begInd);
    	len = str.substring(begInd + 1, endInd);
    
    	return ({ type: type, len: len });
    }
    
    /*
     * Given a request validate that all of the fields for it are valid and make
     * sense. This includes verifying the following notions:
     *  - Each type requested is present in types
     *  - Only allow a name for a field to be specified once
     *  - If an array is specified, validate that the requested field exists and
     *    comes before it.
     *  - If fields is defined, check that each entry has the occurrence of field
     */
    function ctCheckReq(def, types, fields)
    {
    	var ii, jj;
    	var req, keys, key;
    	var found = {};
    
    	if (!(def instanceof Array))
    		throw (new Error('definition is not an array'));
    
    	if (def.length === 0)
    		throw (new Error('definition must have at least one element'));
    
    	for (ii = 0; ii < def.length; ii++) {
    		req = def[ii];
    		if (!(req instanceof Object))
    			throw (new Error('definition must be an array of' +
    			    'objects'));
    
    		keys = Object.keys(req);
    		if (keys.length != 1)
    			throw (new Error('definition entry must only have ' +
    			    'one key'));
    
    		if (keys[0] in found)
    			throw (new Error('Specified name already ' +
    			    'specified: ' + keys[0]));
    
    		if (!('type' in req[keys[0]]))
    			throw (new Error('missing required type definition'));
    
    		key = ctParseType(req[keys[0]]['type']);
    
    		/*
    		 * We may have nested arrays, we need to check the validity of
    		 * the types until the len field is undefined in key. However,
    		 * each time len is defined we need to verify it is either an
    		 * integer or corresponds to an already seen key.
    		 */
    		while (key['len'] !== undefined) {
    			if (isNaN(parseInt(key['len'], 10))) {
    				if (!(key['len'] in found))
    					throw (new Error('Given an array ' +
    					    'length without a matching type'));
    
    			}
    
    			key = ctParseType(key['type']);
    		}
    
    		/* Now we can validate if the type is valid */
    		if (!(key['type'] in types))
    			throw (new Error('type not found or typdefed: ' +
    			    key['type']));
    
    		/* Check for any required fields */
    		if (fields !== undefined) {
    			for (jj = 0; jj < fields.length; jj++) {
    				if (!(fields[jj] in req[keys[0]]))
    					throw (new Error('Missing required ' +
    					    'field: ' + fields[jj]));
    			}
    		}
    
    		found[keys[0]] = true;
    	}
    }
    
    
    /*
     * Create a new instance of the parser. Each parser has its own store of
     * typedefs and endianness. Conf is an object with the following required
     * values:
     *
     *	endian		Either 'big' or 'little' do determine the endianness we
     *			want to read from or write to.
     *
     * And the following optional values:
     *
     * 	char-type	Valid options here are uint8 and int8. If uint8 is
     * 			specified this changes the default behavior of a single
     * 			char from being a buffer of a single character to being
     * 			a uint8_t. If int8, it becomes an int8_t instead.
     */
    function CTypeParser(conf)
    {
    	if (!conf) throw (new Error('missing required argument'));
    
    	if (!('endian' in conf))
    		throw (new Error('missing required endian value'));
    
    	if (conf['endian'] != 'big' && conf['endian'] != 'little')
    		throw (new Error('Invalid endian type'));
    
    	if ('char-type' in conf && (conf['char-type'] != 'uint8' &&
    	    conf['char-type'] != 'int8'))
    		throw (new Error('invalid option for char-type: ' +
    		    conf['char-type']));
    
    	this.endian = conf['endian'];
    	this.types = ctGetBasicTypes();
    
    	/*
    	 * There may be a more graceful way to do this, but this will have to
    	 * serve.
    	 */
    	if ('char-type' in conf && conf['char-type'] == 'uint8')
    		this.types['char'] = this.types['uint8_t'];
    
    	if ('char-type' in conf && conf['char-type'] == 'int8')
    		this.types['char'] = this.types['int8_t'];
    }
    
    /*
     * Sets the current endian value for the Parser. If the value is not valid,
     * throws an Error.
     *
     *	endian		Either 'big' or 'little' do determine the endianness we
     *			want to read from or write to.
     *
     */
    CTypeParser.prototype.setEndian = function (endian)
    {
    	if (endian != 'big' && endian != 'little')
    		throw (new Error('invalid endian type, must be big or ' +
    		    'little'));
    
    	this.endian = endian;
    };
    
    /*
     * Returns the current value of the endian value for the parser.
     */
    CTypeParser.prototype.getEndian = function ()
    {
    	return (this.endian);
    };
    
    /*
     * A user has requested to add a type, let us honor their request. Yet, if their
     * request doth spurn us, send them unto the Hells which Dante describes.
     *
     * 	name		The string for the type definition we're adding
     *
     *	value		Either a string that is a type/array name or an object
     *			that describes a struct.
     */
    CTypeParser.prototype.typedef = function (name, value)
    {
    	var type;
    
    	if (name === undefined)
    		throw (new (Error('missing required typedef argument: name')));
    
    	if (value === undefined)
    		throw (new (Error('missing required typedef argument: value')));
    
    	if (typeof (name) != 'string')
    		throw (new (Error('the name of a type must be a string')));
    
    	type = ctParseType(name);
    
    	if (type['len'] !== undefined)
    		throw (new Error('Cannot have an array in the typedef name'));
    
    	if (name in this.types)
    		throw (new Error('typedef name already present: ' + name));
    
    	if (typeof (value) != 'string' && !(value instanceof Array))
    		throw (new Error('typedef value must either be a string or ' +
    		    'struct'));
    
    	if (typeof (value) == 'string') {
    		type = ctParseType(value);
    		if (type['len'] !== undefined) {
    			if (isNaN(parseInt(type['len'], 10)))
    				throw (new (Error('typedef value must use ' +
    				    'fixed size array when outside of a ' +
    				    'struct')));
    		}
    
    		this.types[name] = value;
    	} else {
    		/* We have a struct, validate it */
    		ctCheckReq(value, this.types);
    		this.types[name] = value;
    	}
    };
    
    /*
     * Include all of the typedefs, but none of the built in types. This should be
     * treated as read-only.
     */
    CTypeParser.prototype.lstypes = function ()
    {
    	var key;
    	var ret = {};
    
    	for (key in this.types) {
    		if (key in deftypes)
    			continue;
    		ret[key] = this.types[key];
    	}
    
    	return (ret);
    };
    
    /*
     * Given a type string that may have array types that aren't numbers, try and
     * fill them in from the values object. The object should be of the format where
     * indexing into it should return a number for that type.
     *
     *	str		The type string
     *
     *	values		An object that can be used to fulfill type information
     */
    function ctResolveArray(str, values)
    {
    	var ret = '';
    	var type = ctParseType(str);
    
    	while (type['len'] !== undefined) {
    		if (isNaN(parseInt(type['len'], 10))) {
    			if (typeof (values[type['len']]) != 'number')
    				throw (new Error('cannot sawp in non-number ' +
    				    'for array value'));
    			ret = '[' + values[type['len']] + ']' + ret;
    		} else {
    			ret = '[' + type['len'] + ']' + ret;
    		}
    		type = ctParseType(type['type']);
    	}
    
    	ret = type['type'] + ret;
    
    	return (ret);
    }
    
    /*
     * [private] Either the typedef resolves to another type string or to a struct.
     * If it resolves to a struct, we just pass it off to read struct. If not, we
     * can just pass it off to read entry.
     */
    CTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,
        offset, value)
    {
    	var pt;
    
    	mod_assert.ok(type in this.types);
    	if (typeof (this.types[type]) == 'string') {
    		pt = ctParseType(this.types[type]);
    		if (dispatch == 'read')
    			return (this.readEntry(pt, buffer, offset));
    		else if (dispatch == 'write')
    			return (this.writeEntry(value, pt, buffer, offset));
    		else
    			throw (new Error('invalid dispatch type to ' +
    			    'resolveTypedef'));
    	} else {
    		if (dispatch == 'read')
    			return (this.readStruct(this.types[type], buffer,
    			    offset));
    		else if (dispatch == 'write')
    			return (this.writeStruct(value, this.types[type],
    			    buffer, offset));
    		else
    			throw (new Error('invalid dispatch type to ' +
    			    'resolveTypedef'));
    	}
    
    };
    
    /*
     * [private] Try and read in the specific entry.
     */
    CTypeParser.prototype.readEntry = function (type, buffer, offset)
    {
    	var parse, len;
    
    	/*
    	 * Because we want to special case char[]s this is unfortunately
    	 * a bit uglier than it really should be. We want to special
    	 * case char[]s so that we return a node buffer, thus they are a
    	 * first class type where as all other arrays just call into a
    	 * generic array routine which calls their data-specific routine
    	 * the specified number of times.
    	 *
    	 * The valid dispatch options we have are:
    	 *  - Array and char => char[] handler
    	 *  - Generic array handler
    	 *  - Generic typedef handler
    	 *  - Basic type handler
    	 */
    	if (type['len'] !== undefined) {
    		len = parseInt(type['len'], 10);
    		if (isNaN(len))
    			throw (new Error('somehow got a non-numeric length'));
    
    		if (type['type'] == 'char')
    			parse = this.types['char[]']['read'](len,
    			    this.endian, buffer, offset);
    		else
    			parse = this.readArray(type['type'],
    			    len, buffer, offset);
    	} else {
    		if (type['type'] in deftypes)
    			parse = this.types[type['type']]['read'](this.endian,
    			    buffer, offset);
    		else
    			parse = this.resolveTypedef(type['type'], 'read',
    			    buffer, offset);
    	}
    
    	return (parse);
    };
    
    /*
     * [private] Read an array of data
     */
    CTypeParser.prototype.readArray = function (type, length, buffer, offset)
    {
    	var ii, ent, pt;
    	var baseOffset = offset;
    	var ret = new Array(length);
    	pt = ctParseType(type);
    
    	for (ii = 0; ii < length; ii++) {
    		ent = this.readEntry(pt, buffer, offset);
    		offset += ent['size'];
    		ret[ii] = ent['value'];
    	}
    
    	return ({ value: ret, size: offset - baseOffset });
    };
    
    /*
     * [private] Read a single struct in.
     */
    CTypeParser.prototype.readStruct = function (def, buffer, offset)
    {
    	var parse, ii, type, entry, key;
    	var baseOffset = offset;
    	var ret = {};
    
    	/* Walk it and handle doing what's necessary */
    	for (ii = 0; ii < def.length; ii++) {
    		key = Object.keys(def[ii])[0];
    		entry = def[ii][key];
    
    		/* Resolve all array values */
    		type = ctParseType(ctResolveArray(entry['type'], ret));
    
    		if ('offset' in entry)
    			offset = baseOffset + entry['offset'];
    
    		parse = this.readEntry(type, buffer, offset);
    
    		offset += parse['size'];
    		ret[key] = parse['value'];
    	}
    
    	return ({ value: ret, size: (offset-baseOffset)});
    };
    
    /*
     * This is what we were born to do. We read the data from a buffer and return it
     * in an object whose keys match the values from the object.
     *
     *	def		The array definition of the data to read in
     *
     *	buffer		The buffer to read data from
     *
     *	offset		The offset to start writing to
     *
     * Returns an object where each key corresponds to an entry in def and the value
     * is the read value.
     */
    CTypeParser.prototype.readData = function (def, buffer, offset)
    {
    	/* Sanity check for arguments */
    	if (def === undefined)
    		throw (new Error('missing definition for what we should be' +
    		    'parsing'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer for what we should be ' +
    		    'parsing'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset for what we should be ' +
    		    'parsing'));
    
    	/* Sanity check the object definition */
    	ctCheckReq(def, this.types);
    
    	return (this.readStruct(def, buffer, offset)['value']);
    };
    
    /*
     * [private] Write out an array of data
     */
    CTypeParser.prototype.writeArray = function (value, type, length, buffer,
        offset)
    {
    	var ii, pt;
    	var baseOffset = offset;
    	if (!(value instanceof Array))
    		throw (new Error('asked to write an array, but value is not ' +
    		    'an array'));
    
    	if (value.length != length)
    		throw (new Error('asked to write array of length ' + length +
    		    ' but that does not match value length: ' + value.length));
    
    	pt = ctParseType(type);
    	for (ii = 0; ii < length; ii++)
    		offset += this.writeEntry(value[ii], pt, buffer, offset);
    
    	return (offset - baseOffset);
    };
    
    /*
     * [private] Write the specific entry
     */
    CTypeParser.prototype.writeEntry = function (value, type, buffer, offset)
    {
    	var len, ret;
    
    	if (type['len'] !== undefined) {
    		len = parseInt(type['len'], 10);
    		if (isNaN(len))
    			throw (new Error('somehow got a non-numeric length'));
    
    		if (type['type'] == 'char')
    			ret = this.types['char[]']['write'](value, len,
    			    this.endian, buffer, offset);
    		else
    			ret = this.writeArray(value, type['type'],
    			    len, buffer, offset);
    	} else {
    		if (type['type'] in deftypes)
    			ret = this.types[type['type']]['write'](value,
    			    this.endian, buffer, offset);
    		else
    			ret = this.resolveTypedef(type['type'], 'write',
    			    buffer, offset, value);
    	}
    
    	return (ret);
    };
    
    /*
     * [private] Write a single struct out.
     */
    CTypeParser.prototype.writeStruct = function (value, def, buffer, offset)
    {
    	var ii, entry, type, key;
    	var baseOffset = offset;
    	var vals = {};
    
    	for (ii = 0; ii < def.length; ii++) {
    		key = Object.keys(def[ii])[0];
    		entry = def[ii][key];
    
    		type = ctParseType(ctResolveArray(entry['type'], vals));
    
    		if ('offset' in entry)
    			offset = baseOffset + entry['offset'];
    
    		offset += this.writeEntry(value[ii], type, buffer, offset);
    		/* Now that we've written it out, we can use it for arrays */
    		vals[key] = value[ii];
    	}
    
    	return (offset);
    };
    
    /*
     * Unfortunately, we're stuck with the sins of an initial poor design. Because
     * of that, we are going to have to support the old way of writing data via
     * writeData. There we insert the values that you want to write into the
     * definition. A little baroque. Internally, we use the new model. So we need to
     * just get those values out of there. But to maintain the principle of least
     * surprise, we're not going to modify the input data.
     */
    function getValues(def)
    {
    	var ii, out, key;
    	out = [];
    	for (ii = 0; ii < def.length; ii++) {
    		key = Object.keys(def[ii])[0];
    		mod_assert.ok('value' in def[ii][key]);
    		out.push(def[ii][key]['value']);
    	}
    
    	return (out);
    }
    
    /*
     * This is the second half of what we were born to do, write out the data
     * itself. Historically this function required you to put your values in the
     * definition section. This was not the smartest thing to do and a bit of an
     * oversight to be honest. As such, this function now takes a values argument.
     * If values is non-null and non-undefined, it will be used to determine the
     * values. This means that the old method is still supported, but is no longer
     * acceptable.
     *
     *	def		The array definition of the data to write out with
     *			values
     *
     *	buffer		The buffer to write to
     *
     *	offset		The offset in the buffer to write to
     *
     *	values		An array of values to write.
     */
    CTypeParser.prototype.writeData = function (def, buffer, offset, values)
    {
    	var hv;
    
    	if (def === undefined)
    		throw (new Error('missing definition for what we should be' +
    		    'parsing'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer for what we should be ' +
    		    'parsing'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset for what we should be ' +
    		    'parsing'));
    
    	hv = (values != null && values != undefined);
    	if (hv) {
    		if (!Array.isArray(values))
    			throw (new Error('missing values for writing'));
    		ctCheckReq(def, this.types);
    	} else {
    		ctCheckReq(def, this.types, [ 'value' ]);
    	}
    
    	this.writeStruct(hv ? values : getValues(def), def, buffer, offset);
    };
    
    /*
     * Functions to go to and from 64 bit numbers in a way that is compatible with
     * Javascript limitations. There are two sets. One where the user is okay with
     * an approximation and one where they are definitely not okay with an
     * approximation.
     */
    
    /*
     * Attempts to convert an array of two integers returned from rsint64 / ruint64
     * into an absolute 64 bit number. If however the value would exceed 2^52 this
     * will instead throw an error. The mantissa in a double is a 52 bit number and
     * rather than potentially give you a value that is an approximation this will
     * error. If you would rather an approximation, please see toApprox64.
     *
     *	val		An array of two 32-bit integers
     */
    function toAbs64(val)
    {
    	if (val === undefined)
    		throw (new Error('missing required arg: value'));
    
    	if (!Array.isArray(val))
    		throw (new Error('value must be an array'));
    
    	if (val.length != 2)
    		throw (new Error('value must be an array of length 2'));
    
    	/* We have 20 bits worth of precision in this range */
    	if (val[0] >= 0x100000)
    		throw (new Error('value would become approximated'));
    
    	return (val[0] * Math.pow(2, 32) + val[1]);
    }
    
    /*
     * Will return the 64 bit value as returned in an array from rsint64 / ruint64
     * to a value as close as it can. Note that Javascript stores all numbers as a
     * double and the mantissa only has 52 bits. Thus this version may approximate
     * the value.
     *
     *	val		An array of two 32-bit integers
     */
    function toApprox64(val)
    {
    	if (val === undefined)
    		throw (new Error('missing required arg: value'));
    
    	if (!Array.isArray(val))
    		throw (new Error('value must be an array'));
    
    	if (val.length != 2)
    		throw (new Error('value must be an array of length 2'));
    
    	return (Math.pow(2, 32) * val[0] + val[1]);
    }
    
    function parseCTF(json, conf)
    {
    	var ctype = new CTypeParser(conf);
    	mod_ctf.ctfParseJson(json, ctype);
    
    	return (ctype);
    }
    
    /*
     * Export the few things we actually want to. Currently this is just the CType
     * Parser and ctio.
     */
    exports.Parser = CTypeParser;
    exports.toAbs64 = toAbs64;
    exports.toApprox64 = toApprox64;
    
    exports.parseCTF = parseCTF;
    
    exports.ruint8 = mod_ctio.ruint8;
    exports.ruint16 = mod_ctio.ruint16;
    exports.ruint32 = mod_ctio.ruint32;
    exports.ruint64 = mod_ctio.ruint64;
    exports.wuint8 = mod_ctio.wuint8;
    exports.wuint16 = mod_ctio.wuint16;
    exports.wuint32 = mod_ctio.wuint32;
    exports.wuint64 = mod_ctio.wuint64;
    
    exports.rsint8 = mod_ctio.rsint8;
    exports.rsint16 = mod_ctio.rsint16;
    exports.rsint32 = mod_ctio.rsint32;
    exports.rsint64 = mod_ctio.rsint64;
    exports.wsint8 = mod_ctio.wsint8;
    exports.wsint16 = mod_ctio.wsint16;
    exports.wsint32 = mod_ctio.wsint32;
    exports.wsint64 = mod_ctio.wsint64;
    
    exports.rfloat = mod_ctio.rfloat;
    exports.rdouble = mod_ctio.rdouble;
    exports.wfloat = mod_ctio.wfloat;
    exports.wdouble = mod_ctio.wdouble;
    
  provide("ctype", module.exports);
}(global));

// pakmanager:cryptiles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Crypto = require('crypto');
    var Boom = require('boom');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Generate a cryptographically strong pseudo-random data
    
    exports.randomString = function (size) {
    
        var buffer = exports.randomBits((size + 1) * 6);
        if (buffer instanceof Error) {
            return buffer;
        }
    
        var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
        return string.slice(0, size);
    };
    
    
    exports.randomBits = function (bits) {
    
        if (!bits ||
            bits < 0) {
    
            return Boom.internal('Invalid random bits count');
        }
    
        var bytes = Math.ceil(bits / 8);
        try {
            return Crypto.randomBytes(bytes);
        }
        catch (err) {
            return Boom.internal('Failed generating random bits: ' + err.message);
        }
    };
    
    
    // Compare two strings using fixed time algorithm (to prevent time-based analysis of MAC digest match)
    
    exports.fixedTimeComparison = function (a, b) {
    
        if (typeof a !== 'string' ||
            typeof b !== 'string') {
    
            return false;
        }
    
        var mismatch = (a.length === b.length ? 0 : 1);
        if (mismatch) {
            b = a;
        }
    
        for (var i = 0, il = a.length; i < il; ++i) {
            var ac = a.charCodeAt(i);
            var bc = b.charCodeAt(i);
            mismatch |= (ac ^ bc);
        }
    
        return (mismatch === 0);
    };
    
    
    
  provide("cryptiles", module.exports);
}(global));

// pakmanager:sntp/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Dgram = require('dgram');
    var Dns = require('dns');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.time = function (options, callback) {
    
        if (arguments.length !== 2) {
            callback = arguments[0];
            options = {};
        }
    
        var settings = Hoek.clone(options);
        settings.host = settings.host || 'pool.ntp.org';
        settings.port = settings.port || 123;
        settings.resolveReference = settings.resolveReference || false;
    
        // Declare variables used by callback
    
        var timeoutId = 0;
        var sent = 0;
    
        // Ensure callback is only called once
    
        var finish = function (err, result) {
    
            if (timeoutId) {
                clearTimeout(timeoutId);
                timeoutId = 0;
            }
    
            socket.removeAllListeners();
            socket.once('error', internals.ignore);
            socket.close();
            return callback(err, result);
        };
    
        finish = Hoek.once(finish);
    
        // Create UDP socket
    
        var socket = Dgram.createSocket('udp4');
    
        socket.once('error', function (err) {
    
            return finish(err);
        });
    
        // Listen to incoming messages
    
        socket.on('message', function (buffer, rinfo) {
    
            var received = Date.now();
    
            var message = new internals.NtpMessage(buffer);
            if (!message.isValid) {
                return finish(new Error('Invalid server response'), message);
            }
    
            if (message.originateTimestamp !== sent) {
                return finish(new Error('Wrong originate timestamp'), message);
            }
    
            // Timestamp Name          ID   When Generated
            // ------------------------------------------------------------
            // Originate Timestamp     T1   time request sent by client
            // Receive Timestamp       T2   time request received by server
            // Transmit Timestamp      T3   time reply sent by server
            // Destination Timestamp   T4   time reply received by client
            //
            // The roundtrip delay d and system clock offset t are defined as:
            //
            // d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2
    
            var T1 = message.originateTimestamp;
            var T2 = message.receiveTimestamp;
            var T3 = message.transmitTimestamp;
            var T4 = received;
    
            message.d = (T4 - T1) - (T3 - T2);
            message.t = ((T2 - T1) + (T3 - T4)) / 2;
            message.receivedLocally = received;
    
            if (!settings.resolveReference ||
                message.stratum !== 'secondary') {
    
                return finish(null, message);
            }
    
            // Resolve reference IP address
    
            Dns.reverse(message.referenceId, function (err, domains) {
    
                if (/* $lab:coverage:off$ */ !err /* $lab:coverage:on$ */) {
                    message.referenceHost = domains[0];
                }
    
                return finish(null, message);
            });
        });
    
        // Set timeout
    
        if (settings.timeout) {
            timeoutId = setTimeout(function () {
    
                timeoutId = 0;
                return finish(new Error('Timeout'));
            }, settings.timeout);
        }
    
        // Construct NTP message
    
        var message = new Buffer(48);
        for (var i = 0; i < 48; i++) {                      // Zero message
            message[i] = 0;
        }
    
        message[0] = (0 << 6) + (4 << 3) + (3 << 0)         // Set version number to 4 and Mode to 3 (client)
        sent = Date.now();
        internals.fromMsecs(sent, message, 40);               // Set transmit timestamp (returns as originate)
    
        // Send NTP request
    
        socket.send(message, 0, message.length, settings.port, settings.host, function (err, bytes) {
    
            if (err ||
                bytes !== 48) {
    
                return finish(err || new Error('Could not send entire message'));
            }
        });
    };
    
    
    internals.NtpMessage = function (buffer) {
    
        this.isValid = false;
    
        // Validate
    
        if (buffer.length !== 48) {
            return;
        }
    
        // Leap indicator
    
        var li = (buffer[0] >> 6);
        switch (li) {
            case 0: this.leapIndicator = 'no-warning'; break;
            case 1: this.leapIndicator = 'last-minute-61'; break;
            case 2: this.leapIndicator = 'last-minute-59'; break;
            case 3: this.leapIndicator = 'alarm'; break;
        }
    
        // Version
    
        var vn = ((buffer[0] & 0x38) >> 3);
        this.version = vn;
    
        // Mode
    
        var mode = (buffer[0] & 0x7);
        switch (mode) {
            case 1: this.mode = 'symmetric-active'; break;
            case 2: this.mode = 'symmetric-passive'; break;
            case 3: this.mode = 'client'; break;
            case 4: this.mode = 'server'; break;
            case 5: this.mode = 'broadcast'; break;
            case 0:
            case 6:
            case 7: this.mode = 'reserved'; break;
        }
    
        // Stratum
    
        var stratum = buffer[1];
        if (stratum === 0) {
            this.stratum = 'death';
        }
        else if (stratum === 1) {
            this.stratum = 'primary';
        }
        else if (stratum <= 15) {
            this.stratum = 'secondary';
        }
        else {
            this.stratum = 'reserved';
        }
    
        // Poll interval (msec)
    
        this.pollInterval = Math.round(Math.pow(2, buffer[2])) * 1000;
    
        // Precision (msecs)
    
        this.precision = Math.pow(2, buffer[3]) * 1000;
    
        // Root delay (msecs)
    
        var rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]) + buffer[6]) + buffer[7];
        this.rootDelay = 1000 * (rootDelay / 0x10000);
    
        // Root dispersion (msecs)
    
        this.rootDispersion = ((buffer[8] << 8) + buffer[9] + ((buffer[10] << 8) + buffer[11]) / Math.pow(2, 16)) * 1000;
    
        // Reference identifier
    
        this.referenceId = '';
        switch (this.stratum) {
            case 'death':
            case 'primary':
                this.referenceId = String.fromCharCode(buffer[12]) + String.fromCharCode(buffer[13]) + String.fromCharCode(buffer[14]) + String.fromCharCode(buffer[15]);
                break;
            case 'secondary':
                this.referenceId = '' + buffer[12] + '.' + buffer[13] + '.' + buffer[14] + '.' + buffer[15];
                break;
        }
    
        // Reference timestamp
    
        this.referenceTimestamp = internals.toMsecs(buffer, 16);
    
        // Originate timestamp
    
        this.originateTimestamp = internals.toMsecs(buffer, 24);
    
        // Receive timestamp
    
        this.receiveTimestamp = internals.toMsecs(buffer, 32);
    
        // Transmit timestamp
    
        this.transmitTimestamp = internals.toMsecs(buffer, 40);
    
        // Validate
    
        if (this.version === 4 &&
            this.stratum !== 'reserved' &&
            this.mode === 'server' &&
            this.originateTimestamp &&
            this.receiveTimestamp &&
            this.transmitTimestamp) {
    
            this.isValid = true;
        }
    
        return this;
    };
    
    
    internals.toMsecs = function (buffer, offset) {
    
        var seconds = 0;
        var fraction = 0;
    
        for (var i = 0; i < 4; ++i) {
            seconds = (seconds * 256) + buffer[offset + i];
        }
    
        for (i = 4; i < 8; ++i) {
            fraction = (fraction * 256) + buffer[offset + i];
        }
    
        return ((seconds - 2208988800 + (fraction / Math.pow(2, 32))) * 1000);
    };
    
    
    internals.fromMsecs = function (ts, buffer, offset) {
    
        var seconds = Math.floor(ts / 1000) + 2208988800;
        var fraction = Math.round((ts % 1000) / 1000 * Math.pow(2, 32));
    
        buffer[offset + 0] = (seconds & 0xFF000000) >> 24;
        buffer[offset + 1] = (seconds & 0x00FF0000) >> 16;
        buffer[offset + 2] = (seconds & 0x0000FF00) >> 8;
        buffer[offset + 3] = (seconds & 0x000000FF);
    
        buffer[offset + 4] = (fraction & 0xFF000000) >> 24;
        buffer[offset + 5] = (fraction & 0x00FF0000) >> 16;
        buffer[offset + 6] = (fraction & 0x0000FF00) >> 8;
        buffer[offset + 7] = (fraction & 0x000000FF);
    };
    
    
    // Offset singleton
    
    internals.last = {
        offset: 0,
        expires: 0,
        host: '',
        port: 0
    };
    
    
    exports.offset = function (options, callback) {
    
        if (arguments.length !== 2) {
            callback = arguments[0];
            options = {};
        }
    
        var now = Date.now();
        var clockSyncRefresh = options.clockSyncRefresh || 24 * 60 * 60 * 1000;                    // Daily
    
        if (internals.last.offset &&
            internals.last.host === options.host &&
            internals.last.port === options.port &&
            now < internals.last.expires) {
    
            process.nextTick(function () {
    
                callback(null, internals.last.offset);
            });
    
            return;
        }
    
        exports.time(options, function (err, time) {
    
            if (err) {
                return callback(err, 0);
            }
    
            internals.last = {
                offset: Math.round(time.t),
                expires: now + clockSyncRefresh,
                host: options.host,
                port: options.port
            };
    
            return callback(null, internals.last.offset);
        });
    };
    
    
    // Now singleton
    
    internals.now = {
        intervalId: 0
    };
    
    
    exports.start = function (options, callback) {
    
        if (arguments.length !== 2) {
            callback = arguments[0];
            options = {};
        }
    
        if (internals.now.intervalId) {
            process.nextTick(function () {
    
                callback();
            });
    
            return;
        }
    
        exports.offset(options, function (err, offset) {
    
            internals.now.intervalId = setInterval(function () {
    
                exports.offset(options, function () { });
            }, options.clockSyncRefresh || 24 * 60 * 60 * 1000);                                // Daily
    
            return callback();
        });
    };
    
    
    exports.stop = function () {
    
        if (!internals.now.intervalId) {
            return;
        }
    
        clearInterval(internals.now.intervalId);
        internals.now.intervalId = 0;
    };
    
    
    exports.isLive = function () {
    
        return !!internals.now.intervalId;
    };
    
    
    exports.now = function () {
    
        var now = Date.now();
        if (!exports.isLive() ||
            now >= internals.last.expires) {
    
            return now;
        }
    
        return now + internals.last.offset;
    };
    
    
    internals.ignore = function () {
    
    };
    
  provide("sntp/lib", module.exports);
}(global));

// pakmanager:sntp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('sntp/lib');
  provide("sntp", module.exports);
}(global));

// pakmanager:bluebird/js/main/es5.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isES5 = (function(){
        "use strict";
        return this === undefined;
    })();
    
    if (isES5) {
        module.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5: isES5,
            propertyIsWritable: function(obj, prop) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                return !!(!descriptor || descriptor.writable || descriptor.set);
            }
        };
    } else {
        var has = {}.hasOwnProperty;
        var str = {}.toString;
        var proto = {}.constructor.prototype;
    
        var ObjectKeys = function (o) {
            var ret = [];
            for (var key in o) {
                if (has.call(o, key)) {
                    ret.push(key);
                }
            }
            return ret;
        };
    
        var ObjectGetDescriptor = function(o, key) {
            return {value: o[key]};
        };
    
        var ObjectDefineProperty = function (o, key, desc) {
            o[key] = desc.value;
            return o;
        };
    
        var ObjectFreeze = function (obj) {
            return obj;
        };
    
        var ObjectGetPrototypeOf = function (obj) {
            try {
                return Object(obj).constructor.prototype;
            }
            catch (e) {
                return proto;
            }
        };
    
        var ArrayIsArray = function (obj) {
            try {
                return str.call(obj) === "[object Array]";
            }
            catch(e) {
                return false;
            }
        };
    
        module.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5: isES5,
            propertyIsWritable: function() {
                return true;
            }
        };
    }
    
  provide("bluebird/js/main/es5.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var canEvaluate = typeof navigator == "undefined";
    var haveGetters = (function(){
        try {
            var o = {};
            es5.defineProperty(o, "f", {
                get: function () {
                    return 3;
                }
            });
            return o.f === 3;
        }
        catch (e) {
            return false;
        }
    
    })();
    
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
        try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    
    var inherits = function(Child, Parent) {
        var hasProp = {}.hasOwnProperty;
    
        function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) &&
                    propertyName.charAt(propertyName.length-1) !== "$"
               ) {
                    this[propertyName + "$"] = Parent.prototype[propertyName];
                }
            }
        }
        T.prototype = Parent.prototype;
        Child.prototype = new T();
        return Child.prototype;
    };
    
    
    function isPrimitive(val) {
        return val == null || val === true || val === false ||
            typeof val === "string" || typeof val === "number";
    
    }
    
    function isObject(value) {
        return !isPrimitive(value);
    }
    
    function maybeWrapAsError(maybeError) {
        if (!isPrimitive(maybeError)) return maybeError;
    
        return new Error(safeToString(maybeError));
    }
    
    function withAppended(target, appendee) {
        var len = target.length;
        var ret = new Array(len + 1);
        var i;
        for (i = 0; i < len; ++i) {
            ret[i] = target[i];
        }
        ret[i] = appendee;
        return ret;
    }
    
    function getDataPropertyOrDefault(obj, key, defaultValue) {
        if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj, key);
    
            if (desc != null) {
                return desc.get == null && desc.set == null
                        ? desc.value
                        : defaultValue;
            }
        } else {
            return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
        }
    }
    
    function notEnumerableProp(obj, name, value) {
        if (isPrimitive(obj)) return obj;
        var descriptor = {
            value: value,
            configurable: true,
            enumerable: false,
            writable: true
        };
        es5.defineProperty(obj, name, descriptor);
        return obj;
    }
    
    function thrower(r) {
        throw r;
    }
    
    var inheritedDataKeys = (function() {
        var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
        ];
    
        var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
                if (excludedPrototypes[i] === val) {
                    return true;
                }
            }
            return false;
        };
    
        if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && !isExcludedProto(obj)) {
                    var keys;
                    try {
                        keys = getKeys(obj);
                    } catch (e) {
                        return ret;
                    }
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        if (visitedKeys[key]) continue;
                        visitedKeys[key] = true;
                        var desc = Object.getOwnPropertyDescriptor(obj, key);
                        if (desc != null && desc.get == null && desc.set == null) {
                            ret.push(key);
                        }
                    }
                    obj = es5.getPrototypeOf(obj);
                }
                return ret;
            };
        } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj) {
                if (isExcludedProto(obj)) return [];
                var ret = [];
    
                /*jshint forin:false */
                enumeration: for (var key in obj) {
                    if (hasProp.call(obj, key)) {
                        ret.push(key);
                    } else {
                        for (var i = 0; i < excludedPrototypes.length; ++i) {
                            if (hasProp.call(excludedPrototypes[i], key)) {
                                continue enumeration;
                            }
                        }
                        ret.push(key);
                    }
                }
                return ret;
            };
        }
    
    })();
    
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
        try {
            if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
    
                var hasMethods = es5.isES5 && keys.length > 1;
                var hasMethodsOtherThanConstructor = keys.length > 0 &&
                    !(keys.length === 1 && keys[0] === "constructor");
                var hasThisAssignmentAndStaticMethods =
                    thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
    
                if (hasMethods || hasMethodsOtherThanConstructor ||
                    hasThisAssignmentAndStaticMethods) {
                    return true;
                }
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    function toFastProperties(obj) {
        /*jshint -W027,-W055,-W031*/
        function f() {}
        f.prototype = obj;
        var l = 8;
        while (l--) new f();
        return obj;
        eval(obj);
    }
    
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
        return rident.test(str);
    }
    
    function filledRange(count, prefix, suffix) {
        var ret = new Array(count);
        for(var i = 0; i < count; ++i) {
            ret[i] = prefix + i + suffix;
        }
        return ret;
    }
    
    function safeToString(obj) {
        try {
            return obj + "";
        } catch (e) {
            return "[no string representation]";
        }
    }
    
    function markAsOriginatingFromRejection(e) {
        try {
            notEnumerableProp(e, "isOperational", true);
        }
        catch(ignore) {}
    }
    
    function originatesFromRejection(e) {
        if (e == null) return false;
        return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
            e["isOperational"] === true);
    }
    
    function canAttachTrace(obj) {
        return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
    }
    
    var ensureErrorObject = (function() {
        if (!("stack" in new Error())) {
            return function(value) {
                if (canAttachTrace(value)) return value;
                try {throw new Error(safeToString(value));}
                catch(err) {return err;}
            };
        } else {
            return function(value) {
                if (canAttachTrace(value)) return value;
                return new Error(safeToString(value));
            };
        }
    })();
    
    function classString(obj) {
        return {}.toString.call(obj);
    }
    
    function copyDescriptors(from, to, filter) {
        var keys = es5.names(from);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
                try {
                    es5.defineProperty(to, key, es5.getDescriptor(from, key));
                } catch (ignore) {}
            }
        }
    }
    
    var ret = {
        isClass: isClass,
        isIdentifier: isIdentifier,
        inheritedDataKeys: inheritedDataKeys,
        getDataPropertyOrDefault: getDataPropertyOrDefault,
        thrower: thrower,
        isArray: es5.isArray,
        haveGetters: haveGetters,
        notEnumerableProp: notEnumerableProp,
        isPrimitive: isPrimitive,
        isObject: isObject,
        canEvaluate: canEvaluate,
        errorObj: errorObj,
        tryCatch: tryCatch,
        inherits: inherits,
        withAppended: withAppended,
        maybeWrapAsError: maybeWrapAsError,
        toFastProperties: toFastProperties,
        filledRange: filledRange,
        toString: safeToString,
        canAttachTrace: canAttachTrace,
        ensureErrorObject: ensureErrorObject,
        originatesFromRejection: originatesFromRejection,
        markAsOriginatingFromRejection: markAsOriginatingFromRejection,
        classString: classString,
        copyDescriptors: copyDescriptors,
        hasDevTools: typeof chrome !== "undefined" && chrome &&
                     typeof chrome.loadTimes === "function",
        isNode: typeof process !== "undefined" &&
            classString(process).toLowerCase() === "[object process]"
    };
    ret.isRecentNode = ret.isNode && (function() {
        var version = process.versions.node.split(".").map(Number);
        return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
    })();
    
    if (ret.isNode) ret.toFastProperties(process);
    
    try {throw new Error(); } catch (e) {ret.lastLineError = e;}
    module.exports = ret;
    
  provide("bluebird/js/main/util", module.exports);
}(global));

// pakmanager:bluebird/js/main/util.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var canEvaluate = typeof navigator == "undefined";
    var haveGetters = (function(){
        try {
            var o = {};
            es5.defineProperty(o, "f", {
                get: function () {
                    return 3;
                }
            });
            return o.f === 3;
        }
        catch (e) {
            return false;
        }
    
    })();
    
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
        try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    
    var inherits = function(Child, Parent) {
        var hasProp = {}.hasOwnProperty;
    
        function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) &&
                    propertyName.charAt(propertyName.length-1) !== "$"
               ) {
                    this[propertyName + "$"] = Parent.prototype[propertyName];
                }
            }
        }
        T.prototype = Parent.prototype;
        Child.prototype = new T();
        return Child.prototype;
    };
    
    
    function isPrimitive(val) {
        return val == null || val === true || val === false ||
            typeof val === "string" || typeof val === "number";
    
    }
    
    function isObject(value) {
        return !isPrimitive(value);
    }
    
    function maybeWrapAsError(maybeError) {
        if (!isPrimitive(maybeError)) return maybeError;
    
        return new Error(safeToString(maybeError));
    }
    
    function withAppended(target, appendee) {
        var len = target.length;
        var ret = new Array(len + 1);
        var i;
        for (i = 0; i < len; ++i) {
            ret[i] = target[i];
        }
        ret[i] = appendee;
        return ret;
    }
    
    function getDataPropertyOrDefault(obj, key, defaultValue) {
        if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj, key);
    
            if (desc != null) {
                return desc.get == null && desc.set == null
                        ? desc.value
                        : defaultValue;
            }
        } else {
            return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
        }
    }
    
    function notEnumerableProp(obj, name, value) {
        if (isPrimitive(obj)) return obj;
        var descriptor = {
            value: value,
            configurable: true,
            enumerable: false,
            writable: true
        };
        es5.defineProperty(obj, name, descriptor);
        return obj;
    }
    
    function thrower(r) {
        throw r;
    }
    
    var inheritedDataKeys = (function() {
        var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
        ];
    
        var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
                if (excludedPrototypes[i] === val) {
                    return true;
                }
            }
            return false;
        };
    
        if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && !isExcludedProto(obj)) {
                    var keys;
                    try {
                        keys = getKeys(obj);
                    } catch (e) {
                        return ret;
                    }
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        if (visitedKeys[key]) continue;
                        visitedKeys[key] = true;
                        var desc = Object.getOwnPropertyDescriptor(obj, key);
                        if (desc != null && desc.get == null && desc.set == null) {
                            ret.push(key);
                        }
                    }
                    obj = es5.getPrototypeOf(obj);
                }
                return ret;
            };
        } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj) {
                if (isExcludedProto(obj)) return [];
                var ret = [];
    
                /*jshint forin:false */
                enumeration: for (var key in obj) {
                    if (hasProp.call(obj, key)) {
                        ret.push(key);
                    } else {
                        for (var i = 0; i < excludedPrototypes.length; ++i) {
                            if (hasProp.call(excludedPrototypes[i], key)) {
                                continue enumeration;
                            }
                        }
                        ret.push(key);
                    }
                }
                return ret;
            };
        }
    
    })();
    
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
        try {
            if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
    
                var hasMethods = es5.isES5 && keys.length > 1;
                var hasMethodsOtherThanConstructor = keys.length > 0 &&
                    !(keys.length === 1 && keys[0] === "constructor");
                var hasThisAssignmentAndStaticMethods =
                    thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
    
                if (hasMethods || hasMethodsOtherThanConstructor ||
                    hasThisAssignmentAndStaticMethods) {
                    return true;
                }
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    function toFastProperties(obj) {
        /*jshint -W027,-W055,-W031*/
        function f() {}
        f.prototype = obj;
        var l = 8;
        while (l--) new f();
        return obj;
        eval(obj);
    }
    
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
        return rident.test(str);
    }
    
    function filledRange(count, prefix, suffix) {
        var ret = new Array(count);
        for(var i = 0; i < count; ++i) {
            ret[i] = prefix + i + suffix;
        }
        return ret;
    }
    
    function safeToString(obj) {
        try {
            return obj + "";
        } catch (e) {
            return "[no string representation]";
        }
    }
    
    function markAsOriginatingFromRejection(e) {
        try {
            notEnumerableProp(e, "isOperational", true);
        }
        catch(ignore) {}
    }
    
    function originatesFromRejection(e) {
        if (e == null) return false;
        return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
            e["isOperational"] === true);
    }
    
    function canAttachTrace(obj) {
        return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
    }
    
    var ensureErrorObject = (function() {
        if (!("stack" in new Error())) {
            return function(value) {
                if (canAttachTrace(value)) return value;
                try {throw new Error(safeToString(value));}
                catch(err) {return err;}
            };
        } else {
            return function(value) {
                if (canAttachTrace(value)) return value;
                return new Error(safeToString(value));
            };
        }
    })();
    
    function classString(obj) {
        return {}.toString.call(obj);
    }
    
    function copyDescriptors(from, to, filter) {
        var keys = es5.names(from);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
                try {
                    es5.defineProperty(to, key, es5.getDescriptor(from, key));
                } catch (ignore) {}
            }
        }
    }
    
    var ret = {
        isClass: isClass,
        isIdentifier: isIdentifier,
        inheritedDataKeys: inheritedDataKeys,
        getDataPropertyOrDefault: getDataPropertyOrDefault,
        thrower: thrower,
        isArray: es5.isArray,
        haveGetters: haveGetters,
        notEnumerableProp: notEnumerableProp,
        isPrimitive: isPrimitive,
        isObject: isObject,
        canEvaluate: canEvaluate,
        errorObj: errorObj,
        tryCatch: tryCatch,
        inherits: inherits,
        withAppended: withAppended,
        maybeWrapAsError: maybeWrapAsError,
        toFastProperties: toFastProperties,
        filledRange: filledRange,
        toString: safeToString,
        canAttachTrace: canAttachTrace,
        ensureErrorObject: ensureErrorObject,
        originatesFromRejection: originatesFromRejection,
        markAsOriginatingFromRejection: markAsOriginatingFromRejection,
        classString: classString,
        copyDescriptors: copyDescriptors,
        hasDevTools: typeof chrome !== "undefined" && chrome &&
                     typeof chrome.loadTimes === "function",
        isNode: typeof process !== "undefined" &&
            classString(process).toLowerCase() === "[object process]"
    };
    ret.isRecentNode = ret.isNode && (function() {
        var version = process.versions.node.split(".").map(Number);
        return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
    })();
    
    if (ret.isNode) ret.toFastProperties(process);
    
    try {throw new Error(); } catch (e) {ret.lastLineError = e;}
    module.exports = ret;
    
  provide("bluebird/js/main/util.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/schedule.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var schedule;
    var util =  require('bluebird/js/main/util');
    var noAsyncScheduler = function() {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
    };
    if (util.isNode && typeof MutationObserver === "undefined") {
        var GlobalSetImmediate = global.setImmediate;
        var ProcessNextTick = process.nextTick;
        schedule = util.isRecentNode
                    ? function(fn) { GlobalSetImmediate.call(global, fn); }
                    : function(fn) { ProcessNextTick.call(process, fn); };
    } else if ((typeof MutationObserver !== "undefined") &&
              !(typeof window !== "undefined" &&
                window.navigator &&
                window.navigator.standalone)) {
        schedule = function(fn) {
            var div = document.createElement("div");
            var observer = new MutationObserver(fn);
            observer.observe(div, {attributes: true});
            return function() { div.classList.toggle("foo"); };
        };
        schedule.isStatic = true;
    } else if (typeof setImmediate !== "undefined") {
        schedule = function (fn) {
            setImmediate(fn);
        };
    } else if (typeof setTimeout !== "undefined") {
        schedule = function (fn) {
            setTimeout(fn, 0);
        };
    } else {
        schedule = noAsyncScheduler;
    }
    module.exports = schedule;
    
  provide("bluebird/js/main/schedule.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/queue.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
        for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
        }
    }
    
    function Queue(capacity) {
        this._capacity = capacity;
        this._length = 0;
        this._front = 0;
    }
    
    Queue.prototype._willBeOverCapacity = function (size) {
        return this._capacity < size;
    };
    
    Queue.prototype._pushOne = function (arg) {
        var length = this.length();
        this._checkCapacity(length + 1);
        var i = (this._front + length) & (this._capacity - 1);
        this[i] = arg;
        this._length = length + 1;
    };
    
    Queue.prototype._unshiftOne = function(value) {
        var capacity = this._capacity;
        this._checkCapacity(this.length() + 1);
        var front = this._front;
        var i = (((( front - 1 ) &
                        ( capacity - 1) ) ^ capacity ) - capacity );
        this[i] = value;
        this._front = i;
        this._length = this.length() + 1;
    };
    
    Queue.prototype.unshift = function(fn, receiver, arg) {
        this._unshiftOne(arg);
        this._unshiftOne(receiver);
        this._unshiftOne(fn);
    };
    
    Queue.prototype.push = function (fn, receiver, arg) {
        var length = this.length() + 3;
        if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver);
            this._pushOne(arg);
            return;
        }
        var j = this._front + length - 3;
        this._checkCapacity(length);
        var wrapMask = this._capacity - 1;
        this[(j + 0) & wrapMask] = fn;
        this[(j + 1) & wrapMask] = receiver;
        this[(j + 2) & wrapMask] = arg;
        this._length = length;
    };
    
    Queue.prototype.shift = function () {
        var front = this._front,
            ret = this[front];
    
        this[front] = undefined;
        this._front = (front + 1) & (this._capacity - 1);
        this._length--;
        return ret;
    };
    
    Queue.prototype.length = function () {
        return this._length;
    };
    
    Queue.prototype._checkCapacity = function (size) {
        if (this._capacity < size) {
            this._resizeTo(this._capacity << 1);
        }
    };
    
    Queue.prototype._resizeTo = function (capacity) {
        var oldCapacity = this._capacity;
        this._capacity = capacity;
        var front = this._front;
        var length = this._length;
        var moveItemsCount = (front + length) & (oldCapacity - 1);
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    
    module.exports = Queue;
    
  provide("bluebird/js/main/queue.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/errors.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var Objectfreeze = es5.freeze;
    var util =  require('bluebird/js/main/util.js');
    var inherits = util.inherits;
    var notEnumerableProp = util.notEnumerableProp;
    
    function subError(nameProperty, defaultMessage) {
        function SubError(message) {
            if (!(this instanceof SubError)) return new SubError(message);
            notEnumerableProp(this, "message",
                typeof message === "string" ? message : defaultMessage);
            notEnumerableProp(this, "name", nameProperty);
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            } else {
                Error.call(this);
            }
        }
        inherits(SubError, Error);
        return SubError;
    }
    
    var _TypeError, _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
        _TypeError = TypeError;
        _RangeError = RangeError;
    } catch(e) {
        _TypeError = subError("TypeError", "type error");
        _RangeError = subError("RangeError", "range error");
    }
    
    var methods = ("join pop push shift unshift slice filter forEach some " +
        "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
    
    for (var i = 0; i < methods.length; ++i) {
        if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
        }
    }
    
    es5.defineProperty(AggregateError.prototype, "length", {
        value: 0,
        configurable: false,
        writable: true,
        enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
        var indent = Array(level * 4 + 1).join(" ");
        var ret = "\n" + indent + "AggregateError of:" + "\n";
        level++;
        indent = Array(level * 4 + 1).join(" ");
        for (var i = 0; i < this.length; ++i) {
            var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret += str + "\n";
        }
        level--;
        return ret;
    };
    
    function OperationalError(message) {
        if (!(this instanceof OperationalError))
            return new OperationalError(message);
        notEnumerableProp(this, "name", "OperationalError");
        notEnumerableProp(this, "message", message);
        this.cause = message;
        this["isOperational"] = true;
    
        if (message instanceof Error) {
            notEnumerableProp(this, "message", message.message);
            notEnumerableProp(this, "stack", message.stack);
        } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    
    }
    inherits(OperationalError, Error);
    
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
        errorTypes = Objectfreeze({
            CancellationError: CancellationError,
            TimeoutError: TimeoutError,
            OperationalError: OperationalError,
            RejectionError: OperationalError,
            AggregateError: AggregateError
        });
        notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
    }
    
    module.exports = {
        Error: Error,
        TypeError: _TypeError,
        RangeError: _RangeError,
        CancellationError: errorTypes.CancellationError,
        OperationalError: errorTypes.OperationalError,
        TimeoutError: errorTypes.TimeoutError,
        AggregateError: errorTypes.AggregateError,
        Warning: Warning
    };
    
  provide("bluebird/js/main/errors.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/async.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var firstLineError;
    try {throw new Error(); } catch (e) {firstLineError = e;}
    var schedule =  require('bluebird/js/main/schedule.js');
    var Queue =  require('bluebird/js/main/queue.js');
    var util =  require('bluebird/js/main/util.js');
    
    function Async() {
        this._isTickUsed = false;
        this._lateQueue = new Queue(16);
        this._normalQueue = new Queue(16);
        this._trampolineEnabled = true;
        var self = this;
        this.drainQueues = function () {
            self._drainQueues();
        };
        this._schedule =
            schedule.isStatic ? schedule(this.drainQueues) : schedule;
    }
    
    Async.prototype.disableTrampolineIfNecessary = function() {
        if (util.hasDevTools) {
            this._trampolineEnabled = false;
        }
    };
    
    Async.prototype.enableTrampoline = function() {
        if (!this._trampolineEnabled) {
            this._trampolineEnabled = true;
            this._schedule = function(fn) {
                setTimeout(fn, 0);
            };
        }
    };
    
    Async.prototype.haveItemsQueued = function () {
        return this._normalQueue.length() > 0;
    };
    
    Async.prototype.throwLater = function(fn, arg) {
        if (arguments.length === 1) {
            arg = fn;
            fn = function () { throw arg; };
        }
        if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
                fn(arg);
            }, 0);
        } else try {
            this._schedule(function() {
                fn(arg);
            });
        } catch (e) {
            throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
        }
    };
    
    function AsyncInvokeLater(fn, receiver, arg) {
        this._lateQueue.push(fn, receiver, arg);
        this._queueTick();
    }
    
    function AsyncInvoke(fn, receiver, arg) {
        this._normalQueue.push(fn, receiver, arg);
        this._queueTick();
    }
    
    function AsyncSettlePromises(promise) {
        this._normalQueue._pushOne(promise);
        this._queueTick();
    }
    
    if (!util.hasDevTools) {
        Async.prototype.invokeLater = AsyncInvokeLater;
        Async.prototype.invoke = AsyncInvoke;
        Async.prototype.settlePromises = AsyncSettlePromises;
    } else {
        if (schedule.isStatic) {
            schedule = function(fn) { setTimeout(fn, 0); };
        }
        Async.prototype.invokeLater = function (fn, receiver, arg) {
            if (this._trampolineEnabled) {
                AsyncInvokeLater.call(this, fn, receiver, arg);
            } else {
                this._schedule(function() {
                    setTimeout(function() {
                        fn.call(receiver, arg);
                    }, 100);
                });
            }
        };
    
        Async.prototype.invoke = function (fn, receiver, arg) {
            if (this._trampolineEnabled) {
                AsyncInvoke.call(this, fn, receiver, arg);
            } else {
                this._schedule(function() {
                    fn.call(receiver, arg);
                });
            }
        };
    
        Async.prototype.settlePromises = function(promise) {
            if (this._trampolineEnabled) {
                AsyncSettlePromises.call(this, promise);
            } else {
                this._schedule(function() {
                    promise._settlePromises();
                });
            }
        };
    }
    
    Async.prototype.invokeFirst = function (fn, receiver, arg) {
        this._normalQueue.unshift(fn, receiver, arg);
        this._queueTick();
    };
    
    Async.prototype._drainQueue = function(queue) {
        while (queue.length() > 0) {
            var fn = queue.shift();
            if (typeof fn !== "function") {
                fn._settlePromises();
                continue;
            }
            var receiver = queue.shift();
            var arg = queue.shift();
            fn.call(receiver, arg);
        }
    };
    
    Async.prototype._drainQueues = function () {
        this._drainQueue(this._normalQueue);
        this._reset();
        this._drainQueue(this._lateQueue);
    };
    
    Async.prototype._queueTick = function () {
        if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
        }
    };
    
    Async.prototype._reset = function () {
        this._isTickUsed = false;
    };
    
    module.exports = new Async();
    module.exports.firstLineError = firstLineError;
    
  provide("bluebird/js/main/async.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise_resolver.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var util =  require('bluebird/js/main/util.js');
    var maybeWrapAsError = util.maybeWrapAsError;
    var errors =  require('bluebird/js/main/errors.js');
    var TimeoutError = errors.TimeoutError;
    var OperationalError = errors.OperationalError;
    var haveGetters = util.haveGetters;
    var es5 =  require('bluebird/js/main/es5.js');
    
    function isUntypedError(obj) {
        return obj instanceof Error &&
            es5.getPrototypeOf(obj) === Error.prototype;
    }
    
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj) {
        var ret;
        if (isUntypedError(obj)) {
            ret = new OperationalError(obj);
            ret.name = obj.name;
            ret.message = obj.message;
            ret.stack = obj.stack;
            var keys = es5.keys(obj);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (!rErrorKey.test(key)) {
                    ret[key] = obj[key];
                }
            }
            return ret;
        }
        util.markAsOriginatingFromRejection(obj);
        return obj;
    }
    
    function nodebackForPromise(promise) {
        return function(err, value) {
            if (promise === null) return;
    
            if (err) {
                var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                promise._attachExtraTrace(wrapped);
                promise._reject(wrapped);
            } else if (arguments.length > 2) {
                var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
                promise._fulfill(args);
            } else {
                promise._fulfill(value);
            }
    
            promise = null;
        };
    }
    
    
    var PromiseResolver;
    if (!haveGetters) {
        PromiseResolver = function (promise) {
            this.promise = promise;
            this.asCallback = nodebackForPromise(promise);
            this.callback = this.asCallback;
        };
    }
    else {
        PromiseResolver = function (promise) {
            this.promise = promise;
        };
    }
    if (haveGetters) {
        var prop = {
            get: function() {
                return nodebackForPromise(this.promise);
            }
        };
        es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
        es5.defineProperty(PromiseResolver.prototype, "callback", prop);
    }
    
    PromiseResolver._nodebackForPromise = nodebackForPromise;
    
    PromiseResolver.prototype.toString = function () {
        return "[object PromiseResolver]";
    };
    
    PromiseResolver.prototype.resolve =
    PromiseResolver.prototype.fulfill = function (value) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._resolveCallback(value);
    };
    
    PromiseResolver.prototype.reject = function (reason) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._rejectCallback(reason);
    };
    
    PromiseResolver.prototype.progress = function (value) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._progress(value);
    };
    
    PromiseResolver.prototype.cancel = function (err) {
        this.promise.cancel(err);
    };
    
    PromiseResolver.prototype.timeout = function () {
        this.reject(new TimeoutError("timeout"));
    };
    
    PromiseResolver.prototype.isResolved = function () {
        return this.promise.isResolved();
    };
    
    PromiseResolver.prototype.toJSON = function () {
        return this.promise.toJSON();
    };
    
    module.exports = PromiseResolver;
    
  provide("bluebird/js/main/promise_resolver.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/errors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var Objectfreeze = es5.freeze;
    var util =  require('bluebird/js/main/util.js');
    var inherits = util.inherits;
    var notEnumerableProp = util.notEnumerableProp;
    
    function subError(nameProperty, defaultMessage) {
        function SubError(message) {
            if (!(this instanceof SubError)) return new SubError(message);
            notEnumerableProp(this, "message",
                typeof message === "string" ? message : defaultMessage);
            notEnumerableProp(this, "name", nameProperty);
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            } else {
                Error.call(this);
            }
        }
        inherits(SubError, Error);
        return SubError;
    }
    
    var _TypeError, _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
        _TypeError = TypeError;
        _RangeError = RangeError;
    } catch(e) {
        _TypeError = subError("TypeError", "type error");
        _RangeError = subError("RangeError", "range error");
    }
    
    var methods = ("join pop push shift unshift slice filter forEach some " +
        "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
    
    for (var i = 0; i < methods.length; ++i) {
        if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
        }
    }
    
    es5.defineProperty(AggregateError.prototype, "length", {
        value: 0,
        configurable: false,
        writable: true,
        enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
        var indent = Array(level * 4 + 1).join(" ");
        var ret = "\n" + indent + "AggregateError of:" + "\n";
        level++;
        indent = Array(level * 4 + 1).join(" ");
        for (var i = 0; i < this.length; ++i) {
            var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret += str + "\n";
        }
        level--;
        return ret;
    };
    
    function OperationalError(message) {
        if (!(this instanceof OperationalError))
            return new OperationalError(message);
        notEnumerableProp(this, "name", "OperationalError");
        notEnumerableProp(this, "message", message);
        this.cause = message;
        this["isOperational"] = true;
    
        if (message instanceof Error) {
            notEnumerableProp(this, "message", message.message);
            notEnumerableProp(this, "stack", message.stack);
        } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    
    }
    inherits(OperationalError, Error);
    
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
        errorTypes = Objectfreeze({
            CancellationError: CancellationError,
            TimeoutError: TimeoutError,
            OperationalError: OperationalError,
            RejectionError: OperationalError,
            AggregateError: AggregateError
        });
        notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
    }
    
    module.exports = {
        Error: Error,
        TypeError: _TypeError,
        RangeError: _RangeError,
        CancellationError: errorTypes.CancellationError,
        OperationalError: errorTypes.OperationalError,
        TimeoutError: errorTypes.TimeoutError,
        AggregateError: errorTypes.AggregateError,
        Warning: Warning
    };
    
  provide("bluebird/js/main/errors", module.exports);
}(global));

// pakmanager:bluebird/js/main/thenables.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var errorObj = util.errorObj;
    var isObject = util.isObject;
    
    function tryConvertToPromise(obj, context) {
        if (isObject(obj)) {
            if (obj instanceof Promise) {
                return obj;
            }
            else if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfillUnchecked,
                    ret._rejectUncheckedCheckError,
                    ret._progressUnchecked,
                    ret,
                    null
                );
                return ret;
            }
            var then = util.tryCatch(getThen)(obj);
            if (then === errorObj) {
                if (context) context._pushContext();
                var ret = Promise.reject(then.e);
                if (context) context._popContext();
                return ret;
            } else if (typeof then === "function") {
                return doThenable(obj, then, context);
            }
        }
        return obj;
    }
    
    function getThen(obj) {
        return obj.then;
    }
    
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
        return hasProp.call(obj, "_promise0");
    }
    
    function doThenable(x, then, context) {
        var promise = new Promise(INTERNAL);
        var ret = promise;
        if (context) context._pushContext();
        promise._captureStackTrace();
        if (context) context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x,
                                            resolveFromThenable,
                                            rejectFromThenable,
                                            progressFromThenable);
        synchronous = false;
        if (promise && result === errorObj) {
            promise._rejectCallback(result.e, true, true);
            promise = null;
        }
    
        function resolveFromThenable(value) {
            if (!promise) return;
            promise._resolveCallback(value);
            promise = null;
        }
    
        function rejectFromThenable(reason) {
            if (!promise) return;
            promise._rejectCallback(reason, synchronous, true);
            promise = null;
        }
    
        function progressFromThenable(value) {
            if (!promise) return;
            if (typeof promise._progress === "function") {
                promise._progress(value);
            }
        }
        return ret;
    }
    
    return tryConvertToPromise;
    };
    
  provide("bluebird/js/main/thenables.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise_array.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise,
        apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var isArray = util.isArray;
    
    function toResolutionValue(val) {
        switch(val) {
        case -2: return [];
        case -3: return {};
        }
    }
    
    function PromiseArray(values) {
        var promise = this._promise = new Promise(INTERNAL);
        var parent;
        if (values instanceof Promise) {
            parent = values;
            promise._propagateFrom(parent, 1 | 4);
        }
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(undefined, -2);
    }
    PromiseArray.prototype.length = function () {
        return this._length;
    };
    
    PromiseArray.prototype.promise = function () {
        return this._promise;
    };
    
    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise) {
            values = values._target();
            this._values = values;
            if (values._isFulfilled()) {
                values = values._value();
                if (!isArray(values)) {
                    var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
                    this.__hardReject__(err);
                    return;
                }
            } else if (values._isPending()) {
                values._then(
                    init,
                    this._reject,
                    undefined,
                    this,
                    resolveValueIfEmpty
               );
                return;
            } else {
                this._reject(values._reason());
                return;
            }
        } else if (!isArray(values)) {
            this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
            return;
        }
    
        if (values.length === 0) {
            if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
            }
            else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
            }
            return;
        }
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var promise = this._promise;
        for (var i = 0; i < len; ++i) {
            var isResolved = this._isResolved();
            var maybePromise = tryConvertToPromise(values[i], promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (isResolved) {
                    maybePromise._ignoreRejections();
                } else if (maybePromise._isPending()) {
                    maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                    this._promiseFulfilled(maybePromise._value(), i);
                } else {
                    this._promiseRejected(maybePromise._reason(), i);
                }
            } else if (!isResolved) {
                this._promiseFulfilled(maybePromise, i);
            }
        }
    };
    
    PromiseArray.prototype._isResolved = function () {
        return this._values === null;
    };
    
    PromiseArray.prototype._resolve = function (value) {
        this._values = null;
        this._promise._fulfill(value);
    };
    
    PromiseArray.prototype.__hardReject__ =
    PromiseArray.prototype._reject = function (reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false, true);
    };
    
    PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
        this._promise._progress({
            index: index,
            value: progressValue
        });
    };
    
    
    PromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
        }
    };
    
    PromiseArray.prototype._promiseRejected = function (reason, index) {
        this._totalResolved++;
        this._reject(reason);
    };
    
    PromiseArray.prototype.shouldCopyValues = function () {
        return true;
    };
    
    PromiseArray.prototype.getActualLength = function (len) {
        return len;
    };
    
    return PromiseArray;
    };
    
  provide("bluebird/js/main/promise_array.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/captured_trace.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function() {
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var bluebirdFramePattern =
        /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var warn;
    
    function CapturedTrace(parent) {
        this._parent = parent;
        var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32) this.uncycle();
    }
    util.inherits(CapturedTrace, Error);
    
    CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2) return;
        var nodes = [];
        var stackToIndex = {};
    
        for (var i = 0, node = this; node !== undefined; ++i) {
            nodes.push(node);
            node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
            var stack = nodes[i].stack;
            if (stackToIndex[stack] === undefined) {
                stackToIndex[stack] = i;
            }
        }
        for (var i = 0; i < length; ++i) {
            var currentStack = nodes[i].stack;
            var index = stackToIndex[currentStack];
            if (index !== undefined && index !== i) {
                if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = undefined;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
    
                if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length =
                        cycleEdgeNode._parent._length + 1;
                } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                }
                return;
            }
        }
    };
    
    CapturedTrace.prototype.parent = function() {
        return this._parent;
    };
    
    CapturedTrace.prototype.hasParent = function() {
        return this._parent !== undefined;
    };
    
    CapturedTrace.prototype.attachExtraTrace = function(error) {
        if (error.__stackCleaned__) return;
        this.uncycle();
        var parsed = CapturedTrace.parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];
    
        var trace = this;
        while (trace !== undefined) {
            stacks.push(cleanStack(trace.stack.split("\n")));
            trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
    };
    
    function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
            stacks[i].push("From previous event:");
            stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
            stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
    }
    
    function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
            if (stacks[i].length === 0 ||
                ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
                stacks.splice(i, 1);
                i--;
            }
        }
    }
    
    function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
            var prev = stacks[i];
            var currentLastIndex = current.length - 1;
            var currentLastLine = current[currentLastIndex];
            var commonRootMeetPoint = -1;
    
            for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                }
            }
    
            for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                } else {
                    break;
                }
            }
            current = prev;
        }
    }
    
    function cleanStack(stack) {
        var ret = [];
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            var isTraceLine = stackFramePattern.test(line) ||
                "    (No stack trace)" === line;
            var isInternalFrame = isTraceLine && shouldIgnore(line);
            if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                }
                ret.push(line);
            }
        }
        return ret;
    }
    
    function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
            }
        }
        if (i > 0) {
            stack = stack.slice(i);
        }
        return stack;
    }
    
    CapturedTrace.parseStackAndMessage = function(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0
                    ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
            message: message,
            stack: cleanStack(stack)
        };
    };
    
    CapturedTrace.formatAndLogError = function(error, title) {
        if (typeof console !== "undefined") {
            var message;
            if (typeof error === "object" || typeof error === "function") {
                var stack = error.stack;
                message = title + formatStack(stack, error);
            } else {
                message = title + String(error);
            }
            if (typeof warn === "function") {
                warn(message);
            } else if (typeof console.log === "function" ||
                typeof console.log === "object") {
                console.log(message);
            }
        }
    };
    
    CapturedTrace.unhandledRejection = function (reason) {
        CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
    };
    
    CapturedTrace.isSupported = function () {
        return typeof captureStackTrace === "function";
    };
    
    CapturedTrace.fireRejectionEvent =
    function(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
            if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                    localHandler(promise);
                } else {
                    localHandler(reason, promise);
                }
            }
        } catch (e) {
            async.throwLater(e);
        }
    
        var globalEventFired = false;
        try {
            globalEventFired = fireGlobalEvent(name, reason, promise);
        } catch (e) {
            globalEventFired = true;
            async.throwLater(e);
        }
    
        var domEventFired = false;
        if (fireDomEvent) {
            try {
                domEventFired = fireDomEvent(name.toLowerCase(), {
                    reason: reason,
                    promise: promise
                });
            } catch (e) {
                domEventFired = true;
                async.throwLater(e);
            }
        }
    
        if (!globalEventFired && !localEventFired && !domEventFired &&
            name === "unhandledRejection") {
            CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
        }
    };
    
    function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
            str = "[function " +
                (obj.name || "anonymous") +
                "]";
        } else {
            str = obj.toString();
            var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
            if (ruselessToString.test(str)) {
                try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                }
                catch(e) {
    
                }
            }
            if (str.length === 0) {
                str = "(empty array)";
            }
        }
        return ("(<" + snip(str) + ">, no stack trace)");
    }
    
    function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
            return str;
        }
        return str.substr(0, maxChars - 3) + "...";
    }
    
    var shouldIgnore = function() { return false; };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
            return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
            };
        }
    }
    CapturedTrace.setBounds = function(firstLineError, lastLineError) {
        if (!CapturedTrace.isSupported()) return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
            var result = parseLineInfo(firstStackLines[i]);
            if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
            }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
            var result = parseLineInfo(lastStackLines[i]);
            if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
            }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
            firstFileName !== lastFileName || firstIndex >= lastIndex) {
            return;
        }
    
        shouldIgnore = function(line) {
            if (bluebirdFramePattern.test(line)) return true;
            var info = parseLineInfo(line);
            if (info) {
                if (info.fileName === firstFileName &&
                    (firstIndex <= info.line && info.line <= lastIndex)) {
                    return true;
                }
            }
            return false;
        };
    };
    
    var captureStackTrace = (function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error) {
            if (typeof stack === "string") return stack;
    
            if (error.name !== undefined &&
                error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };
    
        if (typeof Error.stackTraceLimit === "number" &&
            typeof Error.captureStackTrace === "function") {
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            var captureStackTrace = Error.captureStackTrace;
    
            shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
            };
            return function(receiver, ignoreUntil) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                captureStackTrace(receiver, ignoreUntil);
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
            };
        }
        var err = new Error();
    
        if (typeof err.stack === "string" &&
            err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
            stackFramePattern = /@/;
            formatStack = v8stackFormatter;
            indentStackFrames = true;
            return function captureStackTrace(o) {
                o.stack = new Error().stack;
            };
        }
    
        var hasStackAfterThrow;
        try { throw new Error(); }
        catch(e) {
            hasStackAfterThrow = ("stack" in e);
        }
        if (!("stack" in err) && hasStackAfterThrow &&
            typeof Error.stackTraceLimit === "number") {
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            return function captureStackTrace(o) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                try { throw new Error(); }
                catch(e) { o.stack = e.stack; }
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
            };
        }
    
        formatStack = function(stack, error) {
            if (typeof stack === "string") return stack;
    
            if ((typeof error === "object" ||
                typeof error === "function") &&
                error.name !== undefined &&
                error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };
    
        return null;
    
    })([]);
    
    var fireDomEvent;
    var fireGlobalEvent = (function() {
        if (util.isNode) {
            return function(name, reason, promise) {
                if (name === "rejectionHandled") {
                    return process.emit(name, promise);
                } else {
                    return process.emit(name, reason, promise);
                }
            };
        } else {
            var customEventWorks = false;
            var anyEventWorks = true;
            try {
                var ev = new self.CustomEvent("test");
                customEventWorks = ev instanceof CustomEvent;
            } catch (e) {}
            if (!customEventWorks) {
                try {
                    var event = document.createEvent("CustomEvent");
                    event.initCustomEvent("testingtheevent", false, true, {});
                    self.dispatchEvent(event);
                } catch (e) {
                    anyEventWorks = false;
                }
            }
            if (anyEventWorks) {
                fireDomEvent = function(type, detail) {
                    var event;
                    if (customEventWorks) {
                        event = new self.CustomEvent(type, {
                            detail: detail,
                            bubbles: false,
                            cancelable: true
                        });
                    } else if (self.dispatchEvent) {
                        event = document.createEvent("CustomEvent");
                        event.initCustomEvent(type, false, true, detail);
                    }
    
                    return event ? !self.dispatchEvent(event) : false;
                };
            }
    
            var toWindowMethodNameMap = {};
            toWindowMethodNameMap["unhandledRejection"] = ("on" +
                "unhandledRejection").toLowerCase();
            toWindowMethodNameMap["rejectionHandled"] = ("on" +
                "rejectionHandled").toLowerCase();
    
            return function(name, reason, promise) {
                var methodName = toWindowMethodNameMap[name];
                var method = self[methodName];
                if (!method) return false;
                if (name === "rejectionHandled") {
                    method.call(self, promise);
                } else {
                    method.call(self, reason, promise);
                }
                return true;
            };
        }
    })();
    
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        warn = function (message) {
            console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
            warn = function(message) {
                process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
            };
        } else if (!util.isNode && typeof (new Error().stack) === "string") {
            warn = function(message) {
                console.warn("%c" + message, "color: red");
            };
        }
    }
    
    return CapturedTrace;
    };
    
  provide("bluebird/js/main/captured_trace.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/debuggability.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, CapturedTrace) {
    var getDomain = Promise._getDomain;
    var async =  require('bluebird/js/main/async.js');
    var Warning =  require('bluebird/js/main/errors.js').Warning;
    var util =  require('bluebird/js/main/util.js');
    var canAttachTrace = util.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var debugging = false || (util.isNode &&
                        (!!process.env["BLUEBIRD_DEBUG"] ||
                         process.env["NODE_ENV"] === "development"));
    
    if (util.isNode && process.env["BLUEBIRD_DEBUG"] == 0) debugging = false;
    
    if (debugging) {
        async.disableTrampolineIfNecessary();
    }
    
    Promise.prototype._ignoreRejections = function() {
        this._unsetRejectionIsUnhandled();
        this._bitField = this._bitField | 16777216;
    };
    
    Promise.prototype._ensurePossibleRejectionHandled = function () {
        if ((this._bitField & 16777216) !== 0) return;
        this._setRejectionIsUnhandled();
        async.invokeLater(this._notifyUnhandledRejection, this, undefined);
    };
    
    Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
        CapturedTrace.fireRejectionEvent("rejectionHandled",
                                      unhandledRejectionHandled, undefined, this);
    };
    
    Promise.prototype._notifyUnhandledRejection = function () {
        if (this._isRejectionUnhandled()) {
            var reason = this._getCarriedStackTrace() || this._settledValue;
            this._setUnhandledRejectionIsNotified();
            CapturedTrace.fireRejectionEvent("unhandledRejection",
                                          possiblyUnhandledRejection, reason, this);
        }
    };
    
    Promise.prototype._setUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField | 524288;
    };
    
    Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField & (~524288);
    };
    
    Promise.prototype._isUnhandledRejectionNotified = function () {
        return (this._bitField & 524288) > 0;
    };
    
    Promise.prototype._setRejectionIsUnhandled = function () {
        this._bitField = this._bitField | 2097152;
    };
    
    Promise.prototype._unsetRejectionIsUnhandled = function () {
        this._bitField = this._bitField & (~2097152);
        if (this._isUnhandledRejectionNotified()) {
            this._unsetUnhandledRejectionIsNotified();
            this._notifyUnhandledRejectionIsHandled();
        }
    };
    
    Promise.prototype._isRejectionUnhandled = function () {
        return (this._bitField & 2097152) > 0;
    };
    
    Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
        this._bitField = this._bitField | 1048576;
        this._fulfillmentHandler0 = capturedTrace;
    };
    
    Promise.prototype._isCarryingStackTrace = function () {
        return (this._bitField & 1048576) > 0;
    };
    
    Promise.prototype._getCarriedStackTrace = function () {
        return this._isCarryingStackTrace()
            ? this._fulfillmentHandler0
            : undefined;
    };
    
    Promise.prototype._captureStackTrace = function () {
        if (debugging) {
            this._trace = new CapturedTrace(this._peekContext());
        }
        return this;
    };
    
    Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
        if (debugging && canAttachTrace(error)) {
            var trace = this._trace;
            if (trace !== undefined) {
                if (ignoreSelf) trace = trace._parent;
            }
            if (trace !== undefined) {
                trace.attachExtraTrace(error);
            } else if (!error.__stackCleaned__) {
                var parsed = CapturedTrace.parseStackAndMessage(error);
                util.notEnumerableProp(error, "stack",
                    parsed.message + "\n" + parsed.stack.join("\n"));
                util.notEnumerableProp(error, "__stackCleaned__", true);
            }
        }
    };
    
    Promise.prototype._warn = function(message) {
        var warning = new Warning(message);
        var ctx = this._peekContext();
        if (ctx) {
            ctx.attachExtraTrace(warning);
        } else {
            var parsed = CapturedTrace.parseStackAndMessage(warning);
            warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        CapturedTrace.formatAndLogError(warning, "");
    };
    
    Promise.onPossiblyUnhandledRejection = function (fn) {
        var domain = getDomain();
        possiblyUnhandledRejection =
            typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                     : undefined;
    };
    
    Promise.onUnhandledRejectionHandled = function (fn) {
        var domain = getDomain();
        unhandledRejectionHandled =
            typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                     : undefined;
    };
    
    Promise.longStackTraces = function () {
        if (async.haveItemsQueued() &&
            debugging === false
       ) {
            throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
        }
        debugging = CapturedTrace.isSupported();
        if (debugging) {
            async.disableTrampolineIfNecessary();
        }
    };
    
    Promise.hasLongStackTraces = function () {
        return debugging && CapturedTrace.isSupported();
    };
    
    if (!CapturedTrace.isSupported()) {
        Promise.longStackTraces = function(){};
        debugging = false;
    }
    
    return function() {
        return debugging;
    };
    };
    
  provide("bluebird/js/main/debuggability.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/context.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, CapturedTrace, isDebugging) {
    var contextStack = [];
    function Context() {
        this._trace = new CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function () {
        if (!isDebugging()) return;
        if (this._trace !== undefined) {
            contextStack.push(this._trace);
        }
    };
    
    Context.prototype._popContext = function () {
        if (!isDebugging()) return;
        if (this._trace !== undefined) {
            contextStack.pop();
        }
    };
    
    function createContext() {
        if (isDebugging()) return new Context();
    }
    
    function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
            return contextStack[lastIndex];
        }
        return undefined;
    }
    
    Promise.prototype._peekContext = peekContext;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    
    return createContext;
    };
    
  provide("bluebird/js/main/context.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/catch_filter.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(NEXT_FILTER) {
    var util =  require('bluebird/js/main/util.js');
    var errors =  require('bluebird/js/main/errors.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var keys =  require('bluebird/js/main/es5.js').keys;
    var TypeError = errors.TypeError;
    
    function CatchFilter(instances, callback, promise) {
        this._instances = instances;
        this._callback = callback;
        this._promise = promise;
    }
    
    function safePredicate(predicate, e) {
        var safeObject = {};
        var retfilter = tryCatch(predicate).call(safeObject, e);
    
        if (retfilter === errorObj) return retfilter;
    
        var safeKeys = keys(safeObject);
        if (safeKeys.length) {
            errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
            return errorObj;
        }
        return retfilter;
    }
    
    CatchFilter.prototype.doFilter = function (e) {
        var cb = this._callback;
        var promise = this._promise;
        var boundTo = promise._boundValue();
        for (var i = 0, len = this._instances.length; i < len; ++i) {
            var item = this._instances[i];
            var itemIsErrorType = item === Error ||
                (item != null && item.prototype instanceof Error);
    
            if (itemIsErrorType && e instanceof item) {
                var ret = tryCatch(cb).call(boundTo, e);
                if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                }
                return ret;
            } else if (typeof item === "function" && !itemIsErrorType) {
                var shouldHandle = safePredicate(item, e);
                if (shouldHandle === errorObj) {
                    e = errorObj.e;
                    break;
                } else if (shouldHandle) {
                    var ret = tryCatch(cb).call(boundTo, e);
                    if (ret === errorObj) {
                        NEXT_FILTER.e = ret.e;
                        return NEXT_FILTER;
                    }
                    return ret;
                }
            }
        }
        NEXT_FILTER.e = e;
        return NEXT_FILTER;
    };
    
    return CatchFilter;
    };
    
  provide("bluebird/js/main/catch_filter.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/progress.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, PromiseArray) {
    var util =  require('bluebird/js/main/util.js');
    var async =  require('bluebird/js/main/async.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    
    Promise.prototype.progressed = function (handler) {
        return this._then(undefined, undefined, handler, undefined, undefined);
    };
    
    Promise.prototype._progress = function (progressValue) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._target()._progressUnchecked(progressValue);
    
    };
    
    Promise.prototype._progressHandlerAt = function (index) {
        return index === 0
            ? this._progressHandler0
            : this[(index << 2) + index - 5 + 2];
    };
    
    Promise.prototype._doProgressWith = function (progression) {
        var progressValue = progression.value;
        var handler = progression.handler;
        var promise = progression.promise;
        var receiver = progression.receiver;
    
        var ret = tryCatch(handler).call(receiver, progressValue);
        if (ret === errorObj) {
            if (ret.e != null &&
                ret.e.name !== "StopProgressPropagation") {
                var trace = util.canAttachTrace(ret.e)
                    ? ret.e : new Error(util.toString(ret.e));
                promise._attachExtraTrace(trace);
                promise._progress(ret.e);
            }
        } else if (ret instanceof Promise) {
            ret._then(promise._progress, null, null, promise, undefined);
        } else {
            promise._progress(ret);
        }
    };
    
    
    Promise.prototype._progressUnchecked = function (progressValue) {
        var len = this._length();
        var progress = this._progress;
        for (var i = 0; i < len; i++) {
            var handler = this._progressHandlerAt(i);
            var promise = this._promiseAt(i);
            if (!(promise instanceof Promise)) {
                var receiver = this._receiverAt(i);
                if (typeof handler === "function") {
                    handler.call(receiver, progressValue, promise);
                } else if (receiver instanceof PromiseArray &&
                           !receiver._isResolved()) {
                    receiver._promiseProgressed(progressValue, promise);
                }
                continue;
            }
    
            if (typeof handler === "function") {
                async.invoke(this._doProgressWith, this, {
                    handler: handler,
                    promise: promise,
                    receiver: this._receiverAt(i),
                    value: progressValue
                });
            } else {
                async.invoke(progress, promise, progressValue);
            }
        }
    };
    };
    
  provide("bluebird/js/main/progress.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/method.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    
    Promise.method = function (fn) {
        if (typeof fn !== "function") {
            throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        return function () {
            var ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._pushContext();
            var value = tryCatch(fn).apply(this, arguments);
            ret._popContext();
            ret._resolveFromSyncValue(value);
            return ret;
        };
    };
    
    Promise.attempt = Promise["try"] = function (fn, args, ctx) {
        if (typeof fn !== "function") {
            return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = util.isArray(args)
            ? tryCatch(fn).apply(ctx, args)
            : tryCatch(fn).call(ctx, args);
        ret._popContext();
        ret._resolveFromSyncValue(value);
        return ret;
    };
    
    Promise.prototype._resolveFromSyncValue = function (value) {
        if (value === util.errorObj) {
            this._rejectCallback(value.e, false, true);
        } else {
            this._resolveCallback(value, true);
        }
    };
    };
    
  provide("bluebird/js/main/method.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/bind.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
    var rejectThis = function(_, e) {
        this._reject(e);
    };
    
    var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    
    var bindingResolved = function(thisArg, context) {
        if (this._isPending()) {
            this._resolveCallback(context.target);
        }
    };
    
    var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued) this._reject(e);
    };
    
    Promise.prototype.bind = function (thisArg) {
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
        ret._propagateFrom(this, 1);
        var target = this._target();
    
        ret._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise) {
            var context = {
                promiseRejectionQueued: false,
                promise: ret,
                target: target,
                bindingPromise: maybePromise
            };
            target._then(INTERNAL, targetRejected, ret._progress, ret, context);
            maybePromise._then(
                bindingResolved, bindingRejected, ret._progress, ret, context);
        } else {
            ret._resolveCallback(target);
        }
        return ret;
    };
    
    Promise.prototype._setBoundTo = function (obj) {
        if (obj !== undefined) {
            this._bitField = this._bitField | 131072;
            this._boundTo = obj;
        } else {
            this._bitField = this._bitField & (~131072);
        }
    };
    
    Promise.prototype._isBound = function () {
        return (this._bitField & 131072) === 131072;
    };
    
    Promise.bind = function (thisArg, value) {
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
    
        ret._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise) {
            maybePromise._then(function() {
                ret._resolveCallback(value);
            }, ret._reject, ret._progress, ret, null);
        } else {
            ret._resolveCallback(value);
        }
        return ret;
    };
    };
    
  provide("bluebird/js/main/bind.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/finally.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
    var util =  require('bluebird/js/main/util.js');
    var isPrimitive = util.isPrimitive;
    var thrower = util.thrower;
    
    function returnThis() {
        return this;
    }
    function throwThis() {
        throw this;
    }
    function return$(r) {
        return function() {
            return r;
        };
    }
    function throw$(r) {
        return function() {
            throw r;
        };
    }
    function promisedFinally(ret, reasonOrValue, isFulfilled) {
        var then;
        if (isPrimitive(reasonOrValue)) {
            then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
        } else {
            then = isFulfilled ? returnThis : throwThis;
        }
        return ret._then(then, thrower, undefined, reasonOrValue, undefined);
    }
    
    function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
    
        var ret = promise._isBound()
                        ? handler.call(promise._boundValue())
                        : handler();
    
        if (ret !== undefined) {
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, reasonOrValue,
                                        promise.isFulfilled());
            }
        }
    
        if (promise.isRejected()) {
            NEXT_FILTER.e = reasonOrValue;
            return NEXT_FILTER;
        } else {
            return reasonOrValue;
        }
    }
    
    function tapHandler(value) {
        var promise = this.promise;
        var handler = this.handler;
    
        var ret = promise._isBound()
                        ? handler.call(promise._boundValue(), value)
                        : handler(value);
    
        if (ret !== undefined) {
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, value, true);
            }
        }
        return value;
    }
    
    Promise.prototype._passThroughHandler = function (handler, isFinally) {
        if (typeof handler !== "function") return this.then();
    
        var promiseAndHandler = {
            promise: this,
            handler: handler
        };
    
        return this._then(
                isFinally ? finallyHandler : tapHandler,
                isFinally ? finallyHandler : undefined, undefined,
                promiseAndHandler, undefined);
    };
    
    Promise.prototype.lastly =
    Promise.prototype["finally"] = function (handler) {
        return this._passThroughHandler(handler, true);
    };
    
    Promise.prototype.tap = function (handler) {
        return this._passThroughHandler(handler, false);
    };
    };
    
  provide("bluebird/js/main/finally.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/direct_resolve.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var util =  require('bluebird/js/main/util.js');
    var isPrimitive = util.isPrimitive;
    
    module.exports = function(Promise) {
    var returner = function () {
        return this;
    };
    var thrower = function () {
        throw this;
    };
    var returnUndefined = function() {};
    var throwUndefined = function() {
        throw undefined;
    };
    
    var wrapper = function (value, action) {
        if (action === 1) {
            return function () {
                throw value;
            };
        } else if (action === 2) {
            return function () {
                return value;
            };
        }
    };
    
    
    Promise.prototype["return"] =
    Promise.prototype.thenReturn = function (value) {
        if (value === undefined) return this.then(returnUndefined);
    
        if (isPrimitive(value)) {
            return this._then(
                wrapper(value, 2),
                undefined,
                undefined,
                undefined,
                undefined
           );
        } else if (value instanceof Promise) {
            value._ignoreRejections();
        }
        return this._then(returner, undefined, undefined, value, undefined);
    };
    
    Promise.prototype["throw"] =
    Promise.prototype.thenThrow = function (reason) {
        if (reason === undefined) return this.then(throwUndefined);
    
        if (isPrimitive(reason)) {
            return this._then(
                wrapper(reason, 1),
                undefined,
                undefined,
                undefined,
                undefined
           );
        }
        return this._then(thrower, undefined, undefined, reason, undefined);
    };
    };
    
  provide("bluebird/js/main/direct_resolve.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/synchronous_inspection.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    function PromiseInspection(promise) {
        if (promise !== undefined) {
            promise = promise._target();
            this._bitField = promise._bitField;
            this._settledValue = promise._settledValue;
        }
        else {
            this._bitField = 0;
            this._settledValue = undefined;
        }
    }
    
    PromiseInspection.prototype.value = function () {
        if (!this.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
        }
        return this._settledValue;
    };
    
    PromiseInspection.prototype.error =
    PromiseInspection.prototype.reason = function () {
        if (!this.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
        }
        return this._settledValue;
    };
    
    PromiseInspection.prototype.isFulfilled =
    Promise.prototype._isFulfilled = function () {
        return (this._bitField & 268435456) > 0;
    };
    
    PromiseInspection.prototype.isRejected =
    Promise.prototype._isRejected = function () {
        return (this._bitField & 134217728) > 0;
    };
    
    PromiseInspection.prototype.isPending =
    Promise.prototype._isPending = function () {
        return (this._bitField & 402653184) === 0;
    };
    
    PromiseInspection.prototype.isResolved =
    Promise.prototype._isResolved = function () {
        return (this._bitField & 402653184) > 0;
    };
    
    Promise.prototype.isPending = function() {
        return this._target()._isPending();
    };
    
    Promise.prototype.isRejected = function() {
        return this._target()._isRejected();
    };
    
    Promise.prototype.isFulfilled = function() {
        return this._target()._isFulfilled();
    };
    
    Promise.prototype.isResolved = function() {
        return this._target()._isResolved();
    };
    
    Promise.prototype._value = function() {
        return this._settledValue;
    };
    
    Promise.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue;
    };
    
    Promise.prototype.value = function() {
        var target = this._target();
        if (!target.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
        }
        return target._settledValue;
    };
    
    Promise.prototype.reason = function() {
        var target = this._target();
        if (!target.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
        }
        target._unsetRejectionIsUnhandled();
        return target._settledValue;
    };
    
    
    Promise.PromiseInspection = PromiseInspection;
    };
    
  provide("bluebird/js/main/synchronous_inspection.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/join.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var canEvaluate = util.canEvaluate;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var reject;
    
    if (!false) {
    if (canEvaluate) {
        var thenCallback = function(i) {
            return new Function("value", "holder", "                             \n\
                'use strict';                                                    \n\
                holder.pIndex = value;                                           \n\
                holder.checkFulfillment(this);                                   \n\
                ".replace(/Index/g, i));
        };
    
        var caller = function(count) {
            var values = [];
            for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
            return new Function("holder", "                                      \n\
                'use strict';                                                    \n\
                var callback = holder.fn;                                        \n\
                return callback(values);                                         \n\
                ".replace(/values/g, values.join(", ")));
        };
        var thenCallbacks = [];
        var callers = [undefined];
        for (var i = 1; i <= 5; ++i) {
            thenCallbacks.push(thenCallback(i));
            callers.push(caller(i));
        }
    
        var Holder = function(total, fn) {
            this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
            this.fn = fn;
            this.total = total;
            this.now = 0;
        };
    
        Holder.prototype.callers = callers;
        Holder.prototype.checkFulfillment = function(promise) {
            var now = this.now;
            now++;
            var total = this.total;
            if (now >= total) {
                var handler = this.callers[total];
                promise._pushContext();
                var ret = tryCatch(handler)(this);
                promise._popContext();
                if (ret === errorObj) {
                    promise._rejectCallback(ret.e, false, true);
                } else {
                    promise._resolveCallback(ret);
                }
            } else {
                this.now = now;
            }
        };
    
        var reject = function (reason) {
            this._reject(reason);
        };
    }
    }
    
    Promise.join = function () {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
            fn = arguments[last];
            if (!false) {
                if (last < 6 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var holder = new Holder(last, fn);
                    var callbacks = thenCallbacks;
                    for (var i = 0; i < last; ++i) {
                        var maybePromise = tryConvertToPromise(arguments[i], ret);
                        if (maybePromise instanceof Promise) {
                            maybePromise = maybePromise._target();
                            if (maybePromise._isPending()) {
                                maybePromise._then(callbacks[i], reject,
                                                   undefined, ret, holder);
                            } else if (maybePromise._isFulfilled()) {
                                callbacks[i].call(ret,
                                                  maybePromise._value(), holder);
                            } else {
                                ret._reject(maybePromise._reason());
                            }
                        } else {
                            callbacks[i].call(ret, maybePromise, holder);
                        }
                    }
                    return ret;
                }
            }
        }
        var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
        if (fn) args.pop();
        var ret = new PromiseArray(args).promise();
        return fn !== undefined ? ret.spread(fn) : ret;
    };
    
    };
    
  provide("bluebird/js/main/join.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/map.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              PromiseArray,
                              apiRejection,
                              tryConvertToPromise,
                              INTERNAL) {
    var getDomain = Promise._getDomain;
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var PENDING = {};
    var EMPTY_ARRAY = [];
    
    function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain = getDomain();
        this._callback = domain === null ? fn : domain.bind(fn);
        this._preservedValues = _filter === INTERNAL
            ? new Array(this.length())
            : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
        async.invoke(init, this, undefined);
    }
    util.inherits(MappingPromiseArray, PromiseArray);
    function init() {this._init$(undefined, -2);}
    
    MappingPromiseArray.prototype._init = function () {};
    
    MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (values[index] === PENDING) {
            values[index] = value;
            if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved()) return;
            }
        } else {
            if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return;
            }
            if (preservedValues !== null) preservedValues[index] = value;
    
            var callback = this._callback;
            var receiver = this._promise._boundValue();
            this._promise._pushContext();
            var ret = tryCatch(callback).call(receiver, value, index, length);
            this._promise._popContext();
            if (ret === errorObj) return this._reject(ret.e);
    
            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                    if (limit >= 1) this._inFlight++;
                    values[index] = PENDING;
                    return maybePromise._proxyPromiseArray(this, index);
                } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                } else {
                    return this._reject(maybePromise._reason());
                }
            }
            values[index] = ret;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
            if (preservedValues !== null) {
                this._filter(values, preservedValues);
            } else {
                this._resolve(values);
            }
    
        }
    };
    
    MappingPromiseArray.prototype._drainQueue = function () {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
            if (this._isResolved()) return;
            var index = queue.pop();
            this._promiseFulfilled(values[index], index);
        }
    };
    
    MappingPromiseArray.prototype._filter = function (booleans, values) {
        var len = values.length;
        var ret = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
            if (booleans[i]) ret[j++] = values[i];
        }
        ret.length = j;
        this._resolve(ret);
    };
    
    MappingPromiseArray.prototype.preservedValues = function () {
        return this._preservedValues;
    };
    
    function map(promises, fn, options, _filter) {
        var limit = typeof options === "object" && options !== null
            ? options.concurrency
            : 0;
        limit = typeof limit === "number" &&
            isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter);
    }
    
    Promise.prototype.map = function (fn, options) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    
        return map(this, fn, options, null).promise();
    };
    
    Promise.map = function (promises, fn, options, _filter) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        return map(promises, fn, options, _filter).promise();
    };
    
    
    };
    
  provide("bluebird/js/main/map.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/cancel.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var errors =  require('bluebird/js/main/errors.js');
    var async =  require('bluebird/js/main/async.js');
    var CancellationError = errors.CancellationError;
    
    Promise.prototype._cancel = function (reason) {
        if (!this.isCancellable()) return this;
        var parent;
        var promiseToReject = this;
        while ((parent = promiseToReject._cancellationParent) !== undefined &&
            parent.isCancellable()) {
            promiseToReject = parent;
        }
        this._unsetCancellable();
        promiseToReject._target()._rejectCallback(reason, false, true);
    };
    
    Promise.prototype.cancel = function (reason) {
        if (!this.isCancellable()) return this;
        if (reason === undefined) reason = new CancellationError();
        async.invokeLater(this._cancel, this, reason);
        return this;
    };
    
    Promise.prototype.cancellable = function () {
        if (this._cancellable()) return this;
        async.enableTrampoline();
        this._setCancellable();
        this._cancellationParent = undefined;
        return this;
    };
    
    Promise.prototype.uncancellable = function () {
        var ret = this.then();
        ret._unsetCancellable();
        return ret;
    };
    
    Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
        var ret = this._then(didFulfill, didReject, didProgress,
                             undefined, undefined);
    
        ret._setCancellable();
        ret._cancellationParent = undefined;
        return ret;
    };
    };
    
  provide("bluebird/js/main/cancel.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/using.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function (Promise, apiRejection, tryConvertToPromise,
        createContext) {
        var TypeError =  require('bluebird/js/main/errors.js').TypeError;
        var inherits =  require('bluebird/js/main/util.js').inherits;
        var PromiseInspection = Promise.PromiseInspection;
    
        function inspectionMapper(inspections) {
            var len = inspections.length;
            for (var i = 0; i < len; ++i) {
                var inspection = inspections[i];
                if (inspection.isRejected()) {
                    return Promise.reject(inspection.error());
                }
                inspections[i] = inspection._settledValue;
            }
            return inspections;
        }
    
        function thrower(e) {
            setTimeout(function(){throw e;}, 0);
        }
    
        function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable &&
                typeof thenable._isDisposable === "function" &&
                typeof thenable._getDisposer === "function" &&
                thenable._isDisposable()) {
                maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
        }
        function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret = Promise.defer();
            function iterator() {
                if (i >= len) return ret.resolve();
                var maybePromise = castPreservingDisposable(resources[i++]);
                if (maybePromise instanceof Promise &&
                    maybePromise._isDisposable()) {
                    try {
                        maybePromise = tryConvertToPromise(
                            maybePromise._getDisposer().tryDispose(inspection),
                            resources.promise);
                    } catch (e) {
                        return thrower(e);
                    }
                    if (maybePromise instanceof Promise) {
                        return maybePromise._then(iterator, thrower,
                                                  null, null, null);
                    }
                }
                iterator();
            }
            iterator();
            return ret.promise;
        }
    
        function disposerSuccess(value) {
            var inspection = new PromiseInspection();
            inspection._settledValue = value;
            inspection._bitField = 268435456;
            return dispose(this, inspection).thenReturn(value);
        }
    
        function disposerFail(reason) {
            var inspection = new PromiseInspection();
            inspection._settledValue = reason;
            inspection._bitField = 134217728;
            return dispose(this, inspection).thenThrow(reason);
        }
    
        function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
        }
    
        Disposer.prototype.data = function () {
            return this._data;
        };
    
        Disposer.prototype.promise = function () {
            return this._promise;
        };
    
        Disposer.prototype.resource = function () {
            if (this.promise().isFulfilled()) {
                return this.promise().value();
            }
            return null;
        };
    
        Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== undefined) context._pushContext();
            var ret = resource !== null
                ? this.doDispose(resource, inspection) : null;
            if (context !== undefined) context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret;
        };
    
        Disposer.isDisposer = function (d) {
            return (d != null &&
                    typeof d.resource === "function" &&
                    typeof d.tryDispose === "function");
        };
    
        function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
        }
        inherits(FunctionDisposer, Disposer);
    
        FunctionDisposer.prototype.doDispose = function (resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
        };
    
        function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
                this.resources[this.index]._setDisposable(value);
                return value.promise();
            }
            return value;
        }
    
        Promise.using = function () {
            var len = arguments.length;
            if (len < 2) return apiRejection(
                            "you must pass at least 2 arguments to Promise.using");
            var fn = arguments[len - 1];
            if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    
            var input;
            var spreadArgs = true;
            if (len === 2 && Array.isArray(arguments[0])) {
                input = arguments[0];
                len = input.length;
                spreadArgs = false;
            } else {
                input = arguments;
                len--;
            }
            var resources = new Array(len);
            for (var i = 0; i < len; ++i) {
                var resource = input[i];
                if (Disposer.isDisposer(resource)) {
                    var disposer = resource;
                    resource = resource.promise();
                    resource._setDisposable(disposer);
                } else {
                    var maybePromise = tryConvertToPromise(resource);
                    if (maybePromise instanceof Promise) {
                        resource =
                            maybePromise._then(maybeUnwrapDisposer, null, null, {
                                resources: resources,
                                index: i
                        }, undefined);
                    }
                }
                resources[i] = resource;
            }
    
            var promise = Promise.settle(resources)
                .then(inspectionMapper)
                .then(function(vals) {
                    promise._pushContext();
                    var ret;
                    try {
                        ret = spreadArgs
                            ? fn.apply(undefined, vals) : fn.call(undefined,  vals);
                    } finally {
                        promise._popContext();
                    }
                    return ret;
                })
                ._then(
                    disposerSuccess, disposerFail, undefined, resources, undefined);
            resources.promise = promise;
            return promise;
        };
    
        Promise.prototype._setDisposable = function (disposer) {
            this._bitField = this._bitField | 262144;
            this._disposer = disposer;
        };
    
        Promise.prototype._isDisposable = function () {
            return (this._bitField & 262144) > 0;
        };
    
        Promise.prototype._getDisposer = function () {
            return this._disposer;
        };
    
        Promise.prototype._unsetDisposable = function () {
            this._bitField = this._bitField & (~262144);
            this._disposer = undefined;
        };
    
        Promise.prototype.disposer = function (fn) {
            if (typeof fn === "function") {
                return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError();
        };
    
    };
    
  provide("bluebird/js/main/using.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/generators.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              apiRejection,
                              INTERNAL,
                              tryConvertToPromise) {
    var errors =  require('bluebird/js/main/errors.js');
    var TypeError = errors.TypeError;
    var util =  require('bluebird/js/main/util.js');
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var yieldHandlers = [];
    
    function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
        for (var i = 0; i < yieldHandlers.length; ++i) {
            traceParent._pushContext();
            var result = tryCatch(yieldHandlers[i])(value);
            traceParent._popContext();
            if (result === errorObj) {
                traceParent._pushContext();
                var ret = Promise.reject(errorObj.e);
                traceParent._popContext();
                return ret;
            }
            var maybePromise = tryConvertToPromise(result, traceParent);
            if (maybePromise instanceof Promise) return maybePromise;
        }
        return null;
    }
    
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        var promise = this._promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = undefined;
        this._yieldHandlers = typeof yieldHandler === "function"
            ? [yieldHandler].concat(yieldHandlers)
            : yieldHandlers;
    }
    
    PromiseSpawn.prototype.promise = function () {
        return this._promise;
    };
    
    PromiseSpawn.prototype._run = function () {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver =
            this._generatorFunction = undefined;
        this._next(undefined);
    };
    
    PromiseSpawn.prototype._continue = function (result) {
        if (result === errorObj) {
            return this._promise._rejectCallback(result.e, false, true);
        }
    
        var value = result.value;
        if (result.done === true) {
            this._promise._resolveCallback(value);
        } else {
            var maybePromise = tryConvertToPromise(value, this._promise);
            if (!(maybePromise instanceof Promise)) {
                maybePromise =
                    promiseFromYieldHandler(maybePromise,
                                            this._yieldHandlers,
                                            this._promise);
                if (maybePromise === null) {
                    this._throw(
                        new TypeError(
                            "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
                            "From coroutine:\u000a" +
                            this._stack.split("\n").slice(1, -7).join("\n")
                        )
                    );
                    return;
                }
            }
            maybePromise._then(
                this._next,
                this._throw,
                undefined,
                this,
                null
           );
        }
    };
    
    PromiseSpawn.prototype._throw = function (reason) {
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch(this._generator["throw"])
            .call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
    };
    
    PromiseSpawn.prototype._next = function (value) {
        this._promise._pushContext();
        var result = tryCatch(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
    };
    
    Promise.coroutine = function (generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
            throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function () {
            var generator = generatorFunction.apply(this, arguments);
            var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                          stack);
            spawn._generator = generator;
            spawn._next(undefined);
            return spawn.promise();
        };
    };
    
    Promise.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        yieldHandlers.push(fn);
    };
    
    Promise.spawn = function (generatorFunction) {
        if (typeof generatorFunction !== "function") {
            return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret = spawn.promise();
        spawn._run(Promise.spawn);
        return ret;
    };
    };
    
  provide("bluebird/js/main/generators.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/nodeify.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var util =  require('bluebird/js/main/util.js');
    var async =  require('bluebird/js/main/async.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    
    function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
        var ret =
            tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    
    function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret = val === undefined
            ? tryCatch(nodeback).call(receiver, null)
            : tryCatch(nodeback).call(receiver, null, val);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
            var target = promise._target();
            var newReason = target._getCarriedStackTrace();
            newReason.cause = reason;
            reason = newReason;
        }
        var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    
    Promise.prototype.asCallback =
    Promise.prototype.nodeify = function (nodeback, options) {
        if (typeof nodeback == "function") {
            var adapter = successAdapter;
            if (options !== undefined && Object(options).spread) {
                adapter = spreadAdapter;
            }
            this._then(
                adapter,
                errorAdapter,
                undefined,
                this,
                nodeback
            );
        }
        return this;
    };
    };
    
  provide("bluebird/js/main/nodeify.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/call_get.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var cr = Object.create;
    if (cr) {
        var callerCache = cr(null);
        var getterCache = cr(null);
        callerCache[" size"] = getterCache[" size"] = 0;
    }
    
    module.exports = function(Promise) {
    var util =  require('bluebird/js/main/util.js');
    var canEvaluate = util.canEvaluate;
    var isIdentifier = util.isIdentifier;
    
    var getMethodCaller;
    var getGetter;
    if (!false) {
    var makeMethodCaller = function (methodName) {
        return new Function("ensureMethod", "                                    \n\
            return function(obj) {                                               \n\
                'use strict'                                                     \n\
                var len = this.length;                                           \n\
                ensureMethod(obj, 'methodName');                                 \n\
                switch(len) {                                                    \n\
                    case 1: return obj.methodName(this[0]);                      \n\
                    case 2: return obj.methodName(this[0], this[1]);             \n\
                    case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                    case 0: return obj.methodName();                             \n\
                    default:                                                     \n\
                        return obj.methodName.apply(obj, this);                  \n\
                }                                                                \n\
            };                                                                   \n\
            ".replace(/methodName/g, methodName))(ensureMethod);
    };
    
    var makeGetter = function (propertyName) {
        return new Function("obj", "                                             \n\
            'use strict';                                                        \n\
            return obj.propertyName;                                             \n\
            ".replace("propertyName", propertyName));
    };
    
    var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
            if (!isIdentifier(name)) {
                return null;
            }
            ret = compiler(name);
            cache[name] = ret;
            cache[" size"]++;
            if (cache[" size"] > 512) {
                var keys = Object.keys(cache);
                for (var i = 0; i < 256; ++i) delete cache[keys[i]];
                cache[" size"] = keys.length - 256;
            }
        }
        return ret;
    };
    
    getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
    };
    
    getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
    };
    }
    
    function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null) fn = obj[methodName];
        if (typeof fn !== "function") {
            var message = "Object " + util.classString(obj) + " has no method '" +
                util.toString(methodName) + "'";
            throw new Promise.TypeError(message);
        }
        return fn;
    }
    
    function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
    }
    Promise.prototype.call = function (methodName) {
        var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
        if (!false) {
            if (canEvaluate) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                    return this._then(
                        maybeCaller, undefined, undefined, args, undefined);
                }
            }
        }
        args.push(methodName);
        return this._then(caller, undefined, undefined, args, undefined);
    };
    
    function namedGetter(obj) {
        return obj[this];
    }
    function indexedGetter(obj) {
        var index = +this;
        if (index < 0) index = Math.max(0, index + obj.length);
        return obj[index];
    }
    Promise.prototype.get = function (propertyName) {
        var isIndex = (typeof propertyName === "number");
        var getter;
        if (!isIndex) {
            if (canEvaluate) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
            } else {
                getter = namedGetter;
            }
        } else {
            getter = indexedGetter;
        }
        return this._then(getter, undefined, undefined, propertyName, undefined);
    };
    };
    
  provide("bluebird/js/main/call_get.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/props.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(
        Promise, PromiseArray, tryConvertToPromise, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var isObject = util.isObject;
    var es5 =  require('bluebird/js/main/es5.js');
    
    function PropertiesPromiseArray(obj) {
        var keys = es5.keys(obj);
        var len = keys.length;
        var values = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
            var key = keys[i];
            values[i] = obj[key];
            values[i + len] = key;
        }
        this.constructor$(values);
    }
    util.inherits(PropertiesPromiseArray, PromiseArray);
    
    PropertiesPromiseArray.prototype._init = function () {
        this._init$(undefined, -3) ;
    };
    
    PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            var val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
            }
            this._resolve(val);
        }
    };
    
    PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
        this._promise._progress({
            key: this._values[index + this.length()],
            value: value
        });
    };
    
    PropertiesPromiseArray.prototype.shouldCopyValues = function () {
        return false;
    };
    
    PropertiesPromiseArray.prototype.getActualLength = function (len) {
        return len >> 1;
    };
    
    function props(promises) {
        var ret;
        var castValue = tryConvertToPromise(promises);
    
        if (!isObject(castValue)) {
            return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
        } else if (castValue instanceof Promise) {
            ret = castValue._then(
                Promise.props, undefined, undefined, undefined, undefined);
        } else {
            ret = new PropertiesPromiseArray(castValue).promise();
        }
    
        if (castValue instanceof Promise) {
            ret._propagateFrom(castValue, 4);
        }
        return ret;
    }
    
    Promise.prototype.props = function () {
        return props(this);
    };
    
    Promise.props = function (promises) {
        return props(promises);
    };
    };
    
  provide("bluebird/js/main/props.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/race.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(
        Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var isArray =  require('bluebird/js/main/util.js').isArray;
    
    var raceLater = function (promise) {
        return promise.then(function(array) {
            return race(array, promise);
        });
    };
    
    function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
    
        if (maybePromise instanceof Promise) {
            return raceLater(maybePromise);
        } else if (!isArray(promises)) {
            return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
        }
    
        var ret = new Promise(INTERNAL);
        if (parent !== undefined) {
            ret._propagateFrom(parent, 4 | 1);
        }
        var fulfill = ret._fulfill;
        var reject = ret._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
            var val = promises[i];
    
            if (val === undefined && !(i in promises)) {
                continue;
            }
    
            Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
        }
        return ret;
    }
    
    Promise.race = function (promises) {
        return race(promises, undefined);
    };
    
    Promise.prototype.race = function () {
        return race(this, undefined);
    };
    
    };
    
  provide("bluebird/js/main/race.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/reduce.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              PromiseArray,
                              apiRejection,
                              tryConvertToPromise,
                              INTERNAL) {
    var getDomain = Promise._getDomain;
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    function ReductionPromiseArray(promises, fn, accum, _each) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        this._preservedValues = _each === INTERNAL ? [] : null;
        this._zerothIsAccum = (accum === undefined);
        this._gotAccum = false;
        this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
        this._valuesPhase = undefined;
        var maybePromise = tryConvertToPromise(accum, this._promise);
        var rejected = false;
        var isPromise = maybePromise instanceof Promise;
        if (isPromise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, -1);
            } else if (maybePromise._isFulfilled()) {
                accum = maybePromise._value();
                this._gotAccum = true;
            } else {
                this._reject(maybePromise._reason());
                rejected = true;
            }
        }
        if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
        var domain = getDomain();
        this._callback = domain === null ? fn : domain.bind(fn);
        this._accum = accum;
        if (!rejected) async.invoke(init, this, undefined);
    }
    function init() {
        this._init$(undefined, -5);
    }
    util.inherits(ReductionPromiseArray, PromiseArray);
    
    ReductionPromiseArray.prototype._init = function () {};
    
    ReductionPromiseArray.prototype._resolveEmptyArray = function () {
        if (this._gotAccum || this._zerothIsAccum) {
            this._resolve(this._preservedValues !== null
                            ? [] : this._accum);
        }
    };
    
    ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        values[index] = value;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var isEach = preservedValues !== null;
        var gotAccum = this._gotAccum;
        var valuesPhase = this._valuesPhase;
        var valuesPhaseIndex;
        if (!valuesPhase) {
            valuesPhase = this._valuesPhase = new Array(length);
            for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
                valuesPhase[valuesPhaseIndex] = 0;
            }
        }
        valuesPhaseIndex = valuesPhase[index];
    
        if (index === 0 && this._zerothIsAccum) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
            valuesPhase[index] = ((valuesPhaseIndex === 0)
                ? 1 : 2);
        } else if (index === -1) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
        } else {
            if (valuesPhaseIndex === 0) {
                valuesPhase[index] = 1;
            } else {
                valuesPhase[index] = 2;
                this._accum = value;
            }
        }
        if (!gotAccum) return;
    
        var callback = this._callback;
        var receiver = this._promise._boundValue();
        var ret;
    
        for (var i = this._reducingIndex; i < length; ++i) {
            valuesPhaseIndex = valuesPhase[i];
            if (valuesPhaseIndex === 2) {
                this._reducingIndex = i + 1;
                continue;
            }
            if (valuesPhaseIndex !== 1) return;
            value = values[i];
            this._promise._pushContext();
            if (isEach) {
                preservedValues.push(value);
                ret = tryCatch(callback).call(receiver, value, i, length);
            }
            else {
                ret = tryCatch(callback)
                    .call(receiver, this._accum, value, i, length);
            }
            this._promise._popContext();
    
            if (ret === errorObj) return this._reject(ret.e);
    
            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                    valuesPhase[i] = 4;
                    return maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                } else {
                    return this._reject(maybePromise._reason());
                }
            }
    
            this._reducingIndex = i + 1;
            this._accum = ret;
        }
    
        this._resolve(isEach ? preservedValues : this._accum);
    };
    
    function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
    }
    
    Promise.prototype.reduce = function (fn, initialValue) {
        return reduce(this, fn, initialValue, null);
    };
    
    Promise.reduce = function (promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
    };
    };
    
  provide("bluebird/js/main/reduce.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/settle.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
        function(Promise, PromiseArray) {
    var PromiseInspection = Promise.PromiseInspection;
    var util =  require('bluebird/js/main/util.js');
    
    function SettledPromiseArray(values) {
        this.constructor$(values);
    }
    util.inherits(SettledPromiseArray, PromiseArray);
    
    SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
        }
    };
    
    SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var ret = new PromiseInspection();
        ret._bitField = 268435456;
        ret._settledValue = value;
        this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
        var ret = new PromiseInspection();
        ret._bitField = 134217728;
        ret._settledValue = reason;
        this._promiseResolved(index, ret);
    };
    
    Promise.settle = function (promises) {
        return new SettledPromiseArray(promises).promise();
    };
    
    Promise.prototype.settle = function () {
        return new SettledPromiseArray(this).promise();
    };
    };
    
  provide("bluebird/js/main/settle.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/some.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, PromiseArray, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var RangeError =  require('bluebird/js/main/errors.js').RangeError;
    var AggregateError =  require('bluebird/js/main/errors.js').AggregateError;
    var isArray = util.isArray;
    
    
    function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
    }
    util.inherits(SomePromiseArray, PromiseArray);
    
    SomePromiseArray.prototype._init = function () {
        if (!this._initialized) {
            return;
        }
        if (this._howMany === 0) {
            this._resolve([]);
            return;
        }
        this._init$(undefined, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() &&
            isArrayResolved &&
            this._howMany > this._canPossiblyFulfill()) {
            this._reject(this._getRangeError(this.length()));
        }
    };
    
    SomePromiseArray.prototype.init = function () {
        this._initialized = true;
        this._init();
    };
    
    SomePromiseArray.prototype.setUnwrap = function () {
        this._unwrap = true;
    };
    
    SomePromiseArray.prototype.howMany = function () {
        return this._howMany;
    };
    
    SomePromiseArray.prototype.setHowMany = function (count) {
        this._howMany = count;
    };
    
    SomePromiseArray.prototype._promiseFulfilled = function (value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
            this._values.length = this.howMany();
            if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
            } else {
                this._resolve(this._values);
            }
        }
    
    };
    SomePromiseArray.prototype._promiseRejected = function (reason) {
        this._addRejected(reason);
        if (this.howMany() > this._canPossiblyFulfill()) {
            var e = new AggregateError();
            for (var i = this.length(); i < this._values.length; ++i) {
                e.push(this._values[i]);
            }
            this._reject(e);
        }
    };
    
    SomePromiseArray.prototype._fulfilled = function () {
        return this._totalResolved;
    };
    
    SomePromiseArray.prototype._rejected = function () {
        return this._values.length - this.length();
    };
    
    SomePromiseArray.prototype._addRejected = function (reason) {
        this._values.push(reason);
    };
    
    SomePromiseArray.prototype._addFulfilled = function (value) {
        this._values[this._totalResolved++] = value;
    };
    
    SomePromiseArray.prototype._canPossiblyFulfill = function () {
        return this.length() - this._rejected();
    };
    
    SomePromiseArray.prototype._getRangeError = function (count) {
        var message = "Input array must contain at least " +
                this._howMany + " items but contains only " + count + " items";
        return new RangeError(message);
    };
    
    SomePromiseArray.prototype._resolveEmptyArray = function () {
        this._reject(this._getRangeError(0));
    };
    
    function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
            return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
        }
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(howMany);
        ret.init();
        return promise;
    }
    
    Promise.some = function (promises, howMany) {
        return some(promises, howMany);
    };
    
    Promise.prototype.some = function (howMany) {
        return some(this, howMany);
    };
    
    Promise._SomePromiseArray = SomePromiseArray;
    };
    
  provide("bluebird/js/main/some.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promisify.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var THIS = {};
    var util =  require('bluebird/js/main/util.js');
    var nodebackForPromise =  require('bluebird/js/main/promise_resolver.js')
        ._nodebackForPromise;
    var withAppended = util.withAppended;
    var maybeWrapAsError = util.maybeWrapAsError;
    var canEvaluate = util.canEvaluate;
    var TypeError =  require('bluebird/js/main/errors').TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = {__isPromisified__: true};
    var noCopyProps = [
        "arity",    "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    
    var defaultFilter = function(name) {
        return util.isIdentifier(name) &&
            name.charAt(0) !== "_" &&
            name !== "constructor";
    };
    
    function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
    }
    
    function isPromisified(fn) {
        try {
            return fn.__isPromisified__ === true;
        }
        catch (e) {
            return false;
        }
    }
    
    function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                                defaultPromisified);
        return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
        for (var i = 0; i < ret.length; i += 2) {
            var key = ret[i];
            if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                        throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
                            .replace("%s", suffix));
                    }
                }
            }
        }
    }
    
    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret = [];
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = obj[key];
            var passesDefaultFilter = filter === defaultFilter
                ? true : defaultFilter(key, value, obj);
            if (typeof value === "function" &&
                !isPromisified(value) &&
                !hasPromisified(obj, key, suffix) &&
                filter(key, value, obj, passesDefaultFilter)) {
                ret.push(key, value);
            }
        }
        checkValid(ret, suffix, suffixRegexp);
        return ret;
    }
    
    var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
    };
    
    var makeNodePromisifiedEval;
    if (!false) {
    var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min = Math.max(0, likelyArgumentCount - 1 - 3);
        for(var i = likelyArgumentCount - 1; i >= min; --i) {
            ret.push(i);
        }
        for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret.push(i);
        }
        return ret;
    };
    
    var argumentSequence = function(argumentCount) {
        return util.filledRange(argumentCount, "_arg", "");
    };
    
    var parameterDeclaration = function(parameterCount) {
        return util.filledRange(
            Math.max(parameterCount, 3), "_arg", "");
    };
    
    var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
    };
    
    makeNodePromisifiedEval =
    function(callback, receiver, originalName, fn) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
    
        function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret;
            if (shouldProxyThis) {
                ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
                ret = receiver === undefined
                    ? "ret = callback({{args}}, nodeback); break;\n"
                    : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret.replace("{{args}}", args).replace(", ", comma);
        }
    
        function generateArgumentSwitchCase() {
            var ret = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
                ret += "case " + argumentOrder[i] +":" +
                    generateCallForArgumentCount(argumentOrder[i]);
            }
    
            ret += "                                                             \n\
            default:                                                             \n\
                var args = new Array(len + 1);                                   \n\
                var i = 0;                                                       \n\
                for (var i = 0; i < len; ++i) {                                  \n\
                   args[i] = arguments[i];                                       \n\
                }                                                                \n\
                args[i] = nodeback;                                              \n\
                [CodeForCall]                                                    \n\
                break;                                                           \n\
            ".replace("[CodeForCall]", (shouldProxyThis
                                    ? "ret = callback.apply(this, args);\n"
                                    : "ret = callback.apply(receiver, args);\n"));
            return ret;
        }
    
        var getFunctionCode = typeof callback === "string"
                                    ? ("this != null ? this['"+callback+"'] : fn")
                                    : "fn";
    
        return new Function("Promise",
                            "fn",
                            "receiver",
                            "withAppended",
                            "maybeWrapAsError",
                            "nodebackForPromise",
                            "tryCatch",
                            "errorObj",
                            "notEnumerableProp",
                            "INTERNAL","'use strict';                            \n\
            var ret = function (Parameters) {                                    \n\
                'use strict';                                                    \n\
                var len = arguments.length;                                      \n\
                var promise = new Promise(INTERNAL);                             \n\
                promise._captureStackTrace();                                    \n\
                var nodeback = nodebackForPromise(promise);                      \n\
                var ret;                                                         \n\
                var callback = tryCatch([GetFunctionCode]);                      \n\
                switch(len) {                                                    \n\
                    [CodeForSwitchCase]                                          \n\
                }                                                                \n\
                if (ret === errorObj) {                                          \n\
                    promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
                }                                                                \n\
                return promise;                                                  \n\
            };                                                                   \n\
            notEnumerableProp(ret, '__isPromisified__', true);                   \n\
            return ret;                                                          \n\
            "
            .replace("Parameters", parameterDeclaration(newParameterCount))
            .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
            .replace("[GetFunctionCode]", getFunctionCode))(
                Promise,
                fn,
                receiver,
                withAppended,
                maybeWrapAsError,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                util.notEnumerableProp,
                INTERNAL
            );
    };
    }
    
    function makeNodePromisifiedClosure(callback, receiver, _, fn) {
        var defaultThis = (function() {return this;})();
        var method = callback;
        if (typeof method === "string") {
            callback = fn;
        }
        function promisified() {
            var _receiver = receiver;
            if (receiver === THIS) _receiver = this;
            var promise = new Promise(INTERNAL);
            promise._captureStackTrace();
            var cb = typeof method === "string" && this !== defaultThis
                ? this[method] : callback;
            var fn = nodebackForPromise(promise);
            try {
                cb.apply(_receiver, withAppended(arguments, fn));
            } catch(e) {
                promise._rejectCallback(maybeWrapAsError(e), true, true);
            }
            return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
    }
    
    var makeNodePromisified = canEvaluate
        ? makeNodePromisifiedEval
        : makeNodePromisifiedClosure;
    
    function promisifyAll(obj, suffix, filter, promisifier) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods =
            promisifiableMethods(obj, suffix, suffixRegexp, filter);
    
        for (var i = 0, len = methods.length; i < len; i+= 2) {
            var key = methods[i];
            var fn = methods[i+1];
            var promisifiedKey = key + suffix;
            obj[promisifiedKey] = promisifier === makeNodePromisified
                    ? makeNodePromisified(key, THIS, key, fn, suffix)
                    : promisifier(fn, function() {
                        return makeNodePromisified(key, THIS, key, fn, suffix);
                    });
        }
        util.toFastProperties(obj);
        return obj;
    }
    
    function promisify(callback, receiver) {
        return makeNodePromisified(callback, receiver, undefined, callback);
    }
    
    Promise.promisify = function (fn, receiver) {
        if (typeof fn !== "function") {
            throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        if (isPromisified(fn)) {
            return fn;
        }
        var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
        util.copyDescriptors(fn, ret, propsFilter);
        return ret;
    };
    
    Promise.promisifyAll = function (target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
            throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
        }
        options = Object(options);
        var suffix = options.suffix;
        if (typeof suffix !== "string") suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function") filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function") promisifier = makeNodePromisified;
    
        if (!util.isIdentifier(suffix)) {
            throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
        }
    
        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
            var value = target[keys[i]];
            if (keys[i] !== "constructor" &&
                util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter, promisifier);
                promisifyAll(value, suffix, filter, promisifier);
            }
        }
    
        return promisifyAll(target, suffix, filter, promisifier);
    };
    };
    
    
  provide("bluebird/js/main/promisify.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/any.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var SomePromiseArray = Promise._SomePromiseArray;
    function any(promises) {
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(1);
        ret.setUnwrap();
        ret.init();
        return promise;
    }
    
    Promise.any = function (promises) {
        return any(promises);
    };
    
    Promise.prototype.any = function () {
        return any(this);
    };
    
    };
    
  provide("bluebird/js/main/any.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/each.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var PromiseReduce = Promise.reduce;
    
    Promise.prototype.each = function (fn) {
        return PromiseReduce(this, fn, null, INTERNAL);
    };
    
    Promise.each = function (promises, fn) {
        return PromiseReduce(promises, fn, null, INTERNAL);
    };
    };
    
  provide("bluebird/js/main/each.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/timers.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var TimeoutError = Promise.TimeoutError;
    
    var afterTimeout = function (promise, message) {
        if (!promise.isPending()) return;
        if (typeof message !== "string") {
            message = "operation timed out";
        }
        var err = new TimeoutError(message);
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._cancel(err);
    };
    
    var afterValue = function(value) { return delay(+this).thenReturn(value); };
    var delay = Promise.delay = function (value, ms) {
        if (ms === undefined) {
            ms = value;
            value = undefined;
            var ret = new Promise(INTERNAL);
            setTimeout(function() { ret._fulfill(); }, ms);
            return ret;
        }
        ms = +ms;
        return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
    };
    
    Promise.prototype.delay = function (ms) {
        return delay(this, ms);
    };
    
    function successClear(value) {
        var handle = this;
        if (handle instanceof Number) handle = +handle;
        clearTimeout(handle);
        return value;
    }
    
    function failureClear(reason) {
        var handle = this;
        if (handle instanceof Number) handle = +handle;
        clearTimeout(handle);
        throw reason;
    }
    
    Promise.prototype.timeout = function (ms, message) {
        ms = +ms;
        var ret = this.then().cancellable();
        ret._cancellationParent = this;
        var handle = setTimeout(function timeoutTimeout() {
            afterTimeout(ret, message);
        }, ms);
        return ret._then(successClear, failureClear, undefined, handle, undefined);
    };
    
    };
    
  provide("bluebird/js/main/timers.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/filter.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var PromiseMap = Promise.map;
    
    Promise.prototype.filter = function (fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
    };
    
    Promise.filter = function (promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
    };
    };
    
  provide("bluebird/js/main/filter.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function() {
    var makeSelfResolutionError = function () {
        return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
    };
    var reflect = function() {
        return new Promise.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
        return Promise.reject(new TypeError(msg));
    };
    
    var util =  require('bluebird/js/main/util.js');
    
    var getDomain;
    if (util.isNode) {
        getDomain = function() {
            var ret = process.domain;
            if (ret === undefined) ret = null;
            return ret;
        };
    } else {
        getDomain = function() {
            return null;
        };
    }
    util.notEnumerableProp(Promise, "_getDomain", getDomain);
    
    var UNDEFINED_BINDING = {};
    var async =  require('bluebird/js/main/async.js');
    var errors =  require('bluebird/js/main/errors.js');
    var TypeError = Promise.TypeError = errors.TypeError;
    Promise.RangeError = errors.RangeError;
    Promise.CancellationError = errors.CancellationError;
    Promise.TimeoutError = errors.TimeoutError;
    Promise.OperationalError = errors.OperationalError;
    Promise.RejectionError = errors.OperationalError;
    Promise.AggregateError = errors.AggregateError;
    var INTERNAL = function(){};
    var APPLY = {};
    var NEXT_FILTER = {e: null};
    var tryConvertToPromise =  require('bluebird/js/main/thenables.js')(Promise, INTERNAL);
    var PromiseArray =
         require('bluebird/js/main/promise_array.js')(Promise, INTERNAL,
                                        tryConvertToPromise, apiRejection);
    var CapturedTrace =  require('bluebird/js/main/captured_trace.js')();
    var isDebugging =  require('bluebird/js/main/debuggability.js')(Promise, CapturedTrace);
     /*jshint unused:false*/
    var createContext =
         require('bluebird/js/main/context.js')(Promise, CapturedTrace, isDebugging);
    var CatchFilter =  require('bluebird/js/main/catch_filter.js')(NEXT_FILTER);
    var PromiseResolver =  require('bluebird/js/main/promise_resolver.js');
    var nodebackForPromise = PromiseResolver._nodebackForPromise;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    function Promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
        }
        if (this.constructor !== Promise) {
            throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = undefined;
        this._rejectionHandler0 = undefined;
        this._progressHandler0 = undefined;
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._settledValue = undefined;
        if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
    }
    
    Promise.prototype.toString = function () {
        return "[object Promise]";
    };
    
    Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
        var len = arguments.length;
        if (len > 1) {
            var catchInstances = new Array(len - 1),
                j = 0, i;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (typeof item === "function") {
                    catchInstances[j++] = item;
                } else {
                    return Promise.reject(
                        new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
                }
            }
            catchInstances.length = j;
            fn = arguments[i];
            var catchFilter = new CatchFilter(catchInstances, fn, this);
            return this._then(undefined, catchFilter.doFilter, undefined,
                catchFilter, undefined);
        }
        return this._then(undefined, fn, undefined, undefined, undefined);
    };
    
    Promise.prototype.reflect = function () {
        return this._then(reflect, reflect, undefined, this, undefined);
    };
    
    Promise.prototype.then = function (didFulfill, didReject, didProgress) {
        if (isDebugging() && arguments.length > 0 &&
            typeof didFulfill !== "function" &&
            typeof didReject !== "function") {
            var msg = ".then() only accepts functions but was passed: " +
                    util.classString(didFulfill);
            if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
            }
            this._warn(msg);
        }
        return this._then(didFulfill, didReject, didProgress,
            undefined, undefined);
    };
    
    Promise.prototype.done = function (didFulfill, didReject, didProgress) {
        var promise = this._then(didFulfill, didReject, didProgress,
            undefined, undefined);
        promise._setIsFinal();
    };
    
    Promise.prototype.spread = function (didFulfill, didReject) {
        return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
    };
    
    Promise.prototype.isCancellable = function () {
        return !this.isResolved() &&
            this._cancellable();
    };
    
    Promise.prototype.toJSON = function () {
        var ret = {
            isFulfilled: false,
            isRejected: false,
            fulfillmentValue: undefined,
            rejectionReason: undefined
        };
        if (this.isFulfilled()) {
            ret.fulfillmentValue = this.value();
            ret.isFulfilled = true;
        } else if (this.isRejected()) {
            ret.rejectionReason = this.reason();
            ret.isRejected = true;
        }
        return ret;
    };
    
    Promise.prototype.all = function () {
        return new PromiseArray(this).promise();
    };
    
    Promise.prototype.error = function (fn) {
        return this.caught(util.originatesFromRejection, fn);
    };
    
    Promise.is = function (val) {
        return val instanceof Promise;
    };
    
    Promise.fromNode = function(fn) {
        var ret = new Promise(INTERNAL);
        var result = tryCatch(fn)(nodebackForPromise(ret));
        if (result === errorObj) {
            ret._rejectCallback(result.e, true, true);
        }
        return ret;
    };
    
    Promise.all = function (promises) {
        return new PromiseArray(promises).promise();
    };
    
    Promise.defer = Promise.pending = function () {
        var promise = new Promise(INTERNAL);
        return new PromiseResolver(promise);
    };
    
    Promise.cast = function (obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise)) {
            var val = ret;
            ret = new Promise(INTERNAL);
            ret._fulfillUnchecked(val);
        }
        return ret;
    };
    
    Promise.resolve = Promise.fulfilled = Promise.cast;
    
    Promise.reject = Promise.rejected = function (reason) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
    };
    
    Promise.setScheduler = function(fn) {
        if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        var prev = async._schedule;
        async._schedule = fn;
        return prev;
    };
    
    Promise.prototype._then = function (
        didFulfill,
        didReject,
        didProgress,
        receiver,
        internalData
    ) {
        var haveInternalData = internalData !== undefined;
        var ret = haveInternalData ? internalData : new Promise(INTERNAL);
    
        if (!haveInternalData) {
            ret._propagateFrom(this, 4 | 1);
            ret._captureStackTrace();
        }
    
        var target = this._target();
        if (target !== this) {
            if (receiver === undefined) receiver = this._boundTo;
            if (!haveInternalData) ret._setIsMigrated();
        }
    
        var callbackIndex = target._addCallbacks(didFulfill,
                                                 didReject,
                                                 didProgress,
                                                 ret,
                                                 receiver,
                                                 getDomain());
    
        if (target._isResolved() && !target._isSettlePromisesQueued()) {
            async.invoke(
                target._settlePromiseAtPostResolution, target, callbackIndex);
        }
    
        return ret;
    };
    
    Promise.prototype._settlePromiseAtPostResolution = function (index) {
        if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
        this._settlePromiseAt(index);
    };
    
    Promise.prototype._length = function () {
        return this._bitField & 131071;
    };
    
    Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
        return (this._bitField & 939524096) > 0;
    };
    
    Promise.prototype._isFollowing = function () {
        return (this._bitField & 536870912) === 536870912;
    };
    
    Promise.prototype._setLength = function (len) {
        this._bitField = (this._bitField & -131072) |
            (len & 131071);
    };
    
    Promise.prototype._setFulfilled = function () {
        this._bitField = this._bitField | 268435456;
    };
    
    Promise.prototype._setRejected = function () {
        this._bitField = this._bitField | 134217728;
    };
    
    Promise.prototype._setFollowing = function () {
        this._bitField = this._bitField | 536870912;
    };
    
    Promise.prototype._setIsFinal = function () {
        this._bitField = this._bitField | 33554432;
    };
    
    Promise.prototype._isFinal = function () {
        return (this._bitField & 33554432) > 0;
    };
    
    Promise.prototype._cancellable = function () {
        return (this._bitField & 67108864) > 0;
    };
    
    Promise.prototype._setCancellable = function () {
        this._bitField = this._bitField | 67108864;
    };
    
    Promise.prototype._unsetCancellable = function () {
        this._bitField = this._bitField & (~67108864);
    };
    
    Promise.prototype._setIsMigrated = function () {
        this._bitField = this._bitField | 4194304;
    };
    
    Promise.prototype._unsetIsMigrated = function () {
        this._bitField = this._bitField & (~4194304);
    };
    
    Promise.prototype._isMigrated = function () {
        return (this._bitField & 4194304) > 0;
    };
    
    Promise.prototype._receiverAt = function (index) {
        var ret = index === 0
            ? this._receiver0
            : this[
                index * 5 - 5 + 4];
        if (ret === UNDEFINED_BINDING) {
            return undefined;
        } else if (ret === undefined && this._isBound()) {
            return this._boundValue();
        }
        return ret;
    };
    
    Promise.prototype._promiseAt = function (index) {
        return index === 0
            ? this._promise0
            : this[index * 5 - 5 + 3];
    };
    
    Promise.prototype._fulfillmentHandlerAt = function (index) {
        return index === 0
            ? this._fulfillmentHandler0
            : this[index * 5 - 5 + 0];
    };
    
    Promise.prototype._rejectionHandlerAt = function (index) {
        return index === 0
            ? this._rejectionHandler0
            : this[index * 5 - 5 + 1];
    };
    
    Promise.prototype._boundValue = function() {
        var ret = this._boundTo;
        if (ret !== undefined) {
            if (ret instanceof Promise) {
                if (ret.isFulfilled()) {
                    return ret.value();
                } else {
                    return undefined;
                }
            }
        }
        return ret;
    };
    
    Promise.prototype._migrateCallbacks = function (follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var progress = follower._progressHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (promise instanceof Promise) promise._setIsMigrated();
        if (receiver === undefined) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
    };
    
    Promise.prototype._addCallbacks = function (
        fulfill,
        reject,
        progress,
        promise,
        receiver,
        domain
    ) {
        var index = this._length();
    
        if (index >= 131071 - 5) {
            index = 0;
            this._setLength(0);
        }
    
        if (index === 0) {
            this._promise0 = promise;
            if (receiver !== undefined) this._receiver0 = receiver;
            if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 =
                    domain === null ? fulfill : domain.bind(fulfill);
            }
            if (typeof reject === "function") {
                this._rejectionHandler0 =
                    domain === null ? reject : domain.bind(reject);
            }
            if (typeof progress === "function") {
                this._progressHandler0 =
                    domain === null ? progress : domain.bind(progress);
            }
        } else {
            var base = index * 5 - 5;
            this[base + 3] = promise;
            this[base + 4] = receiver;
            if (typeof fulfill === "function") {
                this[base + 0] =
                    domain === null ? fulfill : domain.bind(fulfill);
            }
            if (typeof reject === "function") {
                this[base + 1] =
                    domain === null ? reject : domain.bind(reject);
            }
            if (typeof progress === "function") {
                this[base + 2] =
                    domain === null ? progress : domain.bind(progress);
            }
        }
        this._setLength(index + 1);
        return index;
    };
    
    Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
        var index = this._length();
    
        if (index >= 131071 - 5) {
            index = 0;
            this._setLength(0);
        }
        if (index === 0) {
            this._promise0 = promiseSlotValue;
            this._receiver0 = receiver;
        } else {
            var base = index * 5 - 5;
            this[base + 3] = promiseSlotValue;
            this[base + 4] = receiver;
        }
        this._setLength(index + 1);
    };
    
    Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
        this._setProxyHandlers(promiseArray, index);
    };
    
    Promise.prototype._resolveCallback = function(value, shouldBind) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        if (value === this)
            return this._rejectCallback(makeSelfResolutionError(), false, true);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise)) return this._fulfill(value);
    
        var propagationFlags = 1 | (shouldBind ? 4 : 0);
        this._propagateFrom(maybePromise, propagationFlags);
        var promise = maybePromise._target();
        if (promise._isPending()) {
            var len = this._length();
            for (var i = 0; i < len; ++i) {
                promise._migrateCallbacks(this, i);
            }
            this._setFollowing();
            this._setLength(0);
            this._setFollowee(promise);
        } else if (promise._isFulfilled()) {
            this._fulfillUnchecked(promise._value());
        } else {
            this._rejectUnchecked(promise._reason(),
                promise._getCarriedStackTrace());
        }
    };
    
    Promise.prototype._rejectCallback =
    function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
        if (!shouldNotMarkOriginatingFromRejection) {
            util.markAsOriginatingFromRejection(reason);
        }
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason, hasStack ? undefined : trace);
    };
    
    Promise.prototype._resolveFromResolver = function (resolver) {
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = tryCatch(resolver)(function(value) {
            if (promise === null) return;
            promise._resolveCallback(value);
            promise = null;
        }, function (reason) {
            if (promise === null) return;
            promise._rejectCallback(reason, synchronous);
            promise = null;
        });
        synchronous = false;
        this._popContext();
    
        if (r !== undefined && r === errorObj && promise !== null) {
            promise._rejectCallback(r.e, true, true);
            promise = null;
        }
    };
    
    Promise.prototype._settlePromiseFromHandler = function (
        handler, receiver, value, promise
    ) {
        if (promise._isRejected()) return;
        promise._pushContext();
        var x;
        if (receiver === APPLY && !this._isRejected()) {
            x = tryCatch(handler).apply(this._boundValue(), value);
        } else {
            x = tryCatch(handler).call(receiver, value);
        }
        promise._popContext();
    
        if (x === errorObj || x === promise || x === NEXT_FILTER) {
            var err = x === promise ? makeSelfResolutionError() : x.e;
            promise._rejectCallback(err, false, true);
        } else {
            promise._resolveCallback(x);
        }
    };
    
    Promise.prototype._target = function() {
        var ret = this;
        while (ret._isFollowing()) ret = ret._followee();
        return ret;
    };
    
    Promise.prototype._followee = function() {
        return this._rejectionHandler0;
    };
    
    Promise.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
    };
    
    Promise.prototype._cleanValues = function () {
        if (this._cancellable()) {
            this._cancellationParent = undefined;
        }
    };
    
    Promise.prototype._propagateFrom = function (parent, flags) {
        if ((flags & 1) > 0 && parent._cancellable()) {
            this._setCancellable();
            this._cancellationParent = parent;
        }
        if ((flags & 4) > 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    };
    
    Promise.prototype._fulfill = function (value) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._fulfillUnchecked(value);
    };
    
    Promise.prototype._reject = function (reason, carriedStackTrace) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._rejectUnchecked(reason, carriedStackTrace);
    };
    
    Promise.prototype._settlePromiseAt = function (index) {
        var promise = this._promiseAt(index);
        var isPromise = promise instanceof Promise;
    
        if (isPromise && promise._isMigrated()) {
            promise._unsetIsMigrated();
            return async.invoke(this._settlePromiseAt, this, index);
        }
        var handler = this._isFulfilled()
            ? this._fulfillmentHandlerAt(index)
            : this._rejectionHandlerAt(index);
    
        var carriedStackTrace =
            this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
        var value = this._settledValue;
        var receiver = this._receiverAt(index);
        this._clearCallbackDataAtIndex(index);
    
        if (typeof handler === "function") {
            if (!isPromise) {
                handler.call(receiver, value, promise);
            } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (receiver instanceof PromiseArray) {
            if (!receiver._isResolved()) {
                if (this._isFulfilled()) {
                    receiver._promiseFulfilled(value, promise);
                }
                else {
                    receiver._promiseRejected(value, promise);
                }
            }
        } else if (isPromise) {
            if (this._isFulfilled()) {
                promise._fulfill(value);
            } else {
                promise._reject(value, carriedStackTrace);
            }
        }
    
        if (index >= 4 && (index & 31) === 4)
            async.invokeLater(this._setLength, this, 0);
    };
    
    Promise.prototype._clearCallbackDataAtIndex = function(index) {
        if (index === 0) {
            if (!this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = undefined;
            }
            this._rejectionHandler0 =
            this._progressHandler0 =
            this._receiver0 =
            this._promise0 = undefined;
        } else {
            var base = index * 5 - 5;
            this[base + 3] =
            this[base + 4] =
            this[base + 0] =
            this[base + 1] =
            this[base + 2] = undefined;
        }
    };
    
    Promise.prototype._isSettlePromisesQueued = function () {
        return (this._bitField &
                -1073741824) === -1073741824;
    };
    
    Promise.prototype._setSettlePromisesQueued = function () {
        this._bitField = this._bitField | -1073741824;
    };
    
    Promise.prototype._unsetSettlePromisesQueued = function () {
        this._bitField = this._bitField & (~-1073741824);
    };
    
    Promise.prototype._queueSettlePromises = function() {
        async.settlePromises(this);
        this._setSettlePromisesQueued();
    };
    
    Promise.prototype._fulfillUnchecked = function (value) {
        if (value === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._rejectUnchecked(err, undefined);
        }
        this._setFulfilled();
        this._settledValue = value;
        this._cleanValues();
    
        if (this._length() > 0) {
            this._queueSettlePromises();
        }
    };
    
    Promise.prototype._rejectUncheckedCheckError = function (reason) {
        var trace = util.ensureErrorObject(reason);
        this._rejectUnchecked(reason, trace === reason ? undefined : trace);
    };
    
    Promise.prototype._rejectUnchecked = function (reason, trace) {
        if (reason === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._rejectUnchecked(err);
        }
        this._setRejected();
        this._settledValue = reason;
        this._cleanValues();
    
        if (this._isFinal()) {
            async.throwLater(function(e) {
                if ("stack" in e) {
                    async.invokeFirst(
                        CapturedTrace.unhandledRejection, undefined, e);
                }
                throw e;
            }, trace === undefined ? reason : trace);
            return;
        }
    
        if (trace !== undefined && trace !== reason) {
            this._setCarriedStackTrace(trace);
        }
    
        if (this._length() > 0) {
            this._queueSettlePromises();
        } else {
            this._ensurePossibleRejectionHandled();
        }
    };
    
    Promise.prototype._settlePromises = function () {
        this._unsetSettlePromisesQueued();
        var len = this._length();
        for (var i = 0; i < len; i++) {
            this._settlePromiseAt(i);
        }
    };
    
    util.notEnumerableProp(Promise,
                           "_makeSelfResolutionError",
                           makeSelfResolutionError);
    
     require('bluebird/js/main/progress.js')(Promise, PromiseArray);
     require('bluebird/js/main/method.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/bind.js')(Promise, INTERNAL, tryConvertToPromise);
     require('bluebird/js/main/finally.js')(Promise, NEXT_FILTER, tryConvertToPromise);
     require('bluebird/js/main/direct_resolve.js')(Promise);
     require('bluebird/js/main/synchronous_inspection.js')(Promise);
     require('bluebird/js/main/join.js')(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
    Promise.Promise = Promise;
     require('bluebird/js/main/map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
     require('bluebird/js/main/cancel.js')(Promise);
     require('bluebird/js/main/using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
     require('bluebird/js/main/generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
     require('bluebird/js/main/nodeify.js')(Promise);
     require('bluebird/js/main/call_get.js')(Promise);
     require('bluebird/js/main/props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
     require('bluebird/js/main/settle.js')(Promise, PromiseArray);
     require('bluebird/js/main/some.js')(Promise, PromiseArray, apiRejection);
     require('bluebird/js/main/promisify.js')(Promise, INTERNAL);
     require('bluebird/js/main/any.js')(Promise);
     require('bluebird/js/main/each.js')(Promise, INTERNAL);
     require('bluebird/js/main/timers.js')(Promise, INTERNAL);
     require('bluebird/js/main/filter.js')(Promise, INTERNAL);
                                                             
        util.toFastProperties(Promise);                                          
        util.toFastProperties(Promise.prototype);                                
        function fillTypes(value) {                                              
            var p = new Promise(INTERNAL);                                       
            p._fulfillmentHandler0 = value;                                      
            p._rejectionHandler0 = value;                                        
            p._progressHandler0 = value;                                         
            p._promise0 = value;                                                 
            p._receiver0 = value;                                                
            p._settledValue = value;                                             
        }                                                                        
        // Complete slack tracking, opt out of field-type tracking and           
        // stabilize map                                                         
        fillTypes({a: 1});                                                       
        fillTypes({b: 2});                                                       
        fillTypes({c: 3});                                                       
        fillTypes(1);                                                            
        fillTypes(function(){});                                                 
        fillTypes(undefined);                                                    
        fillTypes(false);                                                        
        fillTypes(new Promise(INTERNAL));                                        
        CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
        return Promise;                                                          
    
    };
    
  provide("bluebird/js/main/promise.js", module.exports);
}(global));

// pakmanager:bluebird
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var old;
    if (typeof Promise !== "undefined") old = Promise;
    function noConflict() {
        try { if (Promise === bluebird) Promise = old; }
        catch (e) {}
        return bluebird;
    }
    var bluebird =  require('bluebird/js/main/promise.js')();
    bluebird.noConflict = noConflict;
    module.exports = bluebird;
    
  provide("bluebird", module.exports);
}(global));

// pakmanager:chalk
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var escapeStringRegexp = require('escape-string-regexp');
    var ansiStyles = require('ansi-styles');
    var stripAnsi = require('strip-ansi');
    var hasAnsi = require('has-ansi');
    var supportsColor = require('supports-color');
    var defineProps = Object.defineProperties;
    var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);
    
    function Chalk(options) {
    	// detect mode if not set manually
    	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
    }
    
    // use bright blue on Windows as the normal blue color is illegible
    if (isSimpleWindowsTerm) {
    	ansiStyles.blue.open = '\u001b[94m';
    }
    
    var styles = (function () {
    	var ret = {};
    
    	Object.keys(ansiStyles).forEach(function (key) {
    		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    
    		ret[key] = {
    			get: function () {
    				return build.call(this, this._styles.concat(key));
    			}
    		};
    	});
    
    	return ret;
    })();
    
    var proto = defineProps(function chalk() {}, styles);
    
    function build(_styles) {
    	var builder = function () {
    		return applyStyle.apply(builder, arguments);
    	};
    
    	builder._styles = _styles;
    	builder.enabled = this.enabled;
    	// __proto__ is used because we must return a function, but there is
    	// no way to create a function with a different prototype.
    	/* eslint-disable no-proto */
    	builder.__proto__ = proto;
    
    	return builder;
    }
    
    function applyStyle() {
    	// support varags, but simply cast to string in case there's only one arg
    	var args = arguments;
    	var argsLen = args.length;
    	var str = argsLen !== 0 && String(arguments[0]);
    
    	if (argsLen > 1) {
    		// don't slice `arguments`, it prevents v8 optimizations
    		for (var a = 1; a < argsLen; a++) {
    			str += ' ' + args[a];
    		}
    	}
    
    	if (!this.enabled || !str) {
    		return str;
    	}
    
    	var nestedStyles = this._styles;
    	var i = nestedStyles.length;
    
    	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
    	// see https://github.com/chalk/chalk/issues/58
    	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
    	var originalDim = ansiStyles.dim.open;
    	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
    		ansiStyles.dim.open = '';
    	}
    
    	while (i--) {
    		var code = ansiStyles[nestedStyles[i]];
    
    		// Replace any instances already present with a re-opening code
    		// otherwise only the part of the string until said closing code
    		// will be colored, and the rest will simply be 'plain'.
    		str = code.open + str.replace(code.closeRe, code.open) + code.close;
    	}
    
    	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
    	ansiStyles.dim.open = originalDim;
    
    	return str;
    }
    
    function init() {
    	var ret = {};
    
    	Object.keys(styles).forEach(function (name) {
    		ret[name] = {
    			get: function () {
    				return build.call(this, [name]);
    			}
    		};
    	});
    
    	return ret;
    }
    
    defineProps(Chalk.prototype, init());
    
    module.exports = new Chalk();
    module.exports.styles = ansiStyles;
    module.exports.hasColor = hasAnsi;
    module.exports.stripColor = stripAnsi;
    module.exports.supportsColor = supportsColor;
    
  provide("chalk", module.exports);
}(global));

// pakmanager:commander
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter;
    var spawn = require('child_process').spawn;
    var readlink = require('graceful-readlink').readlinkSync;
    var path = require('path');
    var dirname = path.dirname;
    var basename = path.basename;
    var fs = require('fs');
    
    /**
     * Expose the root command.
     */
    
    exports = module.exports = new Command();
    
    /**
     * Expose `Command`.
     */
    
    exports.Command = Command;
    
    /**
     * Expose `Option`.
     */
    
    exports.Option = Option;
    
    /**
     * Initialize a new `Option` with the given `flags` and `description`.
     *
     * @param {String} flags
     * @param {String} description
     * @api public
     */
    
    function Option(flags, description) {
      this.flags = flags;
      this.required = ~flags.indexOf('<');
      this.optional = ~flags.indexOf('[');
      this.bool = !~flags.indexOf('-no-');
      flags = flags.split(/[ ,|]+/);
      if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
      this.long = flags.shift();
      this.description = description || '';
    }
    
    /**
     * Return option name.
     *
     * @return {String}
     * @api private
     */
    
    Option.prototype.name = function() {
      return this.long
        .replace('--', '')
        .replace('no-', '');
    };
    
    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {String} arg
     * @return {Boolean}
     * @api private
     */
    
    Option.prototype.is = function(arg) {
      return arg == this.short || arg == this.long;
    };
    
    /**
     * Initialize a new `Command`.
     *
     * @param {String} name
     * @api public
     */
    
    function Command(name) {
      this.commands = [];
      this.options = [];
      this._execs = [];
      this._allowUnknownOption = false;
      this._args = [];
      this._name = name;
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Command.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Add command `name`.
     *
     * The `.action()` callback is invoked when the
     * command `name` is specified via __ARGV__,
     * and the remaining arguments are applied to the
     * function for access.
     *
     * When the `name` is "*" an un-matched command
     * will be passed as the first arg, followed by
     * the rest of __ARGV__ remaining.
     *
     * Examples:
     *
     *      program
     *        .version('0.0.1')
     *        .option('-C, --chdir <path>', 'change the working directory')
     *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
     *        .option('-T, --no-tests', 'ignore test hook')
     *
     *      program
     *        .command('setup')
     *        .description('run remote setup commands')
     *        .action(function() {
     *          console.log('setup');
     *        });
     *
     *      program
     *        .command('exec <cmd>')
     *        .description('run the given remote command')
     *        .action(function(cmd) {
     *          console.log('exec "%s"', cmd);
     *        });
     *
     *      program
     *        .command('teardown <dir> [otherDirs...]')
     *        .description('run teardown commands')
     *        .action(function(dir, otherDirs) {
     *          console.log('dir "%s"', dir);
     *          if (otherDirs) {
     *            otherDirs.forEach(function (oDir) {
     *              console.log('dir "%s"', oDir);
     *            });
     *          }
     *        });
     *
     *      program
     *        .command('*')
     *        .description('deploy the given env')
     *        .action(function(env) {
     *          console.log('deploying "%s"', env);
     *        });
     *
     *      program.parse(process.argv);
      *
     * @param {String} name
     * @param {String} [desc] for git-style sub-commands
     * @return {Command} the new command
     * @api public
     */
    
    Command.prototype.command = function(name, desc, opts) {
      opts = opts || {};
      var args = name.split(/ +/);
      var cmd = new Command(args.shift());
    
      if (desc) {
        cmd.description(desc);
        this.executables = true;
        this._execs[cmd._name] = true;
      }
    
      cmd._noHelp = !!opts.noHelp;
      this.commands.push(cmd);
      cmd.parseExpectedArgs(args);
      cmd.parent = this;
    
      if (desc) return this;
      return cmd;
    };
    
    /**
     * Define argument syntax for the top-level command.
     *
     * @api public
     */
    
    Command.prototype.arguments = function (desc) {
      return this.parseExpectedArgs(desc.split(/ +/));
    }
    
    /**
     * Add an implicit `help [cmd]` subcommand
     * which invokes `--help` for the given command.
     *
     * @api private
     */
    
    Command.prototype.addImplicitHelpCommand = function() {
      this.command('help [cmd]', 'display help for [cmd]');
    };
    
    /**
     * Parse expected `args`.
     *
     * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parseExpectedArgs = function(args) {
      if (!args.length) return;
      var self = this;
      args.forEach(function(arg) {
        var argDetails = {
          required: false,
          name: '',
          variadic: false
        };
    
        switch (arg[0]) {
          case '<':
            argDetails.required = true;
            argDetails.name = arg.slice(1, -1);
            break;
          case '[':
            argDetails.name = arg.slice(1, -1);
            break;
        }
    
        if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
          argDetails.variadic = true;
          argDetails.name = argDetails.name.slice(0, -3);
        }
        if (argDetails.name) {
          self._args.push(argDetails);
        }
      });
      return this;
    };
    
    /**
     * Register callback `fn` for the command.
     *
     * Examples:
     *
     *      program
     *        .command('help')
     *        .description('display verbose help')
     *        .action(function() {
     *           // output help here
     *        });
     *
     * @param {Function} fn
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.action = function(fn) {
      var self = this;
      var listener = function(args, unknown) {
        // Parse any so-far unknown options
        args = args || [];
        unknown = unknown || [];
    
        var parsed = self.parseOptions(unknown);
    
        // Output help if necessary
        outputHelpIfNecessary(self, parsed.unknown);
    
        // If there are still any unknown options, then we simply
        // die, unless someone asked for help, in which case we give it
        // to them, and then we die.
        if (parsed.unknown.length > 0) {
          self.unknownOption(parsed.unknown[0]);
        }
    
        // Leftover arguments need to be pushed back. Fixes issue #56
        if (parsed.args.length) args = parsed.args.concat(args);
    
        self._args.forEach(function(arg, i) {
          if (arg.required && null == args[i]) {
            self.missingArgument(arg.name);
          } else if (arg.variadic) {
            if (i !== self._args.length - 1) {
              self.variadicArgNotLast(arg.name);
            }
    
            args[i] = args.splice(i);
          }
        });
    
        // Always append ourselves to the end of the arguments,
        // to make sure we match the number of arguments the user
        // expects
        if (self._args.length) {
          args[self._args.length] = self;
        } else {
          args.push(self);
        }
    
        fn.apply(self, args);
      };
      var parent = this.parent || this;
      var name = parent === this ? '*' : this._name;
      parent.on(name, listener);
      if (this._alias) parent.on(this._alias, listener);
      return this;
    };
    
    /**
     * Define option with `flags`, `description` and optional
     * coercion `fn`.
     *
     * The `flags` string should contain both the short and long flags,
     * separated by comma, a pipe or space. The following are all valid
     * all will output this way when `--help` is used.
     *
     *    "-p, --pepper"
     *    "-p|--pepper"
     *    "-p --pepper"
     *
     * Examples:
     *
     *     // simple boolean defaulting to false
     *     program.option('-p, --pepper', 'add pepper');
     *
     *     --pepper
     *     program.pepper
     *     // => Boolean
     *
     *     // simple boolean defaulting to true
     *     program.option('-C, --no-cheese', 'remove cheese');
     *
     *     program.cheese
     *     // => true
     *
     *     --no-cheese
     *     program.cheese
     *     // => false
     *
     *     // required argument
     *     program.option('-C, --chdir <path>', 'change the working directory');
     *
     *     --chdir /tmp
     *     program.chdir
     *     // => "/tmp"
     *
     *     // optional argument
     *     program.option('-c, --cheese [type]', 'add cheese [marble]');
     *
     * @param {String} flags
     * @param {String} description
     * @param {Function|Mixed} fn or default
     * @param {Mixed} defaultValue
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.option = function(flags, description, fn, defaultValue) {
      var self = this
        , option = new Option(flags, description)
        , oname = option.name()
        , name = camelcase(oname);
    
      // default as 3rd arg
      if (typeof fn != 'function') {
        if (fn instanceof RegExp) {
          var regex = fn;
          fn = function(val, def) {
            var m = regex.exec(val);
            return m ? m[0] : def;
          }
        }
        else {
          defaultValue = fn;
          fn = null;
        }
      }
    
      // preassign default value only for --no-*, [optional], or <required>
      if (false == option.bool || option.optional || option.required) {
        // when --no-* we make sure default is true
        if (false == option.bool) defaultValue = true;
        // preassign only if we have a default
        if (undefined !== defaultValue) self[name] = defaultValue;
      }
    
      // register the option
      this.options.push(option);
    
      // when it's passed assign the value
      // and conditionally invoke the callback
      this.on(oname, function(val) {
        // coercion
        if (null !== val && fn) val = fn(val, undefined === self[name]
          ? defaultValue
          : self[name]);
    
        // unassigned or bool
        if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
          // if no value, bool true, and we have a default, then use it!
          if (null == val) {
            self[name] = option.bool
              ? defaultValue || true
              : false;
          } else {
            self[name] = val;
          }
        } else if (null !== val) {
          // reassign
          self[name] = val;
        }
      });
    
      return this;
    };
    
    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} arg if `true` or omitted, no error will be thrown
     * for unknown options.
     * @api public
     */
    Command.prototype.allowUnknownOption = function(arg) {
        this._allowUnknownOption = arguments.length === 0 || arg;
        return this;
    };
    
    /**
     * Parse `argv`, settings options and invoking commands when defined.
     *
     * @param {Array} argv
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parse = function(argv) {
      // implicit help
      if (this.executables) this.addImplicitHelpCommand();
    
      // store raw args
      this.rawArgs = argv;
    
      // guess name
      this._name = this._name || basename(argv[1], '.js');
    
      // github-style sub-commands with no sub-command
      if (this.executables && argv.length < 3) {
        // this user needs help
        argv.push('--help');
      }
    
      // process argv
      var parsed = this.parseOptions(this.normalize(argv.slice(2)));
      var args = this.args = parsed.args;
    
      var result = this.parseArgs(this.args, parsed.unknown);
    
      // executable sub-commands
      var name = result.args[0];
      if (this._execs[name] && typeof this._execs[name] != "function") {
        return this.executeSubCommand(argv, args, parsed.unknown);
      }
    
      return result;
    };
    
    /**
     * Execute a sub-command executable.
     *
     * @param {Array} argv
     * @param {Array} args
     * @param {Array} unknown
     * @api private
     */
    
    Command.prototype.executeSubCommand = function(argv, args, unknown) {
      args = args.concat(unknown);
    
      if (!args.length) this.help();
      if ('help' == args[0] && 1 == args.length) this.help();
    
      // <cmd> --help
      if ('help' == args[0]) {
        args[0] = args[1];
        args[1] = '--help';
      }
    
      // executable
      var f = argv[1];
      // name of the subcommand, link `pm-install`
      var bin = basename(f, '.js') + '-' + args[0];
    
    
      // In case of globally installed, get the base dir where executable
      //  subcommand file should be located at
      var baseDir
        , link = readlink(f);
    
      // when symbolink is relative path
      if (link !== f && link.charAt(0) !== '/') {
        link = path.join(dirname(f), link)
      }
      baseDir = dirname(link);
    
      // prefer local `./<bin>` to bin in the $PATH
      var localBin = path.join(baseDir, bin);
    
      // whether bin file is a js script with explicit `.js` extension
      var isExplicitJS = false;
      if (exists(localBin + '.js')) {
        bin = localBin + '.js';
        isExplicitJS = true;
      } else if (exists(localBin)) {
        bin = localBin;
      }
    
      args = args.slice(1);
    
      var proc;
      if (process.platform !== 'win32') {
        if (isExplicitJS) {
          args.unshift(localBin);
          // add executable arguments to spawn
          args = (process.execArgv || []).concat(args);
    
          proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
        } else {
          proc = spawn(bin, args, { stdio: 'inherit', customFds: [0, 1, 2] });
        }
      } else {
        args.unshift(localBin);
        proc = spawn(process.execPath, args, { stdio: 'inherit'});
      }
    
      proc.on('close', process.exit.bind(process));
      proc.on('error', function(err) {
        if (err.code == "ENOENT") {
          console.error('\n  %s(1) does not exist, try --help\n', bin);
        } else if (err.code == "EACCES") {
          console.error('\n  %s(1) not executable. try chmod or run with root\n', bin);
        }
        process.exit(1);
      });
    
      this.runningCommand = proc;
    };
    
    /**
     * Normalize `args`, splitting joined short flags. For example
     * the arg "-abc" is equivalent to "-a -b -c".
     * This also normalizes equal sign and splits "--abc=def" into "--abc def".
     *
     * @param {Array} args
     * @return {Array}
     * @api private
     */
    
    Command.prototype.normalize = function(args) {
      var ret = []
        , arg
        , lastOpt
        , index;
    
      for (var i = 0, len = args.length; i < len; ++i) {
        arg = args[i];
        if (i > 0) {
          lastOpt = this.optionFor(args[i-1]);
        }
    
        if (arg === '--') {
          // Honor option terminator
          ret = ret.concat(args.slice(i));
          break;
        } else if (lastOpt && lastOpt.required) {
          ret.push(arg);
        } else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {
          arg.slice(1).split('').forEach(function(c) {
            ret.push('-' + c);
          });
        } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
          ret.push(arg.slice(0, index), arg.slice(index + 1));
        } else {
          ret.push(arg);
        }
      }
    
      return ret;
    };
    
    /**
     * Parse command `args`.
     *
     * When listener(s) are available those
     * callbacks are invoked, otherwise the "*"
     * event is emitted and those actions are invoked.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api private
     */
    
    Command.prototype.parseArgs = function(args, unknown) {
      var name;
    
      if (args.length) {
        name = args[0];
        if (this.listeners(name).length) {
          this.emit(args.shift(), args, unknown);
        } else {
          this.emit('*', args);
        }
      } else {
        outputHelpIfNecessary(this, unknown);
    
        // If there were no args and we have unknown options,
        // then they are extraneous and we need to error.
        if (unknown.length > 0) {
          this.unknownOption(unknown[0]);
        }
      }
    
      return this;
    };
    
    /**
     * Return an option matching `arg` if any.
     *
     * @param {String} arg
     * @return {Option}
     * @api private
     */
    
    Command.prototype.optionFor = function(arg) {
      for (var i = 0, len = this.options.length; i < len; ++i) {
        if (this.options[i].is(arg)) {
          return this.options[i];
        }
      }
    };
    
    /**
     * Parse options from `argv` returning `argv`
     * void of these options.
     *
     * @param {Array} argv
     * @return {Array}
     * @api public
     */
    
    Command.prototype.parseOptions = function(argv) {
      var args = []
        , len = argv.length
        , literal
        , option
        , arg;
    
      var unknownOptions = [];
    
      // parse options
      for (var i = 0; i < len; ++i) {
        arg = argv[i];
    
        // literal args after --
        if ('--' == arg) {
          literal = true;
          continue;
        }
    
        if (literal) {
          args.push(arg);
          continue;
        }
    
        // find matching Option
        option = this.optionFor(arg);
    
        // option is defined
        if (option) {
          // requires arg
          if (option.required) {
            arg = argv[++i];
            if (null == arg) return this.optionMissingArgument(option);
            this.emit(option.name(), arg);
          // optional arg
          } else if (option.optional) {
            arg = argv[i+1];
            if (null == arg || ('-' == arg[0] && '-' != arg)) {
              arg = null;
            } else {
              ++i;
            }
            this.emit(option.name(), arg);
          // bool
          } else {
            this.emit(option.name());
          }
          continue;
        }
    
        // looks like an option
        if (arg.length > 1 && '-' == arg[0]) {
          unknownOptions.push(arg);
    
          // If the next argument looks like it might be
          // an argument for this option, we pass it on.
          // If it isn't, then it'll simply be ignored
          if (argv[i+1] && '-' != argv[i+1][0]) {
            unknownOptions.push(argv[++i]);
          }
          continue;
        }
    
        // arg
        args.push(arg);
      }
    
      return { args: args, unknown: unknownOptions };
    };
    
    /**
     * Return an object containing options as key-value pairs
     *
     * @return {Object}
     * @api public
     */
    Command.prototype.opts = function() {
      var result = {}
        , len = this.options.length;
    
      for (var i = 0 ; i < len; i++) {
        var key = camelcase(this.options[i].name());
        result[key] = key === 'version' ? this._version : this[key];
      }
      return result;
    };
    
    /**
     * Argument `name` is missing.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.missingArgument = function(name) {
      console.error();
      console.error("  error: missing required argument `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * `Option` is missing an argument, but received `flag` or nothing.
     *
     * @param {String} option
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.optionMissingArgument = function(option, flag) {
      console.error();
      if (flag) {
        console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);
      } else {
        console.error("  error: option `%s' argument missing", option.flags);
      }
      console.error();
      process.exit(1);
    };
    
    /**
     * Unknown option `flag`.
     *
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.unknownOption = function(flag) {
      if (this._allowUnknownOption) return;
      console.error();
      console.error("  error: unknown option `%s'", flag);
      console.error();
      process.exit(1);
    };
    
    /**
     * Variadic argument with `name` is not the last argument as required.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.variadicArgNotLast = function(name) {
      console.error();
      console.error("  error: variadic arguments must be last `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * Set the program version to `str`.
     *
     * This method auto-registers the "-V, --version" flag
     * which will print the version number when passed.
     *
     * @param {String} str
     * @param {String} flags
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.version = function(str, flags) {
      if (0 == arguments.length) return this._version;
      this._version = str;
      flags = flags || '-V, --version';
      this.option(flags, 'output the version number');
      this.on('version', function() {
        process.stdout.write(str + '\n');
        process.exit(0);
      });
      return this;
    };
    
    /**
     * Set the description to `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.description = function(str) {
      if (0 == arguments.length) return this._description;
      this._description = str;
      return this;
    };
    
    /**
     * Set an alias for the command
     *
     * @param {String} alias
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.alias = function(alias) {
      if (0 == arguments.length) return this._alias;
      this._alias = alias;
      return this;
    };
    
    /**
     * Set / get the command usage `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.usage = function(str) {
      var args = this._args.map(function(arg) {
        return humanReadableArgName(arg);
      });
    
      var usage = '[options]'
        + (this.commands.length ? ' [command]' : '')
        + (this._args.length ? ' ' + args.join(' ') : '');
    
      if (0 == arguments.length) return this._usage || usage;
      this._usage = str;
    
      return this;
    };
    
    /**
     * Get the name of the command
     *
     * @param {String} name
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.name = function() {
      return this._name;
    };
    
    /**
     * Return the largest option length.
     *
     * @return {Number}
     * @api private
     */
    
    Command.prototype.largestOptionLength = function() {
      return this.options.reduce(function(max, option) {
        return Math.max(max, option.flags.length);
      }, 0);
    };
    
    /**
     * Return help for options.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.optionHelp = function() {
      var width = this.largestOptionLength();
    
      // Prepend the help information
      return [pad('-h, --help', width) + '  ' + 'output usage information']
        .concat(this.options.map(function(option) {
          return pad(option.flags, width) + '  ' + option.description;
          }))
        .join('\n');
    };
    
    /**
     * Return command help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.commandHelp = function() {
      if (!this.commands.length) return '';
    
      var commands = this.commands.filter(function(cmd) {
        return !cmd._noHelp;
      }).map(function(cmd) {
        var args = cmd._args.map(function(arg) {
          return humanReadableArgName(arg);
        }).join(' ');
    
        return [
          cmd._name
            + (cmd._alias
              ? '|' + cmd._alias
              : '')
            + (cmd.options.length
              ? ' [options]'
              : '')
            + ' ' + args
        , cmd.description()
        ];
      });
    
      var width = commands.reduce(function(max, command) {
        return Math.max(max, command[0].length);
      }, 0);
    
      return [
          ''
        , '  Commands:'
        , ''
        , commands.map(function(cmd) {
          return pad(cmd[0], width) + '  ' + cmd[1];
        }).join('\n').replace(/^/gm, '    ')
        , ''
      ].join('\n');
    };
    
    /**
     * Return program help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.helpInformation = function() {
      var desc = [];
      if (this._description) {
        desc = [
          '  ' + this._description
          , ''
        ];
      }
    
      var cmdName = this._name;
      if (this._alias) {
        cmdName = cmdName + '|' + this._alias;
      }
      var usage = [
        ''
        ,'  Usage: ' + cmdName + ' ' + this.usage()
        , ''
      ];
    
      var cmds = [];
      var commandHelp = this.commandHelp();
      if (commandHelp) cmds = [commandHelp];
    
      var options = [
        '  Options:'
        , ''
        , '' + this.optionHelp().replace(/^/gm, '    ')
        , ''
        , ''
      ];
    
      return usage
        .concat(cmds)
        .concat(desc)
        .concat(options)
        .join('\n');
    };
    
    /**
     * Output help information for this command
     *
     * @api public
     */
    
    Command.prototype.outputHelp = function() {
      process.stdout.write(this.helpInformation());
      this.emit('--help');
    };
    
    /**
     * Output help information and exit.
     *
     * @api public
     */
    
    Command.prototype.help = function() {
      this.outputHelp();
      process.exit();
    };
    
    /**
     * Camel-case the given `flag`
     *
     * @param {String} flag
     * @return {String}
     * @api private
     */
    
    function camelcase(flag) {
      return flag.split('-').reduce(function(str, word) {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }
    
    /**
     * Pad `str` to `width`.
     *
     * @param {String} str
     * @param {Number} width
     * @return {String}
     * @api private
     */
    
    function pad(str, width) {
      var len = Math.max(0, width - str.length);
      return str + Array(len + 1).join(' ');
    }
    
    /**
     * Output help information if necessary
     *
     * @param {Command} command to output help for
     * @param {Array} array of options to search for -h or --help
     * @api private
     */
    
    function outputHelpIfNecessary(cmd, options) {
      options = options || [];
      for (var i = 0; i < options.length; i++) {
        if (options[i] == '--help' || options[i] == '-h') {
          cmd.outputHelp();
          process.exit(0);
        }
      }
    }
    
    /**
     * Takes an argument an returns its human readable equivalent for help usage.
     *
     * @param {Object} arg
     * @return {String}
     * @api private
     */
    
    function humanReadableArgName(arg) {
      var nameOutput = arg.name + (arg.variadic === true ? '...' : '');
    
      return arg.required
        ? '<' + nameOutput + '>'
        : '[' + nameOutput + ']'
    }
    
    // for versions before node v0.8 when there weren't `fs.existsSync`
    function exists(file) {
      try {
        if (fs.statSync(file).isFile()) {
          return true;
        }
      } catch (e) {
        return false;
      }
    }
    
    
  provide("commander", module.exports);
}(global));

// pakmanager:is-my-json-valid/formats
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports['date-time'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/
    exports['date'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/
    exports['time'] = /^\d{2}:\d{2}:\d{2}$/
    exports['email'] = /^\S+@\S+$/
    exports['ip-address'] = exports['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
    exports['ipv6'] = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/
    exports['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/
    exports['color'] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/
    exports['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$/
    exports['alpha'] = /^[a-zA-Z]+$/
    exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
    exports['style'] = /\s*(.+?):\s*([^;]+);?/g
    exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
    exports['utc-millisec'] = /^[0-9]+(\.?[0-9]+)?$/
    
  provide("is-my-json-valid/formats", module.exports);
}(global));

// pakmanager:is-my-json-valid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var genobj = require('generate-object-property')
    var genfun = require('generate-function')
    var jsonpointer = require('jsonpointer')
    var xtend = require('xtend')
    var formats =  require('is-my-json-valid/formats')
    
    var get = function(obj, additionalSchemas, ptr) {
      if (/^https?:\/\//.test(ptr)) return null
    
      var visit = function(sub) {
        if (sub && sub.id === ptr) return sub
        if (typeof sub !== 'object' || !sub) return null
        return Object.keys(sub).reduce(function(res, k) {
          return res || visit(sub[k])
        }, null)
      }
    
      var res = visit(obj)
      if (res) return res
    
      ptr = ptr.replace(/^#/, '')
      ptr = ptr.replace(/\/$/, '')
    
      try {
        return jsonpointer.get(obj, decodeURI(ptr))
      } catch (err) {
        var end = ptr.indexOf('#')
        var other
        // external reference
        if (end !== 0) {
          // fragment doesn't exist.
          if (end === -1) {
            other = additionalSchemas[ptr]
          } else {
            var ext = ptr.slice(0, end)
            other = additionalSchemas[ext]
            var fragment = ptr.slice(end).replace(/^#/, '')
            try {
              return jsonpointer.get(other, fragment)
            } catch (err) {}
          }
        } else {
          other = additionalSchemas[ptr]
        }
        return other || null
      }
    }
    
    var formatName = function(field) {
      field = JSON.stringify(field)
      var pattern = /\[([^\[\]"]+)\]/
      while (pattern.test(field)) field = field.replace(pattern, '."+$1+"')
      return field
    }
    
    var types = {}
    
    types.any = function() {
      return 'true'
    }
    
    types.null = function(name) {
      return name+' === null'
    }
    
    types.boolean = function(name) {
      return 'typeof '+name+' === "boolean"'
    }
    
    types.array = function(name) {
      return 'Array.isArray('+name+')'
    }
    
    types.object = function(name) {
      return 'typeof '+name+' === "object" && '+name+' && !Array.isArray('+name+')'
    }
    
    types.number = function(name) {
      return 'typeof '+name+' === "number"'
    }
    
    types.integer = function(name) {
      return 'typeof '+name+' === "number" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'
    }
    
    types.string = function(name) {
      return 'typeof '+name+' === "string"'
    }
    
    var unique = function(array) {
      var list = []
      for (var i = 0; i < array.length; i++) {
        list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])
      }
      for (var i = 1; i < list.length; i++) {
        if (list.indexOf(list[i]) !== i) return false
      }
      return true
    }
    
    var toType = function(node) {
      return node.type
    }
    
    var compile = function(schema, cache, root, reporter, opts) {
      var fmts = opts ? xtend(formats, opts.formats) : formats
      var scope = {unique:unique, formats:fmts}
      var verbose = opts ? !!opts.verbose : false;
      var greedy = opts && opts.greedy !== undefined ?
        opts.greedy : false;
    
      var syms = {}
      var gensym = function(name) {
        return name+(syms[name] = (syms[name] || 0)+1)
      }
    
      var reversePatterns = {}
      var patterns = function(p) {
        if (reversePatterns[p]) return reversePatterns[p]
        var n = gensym('pattern')
        scope[n] = new RegExp(p)
        reversePatterns[p] = n
        return n
      }
    
      var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']
      var genloop = function() {
        var v = vars.shift()
        vars.push(v+v[0])
        return v
      }
    
      var visit = function(name, node, reporter, filter) {
        var properties = node.properties
        var type = node.type
        var tuple = false
    
        if (Array.isArray(node.items)) { // tuple type
          properties = {}
          node.items.forEach(function(item, i) {
            properties[i] = item
          })
          type = 'array'
          tuple = true
        }
    
        var indent = 0
        var error = function(msg, prop, value) {
          validate('errors++')
          if (reporter === true) {
            validate('if (validate.errors === null) validate.errors = []')
            if (verbose) {
              validate('validate.errors.push({field:%s,message:%s,value:%s})', formatName(prop || name), JSON.stringify(msg), value || name)
            } else {
              validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))
            }
          }
        }
    
        if (node.required === true) {
          indent++
          validate('if (%s === undefined) {', name)
          error('is required')
          validate('} else {')
        } else {
          indent++
          validate('if (%s !== undefined) {', name)
        }
    
        var valid = [].concat(type)
          .map(function(t) {
            return types[t || 'any'](name)
          })
          .join(' || ') || 'true'
    
        if (valid !== 'true') {
          indent++
          validate('if (!(%s)) {', valid)
          error('is the wrong type')
          validate('} else {')
        }
    
        if (tuple) {
          if (node.additionalItems === false) {
            validate('if (%s.length > %d) {', name, node.items.length)
            error('has additional items')
            validate('}')
          } else if (node.additionalItems) {
            var i = genloop()
            validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)
            visit(name+'['+i+']', node.additionalItems, reporter, filter)
            validate('}')
          }   
        }
    
        if (node.format && fmts[node.format]) {
          if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))
          var n = gensym('format')
          scope[n] = fmts[node.format]
    
          if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)
          else validate('if (!%s.test(%s)) {', n, name)
          error('must be '+node.format+' format')
          validate('}')
          if (type !== 'string' && formats[node.format]) validate('}')
        }
    
        if (Array.isArray(node.required)) {
          var isUndefined = function(req) {
            return genobj(name, req) + ' === undefined'
          }
    
          var checkRequired = function (req) {
            var prop = genobj(name, req);
            validate('if (%s === undefined) {', prop)
            error('is required', prop)
            validate('missing++')
            validate('}')
          }
          validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')
          validate('var missing = 0')
          node.required.map(checkRequired)
          validate('}');
          if (!greedy) {
            validate('if (missing === 0) {')
            indent++
          }
        }
    
        if (node.uniqueItems) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
          validate('if (!(unique(%s))) {', name)
          error('must be unique')
          validate('}')
          if (type !== 'array') validate('}')
        }
    
        if (node.enum) {
          var complex = node.enum.some(function(e) {
            return typeof e === 'object'
          })
    
          var compare = complex ?
            function(e) {
              return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'
            } :
            function(e) {
              return name+' !== '+JSON.stringify(e)
            }
    
          validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')
          error('must be an enum value')
          validate('}')
        }
    
        if (node.dependencies) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
    
          Object.keys(node.dependencies).forEach(function(key) {
            var deps = node.dependencies[key]
            if (typeof deps === 'string') deps = [deps]
    
            var exists = function(k) {
              return genobj(name, k) + ' !== undefined'
            }
    
            if (Array.isArray(deps)) {
              validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')
              error('dependencies not set')
              validate('}')
            }
            if (typeof deps === 'object') {
              validate('if (%s !== undefined) {', genobj(name, key))
              visit(name, deps, reporter, filter)
              validate('}')
            }
          })
    
          if (type !== 'object') validate('}')
        }
    
        if (node.additionalProperties || node.additionalProperties === false) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
    
          var i = genloop()
          var keys = gensym('keys')
    
          var toCompare = function(p) {
            return keys+'['+i+'] !== '+JSON.stringify(p)
          }
    
          var toTest = function(p) {
            return '!'+patterns(p)+'.test('+keys+'['+i+'])'
          }
    
          var additionalProp = Object.keys(properties || {}).map(toCompare)
            .concat(Object.keys(node.patternProperties || {}).map(toTest))
            .join(' && ') || 'true'
    
          validate('var %s = Object.keys(%s)', keys, name)
            ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
              ('if (%s) {', additionalProp)
    
          if (node.additionalProperties === false) {
            if (filter) validate('delete %s', name+'['+keys+'['+i+']]')
            error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')
          } else {
            visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter)
          }
    
          validate
              ('}')
            ('}')
    
          if (type !== 'object') validate('}')
        }
    
        if (node.$ref) {
          var sub = get(root, opts && opts.schemas || {}, node.$ref)
          if (sub) {
            var fn = cache[node.$ref]
            if (!fn) {
              cache[node.$ref] = function proxy(data) {
                return fn(data)
              }
              fn = compile(sub, cache, root, false, opts)
            }
            var n = gensym('ref')
            scope[n] = fn
            validate('if (!(%s(%s))) {', n, name)
            error('referenced schema does not match')
            validate('}')
          }
        }
    
        if (node.not) {
          var prev = gensym('prev')
          validate('var %s = errors', prev)
          visit(name, node.not, false, filter)
          validate('if (%s === errors) {', prev)
          error('negative schema matches')
          validate('} else {')
            ('errors = %s', prev)
          ('}')
        }
    
        if (node.items && !tuple) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
    
          var i = genloop()
          validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)
          visit(name+'['+i+']', node.items, reporter, filter)
          validate('}')
    
          if (type !== 'array') validate('}')
        }
    
        if (node.patternProperties) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
          var keys = gensym('keys')
          var i = genloop()
          validate
            ('var %s = Object.keys(%s)', keys, name)
            ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
    
          Object.keys(node.patternProperties).forEach(function(key) {
            var p = patterns(key)
            validate('if (%s.test(%s)) {', p, keys+'['+i+']')
            visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter)
            validate('}')
          })
    
          validate('}')
          if (type !== 'object') validate('}')
        }
    
        if (node.pattern) {
          var p = patterns(node.pattern)
          if (type !== 'string') validate('if (%s) {', types.string(name))
          validate('if (!(%s.test(%s))) {', p, name)
          error('pattern mismatch')
          validate('}')
          if (type !== 'string') validate('}')
        }
    
        if (node.allOf) {
          node.allOf.forEach(function(sch) {
            visit(name, sch, reporter, filter)
          })
        }
    
        if (node.anyOf && node.anyOf.length) {
          var prev = gensym('prev')
    
          node.anyOf.forEach(function(sch, i) {
            if (i === 0) {
              validate('var %s = errors', prev)
            } else {          
              validate('if (errors !== %s) {', prev)
                ('errors = %s', prev)
            }
            visit(name, sch, false, false)
          })
          node.anyOf.forEach(function(sch, i) {
            if (i) validate('}')
          })
          validate('if (%s !== errors) {', prev)
          error('no schemas match')
          validate('}')
        }
    
        if (node.oneOf && node.oneOf.length) {
          var prev = gensym('prev')
          var passes = gensym('passes')
    
          validate
            ('var %s = errors', prev)
            ('var %s = 0', passes)
    
          node.oneOf.forEach(function(sch, i) {
            visit(name, sch, false, false)
            validate('if (%s === errors) {', prev)
              ('%s++', passes)
            ('} else {')
              ('errors = %s', prev)
            ('}')
          })
    
          validate('if (%s !== 1) {', passes)
          error('no (or more than one) schemas match')
          validate('}')
        }
    
        if (node.multipleOf !== undefined) {
          if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))
    
          var factor = ((node.multipleOf | 0) !== node.multipleOf) ? Math.pow(10, node.multipleOf.toString().split('.').pop().length) : 1
          if (factor > 1) validate('if ((%d*%s) % %d) {', factor, name, factor*node.multipleOf)
          else validate('if (%s % %d) {', name, node.multipleOf)
    
          error('has a remainder')
          validate('}')
    
          if (type !== 'number' && type !== 'integer') validate('}')
        }
    
        if (node.maxProperties !== undefined) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
          
          validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)
          error('has more properties than allowed')
          validate('}')
    
          if (type !== 'object') validate('}')
        }
    
        if (node.minProperties !== undefined) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
          
          validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)
          error('has less properties than allowed')
          validate('}')
    
          if (type !== 'object') validate('}')
        }
    
        if (node.maxItems !== undefined) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
          
          validate('if (%s.length > %d) {', name, node.maxItems)
          error('has more items than allowed')
          validate('}')
    
          if (type !== 'array') validate('}')
        }
    
        if (node.minItems !== undefined) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
          
          validate('if (%s.length < %d) {', name, node.minItems)
          error('has less items than allowed')
          validate('}')
    
          if (type !== 'array') validate('}')
        }
    
        if (node.maxLength !== undefined) {
          if (type !== 'string') validate('if (%s) {', types.string(name))
    
          validate('if (%s.length > %d) {', name, node.maxLength)
          error('has longer length than allowed')
          validate('}')
    
          if (type !== 'string') validate('}')
        }
    
        if (node.minLength !== undefined) {
          if (type !== 'string') validate('if (%s) {', types.string(name))
    
          validate('if (%s.length < %d) {', name, node.minLength)
          error('has less length than allowed')
          validate('}')
    
          if (type !== 'string') validate('}')
        }
    
        if (node.minimum !== undefined) {
          validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)
          error('is less than minimum')
          validate('}')
        }
    
        if (node.maximum !== undefined) {
          validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)
          error('is more than maximum')
          validate('}')
        }
    
        if (properties) {
          Object.keys(properties).forEach(function(p) {
            if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)
    
            visit(genobj(name, p), properties[p], reporter, filter)
    
            if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')
          })
        }
    
        while (indent--) validate('}')
      }
    
      var validate = genfun
        ('function validate(data) {')
          ('validate.errors = null')
          ('var errors = 0')
    
      visit('data', schema, reporter, opts && opts.filter)
    
      validate
          ('return errors === 0')
        ('}')
    
      validate = validate.toFunction(scope)
      validate.errors = null
    
      validate.__defineGetter__('error', function() {
        if (!validate.errors) return ''
        return validate.errors
          .map(function(err) {
            return err.field+' '+err.message
          })
          .join('\n')
      })
    
      validate.toJSON = function() {
        return schema
      }
    
      return validate
    }
    
    module.exports = function(schema, opts) {
      if (typeof schema === 'string') schema = JSON.parse(schema)
      return compile(schema, {}, schema, true, opts)
    }
    
    module.exports.filter = function(schema, opts) {
      var validate = module.exports(schema, xtend(opts, {filter: true}))
      return function(sch) {
        validate(sch)
        return sch
      }
    }
    
  provide("is-my-json-valid", module.exports);
}(global));

// pakmanager:concat-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Writable = require('readable-stream').Writable
    var inherits = require('inherits')
    
    if (typeof Uint8Array === 'undefined') {
      var U8 = require('typedarray').Uint8Array
    } else {
      var U8 = Uint8Array
    }
    
    function ConcatStream(opts, cb) {
      if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)
    
      if (typeof opts === 'function') {
        cb = opts
        opts = {}
      }
      if (!opts) opts = {}
    
      var encoding = opts.encoding
      var shouldInferEncoding = false
    
      if (!encoding) {
        shouldInferEncoding = true
      } else {
        encoding =  String(encoding).toLowerCase()
        if (encoding === 'u8' || encoding === 'uint8') {
          encoding = 'uint8array'
        }
      }
    
      Writable.call(this, { objectMode: true })
    
      this.encoding = encoding
      this.shouldInferEncoding = shouldInferEncoding
    
      if (cb) this.on('finish', function () { cb(this.getBody()) })
      this.body = []
    }
    
    module.exports = ConcatStream
    inherits(ConcatStream, Writable)
    
    ConcatStream.prototype._write = function(chunk, enc, next) {
      this.body.push(chunk)
      next()
    }
    
    ConcatStream.prototype.inferEncoding = function (buff) {
      var firstBuffer = buff === undefined ? this.body[0] : buff;
      if (Buffer.isBuffer(firstBuffer)) return 'buffer'
      if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'
      if (Array.isArray(firstBuffer)) return 'array'
      if (typeof firstBuffer === 'string') return 'string'
      if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return 'object'
      return 'buffer'
    }
    
    ConcatStream.prototype.getBody = function () {
      if (!this.encoding && this.body.length === 0) return []
      if (this.shouldInferEncoding) this.encoding = this.inferEncoding()
      if (this.encoding === 'array') return arrayConcat(this.body)
      if (this.encoding === 'string') return stringConcat(this.body)
      if (this.encoding === 'buffer') return bufferConcat(this.body)
      if (this.encoding === 'uint8array') return u8Concat(this.body)
      return this.body
    }
    
    var isArray = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]'
    }
    
    function isArrayish (arr) {
      return /Array\]$/.test(Object.prototype.toString.call(arr))
    }
    
    function stringConcat (parts) {
      var strings = []
      var needsToString = false
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i]
        if (typeof p === 'string') {
          strings.push(p)
        } else if (Buffer.isBuffer(p)) {
          strings.push(p)
        } else {
          strings.push(Buffer(p))
        }
      }
      if (Buffer.isBuffer(parts[0])) {
        strings = Buffer.concat(strings)
        strings = strings.toString('utf8')
      } else {
        strings = strings.join('')
      }
      return strings
    }
    
    function bufferConcat (parts) {
      var bufs = []
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i]
        if (Buffer.isBuffer(p)) {
          bufs.push(p)
        } else if (typeof p === 'string' || isArrayish(p)
        || (p && typeof p.subarray === 'function')) {
          bufs.push(Buffer(p))
        } else bufs.push(Buffer(String(p)))
      }
      return Buffer.concat(bufs)
    }
    
    function arrayConcat (parts) {
      var res = []
      for (var i = 0; i < parts.length; i++) {
        res.push.apply(res, parts[i])
      }
      return res
    }
    
    function u8Concat (parts) {
      var len = 0
      for (var i = 0; i < parts.length; i++) {
        if (typeof parts[i] === 'string') {
          parts[i] = Buffer(parts[i])
        }
        len += parts[i].length
      }
      var u8 = new U8(len)
      for (var i = 0, offset = 0; i < parts.length; i++) {
        var part = parts[i]
        for (var j = 0; j < part.length; j++) {
          u8[offset++] = part[j]
        }
      }
      return u8
    }
    
  provide("concat-stream", module.exports);
}(global));

// pakmanager:duplexer2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var stream = require("readable-stream");
    
    var duplex2 = module.exports = function duplex2(options, writable, readable) {
      return new DuplexWrapper(options, writable, readable);
    };
    
    var DuplexWrapper = exports.DuplexWrapper = function DuplexWrapper(options, writable, readable) {
      if (typeof readable === "undefined") {
        readable = writable;
        writable = options;
        options = null;
      }
    
      options = options || {};
      options.objectMode = true;
    
      stream.Duplex.call(this, options);
    
      this._bubbleErrors = (typeof options.bubbleErrors === "undefined") || !!options.bubbleErrors;
    
      this._writable = writable;
      this._readable = readable;
    
      var self = this;
    
      writable.once("finish", function() {
        self.end();
      });
    
      this.once("finish", function() {
        writable.end();
      });
    
      readable.on("data", function(e) {
        if (!self.push(e)) {
          readable.pause();
        }
      });
    
      readable.once("end", function() {
        return self.push(null);
      });
    
      if (this._bubbleErrors) {
        writable.on("error", function(err) {
          return self.emit("error", err);
        });
    
        readable.on("error", function(err) {
          return self.emit("error", err);
        });
      }
    };
    DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});
    
    DuplexWrapper.prototype._write = function _write(input, encoding, done) {
      this._writable.write(input, encoding, done);
    };
    
    DuplexWrapper.prototype._read = function _read(n) {
      this._readable.resume();
    };
    
  provide("duplexer2", module.exports);
}(global));

// pakmanager:falafel
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var parse = require('acorn').parse;
    var isArray = require('isarray');
    var objectKeys = require('object-keys');
    var forEach = require('foreach');
    
    module.exports = function (src, opts, fn) {
        if (typeof opts === 'function') {
            fn = opts;
            opts = {};
        }
        if (src && typeof src === 'object' && src.constructor.name === 'Buffer') {
            src = src.toString();
        }
        else if (src && typeof src === 'object') {
            opts = src;
            src = opts.source;
            delete opts.source;
        }
        src = src === undefined ? opts.source : src;
        if (typeof src !== 'string') src = String(src);
        if (opts.parser) parse = opts.parser.parse;
        var ast = parse(src, opts);
        
        var result = {
            chunks : src.split(''),
            toString : function () { return result.chunks.join('') },
            inspect : function () { return result.toString() }
        };
        var index = 0;
        
        (function walk (node, parent) {
            insertHelpers(node, parent, result.chunks);
            
            forEach(objectKeys(node), function (key) {
                if (key === 'parent') return;
                
                var child = node[key];
                if (isArray(child)) {
                    forEach(child, function (c) {
                        if (c && typeof c.type === 'string') {
                            walk(c, node);
                        }
                    });
                }
                else if (child && typeof child.type === 'string') {
                    walk(child, node);
                }
            });
            fn(node);
        })(ast, undefined);
        
        return result;
    };
     
    function insertHelpers (node, parent, chunks) {
        node.parent = parent;
        
        node.source = function () {
            return chunks.slice(node.start, node.end).join('');
        };
        
        if (node.update && typeof node.update === 'object') {
            var prev = node.update;
            forEach(objectKeys(prev), function (key) {
                update[key] = prev[key];
            });
            node.update = update;
        }
        else {
            node.update = update;
        }
        
        function update (s) {
            chunks[node.start] = s;
            for (var i = node.start + 1; i < node.end; i++) {
                chunks[i] = '';
            }
        }
    }
    
  provide("falafel", module.exports);
}(global));

// pakmanager:has
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var bind = require('function-bind');
    
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    
  provide("has", module.exports);
}(global));

// pakmanager:object-inspect
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function inspect_ (obj, opts, depth, seen) {
        if (!opts) opts = {};
        
        var maxDepth = opts.depth === undefined ? 5 : opts.depth;
        if (depth === undefined) depth = 0;
        if (depth >= maxDepth && maxDepth > 0
        && obj && typeof obj === 'object') {
            return '[Object]';
        }
        
        if (seen === undefined) seen = [];
        else if (indexOf(seen, obj) >= 0) {
            return '[Circular]';
        }
        
        function inspect (value, from) {
            if (from) {
                seen = seen.slice();
                seen.push(from);
            }
            return inspect_(value, opts, depth + 1, seen);
        }
        
        if (typeof obj === 'string') {
            return inspectString(obj);
        }
        else if (typeof obj === 'function') {
            var name = nameOf(obj);
            return '[Function' + (name ? ': ' + name : '') + ']';
        }
        else if (obj === null) {
            return 'null';
        }
        else if (isSymbol(obj)) {
            var symString = Symbol.prototype.toString.call(obj);
            return typeof obj === 'object' ? 'Object(' + symString + ')' : symString;
        }
        else if (isElement(obj)) {
            var s = '<' + String(obj.nodeName).toLowerCase();
            var attrs = obj.attributes || [];
            for (var i = 0; i < attrs.length; i++) {
                s += ' ' + attrs[i].name + '="' + quote(attrs[i].value) + '"';
            }
            s += '>';
            if (obj.childNodes && obj.childNodes.length) s += '...';
            s += '</' + String(obj.nodeName).toLowerCase() + '>';
            return s;
        }
        else if (isArray(obj)) {
            if (obj.length === 0) return '[]';
            var xs = Array(obj.length);
            for (var i = 0; i < obj.length; i++) {
                xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
            }
            return '[ ' + xs.join(', ') + ' ]';
        }
        else if (isError(obj)) {
            var parts = [];
            for (var key in obj) {
                if (!has(obj, key)) continue;
                
                if (/[^\w$]/.test(key)) {
                    parts.push(inspect(key) + ': ' + inspect(obj[key]));
                }
                else {
                    parts.push(key + ': ' + inspect(obj[key]));
                }
            }
            if (parts.length === 0) return '[' + obj + ']';
            return '{ [' + obj + '] ' + parts.join(', ') + ' }';
        }
        else if (typeof obj === 'object' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
        else if (typeof obj === 'object' && !isDate(obj) && !isRegExp(obj)) {
            var xs = [], keys = [];
            for (var key in obj) {
                if (has(obj, key)) keys.push(key);
            }
            keys.sort();
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (/[^\w$]/.test(key)) {
                    xs.push(inspect(key) + ': ' + inspect(obj[key], obj));
                }
                else xs.push(key + ': ' + inspect(obj[key], obj));
            }
            if (xs.length === 0) return '{}';
            return '{ ' + xs.join(', ') + ' }';
        }
        else return String(obj);
    };
    
    function quote (s) {
        return String(s).replace(/"/g, '&quot;');
    }
    
    function isArray (obj) { return toStr(obj) === '[object Array]' }
    function isDate (obj) { return toStr(obj) === '[object Date]' }
    function isRegExp (obj) { return toStr(obj) === '[object RegExp]' }
    function isError (obj) { return toStr(obj) === '[object Error]' }
    function isSymbol (obj) { return toStr(obj) === '[object Symbol]' }
    
    var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
    function has (obj, key) {
        return hasOwn.call(obj, key);
    }
    
    function toStr (obj) {
        return Object.prototype.toString.call(obj);
    }
    
    function nameOf (f) {
        if (f.name) return f.name;
        var m = f.toString().match(/^function\s*([\w$]+)/);
        if (m) return m[1];
    }
    
    function indexOf (xs, x) {
        if (xs.indexOf) return xs.indexOf(x);
        for (var i = 0, l = xs.length; i < l; i++) {
            if (xs[i] === x) return i;
        }
        return -1;
    }
    
    function isElement (x) {
        if (!x || typeof x !== 'object') return false;
        if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
            return true;
        }
        return typeof x.nodeName === 'string'
            && typeof x.getAttribute === 'function'
        ;
    }
    
    function inspectString (str) {
        var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
        return "'" + s + "'";
        
        function lowbyte (c) {
            var n = c.charCodeAt(0);
            var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];
            if (x) return '\\' + x;
            return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
        }
    }
    
  provide("object-inspect", module.exports);
}(global));

// pakmanager:quote-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var through = require('through2');
    var equals = require('buffer-equal')
    var buffers = {
        quote: Buffer('"'),
        escapeQuote: Buffer('\\"'),
        escapeEscape: Buffer('\\\\'),
        escapeB: Buffer('\\b'),
        escapeF: Buffer('\\f'),
        escapeN: Buffer('\\n'),
        escapeR: Buffer('\\r'),
        escapeT: Buffer('\\t'),
        escapeLineSeparator: Buffer('\\u2028'),
        escapeParagraphSeparator: Buffer('\\u2029')
    };
    
    for (var i = 0; i < 32; i++) {
        var s = i.toString(16);
        buffers[i] = Buffer('\\u' + Array(5-s.length).join('0') + s);
    }
    
    var codes = {
        quote: '"'.charCodeAt(0),
        escape: '\\'.charCodeAt(0),
        b: '\b'.charCodeAt(0),
        f: '\f'.charCodeAt(0),
        n: '\n'.charCodeAt(0),
        r: '\r'.charCodeAt(0),
        t: '\t'.charCodeAt(0)
    };
    
    var multiByteBuffers = {
        lineSeparator: Buffer('\u2028', 'utf8'),
        paragraphSeparator: Buffer('\u2029', 'utf8')
    };
    var multiByteSeparatorLength = multiByteBuffers.lineSeparator.length; // same for both
    var multiByteSeparatorOffset = multiByteSeparatorLength - 1;
    var multiByteSeparatorCode = multiByteBuffers.lineSeparator[0]; // same for both
    
    var map = {};
    map[codes.quote] = buffers.escapeQuote;
    map[codes.escape] = buffers.escapeEscape;
    map[codes.b] = buffers.escapeB;
    map[codes.f] = buffers.escapeF;
    map[codes.n] = buffers.escapeN;
    map[codes.r] = buffers.escapeR;
    map[codes.t] = buffers.escapeT;
    
    module.exports = function () {
        var stream = through(write, end);
        stream.push(buffers.quote);
        return stream;
        
        function write (buf, enc, next) {
            var offset = 0;
            for (var i = 0; i < buf.length; i++) {
                var c = buf[i];
                var m = map[c];
                if (m) {
                    var bufs = [ buf.slice(offset, i), m ];
                    this.push(Buffer.concat(bufs));
                    offset = i + 1;
                }
                else if (c < 32) {
                    var bufs = [ buf.slice(offset, i), buffers[c] ];
                    this.push(Buffer.concat(bufs));
                    offset = i + 1;
                }
                else if (c === multiByteSeparatorCode) {
                    var rawBuf = buf.slice(i, i + multiByteSeparatorLength);
                    var escapeBuf = null;
                    if (equals(rawBuf, multiByteBuffers.lineSeparator)) {
                      escapeBuf = buffers.escapeLineSeparator;
                    } else if (equals(rawBuf, multiByteBuffers.paragraphSeparator)) {
                      escapeBuf = buffers.escapeParagraphSeparator;
                    }
                    if (escapeBuf) {
                        var bufs = [ buf.slice(offset, i), escapeBuf ];
                        this.push(Buffer.concat(bufs));
                        offset = i + multiByteSeparatorLength;
                        i += multiByteSeparatorOffset
                    }
                }
            }
            if (offset === 0) this.push(buf)
            else this.push(buf.slice(offset));
            next();
        }
        function end (next) {
            this.push(buffers.quote);
            this.push(null);
        }
    };
    
  provide("quote-stream", module.exports);
}(global));

// pakmanager:shallow-copy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (obj) {
        if (!obj || typeof obj !== 'object') return obj;
        
        var copy;
        
        if (isArray(obj)) {
            var len = obj.length;
            copy = Array(len);
            for (var i = 0; i < len; i++) {
                copy[i] = obj[i];
            }
        }
        else {
            var keys = objectKeys(obj);
            copy = {};
            
            for (var i = 0, l = keys.length; i < l; i++) {
                var key = keys[i];
                copy[key] = obj[key];
            }
        }
        return copy;
    };
    
    var objectKeys = Object.keys || function (obj) {
        var keys = [];
        for (var key in obj) {
            if ({}.hasOwnProperty.call(obj, key)) keys.push(key);
        }
        return keys;
    };
    
    var isArray = Array.isArray || function (xs) {
        return {}.toString.call(xs) === '[object Array]';
    };
    
  provide("shallow-copy", module.exports);
}(global));

// pakmanager:static-eval
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var unparse = require('escodegen').generate;
    
    module.exports = function (ast, vars) {
        if (!vars) vars = {};
        var FAIL = {};
        
        var result = (function walk (node) {
            if (node.type === 'Literal') {
                return node.value;
            }
            else if (node.type === 'UnaryExpression'){
                var val = walk(node.argument)
                if (node.operator === '+') return +val
                if (node.operator === '-') return -val
                if (node.operator === '~') return ~val
                if (node.operator === '!') return !val
                return FAIL
            }
            else if (node.type === 'ArrayExpression') {
                var xs = [];
                for (var i = 0, l = node.elements.length; i < l; i++) {
                    var x = walk(node.elements[i]);
                    if (x === FAIL) return FAIL;
                    xs.push(x);
                }
                return xs;
            }
            else if (node.type === 'ObjectExpression') {
                var obj = {};
                for (var i = 0; i < node.properties.length; i++) {
                    var prop = node.properties[i];
                    var value = prop.value === null
                        ? prop.value
                        : walk(prop.value)
                    ;
                    if (value === FAIL) return FAIL;
                    obj[prop.key.value || prop.key.name] = value;
                }
                return obj;
            }
            else if (node.type === 'BinaryExpression' ||
                     node.type === 'LogicalExpression') {
                var l = walk(node.left);
                if (l === FAIL) return FAIL;
                var r = walk(node.right);
                if (r === FAIL) return FAIL;
                
                var op = node.operator;
                if (op === '==') return l == r;
                if (op === '===') return l === r;
                if (op === '!=') return l != r;
                if (op === '!==') return l !== r;
                if (op === '+') return l + r;
                if (op === '-') return l - r;
                if (op === '*') return l * r;
                if (op === '/') return l / r;
                if (op === '%') return l % r;
                if (op === '<') return l < r;
                if (op === '<=') return l <= r;
                if (op === '>') return l > r;
                if (op === '>=') return l >= r;
                if (op === '|') return l | r;
                if (op === '&') return l & r;
                if (op === '^') return l ^ r;
                if (op === '&&') return l && r;
                if (op === '||') return l || r;
                
                return FAIL;
            }
            else if (node.type === 'Identifier') {
                if ({}.hasOwnProperty.call(vars, node.name)) {
                    return vars[node.name];
                }
                else return FAIL;
            }
            else if (node.type === 'CallExpression') {
                var callee = walk(node.callee);
                if (callee === FAIL) return FAIL;
                
                var ctx = node.callee.object ? walk(node.callee.object) : FAIL;
                if (ctx === FAIL) ctx = null;
    
                var args = [];
                for (var i = 0, l = node.arguments.length; i < l; i++) {
                    var x = walk(node.arguments[i]);
                    if (x === FAIL) return FAIL;
                    args.push(x);
                }
                return callee.apply(ctx, args);
            }
            else if (node.type === 'MemberExpression') {
                var obj = walk(node.object);
                if (obj === FAIL) return FAIL;
                if (node.property.type === 'Identifier') {
                    return obj[node.property.name];
                }
                var prop = walk(node.property);
                if (prop === FAIL) return FAIL;
                return obj[prop];
            }
            else if (node.type === 'ConditionalExpression') {
                var val = walk(node.test)
                if (val === FAIL) return FAIL;
                return val ? walk(node.consequent) : walk(node.alternate)
            }
            else if (node.type === 'FunctionExpression') {
                var keys = Object.keys(vars);
                var vals = keys.map(function(key) {
                    return vars[key];
                });
                return Function(keys.join(', '), 'return ' + unparse(node)).apply(null, vals);
            }
            else return FAIL;
        })(ast);
        
        return result === FAIL ? undefined : result;
    };
    
  provide("static-eval", module.exports);
}(global));

// pakmanager:uglify-to-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var fs = require('fs')
    var PassThrough = require('stream').PassThrough
    var Transform = require('stream').Transform
    
    if (typeof Transform === 'undefined') {
      throw new Error('UglifyJS only supports browserify when using node >= 0.10.x')
    }
    
    var cache = {}
    module.exports = transform
    function transform(file) {
      if (!/tools\/node\.js$/.test(file.replace(/\\/g,'/'))) return new PassThrough();
      if (cache[file]) return makeStream(cache[file])
      var uglify = require(file)
      var src = 'var sys = require("util");\nvar MOZ_SourceMap = require("source-map");\nvar UglifyJS = exports;\n' + uglify.FILES.map(function (path) { return fs.readFileSync(path, 'utf8') }).join('\n')
    
      var ast = uglify.parse(src)
      ast.figure_out_scope()
    
      var variables = ast.variables
        .map(function (node, name) {
          return name
        })
    
      src += '\n\n' + variables.map(function (v) { return 'exports.' + v + ' = ' + v + ';' }).join('\n') + '\n\n'
    
      src += 'exports.AST_Node.warn_function = function (txt) { if (typeof console != "undefined" && typeof console.warn === "function") console.warn(txt) }\n\n'
    
      src += 'exports.minify = ' + uglify.minify.toString() + ';\n\n'
      src += 'exports.describe_ast = ' + uglify.describe_ast.toString() + ';'
    
      // TODO: remove once https://github.com/substack/node-browserify/issues/631 is resolved
      src = src.replace(/"for"/g, '"fo" + "r"')
    
      cache[file] = src
      return makeStream(src);
    }
    
    function makeStream(src) {
      var res = new Transform();
      res._transform = function (chunk, encoding, callback) { callback() }
      res._flush = function (callback) {
        res.push(src)
        callback()
      }
      return res;
    }
    
  provide("uglify-to-browserify", module.exports);
}(global));

// pakmanager:yargs/lib/completion
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    var path = require('path')
    
    // add bash completions to your
    //  yargs-powered applications.
    module.exports = function (yargs, usage) {
      var self = {
        completionKey: 'get-yargs-completions'
      }
    
      // get a list of completion commands.
      self.getCompletion = function (done) {
        var completions = []
        var current = process.argv[process.argv.length - 1]
        var previous = process.argv.slice(process.argv.indexOf('--' + self.completionKey) + 1)
        var argv = yargs.parse(previous)
    
        // a custom completion function can be provided
        // to completion().
        if (completionFunction) {
          if (completionFunction.length < 3) {
            // synchronous completion function.
            return done(completionFunction(current, argv))
          } else {
            // asynchronous completion function
            return completionFunction(current, argv, function (completions) {
              done(completions)
            })
          }
        }
    
        var handlers = yargs.getCommandHandlers()
        for (var i = 0, ii = previous.length; i < ii; ++i) {
          if (handlers[previous[i]]) {
            return handlers[previous[i]](yargs.reset())
          }
        }
    
        if (!current.match(/^-/)) {
          usage.getCommands().forEach(function (command) {
            if (previous.indexOf(command[0]) === -1) {
              completions.push(command[0])
            }
          })
        }
    
        if (current.match(/^-/)) {
          Object.keys(yargs.getOptions().key).forEach(function (key) {
            completions.push('--' + key)
          })
        }
    
        done(completions)
      }
    
      // generate the completion script to add to your .bashrc.
      self.generateCompletionScript = function ($0) {
        var script = fs.readFileSync(
          path.resolve(__dirname, '../completion.sh.hbs'),
          'utf-8'
        )
        var name = path.basename($0)
    
        // add ./to applications not yet installed as bin.
        if ($0.match(/\.js$/)) $0 = './' + $0
    
        script = script.replace(/{{app_name}}/g, name)
        return script.replace(/{{app_path}}/g, $0)
      }
    
      // register a function to perform your own custom
      // completions., this function can be either
      // synchrnous or asynchronous.
      var completionFunction = null
      self.registerFunction = function (fn) {
        completionFunction = fn
      }
    
      return self
    }
    
  provide("yargs/lib/completion", module.exports);
}(global));

// pakmanager:yargs/lib/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // fancy-pants parsing of argv, originally forked
    // from minimist: https://www.npmjs.com/package/minimist
    var camelCase = require('camelcase')
    var path = require('path')
    
    function increment (orig) {
      return orig !== undefined ? orig + 1 : 0
    }
    
    module.exports = function (args, opts, y18n) {
      if (!opts) opts = {}
    
      var __ = y18n.__
      var error = null
      var flags = { arrays: {}, bools: {}, strings: {}, counts: {}, normalize: {}, configs: {}, defaulted: {} }
    
      ;[].concat(opts['array']).filter(Boolean).forEach(function (key) {
        flags.arrays[key] = true
      })
    
      ;[].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
        flags.bools[key] = true
      })
    
      ;[].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true
      })
    
      ;[].concat(opts.count).filter(Boolean).forEach(function (key) {
        flags.counts[key] = true
      })
    
      ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {
        flags.normalize[key] = true
      })
    
      ;[].concat(opts.config).filter(Boolean).forEach(function (key) {
        flags.configs[key] = true
      })
    
      var aliases = {}
      var newAliases = {}
    
      extendAliases(opts.key)
      extendAliases(opts.alias)
    
      var defaults = opts['default'] || {}
      Object.keys(defaults).forEach(function (key) {
        if (/-/.test(key) && !opts.alias[key]) {
          aliases[key] = aliases[key] || []
        }
        (aliases[key] || []).forEach(function (alias) {
          defaults[alias] = defaults[key]
        })
      })
    
      var argv = { _: [] }
    
      Object.keys(flags.bools).forEach(function (key) {
        setArg(key, !(key in defaults) ? false : defaults[key])
        setDefaulted(key)
      })
    
      var notFlags = []
      if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--') + 1)
        args = args.slice(0, args.indexOf('--'))
      }
    
      for (var i = 0; i < args.length; i++) {
        var arg = args[i]
        var broken
        var key
        var letters
        var m
        var next
        var value
    
        // -- seperated by =
        if (arg.match(/^--.+=/)) {
          // Using [\s\S] instead of . because js doesn't support the
          // 'dotall' regex modifier. See:
          // http://stackoverflow.com/a/1068308/13216
          m = arg.match(/^--([^=]+)=([\s\S]*)$/)
    
          // nargs format = '--f=monkey washing cat'
          if (checkAllAliases(m[1], opts.narg)) {
            args.splice(i + 1, m[1], m[2])
            i = eatNargs(i, m[1], args)
          // arrays format = '--f=a b c'
          } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {
            args.splice(i + 1, m[1], m[2])
            i = eatArray(i, m[1], args)
          } else {
            setArg(m[1], m[2])
          }
        } else if (arg.match(/^--no-.+/)) {
          key = arg.match(/^--no-(.+)/)[1]
          setArg(key, false)
    
        // -- seperated by space.
        } else if (arg.match(/^--.+/)) {
          key = arg.match(/^--(.+)/)[1]
    
          // nargs format = '--foo a b c'
          if (checkAllAliases(key, opts.narg)) {
            i = eatNargs(i, key, args)
          // array format = '--foo a b c'
          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
            i = eatArray(i, key, args)
          } else {
            next = args[i + 1]
    
            if (next !== undefined && !next.match(/^-/) &&
              !checkAllAliases(key, flags.bools) &&
              !checkAllAliases(key, flags.counts)) {
              setArg(key, next)
              i++
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next)
              i++
            } else {
              setArg(key, defaultForType(guessType(key, flags)))
            }
          }
    
        // dot-notation flag seperated by '='.
        } else if (arg.match(/^-.\..+=/)) {
          m = arg.match(/^-([^=]+)=([\s\S]*)$/)
          setArg(m[1], m[2])
    
        // dot-notation flag seperated by space.
        } else if (arg.match(/^-.\..+/)) {
          next = args[i + 1]
          key = arg.match(/^-(.\..+)/)[1]
    
          if (next !== undefined && !next.match(/^-/) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)) {
            setArg(key, next)
            i++
          } else {
            setArg(key, defaultForType(guessType(key, flags)))
          }
        } else if (arg.match(/^-[^-]+/)) {
          letters = arg.slice(1, -1).split('')
          broken = false
    
          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2)
    
            if (letters[j + 1] && letters[j + 1] === '=') {
              value = arg.slice(j + 3)
              key = letters[j]
    
              // nargs format = '-f=monkey washing cat'
              if (checkAllAliases(letters[j], opts.narg)) {
                args.splice(i + 1, 0, value)
                i = eatNargs(i, key, args)
              // array format = '-f=a b c'
              } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
                args.splice(i + 1, 0, value)
                i = eatArray(i, key, args)
              } else {
                setArg(key, value)
              }
    
              broken = true
              break
            }
    
            if (next === '-') {
              setArg(letters[j], next)
              continue
            }
    
            if (/[A-Za-z]/.test(letters[j]) &&
              /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next)
              broken = true
              break
            }
    
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2))
              broken = true
              break
            } else {
              setArg(letters[j], defaultForType(guessType(letters[j], flags)))
            }
          }
    
          key = arg.slice(-1)[0]
    
          if (!broken && key !== '-') {
            // nargs format = '-f a b c'
            if (checkAllAliases(key, opts.narg)) {
              i = eatNargs(i, key, args)
            // array format = '-f a b c'
            } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
              i = eatArray(i, key, args)
            } else {
              if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) &&
                !checkAllAliases(key, flags.bools) &&
                !checkAllAliases(key, flags.counts)) {
                setArg(key, args[i + 1])
                i++
              } else if (args[i + 1] && /true|false/.test(args[i + 1])) {
                setArg(key, args[i + 1])
                i++
              } else {
                setArg(key, defaultForType(guessType(key, flags)))
              }
            }
          }
        } else {
          argv._.push(
            flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
          )
        }
      }
    
      setConfig(argv)
      applyDefaultsAndAliases(argv, aliases, defaults)
    
      Object.keys(flags.counts).forEach(function (key) {
        setArg(key, defaults[key])
      })
    
      notFlags.forEach(function (key) {
        argv._.push(key)
      })
    
      // how many arguments should we consume, based
      // on the nargs option?
      function eatNargs (i, key, args) {
        var toEat = checkAllAliases(key, opts.narg)
    
        if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key))
    
        for (var ii = i + 1; ii < (toEat + i + 1); ii++) {
          setArg(key, args[ii])
        }
    
        return (i + toEat)
      }
    
      // if an option is an array, eat all non-hyphenated arguments
      // following it... YUM!
      // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
      function eatArray (i, key, args) {
        for (var ii = i + 1; ii < args.length; ii++) {
          if (/^-/.test(args[ii])) break
          i = ii
          setArg(key, args[ii])
        }
    
        return i
      }
    
      function setArg (key, val) {
        unsetDefaulted(key)
    
        // handle parsing boolean arguments --foo=true --bar false.
        if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
          if (typeof val === 'string') val = val === 'true'
        }
    
        if (/-/.test(key) && !(aliases[key] && aliases[key].length)) {
          var c = camelCase(key)
          aliases[key] = [c]
          newAliases[c] = true
        }
    
        var value = !checkAllAliases(key, flags.strings) && isNumber(val) ? Number(val) : val
    
        if (checkAllAliases(key, flags.counts)) {
          value = increment
        }
    
        var splitKey = key.split('.')
        setKey(argv, splitKey, value)
    
        ;(aliases[splitKey[0]] || []).forEach(function (x) {
          x = x.split('.')
    
          // handle populating dot notation for both
          // the key and its aliases.
          if (splitKey.length > 1) {
            var a = [].concat(splitKey)
            a.shift() // nuke the old key.
            x = x.concat(a)
          }
    
          setKey(argv, x, value)
        })
    
        var keys = [key].concat(aliases[key] || [])
        for (var i = 0, l = keys.length; i < l; i++) {
          if (flags.normalize[keys[i]]) {
            keys.forEach(function (key) {
              argv.__defineSetter__(key, function (v) {
                val = path.normalize(v)
              })
    
              argv.__defineGetter__(key, function () {
                return typeof val === 'string' ? path.normalize(val) : val
              })
            })
            break
          }
        }
      }
    
      // set args from config.json file, this should be
      // applied last so that defaults can be applied.
      function setConfig (argv) {
        var configLookup = {}
    
        // expand defaults/aliases, in-case any happen to reference
        // the config.json file.
        applyDefaultsAndAliases(configLookup, aliases, defaults)
    
        Object.keys(flags.configs).forEach(function (configKey) {
          var configPath = argv[configKey] || configLookup[configKey]
          if (configPath) {
            try {
              var config = require(path.resolve(process.cwd(), configPath))
    
              Object.keys(config).forEach(function (key) {
                // setting arguments via CLI takes precedence over
                // values within the config file.
                if (argv[key] === undefined || (flags.defaulted[key])) {
                  delete argv[key]
                  setArg(key, config[key])
                }
              })
            } catch (ex) {
              if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))
            }
          }
        })
      }
    
      function applyDefaultsAndAliases (obj, aliases, defaults) {
        Object.keys(defaults).forEach(function (key) {
          if (!hasKey(obj, key.split('.'))) {
            setKey(obj, key.split('.'), defaults[key])
    
            ;(aliases[key] || []).forEach(function (x) {
              setKey(obj, x.split('.'), defaults[key])
            })
          }
        })
      }
    
      function hasKey (obj, keys) {
        var o = obj
        keys.slice(0, -1).forEach(function (key) {
          o = (o[key] || {})
        })
    
        var key = keys[keys.length - 1]
        return key in o
      }
    
      function setKey (obj, keys, value) {
        var o = obj
        keys.slice(0, -1).forEach(function (key) {
          if (o[key] === undefined) o[key] = {}
          o = o[key]
        })
    
        var key = keys[keys.length - 1]
        if (value === increment) {
          o[key] = increment(o[key])
        } else if (o[key] === undefined && checkAllAliases(key, flags.arrays)) {
          o[key] = Array.isArray(value) ? value : [value]
        } else if (o[key] === undefined || typeof o[key] === 'boolean') {
          o[key] = value
        } else if (Array.isArray(o[key])) {
          o[key].push(value)
        } else {
          o[key] = [ o[key], value ]
        }
      }
    
      // extend the aliases list with inferred aliases.
      function extendAliases (obj) {
        Object.keys(obj || {}).forEach(function (key) {
          aliases[key] = [].concat(opts.alias[key] || [])
          // For "--option-name", also set argv.optionName
          aliases[key].concat(key).forEach(function (x) {
            if (/-/.test(x)) {
              var c = camelCase(x)
              aliases[key].push(c)
              newAliases[c] = true
            }
          })
          aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
              return x !== y
            }))
          })
        })
      }
    
      // check if a flag is set for any of a key's aliases.
      function checkAllAliases (key, flag) {
        var isSet = false
        var toCheck = [].concat(aliases[key] || [], key)
    
        toCheck.forEach(function (key) {
          if (flag[key]) isSet = flag[key]
        })
    
        return isSet
      }
    
      function setDefaulted (key) {
        [].concat(aliases[key] || [], key).forEach(function (k) {
          flags.defaulted[k] = true
        })
      }
    
      function unsetDefaulted (key) {
        [].concat(aliases[key] || [], key).forEach(function (k) {
          delete flags.defaulted[k]
        })
      }
    
      // return a default value, given the type of a flag.,
      // e.g., key of type 'string' will default to '', rather than 'true'.
      function defaultForType (type) {
        var def = {
          boolean: true,
          string: '',
          array: []
        }
    
        return def[type]
      }
    
      // given a flag, enforce a default type.
      function guessType (key, flags) {
        var type = 'boolean'
    
        if (flags.strings && flags.strings[key]) type = 'string'
        else if (flags.arrays && flags.arrays[key]) type = 'array'
    
        return type
      }
    
      function isNumber (x) {
        if (typeof x === 'number') return true
        if (/^0x[0-9a-f]+$/i.test(x)) return true
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
      }
    
      return {
        argv: argv,
        aliases: aliases,
        error: error,
        newAliases: newAliases
      }
    }
    
  provide("yargs/lib/parser", module.exports);
}(global));

// pakmanager:yargs/lib/usage
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // this file handles outputting usage instructions,
    // failures, etc. keeps logging in one place.
    var cliui = require('cliui')
    var decamelize = require('decamelize')
    var wsize = require('window-size')
    
    module.exports = function (yargs, y18n) {
      var __ = y18n.__
      var self = {}
    
      // methods for ouputting/building failure message.
      var fails = []
      self.failFn = function (f) {
        fails.push(f)
      }
    
      var failMessage = null
      var showHelpOnFail = true
      self.showHelpOnFail = function (enabled, message) {
        if (typeof enabled === 'string') {
          message = enabled
          enabled = true
        } else if (typeof enabled === 'undefined') {
          enabled = true
        }
        failMessage = message
        showHelpOnFail = enabled
        return self
      }
    
      self.fail = function (msg) {
        if (fails.length) {
          fails.forEach(function (f) {
            f(msg)
          })
        } else {
          if (showHelpOnFail) yargs.showHelp('error')
          if (msg) console.error(msg)
          if (failMessage) {
            if (msg) console.error('')
            console.error(failMessage)
          }
          if (yargs.getExitProcess()) {
            process.exit(1)
          } else {
            throw new Error(msg)
          }
        }
      }
    
      // methods for ouputting/building help (usage) message.
      var usage
      self.usage = function (msg) {
        usage = msg
      }
    
      var examples = []
      self.example = function (cmd, description) {
        examples.push([cmd, description || ''])
      }
    
      var commands = []
      self.command = function (cmd, description) {
        commands.push([cmd, description || ''])
      }
      self.getCommands = function () {
        return commands
      }
    
      var descriptions = {}
      self.describe = function (key, desc) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.describe(k, key[k])
          })
        } else {
          descriptions[key] = desc
        }
      }
      self.getDescriptions = function () {
        return descriptions
      }
    
      var epilog
      self.epilog = function (msg) {
        epilog = msg
      }
    
      var wrap = windowWidth()
      self.wrap = function (cols) {
        wrap = cols
      }
    
      var deferY18nLookupPrefix = '__yargsString__:'
      self.deferY18nLookup = function (str) {
        return deferY18nLookupPrefix + str
      }
    
      self.help = function () {
        normalizeAliases()
    
        var demanded = yargs.getDemanded()
        var options = yargs.getOptions()
        var keys = Object.keys(
          Object.keys(descriptions)
          .concat(Object.keys(demanded))
          .concat(Object.keys(options.default))
          .reduce(function (acc, key) {
            if (key !== '_') acc[key] = true
            return acc
          }, {})
        )
        var ui = cliui({
          width: wrap,
          wrap: !!wrap
        })
    
        // the usage string.
        if (usage) {
          var u = usage.replace(/\$0/g, yargs.$0)
          ui.div(u + '\n')
        }
    
        // your application's commands, i.e., non-option
        // arguments populated in '_'.
        if (commands.length) {
          ui.div(__('Commands:'))
    
          commands.forEach(function (command) {
            ui.div(
              {text: command[0], padding: [0, 2, 0, 2], width: maxWidth(commands) + 4},
              {text: command[1]}
            )
          })
    
          ui.div()
        }
    
        // the options table.
        var aliasKeys = (Object.keys(options.alias) || [])
          .concat(Object.keys(yargs.parsed.newAliases) || [])
    
        keys = keys.filter(function (key) {
          return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) {
            return (options.alias[alias] || []).indexOf(key) === -1
          })
        })
    
        var switches = keys.reduce(function (acc, key) {
          acc[key] = [ key ].concat(options.alias[key] || [])
          .map(function (sw) {
            return (sw.length > 1 ? '--' : '-') + sw
          })
          .join(', ')
    
          return acc
        }, {})
    
        if (keys.length) {
          ui.div(__('Options:'))
    
          keys.forEach(function (key) {
            var kswitch = switches[key]
            var desc = descriptions[key] || ''
            var type = null
    
            if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length))
    
            if (~options.boolean.indexOf(key)) type = '[' + __('boolean') + ']'
            if (~options.count.indexOf(key)) type = '[' + __('count') + ']'
            if (~options.string.indexOf(key)) type = '[' + __('string') + ']'
            if (~options.normalize.indexOf(key)) type = '[' + __('string') + ']'
            if (~options.array.indexOf(key)) type = '[' + __('array') + ']'
    
            var extra = [
              type,
              demanded[key] ? '[' + __('required') + ']' : null,
              options.choices && options.choices[key] ? '[' + __('choices:') + ' ' +
                self.stringifiedValues(options.choices[key]) + ']' : null,
              defaultString(options.default[key], options.defaultDescription[key])
            ].filter(Boolean).join(' ')
    
            ui.span(
              {text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches) + 4},
              desc
            )
    
            if (extra) ui.div({text: extra, padding: [0, 0, 0, 2], align: 'right'})
            else ui.div()
          })
    
          ui.div()
        }
    
        // describe some common use-cases for your application.
        if (examples.length) {
          ui.div(__('Examples:'))
    
          examples.forEach(function (example) {
            example[0] = example[0].replace(/\$0/g, yargs.$0)
          })
    
          examples.forEach(function (example) {
            ui.div(
              {text: example[0], padding: [0, 2, 0, 2], width: maxWidth(examples) + 4},
              example[1]
            )
          })
    
          ui.div()
        }
    
        // the usage string.
        if (epilog) {
          var e = epilog.replace(/\$0/g, yargs.$0)
          ui.div(e + '\n')
        }
    
        return ui.toString()
      }
    
      // return the maximum width of a string
      // in the left-hand column of a table.
      function maxWidth (table) {
        var width = 0
    
        // table might be of the form [leftColumn],
        // or {key: leftColumn}}
        if (!Array.isArray(table)) {
          table = Object.keys(table).map(function (key) {
            return [table[key]]
          })
        }
    
        table.forEach(function (v) {
          width = Math.max(v[0].length, width)
        })
    
        // if we've enabled 'wrap' we should limit
        // the max-width of the left-column.
        if (wrap) width = Math.min(width, parseInt(wrap * 0.5, 10))
    
        return width
      }
    
      // make sure any options set for aliases,
      // are copied to the keys being aliased.
      function normalizeAliases () {
        var demanded = yargs.getDemanded()
        var options = yargs.getOptions()
    
        ;(Object.keys(options.alias) || []).forEach(function (key) {
          options.alias[key].forEach(function (alias) {
            // copy descriptions.
            if (descriptions[alias]) self.describe(key, descriptions[alias])
            // copy demanded.
            if (demanded[alias]) yargs.demand(key, demanded[alias].msg)
    
            // type messages.
            if (~options.boolean.indexOf(alias)) yargs.boolean(key)
            if (~options.count.indexOf(alias)) yargs.count(key)
            if (~options.string.indexOf(alias)) yargs.string(key)
            if (~options.normalize.indexOf(alias)) yargs.normalize(key)
            if (~options.array.indexOf(alias)) yargs.array(key)
          })
        })
      }
    
      self.showHelp = function (level) {
        level = level || 'error'
        console[level](self.help())
      }
    
      self.functionDescription = function (fn) {
        var description = fn.name ? decamelize(fn.name, '-') : __('generated-value')
        return ['(', description, ')'].join('')
      }
    
      self.stringifiedValues = function (values, separator) {
        var string = ''
        var sep = separator || ', '
        var array = [].concat(values)
    
        if (!values || !array.length) return string
    
        array.forEach(function (value) {
          if (string.length) string += sep
          string += JSON.stringify(value)
        })
    
        return string
      }
    
      // format the default-value-string displayed in
      // the right-hand column.
      function defaultString (value, defaultDescription) {
        var string = '[' + __('default:') + ' '
    
        if (value === undefined && !defaultDescription) return null
    
        if (defaultDescription) {
          string += defaultDescription
        } else {
          switch (typeof value) {
            case 'string':
              string += JSON.stringify(value)
              break
            case 'object':
              string += JSON.stringify(value)
              break
            default:
              string += value
          }
        }
    
        return string + ']'
      }
    
      // guess the width of the console window, max-width 80.
      function windowWidth () {
        return wsize.width ? Math.min(80, wsize.width) : null
      }
    
      // logic for displaying application version.
      var version = null
      self.version = function (ver, opt, msg) {
        version = ver
      }
    
      self.showVersion = function () {
        if (typeof version === 'function') console.log(version())
        else console.log(version)
      }
    
      return self
    }
    
  provide("yargs/lib/usage", module.exports);
}(global));

// pakmanager:yargs/lib/validation
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // validation-type-stuff, missing params,
    // bad implications, custom checks.
    module.exports = function (yargs, usage, y18n) {
      var __ = y18n.__
      var __n = y18n.__n
      var self = {}
    
      // validate appropriate # of non-option
      // arguments were provided, i.e., '_'.
      self.nonOptionCount = function (argv) {
        var demanded = yargs.getDemanded()
        var _s = argv._.length
    
        if (demanded._ && (_s < demanded._.count || _s > demanded._.max)) {
          if (demanded._.msg !== undefined) {
            usage.fail(demanded._.msg)
          } else if (_s < demanded._.count) {
            usage.fail(
              __('Not enough non-option arguments: got %s, need at least %s', argv._.length, demanded._.count)
            )
          } else {
            usage.fail(
              __('Too many non-option arguments: got %s, maximum of %s', argv._.length, demanded._.max)
            )
          }
        }
      }
    
      // make sure that any args that require an
      // value (--foo=bar), have a value.
      self.missingArgumentValue = function (argv) {
        var defaultValues = [true, false, '']
        var options = yargs.getOptions()
    
        if (options.requiresArg.length > 0) {
          var missingRequiredArgs = []
    
          options.requiresArg.forEach(function (key) {
            var value = argv[key]
    
            // if a value is explicitly requested,
            // flag argument as missing if it does not
            // look like foo=bar was entered.
            if (~defaultValues.indexOf(value) ||
              (Array.isArray(value) && !value.length)) {
              missingRequiredArgs.push(key)
            }
          })
    
          if (missingRequiredArgs.length > 0) {
            usage.fail(__n(
              'Missing argument value: %s',
              'Missing argument values: %s',
              missingRequiredArgs.length,
              missingRequiredArgs.join(', ')
            ))
          }
        }
      }
    
      // make sure all the required arguments are present.
      self.requiredArguments = function (argv) {
        var demanded = yargs.getDemanded()
        var missing = null
    
        Object.keys(demanded).forEach(function (key) {
          if (!argv.hasOwnProperty(key)) {
            missing = missing || {}
            missing[key] = demanded[key]
          }
        })
    
        if (missing) {
          var customMsgs = []
          Object.keys(missing).forEach(function (key) {
            var msg = missing[key].msg
            if (msg && customMsgs.indexOf(msg) < 0) {
              customMsgs.push(msg)
            }
          })
    
          var customMsg = customMsgs.length ? '\n' + customMsgs.join('\n') : ''
    
          usage.fail(__n(
            'Missing required argument: %s',
            'Missing required arguments: %s',
            Object.keys(missing).length,
            Object.keys(missing).join(', ') + customMsg
          ))
        }
      }
    
      // check for unknown arguments (strict-mode).
      self.unknownArguments = function (argv, aliases) {
        var aliasLookup = {}
        var descriptions = usage.getDescriptions()
        var demanded = yargs.getDemanded()
        var unknown = []
    
        Object.keys(aliases).forEach(function (key) {
          aliases[key].forEach(function (alias) {
            aliasLookup[alias] = key
          })
        })
    
        Object.keys(argv).forEach(function (key) {
          if (key !== '$0' && key !== '_' &&
            !descriptions.hasOwnProperty(key) &&
            !demanded.hasOwnProperty(key) &&
            !aliasLookup.hasOwnProperty(key)) {
            unknown.push(key)
          }
        })
    
        if (unknown.length > 0) {
          usage.fail(__n(
            'Unknown argument: %s',
            'Unknown arguments: %s',
            unknown.length,
            unknown.join(', ')
          ))
        }
      }
    
      // validate arguments limited to enumerated choices
      self.limitedChoices = function (argv) {
        var options = yargs.getOptions()
        var invalid = {}
    
        if (!Object.keys(options.choices).length) return
    
        Object.keys(argv).forEach(function (key) {
          if (key !== '$0' && key !== '_' &&
            options.choices.hasOwnProperty(key)) {
            [].concat(argv[key]).forEach(function (value) {
              // TODO case-insensitive configurability
              if (options.choices[key].indexOf(value) === -1) {
                invalid[key] = (invalid[key] || []).concat(value)
              }
            })
          }
        })
    
        var invalidKeys = Object.keys(invalid)
    
        if (!invalidKeys.length) return
    
        var msg = __('Invalid values:')
        invalidKeys.forEach(function (key) {
          msg += '\n  ' + __(
            'Argument: %s, Given: %s, Choices: %s',
            key,
            usage.stringifiedValues(invalid[key]),
            usage.stringifiedValues(options.choices[key])
          )
        })
        usage.fail(msg)
      }
    
      // custom checks, added using the `check` option on yargs.
      var checks = []
      self.check = function (f) {
        checks.push(f)
      }
    
      self.customChecks = function (argv, aliases) {
        checks.forEach(function (f) {
          try {
            var result = f(argv, aliases)
            if (!result) {
              usage.fail(__('Argument check failed: %s', f.toString()))
            } else if (typeof result === 'string') {
              usage.fail(result)
            }
          } catch (err) {
            usage.fail(err.message ? err.message : err)
          }
        })
      }
    
      // check implications, argument foo implies => argument bar.
      var implied = {}
      self.implies = function (key, value) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.implies(k, key[k])
          })
        } else {
          implied[key] = value
        }
      }
      self.getImplied = function () {
        return implied
      }
    
      self.implications = function (argv) {
        var implyFail = []
    
        Object.keys(implied).forEach(function (key) {
          var num
          var origKey = key
          var value = implied[key]
    
          // convert string '1' to number 1
          num = Number(key)
          key = isNaN(num) ? key : num
    
          if (typeof key === 'number') {
            // check length of argv._
            key = argv._.length >= key
          } else if (key.match(/^--no-.+/)) {
            // check if key doesn't exist
            key = key.match(/^--no-(.+)/)[1]
            key = !argv[key]
          } else {
            // check if key exists
            key = argv[key]
          }
    
          num = Number(value)
          value = isNaN(num) ? value : num
    
          if (typeof value === 'number') {
            value = argv._.length >= value
          } else if (value.match(/^--no-.+/)) {
            value = value.match(/^--no-(.+)/)[1]
            value = !argv[value]
          } else {
            value = argv[value]
          }
    
          if (key && !value) {
            implyFail.push(origKey)
          }
        })
    
        if (implyFail.length) {
          var msg = __('Implications failed:') + '\n'
    
          implyFail.forEach(function (key) {
            msg += ('  ' + key + ' -> ' + implied[key])
          })
    
          usage.fail(msg)
        }
      }
    
      return self
    }
    
  provide("yargs/lib/validation", module.exports);
}(global));

// pakmanager:yargs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var assert = require('assert')
    var Completion =  require('yargs/lib/completion')
    var Parser =  require('yargs/lib/parser')
    var path = require('path')
    var Usage =  require('yargs/lib/usage')
    var Validation =  require('yargs/lib/validation')
    var Y18n = require('y18n')
    
    Argv(process.argv.slice(2))
    
    var exports = module.exports = Argv
    function Argv (processArgs, cwd) {
      processArgs = processArgs || [] // handle calling yargs().
    
      var self = {}
      var completion = null
      var usage = null
      var validation = null
      var y18n = Y18n({
        directory: path.resolve(__dirname, './locales'),
        updateFiles: false
      })
    
      if (!cwd) cwd = process.cwd()
    
      self.$0 = process.argv
        .slice(0, 2)
        .map(function (x, i) {
          // ignore the node bin, specify this in your
          // bin file with #!/usr/bin/env node
          if (i === 0 && /\b(node|iojs)$/.test(x)) return
          var b = rebase(cwd, x)
          return x.match(/^\//) && b.length < x.length ? b : x
        })
        .join(' ').trim()
    
      if (process.env._ !== undefined && process.argv[1] === process.env._) {
        self.$0 = process.env._.replace(
          path.dirname(process.execPath) + '/', ''
        )
      }
    
      var options
      self.resetOptions = self.reset = function () {
        // put yargs back into its initial
        // state, this is useful for creating a
        // nested CLI.
        options = {
          array: [],
          boolean: [],
          string: [],
          narg: {},
          key: {},
          alias: {},
          default: {},
          defaultDescription: {},
          choices: {},
          requiresArg: [],
          count: [],
          normalize: [],
          config: []
        }
    
        usage = Usage(self, y18n) // handle usage output.
        validation = Validation(self, usage, y18n) // handle arg validation.
        completion = Completion(self, usage)
    
        demanded = {}
    
        exitProcess = true
        strict = false
        helpOpt = null
        versionOpt = null
        commandHandlers = {}
        self.parsed = false
    
        return self
      }
      self.resetOptions()
    
      self.boolean = function (bools) {
        options.boolean.push.apply(options.boolean, [].concat(bools))
        return self
      }
    
      self.array = function (arrays) {
        options.array.push.apply(options.array, [].concat(arrays))
        return self
      }
    
      self.nargs = function (key, n) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.nargs(k, key[k])
          })
        } else {
          options.narg[key] = n
        }
        return self
      }
    
      self.choices = function (key, values) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.choices(k, key[k])
          })
        } else {
          options.choices[key] = (options.choices[key] || []).concat(values)
        }
        return self
      }
    
      self.normalize = function (strings) {
        options.normalize.push.apply(options.normalize, [].concat(strings))
        return self
      }
    
      self.config = function (key, msg) {
        self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'))
        options.config.push.apply(options.config, [].concat(key))
        return self
      }
    
      self.example = function (cmd, description) {
        usage.example(cmd, description)
        return self
      }
    
      self.command = function (cmd, description, fn) {
        if (description !== false) {
          usage.command(cmd, description)
        }
        if (fn) commandHandlers[cmd] = fn
        return self
      }
    
      var commandHandlers = {}
      self.getCommandHandlers = function () {
        return commandHandlers
      }
    
      self.string = function (strings) {
        options.string.push.apply(options.string, [].concat(strings))
        return self
      }
    
      self.default = function (key, value, defaultDescription) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.default(k, key[k])
          })
        } else {
          if (defaultDescription) options.defaultDescription[key] = defaultDescription
          if (typeof value === 'function') {
            if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value)
            value = value.call()
          }
          options.default[key] = value
        }
        return self
      }
    
      self.alias = function (x, y) {
        if (typeof x === 'object') {
          Object.keys(x).forEach(function (key) {
            self.alias(key, x[key])
          })
        } else {
          options.alias[x] = (options.alias[x] || []).concat(y)
        }
        return self
      }
    
      self.count = function (counts) {
        options.count.push.apply(options.count, [].concat(counts))
        return self
      }
    
      var demanded = {}
      self.demand = self.required = self.require = function (keys, max, msg) {
        // you can optionally provide a 'max' key,
        // which will raise an exception if too many '_'
        // options are provided.
        if (typeof max !== 'number') {
          msg = max
          max = Infinity
        }
    
        if (typeof keys === 'number') {
          if (!demanded._) demanded._ = { count: 0, msg: null, max: max }
          demanded._.count = keys
          demanded._.msg = msg
        } else if (Array.isArray(keys)) {
          keys.forEach(function (key) {
            self.demand(key, msg)
          })
        } else {
          if (typeof msg === 'string') {
            demanded[keys] = { msg: msg }
          } else if (msg === true || typeof msg === 'undefined') {
            demanded[keys] = { msg: undefined }
          }
        }
    
        return self
      }
      self.getDemanded = function () {
        return demanded
      }
    
      self.requiresArg = function (requiresArgs) {
        options.requiresArg.push.apply(options.requiresArg, [].concat(requiresArgs))
        return self
      }
    
      self.implies = function (key, value) {
        validation.implies(key, value)
        return self
      }
    
      self.usage = function (msg, opts) {
        if (!opts && typeof msg === 'object') {
          opts = msg
          msg = null
        }
    
        usage.usage(msg)
    
        if (opts) self.options(opts)
    
        return self
      }
    
      self.epilogue = self.epilog = function (msg) {
        usage.epilog(msg)
        return self
      }
    
      self.fail = function (f) {
        usage.failFn(f)
        return self
      }
    
      self.check = function (f) {
        validation.check(f)
        return self
      }
    
      self.defaults = self.default
    
      self.describe = function (key, desc) {
        options.key[key] = true
        usage.describe(key, desc)
        return self
      }
    
      self.parse = function (args) {
        return parseArgs(args)
      }
    
      self.option = self.options = function (key, opt) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.options(k, key[k])
          })
        } else {
          assert(typeof opt === 'object', 'second argument to option must be an object')
    
          options.key[key] = true // track manually set keys.
    
          if (opt.alias) self.alias(key, opt.alias)
    
          var demand = opt.demand || opt.required || opt.require
    
          if (demand) {
            self.demand(key, demand)
          } if ('config' in opt) {
            self.config(key)
          } if ('default' in opt) {
            self.default(key, opt.default)
          } if ('nargs' in opt) {
            self.nargs(key, opt.nargs)
          } if ('choices' in opt) {
            self.choices(key, opt.choices)
          } if (opt.boolean || opt.type === 'boolean') {
            self.boolean(key)
            if (opt.alias) self.boolean(opt.alias)
          } if (opt.array || opt.type === 'array') {
            self.array(key)
            if (opt.alias) self.array(opt.alias)
          } if (opt.string || opt.type === 'string') {
            self.string(key)
            if (opt.alias) self.string(opt.alias)
          } if (opt.count || opt.type === 'count') {
            self.count(key)
          } if (opt.defaultDescription) {
            options.defaultDescription[key] = opt.defaultDescription
          }
    
          var desc = opt.describe || opt.description || opt.desc
          if (desc) {
            self.describe(key, desc)
          }
    
          if (opt.requiresArg) {
            self.requiresArg(key)
          }
        }
    
        return self
      }
      self.getOptions = function () {
        return options
      }
    
      self.wrap = function (cols) {
        usage.wrap(cols)
        return self
      }
    
      var strict = false
      self.strict = function () {
        strict = true
        return self
      }
      self.getStrict = function () {
        return strict
      }
    
      self.showHelp = function (level) {
        if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.
        usage.showHelp(level)
        return self
      }
    
      var versionOpt = null
      self.version = function (ver, opt, msg) {
        versionOpt = opt || 'version'
        usage.version(ver)
        self.boolean(versionOpt)
        self.describe(versionOpt, msg || usage.deferY18nLookup('Show version number'))
        return self
      }
    
      var helpOpt = null
      self.addHelpOpt = function (opt, msg) {
        helpOpt = opt
        self.boolean(opt)
        self.describe(opt, msg || usage.deferY18nLookup('Show help'))
        return self
      }
    
      self.showHelpOnFail = function (enabled, message) {
        usage.showHelpOnFail(enabled, message)
        return self
      }
    
      var exitProcess = true
      self.exitProcess = function (enabled) {
        if (typeof enabled !== 'boolean') {
          enabled = true
        }
        exitProcess = enabled
        return self
      }
      self.getExitProcess = function () {
        return exitProcess
      }
    
      self.help = function () {
        if (arguments.length > 0) return self.addHelpOpt.apply(self, arguments)
    
        if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.
    
        return usage.help()
      }
    
      var completionCommand = null
      self.completion = function (cmd, desc, fn) {
        // a function to execute when generating
        // completions can be provided as the second
        // or third argument to completion.
        if (typeof desc === 'function') {
          fn = desc
          desc = null
        }
    
        // register the completion command.
        completionCommand = cmd || 'completion'
        if (!desc && desc !== false) {
          desc = 'generate bash completion script'
        }
        self.command(completionCommand, desc)
    
        // a function can be provided
        if (fn) completion.registerFunction(fn)
    
        return self
      }
    
      self.showCompletionScript = function ($0) {
        $0 = $0 || self.$0
        console.log(completion.generateCompletionScript($0))
        return self
      }
    
      self.locale = function (locale) {
        if (arguments.length === 0) {
          guessLocale()
          return y18n.getLocale()
        }
        detectLocale = false
        y18n.setLocale(locale)
        return self
      }
    
      self.updateStrings = self.updateLocale = function (obj) {
        detectLocale = false
        y18n.updateLocale(obj)
        return self
      }
    
      var detectLocale = true
      self.detectLocale = function (detect) {
        detectLocale = detect
        return self
      }
      self.getDetectLocale = function () {
        return detectLocale
      }
    
      self.getUsageInstance = function () {
        return usage
      }
    
      self.getValidationInstance = function () {
        return validation
      }
    
      self.terminalWidth = function () {
        return require('window-size').width
      }
    
      Object.defineProperty(self, 'argv', {
        get: function () {
          var args = null
    
          try {
            args = parseArgs(processArgs)
          } catch (err) {
            usage.fail(err.message)
          }
    
          return args
        },
        enumerable: true
      })
    
      function parseArgs (args) {
        var parsed = Parser(args, options, y18n)
        var argv = parsed.argv
        var aliases = parsed.aliases
    
        argv.$0 = self.$0
    
        self.parsed = parsed
    
        guessLocale() // guess locale lazily, so that it can be turned off in chain.
    
        // while building up the argv object, there
        // are two passes through the parser. If completion
        // is being performed short-circuit on the first pass.
        if (completionCommand &&
          (process.argv.join(' ')).indexOf(completion.completionKey) !== -1 &&
          !argv[completion.completionKey]) {
          return argv
        }
    
        // if there's a handler associated with a
        // command defer processing to it.
        var handlerKeys = Object.keys(self.getCommandHandlers())
        for (var i = 0, command; (command = handlerKeys[i]) !== undefined; i++) {
          if (~argv._.indexOf(command)) {
            self.getCommandHandlers()[command](self.reset())
            return self.argv
          }
        }
    
        // generate a completion script for adding to ~/.bashrc.
        if (completionCommand && ~argv._.indexOf(completionCommand) && !argv[completion.completionKey]) {
          self.showCompletionScript()
          if (exitProcess) {
            process.exit(0)
          }
        }
    
        // we must run completions first, a user might
        // want to complete the --help or --version option.
        if (completion.completionKey in argv) {
          // we allow for asynchronous completions,
          // e.g., loading in a list of commands from an API.
          completion.getCompletion(function (completions) {
            ;(completions || []).forEach(function (completion) {
              console.log(completion)
            })
    
            if (exitProcess) {
              process.exit(0)
            }
          })
          return
        }
    
        Object.keys(argv).forEach(function (key) {
          if (key === helpOpt && argv[key]) {
            self.showHelp('log')
            if (exitProcess) {
              process.exit(0)
            }
          } else if (key === versionOpt && argv[key]) {
            usage.showVersion()
            if (exitProcess) {
              process.exit(0)
            }
          }
        })
    
        if (parsed.error) throw parsed.error
    
        // if we're executed via bash completion, don't
        // bother with validation.
        if (!argv[completion.completionKey]) {
          validation.nonOptionCount(argv)
          validation.missingArgumentValue(argv)
          validation.requiredArguments(argv)
          if (strict) validation.unknownArguments(argv, aliases)
          validation.customChecks(argv, aliases)
          validation.limitedChoices(argv)
          validation.implications(argv)
        }
    
        setPlaceholderKeys(argv)
    
        return argv
      }
    
      function guessLocale () {
        if (!detectLocale) return
    
        try {
          var osLocale = require('os-locale')
          self.locale(osLocale.sync({ spawn: false }))
        } catch (err) {
          // if we explode looking up locale just noop
          // we'll keep using the default language 'en'.
        }
      }
    
      function setPlaceholderKeys (argv) {
        Object.keys(options.key).forEach(function (key) {
          if (typeof argv[key] === 'undefined') argv[key] = undefined
        })
      }
    
      sigletonify(self)
      return self
    }
    
    // rebase an absolute path to a relative one with respect to a base directory
    // exported for tests
    exports.rebase = rebase
    function rebase (base, dir) {
      return path.relative(base, dir)
    }
    
    /*  Hack an instance of Argv with process.argv into Argv
        so people can do
         require('yargs')(['--beeble=1','-z','zizzle']).argv
        to parse a list of args and
         require('yargs').argv
        to get a parsed version of process.argv.
    */
    function sigletonify (inst) {
      Object.keys(inst).forEach(function (key) {
        if (key === 'argv') {
          Argv.__defineGetter__(key, inst.__lookupGetter__(key))
        } else {
          Argv[key] = typeof inst[key] === 'function' ? inst[key].bind(inst) : inst[key]
        }
      })
    }
    
  provide("yargs", module.exports);
}(global));

// pakmanager:ndarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var iota = require("iota-array")
    var isBuffer = require("is-buffer")
    
    var hasTypedArrays  = ((typeof Float64Array) !== "undefined")
    
    function compare1st(a, b) {
      return a[0] - b[0]
    }
    
    function order() {
      var stride = this.stride
      var terms = new Array(stride.length)
      var i
      for(i=0; i<terms.length; ++i) {
        terms[i] = [Math.abs(stride[i]), i]
      }
      terms.sort(compare1st)
      var result = new Array(terms.length)
      for(i=0; i<result.length; ++i) {
        result[i] = terms[i][1]
      }
      return result
    }
    
    function compileConstructor(dtype, dimension) {
      var className = ["View", dimension, "d", dtype].join("")
      if(dimension < 0) {
        className = "View_Nil" + dtype
      }
      var useGetters = (dtype === "generic")
    
      if(dimension === -1) {
        //Special case for trivial arrays
        var code =
          "function "+className+"(a){this.data=a;};\
    var proto="+className+".prototype;\
    proto.dtype='"+dtype+"';\
    proto.index=function(){return -1};\
    proto.size=0;\
    proto.dimension=-1;\
    proto.shape=proto.stride=proto.order=[];\
    proto.lo=proto.hi=proto.transpose=proto.step=\
    function(){return new "+className+"(this.data);};\
    proto.get=proto.set=function(){};\
    proto.pick=function(){return null};\
    return function construct_"+className+"(a){return new "+className+"(a);}"
        var procedure = new Function(code)
        return procedure()
      } else if(dimension === 0) {
        //Special case for 0d arrays
        var code =
          "function "+className+"(a,d) {\
    this.data = a;\
    this.offset = d\
    };\
    var proto="+className+".prototype;\
    proto.dtype='"+dtype+"';\
    proto.index=function(){return this.offset};\
    proto.dimension=0;\
    proto.size=1;\
    proto.shape=\
    proto.stride=\
    proto.order=[];\
    proto.lo=\
    proto.hi=\
    proto.transpose=\
    proto.step=function "+className+"_copy() {\
    return new "+className+"(this.data,this.offset)\
    };\
    proto.pick=function "+className+"_pick(){\
    return TrivialArray(this.data);\
    };\
    proto.valueOf=proto.get=function "+className+"_get(){\
    return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
    "};\
    proto.set=function "+className+"_set(v){\
    return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
    };\
    return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
        var procedure = new Function("TrivialArray", code)
        return procedure(CACHED_CONSTRUCTORS[dtype][0])
      }
    
      var code = ["'use strict'"]
    
      //Create constructor for view
      var indices = iota(dimension)
      var args = indices.map(function(i) { return "i"+i })
      var index_str = "this.offset+" + indices.map(function(i) {
            return "this.stride[" + i + "]*i" + i
          }).join("+")
      var shapeArg = indices.map(function(i) {
          return "b"+i
        }).join(",")
      var strideArg = indices.map(function(i) {
          return "c"+i
        }).join(",")
      code.push(
        "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
          "this.shape=[" + shapeArg + "]",
          "this.stride=[" + strideArg + "]",
          "this.offset=d|0}",
        "var proto="+className+".prototype",
        "proto.dtype='"+dtype+"'",
        "proto.dimension="+dimension)
    
      //view.size:
      code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
    return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
    "}})")
    
      //view.order:
      if(dimension === 1) {
        code.push("proto.order=[0]")
      } else {
        code.push("Object.defineProperty(proto,'order',{get:")
        if(dimension < 4) {
          code.push("function "+className+"_order(){")
          if(dimension === 2) {
            code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
          } else if(dimension === 3) {
            code.push(
    "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
    if(s0>s1){\
    if(s1>s2){\
    return [2,1,0];\
    }else if(s0>s2){\
    return [1,2,0];\
    }else{\
    return [1,0,2];\
    }\
    }else if(s0>s2){\
    return [2,0,1];\
    }else if(s2>s1){\
    return [0,1,2];\
    }else{\
    return [0,2,1];\
    }}})")
          }
        } else {
          code.push("ORDER})")
        }
      }
    
      //view.set(i0, ..., v):
      code.push(
    "proto.set=function "+className+"_set("+args.join(",")+",v){")
      if(useGetters) {
        code.push("return this.data.set("+index_str+",v)}")
      } else {
        code.push("return this.data["+index_str+"]=v}")
      }
    
      //view.get(i0, ...):
      code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
      if(useGetters) {
        code.push("return this.data.get("+index_str+")}")
      } else {
        code.push("return this.data["+index_str+"]}")
      }
    
      //view.index:
      code.push(
        "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")
    
      //view.hi():
      code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
        indices.map(function(i) {
          return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
        }).join(",")+","+
        indices.map(function(i) {
          return "this.stride["+i + "]"
        }).join(",")+",this.offset)}")
    
      //view.lo():
      var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
      var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
      code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
      for(var i=0; i<dimension; ++i) {
        code.push(
    "if(typeof i"+i+"==='number'&&i"+i+">=0){\
    d=i"+i+"|0;\
    b+=c"+i+"*d;\
    a"+i+"-=d}")
      }
      code.push("return new "+className+"(this.data,"+
        indices.map(function(i) {
          return "a"+i
        }).join(",")+","+
        indices.map(function(i) {
          return "c"+i
        }).join(",")+",b)}")
    
      //view.step():
      code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
        indices.map(function(i) {
          return "a"+i+"=this.shape["+i+"]"
        }).join(",")+","+
        indices.map(function(i) {
          return "b"+i+"=this.stride["+i+"]"
        }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
      for(var i=0; i<dimension; ++i) {
        code.push(
    "if(typeof i"+i+"==='number'){\
    d=i"+i+"|0;\
    if(d<0){\
    c+=b"+i+"*(a"+i+"-1);\
    a"+i+"=ceil(-a"+i+"/d)\
    }else{\
    a"+i+"=ceil(a"+i+"/d)\
    }\
    b"+i+"*=d\
    }")
      }
      code.push("return new "+className+"(this.data,"+
        indices.map(function(i) {
          return "a" + i
        }).join(",")+","+
        indices.map(function(i) {
          return "b" + i
        }).join(",")+",c)}")
    
      //view.transpose():
      var tShape = new Array(dimension)
      var tStride = new Array(dimension)
      for(var i=0; i<dimension; ++i) {
        tShape[i] = "a[i"+i+"]"
        tStride[i] = "b[i"+i+"]"
      }
      code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
        args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
        "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")
    
      //view.pick():
      code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
      for(var i=0; i<dimension; ++i) {
        code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
      }
      code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")
    
      //Add return statement
      code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
        indices.map(function(i) {
          return "shape["+i+"]"
        }).join(",")+","+
        indices.map(function(i) {
          return "stride["+i+"]"
        }).join(",")+",offset)}")
    
      //Compile procedure
      var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
      return procedure(CACHED_CONSTRUCTORS[dtype], order)
    }
    
    function arrayDType(data) {
      if(isBuffer(data)) {
        return "buffer"
      }
      if(hasTypedArrays) {
        switch(Object.prototype.toString.call(data)) {
          case "[object Float64Array]":
            return "float64"
          case "[object Float32Array]":
            return "float32"
          case "[object Int8Array]":
            return "int8"
          case "[object Int16Array]":
            return "int16"
          case "[object Int32Array]":
            return "int32"
          case "[object Uint8Array]":
            return "uint8"
          case "[object Uint16Array]":
            return "uint16"
          case "[object Uint32Array]":
            return "uint32"
          case "[object Uint8ClampedArray]":
            return "uint8_clamped"
        }
      }
      if(Array.isArray(data)) {
        return "array"
      }
      return "generic"
    }
    
    var CACHED_CONSTRUCTORS = {
      "float32":[],
      "float64":[],
      "int8":[],
      "int16":[],
      "int32":[],
      "uint8":[],
      "uint16":[],
      "uint32":[],
      "array":[],
      "uint8_clamped":[],
      "buffer":[],
      "generic":[]
    }
    
    ;(function() {
      for(var id in CACHED_CONSTRUCTORS) {
        CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
      }
    });
    
    function wrappedNDArrayCtor(data, shape, stride, offset) {
      if(data === undefined) {
        var ctor = CACHED_CONSTRUCTORS.array[0]
        return ctor([])
      } else if(typeof data === "number") {
        data = [data]
      }
      if(shape === undefined) {
        shape = [ data.length ]
      }
      var d = shape.length
      if(stride === undefined) {
        stride = new Array(d)
        for(var i=d-1, sz=1; i>=0; --i) {
          stride[i] = sz
          sz *= shape[i]
        }
      }
      if(offset === undefined) {
        offset = 0
        for(var i=0; i<d; ++i) {
          if(stride[i] < 0) {
            offset -= (shape[i]-1)*stride[i]
          }
        }
      }
      var dtype = arrayDType(data)
      var ctor_list = CACHED_CONSTRUCTORS[dtype]
      while(ctor_list.length <= d+1) {
        ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
      }
      var ctor = ctor_list[d+1]
      return ctor(data, shape, stride, offset)
    }
    
    module.exports = wrappedNDArrayCtor
    
  provide("ndarray", module.exports);
}(global));

// pakmanager:cwise-compiler/lib/compile.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    var uniq = require("uniq")
    
    // This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
    // TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
    function innerFill(order, proc, body) {
      var dimension = order.length
        , nargs = proc.arrayArgs.length
        , has_index = proc.indexArgs.length>0
        , code = []
        , vars = []
        , idx=0, pidx=0, i, j
      for(i=0; i<dimension; ++i) { // Iteration variables
        vars.push(["i",i,"=0"].join(""))
      }
      //Compute scan deltas
      for(j=0; j<nargs; ++j) {
        for(i=0; i<dimension; ++i) {
          pidx = idx
          idx = order[i]
          if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
            vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
          } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
            vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
          }
        }
      }
      code.push("var " + vars.join(","))
      //Scan loop
      for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
        idx = order[i]
        code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
      }
      //Push body of inner loop
      code.push(body)
      //Advance scan pointers
      for(i=0; i<dimension; ++i) {
        pidx = idx
        idx = order[i]
        for(j=0; j<nargs; ++j) {
          code.push(["p",j,"+=d",j,"s",i].join(""))
        }
        if(has_index) {
          if(i > 0) {
            code.push(["index[",pidx,"]-=s",pidx].join(""))
          }
          code.push(["++index[",idx,"]"].join(""))
        }
        code.push("}")
      }
      return code.join("\n")
    }
    
    // Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
    // TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
    //       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
    function outerFill(matched, order, proc, body) {
      var dimension = order.length
        , nargs = proc.arrayArgs.length
        , blockSize = proc.blockSize
        , has_index = proc.indexArgs.length > 0
        , code = []
      for(var i=0; i<nargs; ++i) {
        code.push(["var offset",i,"=p",i].join(""))
      }
      //Generate loops for unmatched dimensions
      // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
      // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
      for(var i=matched; i<dimension; ++i) {
        code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
        code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
        code.push(["s",order[i],"=j",i].join(""))
        code.push(["j",i,"=0"].join(""))
        code.push(["}else{s",order[i],"=",blockSize].join(""))
        code.push(["j",i,"-=",blockSize,"}"].join(""))
        if(has_index) {
          code.push(["index[",order[i],"]=j",i].join(""))
        }
      }
      for(var i=0; i<nargs; ++i) {
        var indexStr = ["offset"+i]
        for(var j=matched; j<dimension; ++j) {
          indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
        }
        code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
      }
      code.push(innerFill(order, proc, body))
      for(var i=matched; i<dimension; ++i) {
        code.push("}")
      }
      return code.join("\n")
    }
    
    //Count the number of compatible inner orders
    // This is the length of the longest common prefix of the arrays in orders.
    // Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
    // This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
    function countMatches(orders) {
      var matched = 0, dimension = orders[0].length
      while(matched < dimension) {
        for(var j=1; j<orders.length; ++j) {
          if(orders[j][matched] !== orders[0][matched]) {
            return matched
          }
        }
        ++matched
      }
      return matched
    }
    
    //Processes a block according to the given data types
    // Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
    function processBlock(block, proc, dtypes) {
      var code = block.body
      var pre = []
      var post = []
      for(var i=0; i<block.args.length; ++i) {
        var carg = block.args[i]
        if(carg.count <= 0) {
          continue
        }
        var re = new RegExp(carg.name, "g")
        var ptrStr = ""
        var arrNum = proc.arrayArgs.indexOf(i)
        switch(proc.argTypes[i]) {
          case "offset":
            var offArgIndex = proc.offsetArgIndex.indexOf(i)
            var offArg = proc.offsetArgs[offArgIndex]
            arrNum = offArg.array
            ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
          case "array":
            ptrStr = "p" + arrNum + ptrStr
            var localStr = "l" + i
            var arrStr = "a" + arrNum
            if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
              if(carg.count === 1) { // Argument/array used only once(?)
                if(dtypes[arrNum] === "generic") {
                  if(carg.lvalue) {
                    pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                    code = code.replace(re, localStr)
                    post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
                  } else {
                    code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
                  }
                } else {
                  code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
                }
              } else if(dtypes[arrNum] === "generic") {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                code = code.replace(re, localStr)
                if(carg.lvalue) {
                  post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
                }
              } else {
                pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                code = code.replace(re, localStr)
                if(carg.lvalue) {
                  post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
                }
              }
            } else { // Argument to body is a "block"
              var reStrArr = [carg.name], ptrStrArr = [ptrStr]
              for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
                reStrArr.push("\\s*\\[([^\\]]+)\\]")
                ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
              }
              re = new RegExp(reStrArr.join(""), "g")
              ptrStr = ptrStrArr.join("+")
              if(dtypes[arrNum] === "generic") {
                /*if(carg.lvalue) {
                  pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                  code = code.replace(re, localStr)
                  post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
                } else {
                  code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
                }*/
                throw new Error("cwise: Generic arrays not supported in combination with blocks!")
              } else {
                // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
                code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
              }
            }
          break
          case "scalar":
            code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
          break
          case "index":
            code = code.replace(re, "index")
          break
          case "shape":
            code = code.replace(re, "shape")
          break
        }
      }
      return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
    }
    
    function typeSummary(dtypes) {
      var summary = new Array(dtypes.length)
      var allEqual = true
      for(var i=0; i<dtypes.length; ++i) {
        var t = dtypes[i]
        var digits = t.match(/\d+/)
        if(!digits) {
          digits = ""
        } else {
          digits = digits[0]
        }
        if(t.charAt(0) === 0) {
          summary[i] = "u" + t.charAt(1) + digits
        } else {
          summary[i] = t.charAt(0) + digits
        }
        if(i > 0) {
          allEqual = allEqual && summary[i] === summary[i-1]
        }
      }
      if(allEqual) {
        return summary[0]
      }
      return summary.join("")
    }
    
    //Generates a cwise operator
    function generateCWiseOp(proc, typesig) {
    
      //Compute dimension
      // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
      var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
      var orders = new Array(proc.arrayArgs.length)
      var dtypes = new Array(proc.arrayArgs.length)
      for(var i=0; i<proc.arrayArgs.length; ++i) {
        dtypes[i] = typesig[2*i]
        orders[i] = typesig[2*i+1]
      }
      
      //Determine where block and loop indices start and end
      var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
      var loopBegin = [], loopEnd = [] // These indices are iterated over
      var loopOrders = [] // orders restricted to the loop indices
      for(var i=0; i<proc.arrayArgs.length; ++i) {
        if (proc.arrayBlockIndices[i]<0) {
          loopBegin.push(0)
          loopEnd.push(dimension)
          blockBegin.push(dimension)
          blockEnd.push(dimension+proc.arrayBlockIndices[i])
        } else {
          loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
          loopEnd.push(proc.arrayBlockIndices[i]+dimension)
          blockBegin.push(0)
          blockEnd.push(proc.arrayBlockIndices[i])
        }
        var newOrder = []
        for(var j=0; j<orders[i].length; j++) {
          if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
            newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
          }
        }
        loopOrders.push(newOrder)
      }
    
      //First create arguments for procedure
      var arglist = ["SS"] // SS is the overall shape over which we iterate
      var code = ["'use strict'"]
      var vars = []
      
      for(var j=0; j<dimension; ++j) {
        vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
      }
      for(var i=0; i<proc.arrayArgs.length; ++i) {
        arglist.push("a"+i) // Actual data array
        arglist.push("t"+i) // Strides
        arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)
        
        for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
          vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
        }
        
        for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
          vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
        }
      }
      for(var i=0; i<proc.scalarArgs.length; ++i) {
        arglist.push("Y" + i)
      }
      if(proc.shapeArgs.length > 0) {
        vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
      }
      if(proc.indexArgs.length > 0) {
        // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
        var zeros = new Array(dimension)
        for(var i=0; i<dimension; ++i) {
          zeros[i] = "0"
        }
        vars.push(["index=[", zeros.join(","), "]"].join(""))
      }
      for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
        var off_arg = proc.offsetArgs[i]
        var init_string = []
        for(var j=0; j<off_arg.offset.length; ++j) {
          if(off_arg.offset[j] === 0) {
            continue
          } else if(off_arg.offset[j] === 1) {
            init_string.push(["t", off_arg.array, "p", j].join(""))      
          } else {
            init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
          }
        }
        if(init_string.length === 0) {
          vars.push("q" + i + "=0")
        } else {
          vars.push(["q", i, "=", init_string.join("+")].join(""))
        }
      }
    
      //Prepare this variables
      var thisVars = uniq([].concat(proc.pre.thisVars)
                          .concat(proc.body.thisVars)
                          .concat(proc.post.thisVars))
      vars = vars.concat(thisVars)
      code.push("var " + vars.join(","))
      for(var i=0; i<proc.arrayArgs.length; ++i) {
        code.push("p"+i+"|=0")
      }
      
      //Inline prelude
      if(proc.pre.body.length > 3) {
        code.push(processBlock(proc.pre, proc, dtypes))
      }
    
      //Process body
      var body = processBlock(proc.body, proc, dtypes)
      var matched = countMatches(loopOrders)
      if(matched < dimension) {
        code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
      } else {
        code.push(innerFill(loopOrders[0], proc, body))
      }
    
      //Inline epilog
      if(proc.post.body.length > 3) {
        code.push(processBlock(proc.post, proc, dtypes))
      }
      
      if(proc.debug) {
        console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
      }
      
      var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
      var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
      return f()
    }
    module.exports = generateCWiseOp
    
  provide("cwise-compiler/lib/compile.js", module.exports);
}(global));

// pakmanager:cwise-compiler/lib/thunk.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    // The function below is called when constructing a cwise function object, and does the following:
    // A function object is constructed which accepts as argument a compilation function and returns another function.
    // It is this other function that is eventually returned by createThunk, and this function is the one that actually
    // checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
    // The compilation passed to the first function object is used for compiling new functions.
    // Once this function object is created, it is called with compile as argument, where the first argument of compile
    // is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
    // So createThunk roughly works like this:
    // function createThunk(proc) {
    //   var thunk = function(compileBound) {
    //     var CACHED = {}
    //     return function(arrays and scalars) {
    //       if (dtype and order of arrays in CACHED) {
    //         var func = CACHED[dtype and order of arrays]
    //       } else {
    //         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
    //       }
    //       return func(arrays and scalars)
    //     }
    //   }
    //   return thunk(compile.bind1(proc))
    // }
    
    var compile =  require('cwise-compiler/lib/compile.js')
    
    function createThunk(proc) {
      var code = ["'use strict'", "var CACHED={}"]
      var vars = []
      var thunkName = proc.funcName + "_cwise_thunk"
      
      //Build thunk
      code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
      var typesig = []
      var string_typesig = []
      var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                        Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
      var shapeLengthConditions = [], shapeConditions = []
      // Process array arguments
      for(var i=0; i<proc.arrayArgs.length; ++i) {
        var j = proc.arrayArgs[i]
        vars.push(["t", j, "=array", j, ".dtype,",
                   "r", j, "=array", j, ".order"].join(""))
        typesig.push("t" + j)
        typesig.push("r" + j)
        string_typesig.push("t"+j)
        string_typesig.push("r"+j+".join()")
        proc_args.push("array" + j + ".data")
        proc_args.push("array" + j + ".stride")
        proc_args.push("array" + j + ".offset|0")
        if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
          shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
          shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
        }
      }
      // Check for shape equality
      if (proc.arrayArgs.length > 1) {
        code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
        code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
        code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
        code.push("}")
      }
      // Process scalar arguments
      for(var i=0; i<proc.scalarArgs.length; ++i) {
        proc_args.push("scalar" + proc.scalarArgs[i])
      }
      // Check for cached function (and if not present, generate it)
      vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
      vars.push("proc=CACHED[type]")
      code.push("var " + vars.join(","))
      
      code.push(["if(!proc){",
                 "CACHED[type]=proc=compile([", typesig.join(","), "])}",
                 "return proc(", proc_args.join(","), ")}"].join(""))
    
      if(proc.debug) {
        console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
      }
      
      //Compile thunk
      var thunk = new Function("compile", code.join("\n"))
      return thunk(compile.bind(undefined, proc))
    }
    
    module.exports = createThunk
    
  provide("cwise-compiler/lib/thunk.js", module.exports);
}(global));

// pakmanager:cwise-compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    var createThunk =  require('cwise-compiler/lib/thunk.js')
    
    function Procedure() {
      this.argTypes = []
      this.shimArgs = []
      this.arrayArgs = []
      this.arrayBlockIndices = []
      this.scalarArgs = []
      this.offsetArgs = []
      this.offsetArgIndex = []
      this.indexArgs = []
      this.shapeArgs = []
      this.funcName = ""
      this.pre = null
      this.body = null
      this.post = null
      this.debug = false
    }
    
    function compileCwise(user_args) {
      //Create procedure
      var proc = new Procedure()
      
      //Parse blocks
      proc.pre    = user_args.pre
      proc.body   = user_args.body
      proc.post   = user_args.post
    
      //Parse arguments
      var proc_args = user_args.args.slice(0)
      proc.argTypes = proc_args
      for(var i=0; i<proc_args.length; ++i) {
        var arg_type = proc_args[i]
        if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
          proc.argTypes[i] = "array"
          proc.arrayArgs.push(i)
          proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
          proc.shimArgs.push("array" + i)
          if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
            throw new Error("cwise: pre() block may not reference array args")
          }
          if(i < proc.post.args.length && proc.post.args[i].count>0) {
            throw new Error("cwise: post() block may not reference array args")
          }
        } else if(arg_type === "scalar") {
          proc.scalarArgs.push(i)
          proc.shimArgs.push("scalar" + i)
        } else if(arg_type === "index") {
          proc.indexArgs.push(i)
          if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
            throw new Error("cwise: pre() block may not reference array index")
          }
          if(i < proc.body.args.length && proc.body.args[i].lvalue) {
            throw new Error("cwise: body() block may not write to array index")
          }
          if(i < proc.post.args.length && proc.post.args[i].count > 0) {
            throw new Error("cwise: post() block may not reference array index")
          }
        } else if(arg_type === "shape") {
          proc.shapeArgs.push(i)
          if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
            throw new Error("cwise: pre() block may not write to array shape")
          }
          if(i < proc.body.args.length && proc.body.args[i].lvalue) {
            throw new Error("cwise: body() block may not write to array shape")
          }
          if(i < proc.post.args.length && proc.post.args[i].lvalue) {
            throw new Error("cwise: post() block may not write to array shape")
          }
        } else if(typeof arg_type === "object" && arg_type.offset) {
          proc.argTypes[i] = "offset"
          proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
          proc.offsetArgIndex.push(i)
        } else {
          throw new Error("cwise: Unknown argument type " + proc_args[i])
        }
      }
      
      //Make sure at least one array argument was specified
      if(proc.arrayArgs.length <= 0) {
        throw new Error("cwise: No array arguments specified")
      }
      
      //Make sure arguments are correct
      if(proc.pre.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in pre() block")
      }
      if(proc.body.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in body() block")
      }
      if(proc.post.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in post() block")
      }
    
      //Check debug flag
      proc.debug = !!user_args.printCode || !!user_args.debug
      
      //Retrieve name
      proc.funcName = user_args.funcName || "cwise"
      
      //Read in block size
      proc.blockSize = user_args.blockSize || 64
    
      return createThunk(proc)
    }
    
    module.exports = compileCwise
    
  provide("cwise-compiler", module.exports);
}(global));

// pakmanager:bl
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var DuplexStream = require('readable-stream/duplex')
      , util         = require('util')
    
    function BufferList (callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback)
    
      this._bufs  = []
      this.length = 0
    
      if (typeof callback == 'function') {
        this._callback = callback
    
        var piper = function (err) {
          if (this._callback) {
            this._callback(err)
            this._callback = null
          }
        }.bind(this)
    
        this.on('pipe', function (src) {
          src.on('error', piper)
        })
        this.on('unpipe', function (src) {
          src.removeListener('error', piper)
        })
      }
      else if (Buffer.isBuffer(callback))
        this.append(callback)
      else if (Array.isArray(callback)) {
        callback.forEach(function (b) {
          Buffer.isBuffer(b) && this.append(b)
        }.bind(this))
      }
    
      DuplexStream.call(this)
    }
    
    util.inherits(BufferList, DuplexStream)
    
    BufferList.prototype._offset = function (offset) {
      var tot = 0, i = 0, _t
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length
        if (offset < _t)
          return [ i, offset - tot ]
        tot = _t
      }
    }
    
    BufferList.prototype.append = function (buf) {
      var isBuffer = Buffer.isBuffer(buf) ||
                     buf instanceof BufferList
    
      this._bufs.push(isBuffer ? buf : new Buffer(buf))
      this.length += buf.length
      return this
    }
    
    BufferList.prototype._write = function (buf, encoding, callback) {
      this.append(buf)
      if (callback)
        callback()
    }
    
    BufferList.prototype._read = function (size) {
      if (!this.length)
        return this.push(null)
      size = Math.min(size, this.length)
      this.push(this.slice(0, size))
      this.consume(size)
    }
    
    BufferList.prototype.end = function (chunk) {
      DuplexStream.prototype.end.call(this, chunk)
    
      if (this._callback) {
        this._callback(null, this.slice())
        this._callback = null
      }
    }
    
    BufferList.prototype.get = function (index) {
      return this.slice(index, index + 1)[0]
    }
    
    BufferList.prototype.slice = function (start, end) {
      return this.copy(null, 0, start, end)
    }
    
    BufferList.prototype.copy = function (dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != 'number' || srcStart < 0)
        srcStart = 0
      if (typeof srcEnd != 'number' || srcEnd > this.length)
        srcEnd = this.length
      if (srcStart >= this.length)
        return dst || new Buffer(0)
      if (srcEnd <= 0)
        return dst || new Buffer(0)
    
      var copy   = !!dst
        , off    = this._offset(srcStart)
        , len    = srcEnd - srcStart
        , bytes  = len
        , bufoff = (copy && dstStart) || 0
        , start  = off[1]
        , l
        , i
    
      // copy/slice everything
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy) // slice, just return a full concat
          return Buffer.concat(this._bufs)
    
        // copy, need to copy individual buffers
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff)
          bufoff += this._bufs[i].length
        }
    
        return dst
      }
    
      // easy, cheap case where it's a subset of one of the buffers
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy
          ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
          : this._bufs[off[0]].slice(start, start + bytes)
      }
    
      if (!copy) // a slice, we need something to copy in to
        dst = new Buffer(len)
    
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start
    
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start)
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes)
          break
        }
    
        bufoff += l
        bytes -= l
    
        if (start)
          start = 0
      }
    
      return dst
    }
    
    BufferList.prototype.toString = function (encoding, start, end) {
      return this.slice(start, end).toString(encoding)
    }
    
    BufferList.prototype.consume = function (bytes) {
      while (this._bufs.length) {
        if (bytes > this._bufs[0].length) {
          bytes -= this._bufs[0].length
          this.length -= this._bufs[0].length
          this._bufs.shift()
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes)
          this.length -= bytes
          break
        }
      }
      return this
    }
    
    BufferList.prototype.duplicate = function () {
      var i = 0
        , copy = new BufferList()
    
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i])
    
      return copy
    }
    
    BufferList.prototype.destroy = function () {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    }
    
    ;(function () {
      var methods = {
          'readDoubleBE' : 8
        , 'readDoubleLE' : 8
        , 'readFloatBE'  : 4
        , 'readFloatLE'  : 4
        , 'readInt32BE'  : 4
        , 'readInt32LE'  : 4
        , 'readUInt32BE' : 4
        , 'readUInt32LE' : 4
        , 'readInt16BE'  : 2
        , 'readInt16LE'  : 2
        , 'readUInt16BE' : 2
        , 'readUInt16LE' : 2
        , 'readInt8'     : 1
        , 'readUInt8'    : 1
      }
    
      for (var m in methods) {
        (function (m) {
          BufferList.prototype[m] = function (offset) {
            return this.slice(offset, offset + methods[m])[m](0)
          }
        }(m))
      }
    }())
    
    module.exports = BufferList
    
  provide("bl", module.exports);
}(global));

// pakmanager:caseless
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  function Caseless (dict) {
      this.dict = dict || {}
    }
    Caseless.prototype.set = function (name, value, clobber) {
      if (typeof name === 'object') {
        for (var i in name) {
          this.set(i, name[i], value)
        }
      } else {
        if (typeof clobber === 'undefined') clobber = true
        var has = this.has(name)
    
        if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value
        else this.dict[has || name] = value
        return has
      }
    }
    Caseless.prototype.has = function (name) {
      var keys = Object.keys(this.dict)
        , name = name.toLowerCase()
        ;
      for (var i=0;i<keys.length;i++) {
        if (keys[i].toLowerCase() === name) return keys[i]
      }
      return false
    }
    Caseless.prototype.get = function (name) {
      name = name.toLowerCase()
      var result, _key
      var headers = this.dict
      Object.keys(headers).forEach(function (key) {
        _key = key.toLowerCase()
        if (name === _key) result = headers[key]
      })
      return result
    }
    Caseless.prototype.swap = function (name) {
      var has = this.has(name)
      if (!has) throw new Error('There is no header than matches "'+name+'"')
      this.dict[name] = this.dict[has]
      delete this.dict[has]
    }
    Caseless.prototype.del = function (name) {
      var has = this.has(name)
      return delete this.dict[has || name]
    }
    
    module.exports = function (dict) {return new Caseless(dict)}
    module.exports.httpify = function (resp, headers) {
      var c = new Caseless(headers)
      resp.setHeader = function (key, value, clobber) {
        if (typeof value === 'undefined') return
        return c.set(key, value, clobber)
      }
      resp.hasHeader = function (key) {
        return c.has(key)
      }
      resp.getHeader = function (key) {
        return c.get(key)
      }
      resp.removeHeader = function (key) {
        return c.del(key)
      }
      resp.headers = c.dict
      return c
    }
    
  provide("caseless", module.exports);
}(global));

// pakmanager:extend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    
    var isArray = function isArray(arr) {
    	if (typeof Array.isArray === 'function') {
    		return Array.isArray(arr);
    	}
    
    	return toStr.call(arr) === '[object Array]';
    };
    
    var isPlainObject = function isPlainObject(obj) {
    	if (!obj || toStr.call(obj) !== '[object Object]') {
    		return false;
    	}
    
    	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
    	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    	// Not own constructor property must be Object
    	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    		return false;
    	}
    
    	// Own properties are enumerated firstly, so to speed up,
    	// if last one is own, then all properties are own.
    	var key;
    	for (key in obj) {/**/}
    
    	return typeof key === 'undefined' || hasOwn.call(obj, key);
    };
    
    module.exports = function extend() {
    	var options, name, src, copy, copyIsArray, clone,
    		target = arguments[0],
    		i = 1,
    		length = arguments.length,
    		deep = false;
    
    	// Handle a deep copy situation
    	if (typeof target === 'boolean') {
    		deep = target;
    		target = arguments[1] || {};
    		// skip the boolean and the target
    		i = 2;
    	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
    		target = {};
    	}
    
    	for (; i < length; ++i) {
    		options = arguments[i];
    		// Only deal with non-null/undefined values
    		if (options != null) {
    			// Extend the base object
    			for (name in options) {
    				src = target[name];
    				copy = options[name];
    
    				// Prevent never-ending loop
    				if (target !== copy) {
    					// Recurse if we're merging plain objects or arrays
    					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
    						if (copyIsArray) {
    							copyIsArray = false;
    							clone = src && isArray(src) ? src : [];
    						} else {
    							clone = src && isPlainObject(src) ? src : {};
    						}
    
    						// Never move original objects, clone them
    						target[name] = extend(deep, clone, copy);
    
    					// Don't bring in undefined values
    					} else if (typeof copy !== 'undefined') {
    						target[name] = copy;
    					}
    				}
    			}
    		}
    	}
    
    	// Return the modified object
    	return target;
    };
    
    
  provide("extend", module.exports);
}(global));

// pakmanager:forever-agent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = ForeverAgent
    ForeverAgent.SSL = ForeverAgentSSL
    
    var util = require('util')
      , Agent = require('http').Agent
      , net = require('net')
      , tls = require('tls')
      , AgentSSL = require('https').Agent
      
    function getConnectionName(host, port) {  
      var name = ''
      if (typeof host === 'string') {
        name = host + ':' + port
      } else {
        // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.
        name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')
      }
      return name
    }    
    
    function ForeverAgent(options) {
      var self = this
      self.options = options || {}
      self.requests = {}
      self.sockets = {}
      self.freeSockets = {}
      self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
      self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
      self.on('free', function(socket, host, port) {
        var name = getConnectionName(host, port)
    
        if (self.requests[name] && self.requests[name].length) {
          self.requests[name].shift().onSocket(socket)
        } else if (self.sockets[name].length < self.minSockets) {
          if (!self.freeSockets[name]) self.freeSockets[name] = []
          self.freeSockets[name].push(socket)
          
          // if an error happens while we don't use the socket anyway, meh, throw the socket away
          var onIdleError = function() {
            socket.destroy()
          }
          socket._onIdleError = onIdleError
          socket.on('error', onIdleError)
        } else {
          // If there are no pending requests just destroy the
          // socket and it will get removed from the pool. This
          // gets us out of timeout issues and allows us to
          // default to Connection:keep-alive.
          socket.destroy()
        }
      })
    
    }
    util.inherits(ForeverAgent, Agent)
    
    ForeverAgent.defaultMinSockets = 5
    
    
    ForeverAgent.prototype.createConnection = net.createConnection
    ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
    ForeverAgent.prototype.addRequest = function(req, host, port) {
      var name = getConnectionName(host, port)
      
      if (typeof host !== 'string') {
        var options = host
        port = options.port
        host = options.host
      }
    
      if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
        var idleSocket = this.freeSockets[name].pop()
        idleSocket.removeListener('error', idleSocket._onIdleError)
        delete idleSocket._onIdleError
        req._reusedSocket = true
        req.onSocket(idleSocket)
      } else {
        this.addRequestNoreuse(req, host, port)
      }
    }
    
    ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
      if (this.sockets[name]) {
        var index = this.sockets[name].indexOf(s)
        if (index !== -1) {
          this.sockets[name].splice(index, 1)
        }
      } else if (this.sockets[name] && this.sockets[name].length === 0) {
        // don't leak
        delete this.sockets[name]
        delete this.requests[name]
      }
      
      if (this.freeSockets[name]) {
        var index = this.freeSockets[name].indexOf(s)
        if (index !== -1) {
          this.freeSockets[name].splice(index, 1)
          if (this.freeSockets[name].length === 0) {
            delete this.freeSockets[name]
          }
        }
      }
    
      if (this.requests[name] && this.requests[name].length) {
        // If we have pending requests and a socket gets closed a new one
        // needs to be created to take over in the pool for the one that closed.
        this.createSocket(name, host, port).emit('free')
      }
    }
    
    function ForeverAgentSSL (options) {
      ForeverAgent.call(this, options)
    }
    util.inherits(ForeverAgentSSL, ForeverAgent)
    
    ForeverAgentSSL.prototype.createConnection = createConnectionSSL
    ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest
    
    function createConnectionSSL (port, host, options) {
      if (typeof port === 'object') {
        options = port;
      } else if (typeof host === 'object') {
        options = host;
      } else if (typeof options === 'object') {
        options = options;
      } else {
        options = {};
      }
    
      if (typeof port === 'number') {
        options.port = port;
      }
    
      if (typeof host === 'string') {
        options.host = host;
      }
    
      return tls.connect(options);
    }
    
  provide("forever-agent", module.exports);
}(global));

// pakmanager:form-data
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var CombinedStream = require('combined-stream');
    var util = require('util');
    var path = require('path');
    var http = require('http');
    var https = require('https');
    var parseUrl = require('url').parse;
    var fs = require('fs');
    var mime = require('mime-types');
    var async = require('async');
    
    module.exports = FormData;
    function FormData() {
      this._overheadLength = 0;
      this._valueLength = 0;
      this._lengthRetrievers = [];
    
      CombinedStream.call(this);
    }
    util.inherits(FormData, CombinedStream);
    
    FormData.LINE_BREAK = '\r\n';
    FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
    
    FormData.prototype.append = function(field, value, options) {
      options = (typeof options === 'string')
        ? { filename: options }
        : options || {};
    
      var append = CombinedStream.prototype.append.bind(this);
    
      // all that streamy business can't handle numbers
      if (typeof value == 'number') value = ''+value;
    
      // https://github.com/felixge/node-form-data/issues/38
      if (util.isArray(value)) {
        // Please convert your array into string
        // the way web server expects it
        this._error(new Error('Arrays are not supported.'));
        return;
      }
    
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter(field, value, options);
    
      append(header);
      append(value);
      append(footer);
    
      // pass along options.knownLength
      this._trackLength(header, value, options);
    };
    
    FormData.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
    
      // used w/ getLengthSync(), when length is known.
      // e.g. for streaming directly from a remote server,
      // w/ a known file a size, and not wanting to wait for
      // incoming file to finish to get its size.
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === 'string') {
        valueLength = Buffer.byteLength(value);
      }
    
      this._valueLength += valueLength;
    
      // @check why add CRLF? does this account for custom/multiple CRLFs?
      this._overheadLength +=
        Buffer.byteLength(header) +
        FormData.LINE_BREAK.length;
    
      // empty or either doesn't have path or not an http response
      if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
        return;
      }
    
      // no need to bother with the length
      if (!options.knownLength)
      this._lengthRetrievers.push(function(next) {
    
        if (value.hasOwnProperty('fd')) {
    
          // take read range into a account
          // `end` = Infinity > read file till the end
          //
          // TODO: Looks like there is bug in Node fs.createReadStream
          // it doesn't respect `end` options without `start` options
          // Fix it when node fixes it.
          // https://github.com/joyent/node/issues/7819
          if (value.end != undefined && value.end != Infinity && value.start != undefined) {
    
            // when end specified
            // no need to calculate range
            // inclusive, starts with 0
            next(null, value.end+1 - (value.start ? value.start : 0));
    
          // not that fast snoopy
          } else {
            // still need to fetch file size from fs
            fs.stat(value.path, function(err, stat) {
    
              var fileSize;
    
              if (err) {
                next(err);
                return;
              }
    
              // update final size based on the range options
              fileSize = stat.size - (value.start ? value.start : 0);
              next(null, fileSize);
            });
          }
    
        // or http response
        } else if (value.hasOwnProperty('httpVersion')) {
          next(null, +value.headers['content-length']);
    
        // or request stream http://github.com/mikeal/request
        } else if (value.hasOwnProperty('httpModule')) {
          // wait till response come back
          value.on('response', function(response) {
            value.pause();
            next(null, +response.headers['content-length']);
          });
          value.resume();
    
        // something else
        } else {
          next('Unknown stream');
        }
      });
    };
    
    FormData.prototype._multiPartHeader = function(field, value, options) {
      // custom header specified (as string)?
      // it becomes responsible for boundary
      // (e.g. to handle extra CRLFs on .NET servers)
      if (options.header != null) {
        return options.header;
      }
    
      var contents = '';
      var headers  = {
        'Content-Disposition': ['form-data', 'name="' + field + '"'],
        'Content-Type': []
      };
    
      // fs- and request- streams have path property
      // or use custom filename and/or contentType
      // TODO: Use request's response mime-type
      if (options.filename || value.path) {
        headers['Content-Disposition'].push(
          'filename="' + path.basename(options.filename || value.path) + '"'
        );
        headers['Content-Type'].push(
          options.contentType ||
          mime.lookup(options.filename || value.path) ||
          FormData.DEFAULT_CONTENT_TYPE
        );
      // http response has not
      } else if (value.readable && value.hasOwnProperty('httpVersion')) {
        headers['Content-Disposition'].push(
          'filename="' + path.basename(value.client._httpMessage.path) + '"'
        );
        headers['Content-Type'].push(
          options.contentType ||
          value.headers['content-type'] ||
          FormData.DEFAULT_CONTENT_TYPE
        );
      } else if (Buffer.isBuffer(value)) {
        headers['Content-Type'].push(
          options.contentType ||
          FormData.DEFAULT_CONTENT_TYPE
        );
      } else if (options.contentType) {
        headers['Content-Type'].push(options.contentType);
      }
    
      for (var prop in headers) {
        if (headers[prop].length) {
          contents += prop + ': ' + headers[prop].join('; ') + FormData.LINE_BREAK;
        }
      }
      
      return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
    };
    
    FormData.prototype._multiPartFooter = function(field, value, options) {
      return function(next) {
        var footer = FormData.LINE_BREAK;
    
        var lastPart = (this._streams.length === 0);
        if (lastPart) {
          footer += this._lastBoundary();
        }
    
        next(footer);
      }.bind(this);
    };
    
    FormData.prototype._lastBoundary = function() {
      return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
    };
    
    FormData.prototype.getHeaders = function(userHeaders) {
      var formHeaders = {
        'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
      };
    
      for (var header in userHeaders) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    
      return formHeaders;
    }
    
    FormData.prototype.getCustomHeaders = function(contentType) {
        contentType = contentType ? contentType : 'multipart/form-data';
    
        var formHeaders = {
            'content-type': contentType + '; boundary=' + this.getBoundary(),
            'content-length': this.getLengthSync()
        };
    
        return formHeaders;
    }
    
    FormData.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
    
      return this._boundary;
    };
    
    FormData.prototype._generateBoundary = function() {
      // This generates a 50 character boundary similar to those used by Firefox.
      // They are optimized for boyer-moore parsing.
      var boundary = '--------------------------';
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
    
      this._boundary = boundary;
    };
    
    // Note: getLengthSync DOESN'T calculate streams length
    // As workaround one can calculate file size manually
    // and add it as knownLength option
    FormData.prototype.getLengthSync = function(debug) {
      var knownLength = this._overheadLength + this._valueLength;
    
      // Don't get confused, there are 3 "internal" streams for each keyval pair
      // so it basically checks if there is any value added to the form
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
    
      // https://github.com/felixge/node-form-data/issues/40
      if (this._lengthRetrievers.length) {
        // Some async length retrivers are present
        // therefore synchronous length calculation is false.
        // Please use getLength(callback) to get proper length
        this._error(new Error('Cannot calculate proper length in synchronous way.'));
      }
    
      return knownLength;
    };
    
    FormData.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
    
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
    
      if (!this._lengthRetrievers.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
    
      async.parallel(this._lengthRetrievers, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
    
        values.forEach(function(length) {
          knownLength += length;
        });
    
        cb(null, knownLength);
      });
    };
    
    FormData.prototype.submit = function(params, cb) {
    
      var request
        , options
        , defaults = {
            method : 'post'
        };
    
      // parse provided url if it's string
      // or treat it as options object
      if (typeof params == 'string') {
        params = parseUrl(params);
    
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname
        }, defaults);
      }
      else // use custom params
      {
        options = populate(params, defaults);
        // if no port provided use default one
        if (!options.port) {
          options.port = options.protocol == 'https:' ? 443 : 80;
        }
      }
    
      // put that good code in getHeaders to some use
      options.headers = this.getHeaders(params.headers);
    
      // https if specified, fallback to http in any other case
      if (options.protocol == 'https:') {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
    
      // get content length and fire away
      this.getLength(function(err, length) {
    
        // TODO: Add chunked encoding when no length (if err)
    
        // add content length
        request.setHeader('Content-Length', length);
    
        this.pipe(request);
        if (cb) {
          request.on('error', cb);
          request.on('response', cb.bind(this, null));
        }
      }.bind(this));
    
      return request;
    };
    
    FormData.prototype._error = function(err) {
      if (this.error) return;
    
      this.error = err;
      this.pause();
      this.emit('error', err);
    };
    
    /*
     * Santa's little helpers
     */
    
    // populates missing values
    function populate(dst, src) {
      for (var prop in src) {
        if (!dst[prop]) dst[prop] = src[prop];
      }
      return dst;
    }
    
  provide("form-data", module.exports);
}(global));

// pakmanager:json-stringify-safe
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports = module.exports = stringify
    exports.getSerialize = serializer
    
    function stringify(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
    }
    
    function serializer(replacer, cycleReplacer) {
      var stack = [], keys = []
    
      if (cycleReplacer == null) cycleReplacer = function(key, value) {
        if (stack[0] === value) return "[Circular ~]"
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
      }
    
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this)
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
          if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
        }
        else stack.push(value)
    
        return replacer == null ? value : replacer.call(this, key, value)
      }
    }
    
  provide("json-stringify-safe", module.exports);
}(global));

// pakmanager:node-uuid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  //     uuid.js
    //
    //     Copyright (c) 2010-2012 Robert Kieffer
    //     MIT License - http://opensource.org/licenses/mit-license.php
    
    (function() {
      var _global = this;
    
      // Unique ID creation requires a high quality random # generator.  We feature
      // detect to determine the best RNG source, normalizing to a function that
      // returns 128-bits of randomness, since that's what's usually required
      var _rng;
    
      // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
      //
      // Moderately fast, high quality
      if (typeof(_global.require) == 'function') {
        try {
          var _rb = _global.require('crypto').randomBytes;
          _rng = _rb && function() {return _rb(16);};
        } catch(e) {}
      }
    
      if (!_rng && _global.crypto && crypto.getRandomValues) {
        // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
        //
        // Moderately fast, high quality
        var _rnds8 = new Uint8Array(16);
        _rng = function whatwgRNG() {
          crypto.getRandomValues(_rnds8);
          return _rnds8;
        };
      }
    
      if (!_rng) {
        // Math.random()-based (RNG)
        //
        // If all else fails, use Math.random().  It's fast, but is of unspecified
        // quality.
        var  _rnds = new Array(16);
        _rng = function() {
          for (var i = 0, r; i < 16; i++) {
            if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
            _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
          }
    
          return _rnds;
        };
      }
    
      // Buffer class to use
      var BufferClass = typeof(_global.Buffer) == 'function' ? _global.Buffer : Array;
    
      // Maps for number <-> hex string conversion
      var _byteToHex = [];
      var _hexToByte = {};
      for (var i = 0; i < 256; i++) {
        _byteToHex[i] = (i + 0x100).toString(16).substr(1);
        _hexToByte[_byteToHex[i]] = i;
      }
    
      // **`parse()` - Parse a UUID into it's component bytes**
      function parse(s, buf, offset) {
        var i = (buf && offset) || 0, ii = 0;
    
        buf = buf || [];
        s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
          if (ii < 16) { // Don't overflow!
            buf[i + ii++] = _hexToByte[oct];
          }
        });
    
        // Zero out remaining bytes if string was short
        while (ii < 16) {
          buf[i + ii++] = 0;
        }
    
        return buf;
      }
    
      // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
      function unparse(buf, offset) {
        var i = offset || 0, bth = _byteToHex;
        return  bth[buf[i++]] + bth[buf[i++]] +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] +
                bth[buf[i++]] + bth[buf[i++]] +
                bth[buf[i++]] + bth[buf[i++]];
      }
    
      // **`v1()` - Generate time-based UUID**
      //
      // Inspired by https://github.com/LiosK/UUID.js
      // and http://docs.python.org/library/uuid.html
    
      // random #'s we need to init node and clockseq
      var _seedBytes = _rng();
    
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      var _nodeId = [
        _seedBytes[0] | 0x01,
        _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
      ];
    
      // Per 4.2.2, randomize (14 bit) clockseq
      var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
    
      // Previous uuid creation time
      var _lastMSecs = 0, _lastNSecs = 0;
    
      // See https://github.com/broofa/node-uuid for API details
      function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || [];
    
        options = options || {};
    
        var clockseq = options.clockseq != null ? options.clockseq : _clockseq;
    
        // UUID timestamps are 100 nano-second units since the Gregorian epoch,
        // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
        // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
        // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
        var msecs = options.msecs != null ? options.msecs : new Date().getTime();
    
        // Per 4.2.1.2, use count of uuid's generated during the current clock
        // cycle to simulate higher resolution clock
        var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;
    
        // Time since last uuid creation (in msecs)
        var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;
    
        // Per 4.2.1.2, Bump clockseq on clock regression
        if (dt < 0 && options.clockseq == null) {
          clockseq = clockseq + 1 & 0x3fff;
        }
    
        // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
        // time interval
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
          nsecs = 0;
        }
    
        // Per 4.2.1.2 Throw error if too many uuids are requested
        if (nsecs >= 10000) {
          throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
        }
    
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
    
        // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
        msecs += 12219292800000;
    
        // `time_low`
        var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
        b[i++] = tl >>> 24 & 0xff;
        b[i++] = tl >>> 16 & 0xff;
        b[i++] = tl >>> 8 & 0xff;
        b[i++] = tl & 0xff;
    
        // `time_mid`
        var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
        b[i++] = tmh >>> 8 & 0xff;
        b[i++] = tmh & 0xff;
    
        // `time_high_and_version`
        b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
        b[i++] = tmh >>> 16 & 0xff;
    
        // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
        b[i++] = clockseq >>> 8 | 0x80;
    
        // `clock_seq_low`
        b[i++] = clockseq & 0xff;
    
        // `node`
        var node = options.node || _nodeId;
        for (var n = 0; n < 6; n++) {
          b[i + n] = node[n];
        }
    
        return buf ? buf : unparse(b);
      }
    
      // **`v4()` - Generate random UUID**
    
      // See https://github.com/broofa/node-uuid for API details
      function v4(options, buf, offset) {
        // Deprecated - 'format' argument, as supported in v1.2
        var i = buf && offset || 0;
    
        if (typeof(options) == 'string') {
          buf = options == 'binary' ? new BufferClass(16) : null;
          options = null;
        }
        options = options || {};
    
        var rnds = options.random || (options.rng || _rng)();
    
        // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
        rnds[6] = (rnds[6] & 0x0f) | 0x40;
        rnds[8] = (rnds[8] & 0x3f) | 0x80;
    
        // Copy bytes to buffer, if provided
        if (buf) {
          for (var ii = 0; ii < 16; ii++) {
            buf[i + ii] = rnds[ii];
          }
        }
    
        return buf || unparse(rnds);
      }
    
      // Export public API
      var uuid = v4;
      uuid.v1 = v1;
      uuid.v4 = v4;
      uuid.parse = parse;
      uuid.unparse = unparse;
      uuid.BufferClass = BufferClass;
    
      if (typeof(module) != 'undefined' && module.exports) {
        // Publish as node.js module
        module.exports = uuid;
      } else  if (typeof define === 'function' && define.amd) {
        // Publish as AMD module
        define(function() {return uuid;});
     
    
      } else {
        // Publish as global (in browsers)
        var _previousRoot = _global.uuid;
    
        // **`noConflict()` - (browser only) to reset global 'uuid' var**
        uuid.noConflict = function() {
          _global.uuid = _previousRoot;
          return uuid;
        };
    
        _global.uuid = uuid;
      }
    }).call(this);
    
  provide("node-uuid", module.exports);
}(global));

// pakmanager:qs/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    
    // Declare internals
    
    var internals = {};
    internals.hexTable = new Array(256);
    for (var h = 0; h < 256; ++h) {
        internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();
    }
    
    
    exports.arrayToObject = function (source, options) {
    
        var obj = options.plainObjects ? Object.create(null) : {};
        for (var i = 0, il = source.length; i < il; ++i) {
            if (typeof source[i] !== 'undefined') {
    
                obj[i] = source[i];
            }
        }
    
        return obj;
    };
    
    
    exports.merge = function (target, source, options) {
    
        if (!source) {
            return target;
        }
    
        if (typeof source !== 'object') {
            if (Array.isArray(target)) {
                target.push(source);
            }
            else if (typeof target === 'object') {
                target[source] = true;
            }
            else {
                target = [target, source];
            }
    
            return target;
        }
    
        if (typeof target !== 'object') {
            target = [target].concat(source);
            return target;
        }
    
        if (Array.isArray(target) &&
            !Array.isArray(source)) {
    
            target = exports.arrayToObject(target, options);
        }
    
        var keys = Object.keys(source);
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var value = source[key];
    
            if (!Object.prototype.hasOwnProperty.call(target, key)) {
                target[key] = value;
            }
            else {
                target[key] = exports.merge(target[key], value, options);
            }
        }
    
        return target;
    };
    
    
    exports.decode = function (str) {
    
        try {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        } catch (e) {
            return str;
        }
    };
    
    exports.encode = function (str) {
    
        // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
        // It has been adapted here for stricter adherence to RFC 3986
        if (str.length === 0) {
            return str;
        }
    
        if (typeof str !== 'string') {
            str = '' + str;
        }
    
        var out = '';
        for (var i = 0, il = str.length; i < il; ++i) {
            var c = str.charCodeAt(i);
    
            if (c === 0x2D || // -
                c === 0x2E || // .
                c === 0x5F || // _
                c === 0x7E || // ~
                (c >= 0x30 && c <= 0x39) || // 0-9
                (c >= 0x41 && c <= 0x5A) || // a-z
                (c >= 0x61 && c <= 0x7A)) { // A-Z
    
                out += str[i];
                continue;
            }
    
            if (c < 0x80) {
                out += internals.hexTable[c];
                continue;
            }
    
            if (c < 0x800) {
                out += internals.hexTable[0xC0 | (c >> 6)] + internals.hexTable[0x80 | (c & 0x3F)];
                continue;
            }
    
            if (c < 0xD800 || c >= 0xE000) {
                out += internals.hexTable[0xE0 | (c >> 12)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
                continue;
            }
    
            ++i;
            c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));
            out += internals.hexTable[0xF0 | (c >> 18)] + internals.hexTable[0x80 | ((c >> 12) & 0x3F)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
        }
    
        return out;
    };
    
    exports.compact = function (obj, refs) {
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return obj;
        }
    
        refs = refs || [];
        var lookup = refs.indexOf(obj);
        if (lookup !== -1) {
            return refs[lookup];
        }
    
        refs.push(obj);
    
        if (Array.isArray(obj)) {
            var compacted = [];
    
            for (var i = 0, il = obj.length; i < il; ++i) {
                if (typeof obj[i] !== 'undefined') {
                    compacted.push(obj[i]);
                }
            }
    
            return compacted;
        }
    
        var keys = Object.keys(obj);
        for (i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            obj[key] = exports.compact(obj[key], refs);
        }
    
        return obj;
    };
    
    
    exports.isRegExp = function (obj) {
    
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };
    
    
    exports.isBuffer = function (obj) {
    
        if (obj === null ||
            typeof obj === 'undefined') {
    
            return false;
        }
    
        return !!(obj.constructor &&
                  obj.constructor.isBuffer &&
                  obj.constructor.isBuffer(obj));
    };
    
  provide("qs/lib/utils", module.exports);
}(global));

// pakmanager:qs/lib/stringify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Utils =  require('qs/lib/utils');
    
    
    // Declare internals
    
    var internals = {
        delimiter: '&',
        arrayPrefixGenerators: {
            brackets: function (prefix, key) {
    
                return prefix + '[]';
            },
            indices: function (prefix, key) {
    
                return prefix + '[' + key + ']';
            },
            repeat: function (prefix, key) {
    
                return prefix;
            }
        },
        strictNullHandling: false,
        skipNulls: false,
        encode: true
    };
    
    
    internals.stringify = function (obj, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter) {
    
        if (typeof filter === 'function') {
            obj = filter(prefix, obj);
        }
        else if (Utils.isBuffer(obj)) {
            obj = obj.toString();
        }
        else if (obj instanceof Date) {
            obj = obj.toISOString();
        }
        else if (obj === null) {
            if (strictNullHandling) {
                return encode ? Utils.encode(prefix) : prefix;
            }
    
            obj = '';
        }
    
        if (typeof obj === 'string' ||
            typeof obj === 'number' ||
            typeof obj === 'boolean') {
    
            if (encode) {
                return [Utils.encode(prefix) + '=' + Utils.encode(obj)];
            }
            return [prefix + '=' + obj];
        }
    
        var values = [];
    
        if (typeof obj === 'undefined') {
            return values;
        }
    
        var objKeys = Array.isArray(filter) ? filter : Object.keys(obj);
        for (var i = 0, il = objKeys.length; i < il; ++i) {
            var key = objKeys[i];
    
            if (skipNulls &&
                obj[key] === null) {
    
                continue;
            }
    
            if (Array.isArray(obj)) {
                values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));
            }
            else {
                values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));
            }
        }
    
        return values;
    };
    
    
    module.exports = function (obj, options) {
    
        options = options || {};
        var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;
        var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
        var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : internals.skipNulls;
        var encode = typeof options.encode === 'boolean' ? options.encode : internals.encode;
        var objKeys;
        var filter;
        if (typeof options.filter === 'function') {
            filter = options.filter;
            obj = filter('', obj);
        }
        else if (Array.isArray(options.filter)) {
            objKeys = filter = options.filter;
        }
    
        var keys = [];
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return '';
        }
    
        var arrayFormat;
        if (options.arrayFormat in internals.arrayPrefixGenerators) {
            arrayFormat = options.arrayFormat;
        }
        else if ('indices' in options) {
            arrayFormat = options.indices ? 'indices' : 'repeat';
        }
        else {
            arrayFormat = 'indices';
        }
    
        var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];
    
        if (!objKeys) {
            objKeys = Object.keys(obj);
        }
    
        for (var i = 0, il = objKeys.length; i < il; ++i) {
            var key = objKeys[i];
    
            if (skipNulls &&
                obj[key] === null) {
    
                continue;
            }
    
            keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));
        }
    
        return keys.join(delimiter);
    };
    
  provide("qs/lib/stringify", module.exports);
}(global));

// pakmanager:qs/lib/parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Utils =  require('qs/lib/utils');
    
    
    // Declare internals
    
    var internals = {
        delimiter: '&',
        depth: 5,
        arrayLimit: 20,
        parameterLimit: 1000,
        strictNullHandling: false,
        plainObjects: false,
        allowPrototypes: false,
        allowDots: false
    };
    
    
    internals.parseValues = function (str, options) {
    
        var obj = {};
        var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
    
        for (var i = 0, il = parts.length; i < il; ++i) {
            var part = parts[i];
            var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;
    
            if (pos === -1) {
                obj[Utils.decode(part)] = '';
    
                if (options.strictNullHandling) {
                    obj[Utils.decode(part)] = null;
                }
            }
            else {
                var key = Utils.decode(part.slice(0, pos));
                var val = Utils.decode(part.slice(pos + 1));
    
                if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                    obj[key] = val;
                }
                else {
                    obj[key] = [].concat(obj[key]).concat(val);
                }
            }
        }
    
        return obj;
    };
    
    
    internals.parseObject = function (chain, val, options) {
    
        if (!chain.length) {
            return val;
        }
    
        var root = chain.shift();
    
        var obj;
        if (root === '[]') {
            obj = [];
            obj = obj.concat(internals.parseObject(chain, val, options));
        }
        else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
            var index = parseInt(cleanRoot, 10);
            var indexString = '' + index;
            if (!isNaN(index) &&
                root !== cleanRoot &&
                indexString === cleanRoot &&
                index >= 0 &&
                (options.parseArrays &&
                 index <= options.arrayLimit)) {
    
                obj = [];
                obj[index] = internals.parseObject(chain, val, options);
            }
            else {
                obj[cleanRoot] = internals.parseObject(chain, val, options);
            }
        }
    
        return obj;
    };
    
    
    internals.parseKeys = function (key, val, options) {
    
        if (!key) {
            return;
        }
    
        // Transform dot notation to bracket notation
    
        if (options.allowDots) {
            key = key.replace(/\.([^\.\[]+)/g, '[$1]');
        }
    
        // The regex chunks
    
        var parent = /^([^\[\]]*)/;
        var child = /(\[[^\[\]]*\])/g;
    
        // Get the parent
    
        var segment = parent.exec(key);
    
        // Stash the parent if it exists
    
        var keys = [];
        if (segment[1]) {
            // If we aren't using plain objects, optionally prefix keys
            // that would overwrite object prototype properties
            if (!options.plainObjects &&
                Object.prototype.hasOwnProperty(segment[1])) {
    
                if (!options.allowPrototypes) {
                    return;
                }
            }
    
            keys.push(segment[1]);
        }
    
        // Loop through children appending to the array until we hit depth
    
        var i = 0;
        while ((segment = child.exec(key)) !== null && i < options.depth) {
    
            ++i;
            if (!options.plainObjects &&
                Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
    
                if (!options.allowPrototypes) {
                    continue;
                }
            }
            keys.push(segment[1]);
        }
    
        // If there's a remainder, just add whatever is left
    
        if (segment) {
            keys.push('[' + key.slice(segment.index) + ']');
        }
    
        return internals.parseObject(keys, val, options);
    };
    
    
    module.exports = function (str, options) {
    
        options = options || {};
        options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
        options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
        options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
        options.parseArrays = options.parseArrays !== false;
        options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;
        options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;
        options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;
        options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
        options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
    
        if (str === '' ||
            str === null ||
            typeof str === 'undefined') {
    
            return options.plainObjects ? Object.create(null) : {};
        }
    
        var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
        var obj = options.plainObjects ? Object.create(null) : {};
    
        // Iterate over the keys and setup the new object
    
        var keys = Object.keys(tempObj);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            var newObj = internals.parseKeys(key, tempObj[key], options);
            obj = Utils.merge(obj, newObj, options);
        }
    
        return Utils.compact(obj);
    };
    
  provide("qs/lib/parse", module.exports);
}(global));

// pakmanager:qs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Stringify =  require('qs/lib/stringify');
    var Parse =  require('qs/lib/parse');
    
    
    // Declare internals
    
    var internals = {};
    
    
    module.exports = {
        stringify: Stringify,
        parse: Parse
    };
    
  provide("qs", module.exports);
}(global));

// pakmanager:tunnel-agent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var net = require('net')
      , tls = require('tls')
      , http = require('http')
      , https = require('https')
      , events = require('events')
      , assert = require('assert')
      , util = require('util')
      ;
    
    exports.httpOverHttp = httpOverHttp
    exports.httpsOverHttp = httpsOverHttp
    exports.httpOverHttps = httpOverHttps
    exports.httpsOverHttps = httpsOverHttps
    
    
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options)
      agent.request = http.request
      return agent
    }
    
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options)
      agent.request = http.request
      agent.createSocket = createSecureSocket
      return agent
    }
    
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options)
      agent.request = https.request
      return agent
    }
    
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options)
      agent.request = https.request
      agent.createSocket = createSecureSocket
      return agent
    }
    
    
    function TunnelingAgent(options) {
      var self = this
      self.options = options || {}
      self.proxyOptions = self.options.proxy || {}
      self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
      self.requests = []
      self.sockets = []
    
      self.on('free', function onFree(socket, host, port) {
        for (var i = 0, len = self.requests.length; i < len; ++i) {
          var pending = self.requests[i]
          if (pending.host === host && pending.port === port) {
            // Detect the request to connect same origin server,
            // reuse the connection.
            self.requests.splice(i, 1)
            pending.request.onSocket(socket)
            return
          }
        }
        socket.destroy()
        self.removeSocket(socket)
      })
    }
    util.inherits(TunnelingAgent, events.EventEmitter)
    
    TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
      var self = this
    
       // Legacy API: addRequest(req, host, port, path)
      if (typeof options === 'string') {
        options = {
          host: options,
          port: arguments[2],
          path: arguments[3]
        };
      }
    
      if (self.sockets.length >= this.maxSockets) {
        // We are over limit so we'll add it to the queue.
        self.requests.push({host: options.host, port: options.port, request: req})
        return
      }
    
      // If we are under maxSockets create a new one.
      self.createConnection({host: options.host, port: options.port, request: req})
    }
    
    TunnelingAgent.prototype.createConnection = function createConnection(pending) {
      var self = this
    
      self.createSocket(pending, function(socket) {
        socket.on('free', onFree)
        socket.on('close', onCloseOrRemove)
        socket.on('agentRemove', onCloseOrRemove)
        pending.request.onSocket(socket)
    
        function onFree() {
          self.emit('free', socket, pending.host, pending.port)
        }
    
        function onCloseOrRemove(err) {
          self.removeSocket(socket)
          socket.removeListener('free', onFree)
          socket.removeListener('close', onCloseOrRemove)
          socket.removeListener('agentRemove', onCloseOrRemove)
        }
      })
    }
    
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self = this
      var placeholder = {}
      self.sockets.push(placeholder)
    
      var connectOptions = mergeOptions({}, self.proxyOptions, 
        { method: 'CONNECT'
        , path: options.host + ':' + options.port
        , agent: false
        }
      )
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {}
        connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
            new Buffer(connectOptions.proxyAuth).toString('base64')
      }
    
      debug('making CONNECT request')
      var connectReq = self.request(connectOptions)
      connectReq.useChunkedEncodingByDefault = false // for v0.6
      connectReq.once('response', onResponse) // for v0.6
      connectReq.once('upgrade', onUpgrade)   // for v0.6
      connectReq.once('connect', onConnect)   // for v0.7 or later
      connectReq.once('error', onError)
      connectReq.end()
    
      function onResponse(res) {
        // Very hacky. This is necessary to avoid http-parser leaks.
        res.upgrade = true
      }
    
      function onUpgrade(res, socket, head) {
        // Hacky.
        process.nextTick(function() {
          onConnect(res, socket, head)
        })
      }
    
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners()
        socket.removeAllListeners()
    
        if (res.statusCode === 200) {
          assert.equal(head.length, 0)
          debug('tunneling connection has established')
          self.sockets[self.sockets.indexOf(placeholder)] = socket
          cb(socket)
        } else {
          debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
          var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
          error.code = 'ECONNRESET'
          options.request.emit('error', error)
          self.removeSocket(placeholder)
        }
      }
    
      function onError(cause) {
        connectReq.removeAllListeners()
    
        debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
        var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
        error.code = 'ECONNRESET'
        options.request.emit('error', error)
        self.removeSocket(placeholder)
      }
    }
    
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket)
      if (pos === -1) return
      
      this.sockets.splice(pos, 1)
    
      var pending = this.requests.shift()
      if (pending) {
        // If we have pending requests and a socket gets closed a new one
        // needs to be created to take over in the pool for the one that closed.
        this.createConnection(pending)
      }
    }
    
    function createSecureSocket(options, cb) {
      var self = this
      TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
        // 0 is dummy port for v0.6
        var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
          { servername: options.host
          , socket: socket
          }
        ))
        self.sockets[self.sockets.indexOf(socket)] = secureSocket
        cb(secureSocket)
      })
    }
    
    
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i]
        if (typeof overrides === 'object') {
          var keys = Object.keys(overrides)
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j]
            if (overrides[k] !== undefined) {
              target[k] = overrides[k]
            }
          }
        }
      }
      return target
    }
    
    
    var debug
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments)
        if (typeof args[0] === 'string') {
          args[0] = 'TUNNEL: ' + args[0]
        } else {
          args.unshift('TUNNEL:')
        }
        console.error.apply(console, args)
      }
    } else {
      debug = function() {}
    }
    exports.debug = debug // for test
    
  provide("tunnel-agent", module.exports);
}(global));

// pakmanager:tough-cookie/lib/pubsuffix
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /****************************************************
     * AUTOMATICALLY GENERATED by generate-pubsuffix.js *
     *                  DO NOT EDIT!                    *
     ****************************************************/
    
    "use strict";
    
    var punycode = require('punycode');
    
    module.exports.getPublicSuffix = function getPublicSuffix(domain) {
      /*!
       * Copyright (c) 2015, Salesforce.com, Inc.
       * All rights reserved.
       *
       * Redistribution and use in source and binary forms, with or without
       * modification, are permitted provided that the following conditions are met:
       *
       * 1. Redistributions of source code must retain the above copyright notice,
       * this list of conditions and the following disclaimer.
       *
       * 2. Redistributions in binary form must reproduce the above copyright notice,
       * this list of conditions and the following disclaimer in the documentation
       * and/or other materials provided with the distribution.
       *
       * 3. Neither the name of Salesforce.com nor the names of its contributors may
       * be used to endorse or promote products derived from this software without
       * specific prior written permission.
       *
       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
       * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
       * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
       * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
       * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
       * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
       * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
       * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
       * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
       * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
       * POSSIBILITY OF SUCH DAMAGE.
       */
      if (!domain) {
        return null;
      }
      if (domain.match(/^\./)) {
        return null;
      }
      var asciiDomain = punycode.toASCII(domain);
      var converted = false;
      if (asciiDomain !== domain) {
        domain = asciiDomain;
        converted = true;
      }
      if (index[domain]) {
        return null;
      }
    
      domain = domain.toLowerCase();
      var parts = domain.split('.').reverse();
    
      var suffix = '';
      var suffixLen = 0;
      for (var i=0; i<parts.length; i++) {
        var part = parts[i];
        var starstr = '*'+suffix;
        var partstr = part+suffix;
    
        if (index[starstr]) { // star rule matches
          suffixLen = i+1;
          if (index[partstr] === false) { // exception rule matches (NB: false, not undefined)
            suffixLen--;
          }
        } else if (index[partstr]) { // exact match, not exception
          suffixLen = i+1;
        }
    
        suffix = '.'+partstr;
      }
    
      if (index['*'+suffix]) { // *.domain exists (e.g. *.kyoto.jp for domain='kyoto.jp');
        return null;
      }
    
      suffixLen = suffixLen || 1;
      if (parts.length > suffixLen) {
        var publicSuffix = parts.slice(0,suffixLen+1).reverse().join('.');
        return converted ? punycode.toUnicode(publicSuffix) : publicSuffix;
      }
    
      return null;
    };
    
    // The following generated structure is used under the MPL version 1.1
    // See public-suffix.txt for more information
    
    var index = module.exports.index = Object.freeze(
    {"ac":true,"com.ac":true,"edu.ac":true,"gov.ac":true,"net.ac":true,"mil.ac":true,"org.ac":true,"ad":true,"nom.ad":true,"ae":true,"co.ae":true,"net.ae":true,"org.ae":true,"sch.ae":true,"ac.ae":true,"gov.ae":true,"mil.ae":true,"aero":true,"accident-investigation.aero":true,"accident-prevention.aero":true,"aerobatic.aero":true,"aeroclub.aero":true,"aerodrome.aero":true,"agents.aero":true,"aircraft.aero":true,"airline.aero":true,"airport.aero":true,"air-surveillance.aero":true,"airtraffic.aero":true,"air-traffic-control.aero":true,"ambulance.aero":true,"amusement.aero":true,"association.aero":true,"author.aero":true,"ballooning.aero":true,"broker.aero":true,"caa.aero":true,"cargo.aero":true,"catering.aero":true,"certification.aero":true,"championship.aero":true,"charter.aero":true,"civilaviation.aero":true,"club.aero":true,"conference.aero":true,"consultant.aero":true,"consulting.aero":true,"control.aero":true,"council.aero":true,"crew.aero":true,"design.aero":true,"dgca.aero":true,"educator.aero":true,"emergency.aero":true,"engine.aero":true,"engineer.aero":true,"entertainment.aero":true,"equipment.aero":true,"exchange.aero":true,"express.aero":true,"federation.aero":true,"flight.aero":true,"freight.aero":true,"fuel.aero":true,"gliding.aero":true,"government.aero":true,"groundhandling.aero":true,"group.aero":true,"hanggliding.aero":true,"homebuilt.aero":true,"insurance.aero":true,"journal.aero":true,"journalist.aero":true,"leasing.aero":true,"logistics.aero":true,"magazine.aero":true,"maintenance.aero":true,"marketplace.aero":true,"media.aero":true,"microlight.aero":true,"modelling.aero":true,"navigation.aero":true,"parachuting.aero":true,"paragliding.aero":true,"passenger-association.aero":true,"pilot.aero":true,"press.aero":true,"production.aero":true,"recreation.aero":true,"repbody.aero":true,"res.aero":true,"research.aero":true,"rotorcraft.aero":true,"safety.aero":true,"scientist.aero":true,"services.aero":true,"show.aero":true,"skydiving.aero":true,"software.aero":true,"student.aero":true,"taxi.aero":true,"trader.aero":true,"trading.aero":true,"trainer.aero":true,"union.aero":true,"workinggroup.aero":true,"works.aero":true,"af":true,"gov.af":true,"com.af":true,"org.af":true,"net.af":true,"edu.af":true,"ag":true,"com.ag":true,"org.ag":true,"net.ag":true,"co.ag":true,"nom.ag":true,"ai":true,"off.ai":true,"com.ai":true,"net.ai":true,"org.ai":true,"al":true,"com.al":true,"edu.al":true,"gov.al":true,"mil.al":true,"net.al":true,"org.al":true,"am":true,"an":true,"com.an":true,"net.an":true,"org.an":true,"edu.an":true,"ao":true,"ed.ao":true,"gv.ao":true,"og.ao":true,"co.ao":true,"pb.ao":true,"it.ao":true,"aq":true,"ar":true,"com.ar":true,"edu.ar":true,"gob.ar":true,"gov.ar":true,"int.ar":true,"mil.ar":true,"net.ar":true,"org.ar":true,"tur.ar":true,"arpa":true,"e164.arpa":true,"in-addr.arpa":true,"ip6.arpa":true,"iris.arpa":true,"uri.arpa":true,"urn.arpa":true,"as":true,"gov.as":true,"asia":true,"at":true,"ac.at":true,"co.at":true,"gv.at":true,"or.at":true,"au":true,"com.au":true,"net.au":true,"org.au":true,"edu.au":true,"gov.au":true,"asn.au":true,"id.au":true,"info.au":true,"conf.au":true,"oz.au":true,"act.au":true,"nsw.au":true,"nt.au":true,"qld.au":true,"sa.au":true,"tas.au":true,"vic.au":true,"wa.au":true,"act.edu.au":true,"nsw.edu.au":true,"nt.edu.au":true,"qld.edu.au":true,"sa.edu.au":true,"tas.edu.au":true,"vic.edu.au":true,"wa.edu.au":true,"qld.gov.au":true,"sa.gov.au":true,"tas.gov.au":true,"vic.gov.au":true,"wa.gov.au":true,"aw":true,"com.aw":true,"ax":true,"az":true,"com.az":true,"net.az":true,"int.az":true,"gov.az":true,"org.az":true,"edu.az":true,"info.az":true,"pp.az":true,"mil.az":true,"name.az":true,"pro.az":true,"biz.az":true,"ba":true,"org.ba":true,"net.ba":true,"edu.ba":true,"gov.ba":true,"mil.ba":true,"unsa.ba":true,"unbi.ba":true,"co.ba":true,"com.ba":true,"rs.ba":true,"bb":true,"biz.bb":true,"co.bb":true,"com.bb":true,"edu.bb":true,"gov.bb":true,"info.bb":true,"net.bb":true,"org.bb":true,"store.bb":true,"tv.bb":true,"*.bd":true,"be":true,"ac.be":true,"bf":true,"gov.bf":true,"bg":true,"a.bg":true,"b.bg":true,"c.bg":true,"d.bg":true,"e.bg":true,"f.bg":true,"g.bg":true,"h.bg":true,"i.bg":true,"j.bg":true,"k.bg":true,"l.bg":true,"m.bg":true,"n.bg":true,"o.bg":true,"p.bg":true,"q.bg":true,"r.bg":true,"s.bg":true,"t.bg":true,"u.bg":true,"v.bg":true,"w.bg":true,"x.bg":true,"y.bg":true,"z.bg":true,"0.bg":true,"1.bg":true,"2.bg":true,"3.bg":true,"4.bg":true,"5.bg":true,"6.bg":true,"7.bg":true,"8.bg":true,"9.bg":true,"bh":true,"com.bh":true,"edu.bh":true,"net.bh":true,"org.bh":true,"gov.bh":true,"bi":true,"co.bi":true,"com.bi":true,"edu.bi":true,"or.bi":true,"org.bi":true,"biz":true,"bj":true,"asso.bj":true,"barreau.bj":true,"gouv.bj":true,"bm":true,"com.bm":true,"edu.bm":true,"gov.bm":true,"net.bm":true,"org.bm":true,"*.bn":true,"bo":true,"com.bo":true,"edu.bo":true,"gov.bo":true,"gob.bo":true,"int.bo":true,"org.bo":true,"net.bo":true,"mil.bo":true,"tv.bo":true,"br":true,"adm.br":true,"adv.br":true,"agr.br":true,"am.br":true,"arq.br":true,"art.br":true,"ato.br":true,"b.br":true,"bio.br":true,"blog.br":true,"bmd.br":true,"cim.br":true,"cng.br":true,"cnt.br":true,"com.br":true,"coop.br":true,"ecn.br":true,"eco.br":true,"edu.br":true,"emp.br":true,"eng.br":true,"esp.br":true,"etc.br":true,"eti.br":true,"far.br":true,"flog.br":true,"fm.br":true,"fnd.br":true,"fot.br":true,"fst.br":true,"g12.br":true,"ggf.br":true,"gov.br":true,"imb.br":true,"ind.br":true,"inf.br":true,"jor.br":true,"jus.br":true,"leg.br":true,"lel.br":true,"mat.br":true,"med.br":true,"mil.br":true,"mp.br":true,"mus.br":true,"net.br":true,"*.nom.br":true,"not.br":true,"ntr.br":true,"odo.br":true,"org.br":true,"ppg.br":true,"pro.br":true,"psc.br":true,"psi.br":true,"qsl.br":true,"radio.br":true,"rec.br":true,"slg.br":true,"srv.br":true,"taxi.br":true,"teo.br":true,"tmp.br":true,"trd.br":true,"tur.br":true,"tv.br":true,"vet.br":true,"vlog.br":true,"wiki.br":true,"zlg.br":true,"bs":true,"com.bs":true,"net.bs":true,"org.bs":true,"edu.bs":true,"gov.bs":true,"bt":true,"com.bt":true,"edu.bt":true,"gov.bt":true,"net.bt":true,"org.bt":true,"bv":true,"bw":true,"co.bw":true,"org.bw":true,"by":true,"gov.by":true,"mil.by":true,"com.by":true,"of.by":true,"bz":true,"com.bz":true,"net.bz":true,"org.bz":true,"edu.bz":true,"gov.bz":true,"ca":true,"ab.ca":true,"bc.ca":true,"mb.ca":true,"nb.ca":true,"nf.ca":true,"nl.ca":true,"ns.ca":true,"nt.ca":true,"nu.ca":true,"on.ca":true,"pe.ca":true,"qc.ca":true,"sk.ca":true,"yk.ca":true,"gc.ca":true,"cat":true,"cc":true,"cd":true,"gov.cd":true,"cf":true,"cg":true,"ch":true,"ci":true,"org.ci":true,"or.ci":true,"com.ci":true,"co.ci":true,"edu.ci":true,"ed.ci":true,"ac.ci":true,"net.ci":true,"go.ci":true,"asso.ci":true,"xn--aroport-bya.ci":true,"int.ci":true,"presse.ci":true,"md.ci":true,"gouv.ci":true,"*.ck":true,"www.ck":false,"cl":true,"gov.cl":true,"gob.cl":true,"co.cl":true,"mil.cl":true,"cm":true,"co.cm":true,"com.cm":true,"gov.cm":true,"net.cm":true,"cn":true,"ac.cn":true,"com.cn":true,"edu.cn":true,"gov.cn":true,"net.cn":true,"org.cn":true,"mil.cn":true,"xn--55qx5d.cn":true,"xn--io0a7i.cn":true,"xn--od0alg.cn":true,"ah.cn":true,"bj.cn":true,"cq.cn":true,"fj.cn":true,"gd.cn":true,"gs.cn":true,"gz.cn":true,"gx.cn":true,"ha.cn":true,"hb.cn":true,"he.cn":true,"hi.cn":true,"hl.cn":true,"hn.cn":true,"jl.cn":true,"js.cn":true,"jx.cn":true,"ln.cn":true,"nm.cn":true,"nx.cn":true,"qh.cn":true,"sc.cn":true,"sd.cn":true,"sh.cn":true,"sn.cn":true,"sx.cn":true,"tj.cn":true,"xj.cn":true,"xz.cn":true,"yn.cn":true,"zj.cn":true,"hk.cn":true,"mo.cn":true,"tw.cn":true,"co":true,"arts.co":true,"com.co":true,"edu.co":true,"firm.co":true,"gov.co":true,"info.co":true,"int.co":true,"mil.co":true,"net.co":true,"nom.co":true,"org.co":true,"rec.co":true,"web.co":true,"com":true,"coop":true,"cr":true,"ac.cr":true,"co.cr":true,"ed.cr":true,"fi.cr":true,"go.cr":true,"or.cr":true,"sa.cr":true,"cu":true,"com.cu":true,"edu.cu":true,"org.cu":true,"net.cu":true,"gov.cu":true,"inf.cu":true,"cv":true,"cw":true,"com.cw":true,"edu.cw":true,"net.cw":true,"org.cw":true,"cx":true,"gov.cx":true,"*.cy":true,"cz":true,"de":true,"dj":true,"dk":true,"dm":true,"com.dm":true,"net.dm":true,"org.dm":true,"edu.dm":true,"gov.dm":true,"do":true,"art.do":true,"com.do":true,"edu.do":true,"gob.do":true,"gov.do":true,"mil.do":true,"net.do":true,"org.do":true,"sld.do":true,"web.do":true,"dz":true,"com.dz":true,"org.dz":true,"net.dz":true,"gov.dz":true,"edu.dz":true,"asso.dz":true,"pol.dz":true,"art.dz":true,"ec":true,"com.ec":true,"info.ec":true,"net.ec":true,"fin.ec":true,"k12.ec":true,"med.ec":true,"pro.ec":true,"org.ec":true,"edu.ec":true,"gov.ec":true,"gob.ec":true,"mil.ec":true,"edu":true,"ee":true,"edu.ee":true,"gov.ee":true,"riik.ee":true,"lib.ee":true,"med.ee":true,"com.ee":true,"pri.ee":true,"aip.ee":true,"org.ee":true,"fie.ee":true,"eg":true,"com.eg":true,"edu.eg":true,"eun.eg":true,"gov.eg":true,"mil.eg":true,"name.eg":true,"net.eg":true,"org.eg":true,"sci.eg":true,"*.er":true,"es":true,"com.es":true,"nom.es":true,"org.es":true,"gob.es":true,"edu.es":true,"et":true,"com.et":true,"gov.et":true,"org.et":true,"edu.et":true,"biz.et":true,"name.et":true,"info.et":true,"eu":true,"fi":true,"aland.fi":true,"*.fj":true,"*.fk":true,"fm":true,"fo":true,"fr":true,"com.fr":true,"asso.fr":true,"nom.fr":true,"prd.fr":true,"presse.fr":true,"tm.fr":true,"aeroport.fr":true,"assedic.fr":true,"avocat.fr":true,"avoues.fr":true,"cci.fr":true,"chambagri.fr":true,"chirurgiens-dentistes.fr":true,"experts-comptables.fr":true,"geometre-expert.fr":true,"gouv.fr":true,"greta.fr":true,"huissier-justice.fr":true,"medecin.fr":true,"notaires.fr":true,"pharmacien.fr":true,"port.fr":true,"veterinaire.fr":true,"ga":true,"gb":true,"gd":true,"ge":true,"com.ge":true,"edu.ge":true,"gov.ge":true,"org.ge":true,"mil.ge":true,"net.ge":true,"pvt.ge":true,"gf":true,"gg":true,"co.gg":true,"net.gg":true,"org.gg":true,"gh":true,"com.gh":true,"edu.gh":true,"gov.gh":true,"org.gh":true,"mil.gh":true,"gi":true,"com.gi":true,"ltd.gi":true,"gov.gi":true,"mod.gi":true,"edu.gi":true,"org.gi":true,"gl":true,"gm":true,"gn":true,"ac.gn":true,"com.gn":true,"edu.gn":true,"gov.gn":true,"org.gn":true,"net.gn":true,"gov":true,"gp":true,"com.gp":true,"net.gp":true,"mobi.gp":true,"edu.gp":true,"org.gp":true,"asso.gp":true,"gq":true,"gr":true,"com.gr":true,"edu.gr":true,"net.gr":true,"org.gr":true,"gov.gr":true,"gs":true,"gt":true,"com.gt":true,"edu.gt":true,"gob.gt":true,"ind.gt":true,"mil.gt":true,"net.gt":true,"org.gt":true,"*.gu":true,"gw":true,"gy":true,"co.gy":true,"com.gy":true,"net.gy":true,"hk":true,"com.hk":true,"edu.hk":true,"gov.hk":true,"idv.hk":true,"net.hk":true,"org.hk":true,"xn--55qx5d.hk":true,"xn--wcvs22d.hk":true,"xn--lcvr32d.hk":true,"xn--mxtq1m.hk":true,"xn--gmqw5a.hk":true,"xn--ciqpn.hk":true,"xn--gmq050i.hk":true,"xn--zf0avx.hk":true,"xn--io0a7i.hk":true,"xn--mk0axi.hk":true,"xn--od0alg.hk":true,"xn--od0aq3b.hk":true,"xn--tn0ag.hk":true,"xn--uc0atv.hk":true,"xn--uc0ay4a.hk":true,"hm":true,"hn":true,"com.hn":true,"edu.hn":true,"org.hn":true,"net.hn":true,"mil.hn":true,"gob.hn":true,"hr":true,"iz.hr":true,"from.hr":true,"name.hr":true,"com.hr":true,"ht":true,"com.ht":true,"shop.ht":true,"firm.ht":true,"info.ht":true,"adult.ht":true,"net.ht":true,"pro.ht":true,"org.ht":true,"med.ht":true,"art.ht":true,"coop.ht":true,"pol.ht":true,"asso.ht":true,"edu.ht":true,"rel.ht":true,"gouv.ht":true,"perso.ht":true,"hu":true,"co.hu":true,"info.hu":true,"org.hu":true,"priv.hu":true,"sport.hu":true,"tm.hu":true,"2000.hu":true,"agrar.hu":true,"bolt.hu":true,"casino.hu":true,"city.hu":true,"erotica.hu":true,"erotika.hu":true,"film.hu":true,"forum.hu":true,"games.hu":true,"hotel.hu":true,"ingatlan.hu":true,"jogasz.hu":true,"konyvelo.hu":true,"lakas.hu":true,"media.hu":true,"news.hu":true,"reklam.hu":true,"sex.hu":true,"shop.hu":true,"suli.hu":true,"szex.hu":true,"tozsde.hu":true,"utazas.hu":true,"video.hu":true,"id":true,"ac.id":true,"biz.id":true,"co.id":true,"desa.id":true,"go.id":true,"mil.id":true,"my.id":true,"net.id":true,"or.id":true,"sch.id":true,"web.id":true,"ie":true,"gov.ie":true,"*.il":true,"im":true,"ac.im":true,"co.im":true,"com.im":true,"ltd.co.im":true,"net.im":true,"org.im":true,"plc.co.im":true,"tt.im":true,"tv.im":true,"in":true,"co.in":true,"firm.in":true,"net.in":true,"org.in":true,"gen.in":true,"ind.in":true,"nic.in":true,"ac.in":true,"edu.in":true,"res.in":true,"gov.in":true,"mil.in":true,"info":true,"int":true,"eu.int":true,"io":true,"com.io":true,"iq":true,"gov.iq":true,"edu.iq":true,"mil.iq":true,"com.iq":true,"org.iq":true,"net.iq":true,"ir":true,"ac.ir":true,"co.ir":true,"gov.ir":true,"id.ir":true,"net.ir":true,"org.ir":true,"sch.ir":true,"xn--mgba3a4f16a.ir":true,"xn--mgba3a4fra.ir":true,"is":true,"net.is":true,"com.is":true,"edu.is":true,"gov.is":true,"org.is":true,"int.is":true,"it":true,"gov.it":true,"edu.it":true,"abr.it":true,"abruzzo.it":true,"aosta-valley.it":true,"aostavalley.it":true,"bas.it":true,"basilicata.it":true,"cal.it":true,"calabria.it":true,"cam.it":true,"campania.it":true,"emilia-romagna.it":true,"emiliaromagna.it":true,"emr.it":true,"friuli-v-giulia.it":true,"friuli-ve-giulia.it":true,"friuli-vegiulia.it":true,"friuli-venezia-giulia.it":true,"friuli-veneziagiulia.it":true,"friuli-vgiulia.it":true,"friuliv-giulia.it":true,"friulive-giulia.it":true,"friulivegiulia.it":true,"friulivenezia-giulia.it":true,"friuliveneziagiulia.it":true,"friulivgiulia.it":true,"fvg.it":true,"laz.it":true,"lazio.it":true,"lig.it":true,"liguria.it":true,"lom.it":true,"lombardia.it":true,"lombardy.it":true,"lucania.it":true,"mar.it":true,"marche.it":true,"mol.it":true,"molise.it":true,"piedmont.it":true,"piemonte.it":true,"pmn.it":true,"pug.it":true,"puglia.it":true,"sar.it":true,"sardegna.it":true,"sardinia.it":true,"sic.it":true,"sicilia.it":true,"sicily.it":true,"taa.it":true,"tos.it":true,"toscana.it":true,"trentino-a-adige.it":true,"trentino-aadige.it":true,"trentino-alto-adige.it":true,"trentino-altoadige.it":true,"trentino-s-tirol.it":true,"trentino-stirol.it":true,"trentino-sud-tirol.it":true,"trentino-sudtirol.it":true,"trentino-sued-tirol.it":true,"trentino-suedtirol.it":true,"trentinoa-adige.it":true,"trentinoaadige.it":true,"trentinoalto-adige.it":true,"trentinoaltoadige.it":true,"trentinos-tirol.it":true,"trentinostirol.it":true,"trentinosud-tirol.it":true,"trentinosudtirol.it":true,"trentinosued-tirol.it":true,"trentinosuedtirol.it":true,"tuscany.it":true,"umb.it":true,"umbria.it":true,"val-d-aosta.it":true,"val-daosta.it":true,"vald-aosta.it":true,"valdaosta.it":true,"valle-aosta.it":true,"valle-d-aosta.it":true,"valle-daosta.it":true,"valleaosta.it":true,"valled-aosta.it":true,"valledaosta.it":true,"vallee-aoste.it":true,"valleeaoste.it":true,"vao.it":true,"vda.it":true,"ven.it":true,"veneto.it":true,"ag.it":true,"agrigento.it":true,"al.it":true,"alessandria.it":true,"alto-adige.it":true,"altoadige.it":true,"an.it":true,"ancona.it":true,"andria-barletta-trani.it":true,"andria-trani-barletta.it":true,"andriabarlettatrani.it":true,"andriatranibarletta.it":true,"ao.it":true,"aosta.it":true,"aoste.it":true,"ap.it":true,"aq.it":true,"aquila.it":true,"ar.it":true,"arezzo.it":true,"ascoli-piceno.it":true,"ascolipiceno.it":true,"asti.it":true,"at.it":true,"av.it":true,"avellino.it":true,"ba.it":true,"balsan.it":true,"bari.it":true,"barletta-trani-andria.it":true,"barlettatraniandria.it":true,"belluno.it":true,"benevento.it":true,"bergamo.it":true,"bg.it":true,"bi.it":true,"biella.it":true,"bl.it":true,"bn.it":true,"bo.it":true,"bologna.it":true,"bolzano.it":true,"bozen.it":true,"br.it":true,"brescia.it":true,"brindisi.it":true,"bs.it":true,"bt.it":true,"bz.it":true,"ca.it":true,"cagliari.it":true,"caltanissetta.it":true,"campidano-medio.it":true,"campidanomedio.it":true,"campobasso.it":true,"carbonia-iglesias.it":true,"carboniaiglesias.it":true,"carrara-massa.it":true,"carraramassa.it":true,"caserta.it":true,"catania.it":true,"catanzaro.it":true,"cb.it":true,"ce.it":true,"cesena-forli.it":true,"cesenaforli.it":true,"ch.it":true,"chieti.it":true,"ci.it":true,"cl.it":true,"cn.it":true,"co.it":true,"como.it":true,"cosenza.it":true,"cr.it":true,"cremona.it":true,"crotone.it":true,"cs.it":true,"ct.it":true,"cuneo.it":true,"cz.it":true,"dell-ogliastra.it":true,"dellogliastra.it":true,"en.it":true,"enna.it":true,"fc.it":true,"fe.it":true,"fermo.it":true,"ferrara.it":true,"fg.it":true,"fi.it":true,"firenze.it":true,"florence.it":true,"fm.it":true,"foggia.it":true,"forli-cesena.it":true,"forlicesena.it":true,"fr.it":true,"frosinone.it":true,"ge.it":true,"genoa.it":true,"genova.it":true,"go.it":true,"gorizia.it":true,"gr.it":true,"grosseto.it":true,"iglesias-carbonia.it":true,"iglesiascarbonia.it":true,"im.it":true,"imperia.it":true,"is.it":true,"isernia.it":true,"kr.it":true,"la-spezia.it":true,"laquila.it":true,"laspezia.it":true,"latina.it":true,"lc.it":true,"le.it":true,"lecce.it":true,"lecco.it":true,"li.it":true,"livorno.it":true,"lo.it":true,"lodi.it":true,"lt.it":true,"lu.it":true,"lucca.it":true,"macerata.it":true,"mantova.it":true,"massa-carrara.it":true,"massacarrara.it":true,"matera.it":true,"mb.it":true,"mc.it":true,"me.it":true,"medio-campidano.it":true,"mediocampidano.it":true,"messina.it":true,"mi.it":true,"milan.it":true,"milano.it":true,"mn.it":true,"mo.it":true,"modena.it":true,"monza-brianza.it":true,"monza-e-della-brianza.it":true,"monza.it":true,"monzabrianza.it":true,"monzaebrianza.it":true,"monzaedellabrianza.it":true,"ms.it":true,"mt.it":true,"na.it":true,"naples.it":true,"napoli.it":true,"no.it":true,"novara.it":true,"nu.it":true,"nuoro.it":true,"og.it":true,"ogliastra.it":true,"olbia-tempio.it":true,"olbiatempio.it":true,"or.it":true,"oristano.it":true,"ot.it":true,"pa.it":true,"padova.it":true,"padua.it":true,"palermo.it":true,"parma.it":true,"pavia.it":true,"pc.it":true,"pd.it":true,"pe.it":true,"perugia.it":true,"pesaro-urbino.it":true,"pesarourbino.it":true,"pescara.it":true,"pg.it":true,"pi.it":true,"piacenza.it":true,"pisa.it":true,"pistoia.it":true,"pn.it":true,"po.it":true,"pordenone.it":true,"potenza.it":true,"pr.it":true,"prato.it":true,"pt.it":true,"pu.it":true,"pv.it":true,"pz.it":true,"ra.it":true,"ragusa.it":true,"ravenna.it":true,"rc.it":true,"re.it":true,"reggio-calabria.it":true,"reggio-emilia.it":true,"reggiocalabria.it":true,"reggioemilia.it":true,"rg.it":true,"ri.it":true,"rieti.it":true,"rimini.it":true,"rm.it":true,"rn.it":true,"ro.it":true,"roma.it":true,"rome.it":true,"rovigo.it":true,"sa.it":true,"salerno.it":true,"sassari.it":true,"savona.it":true,"si.it":true,"siena.it":true,"siracusa.it":true,"so.it":true,"sondrio.it":true,"sp.it":true,"sr.it":true,"ss.it":true,"suedtirol.it":true,"sv.it":true,"ta.it":true,"taranto.it":true,"te.it":true,"tempio-olbia.it":true,"tempioolbia.it":true,"teramo.it":true,"terni.it":true,"tn.it":true,"to.it":true,"torino.it":true,"tp.it":true,"tr.it":true,"trani-andria-barletta.it":true,"trani-barletta-andria.it":true,"traniandriabarletta.it":true,"tranibarlettaandria.it":true,"trapani.it":true,"trentino.it":true,"trento.it":true,"treviso.it":true,"trieste.it":true,"ts.it":true,"turin.it":true,"tv.it":true,"ud.it":true,"udine.it":true,"urbino-pesaro.it":true,"urbinopesaro.it":true,"va.it":true,"varese.it":true,"vb.it":true,"vc.it":true,"ve.it":true,"venezia.it":true,"venice.it":true,"verbania.it":true,"vercelli.it":true,"verona.it":true,"vi.it":true,"vibo-valentia.it":true,"vibovalentia.it":true,"vicenza.it":true,"viterbo.it":true,"vr.it":true,"vs.it":true,"vt.it":true,"vv.it":true,"je":true,"co.je":true,"net.je":true,"org.je":true,"*.jm":true,"jo":true,"com.jo":true,"org.jo":true,"net.jo":true,"edu.jo":true,"sch.jo":true,"gov.jo":true,"mil.jo":true,"name.jo":true,"jobs":true,"jp":true,"ac.jp":true,"ad.jp":true,"co.jp":true,"ed.jp":true,"go.jp":true,"gr.jp":true,"lg.jp":true,"ne.jp":true,"or.jp":true,"aichi.jp":true,"akita.jp":true,"aomori.jp":true,"chiba.jp":true,"ehime.jp":true,"fukui.jp":true,"fukuoka.jp":true,"fukushima.jp":true,"gifu.jp":true,"gunma.jp":true,"hiroshima.jp":true,"hokkaido.jp":true,"hyogo.jp":true,"ibaraki.jp":true,"ishikawa.jp":true,"iwate.jp":true,"kagawa.jp":true,"kagoshima.jp":true,"kanagawa.jp":true,"kochi.jp":true,"kumamoto.jp":true,"kyoto.jp":true,"mie.jp":true,"miyagi.jp":true,"miyazaki.jp":true,"nagano.jp":true,"nagasaki.jp":true,"nara.jp":true,"niigata.jp":true,"oita.jp":true,"okayama.jp":true,"okinawa.jp":true,"osaka.jp":true,"saga.jp":true,"saitama.jp":true,"shiga.jp":true,"shimane.jp":true,"shizuoka.jp":true,"tochigi.jp":true,"tokushima.jp":true,"tokyo.jp":true,"tottori.jp":true,"toyama.jp":true,"wakayama.jp":true,"yamagata.jp":true,"yamaguchi.jp":true,"yamanashi.jp":true,"xn--4pvxs.jp":true,"xn--vgu402c.jp":true,"xn--c3s14m.jp":true,"xn--f6qx53a.jp":true,"xn--8pvr4u.jp":true,"xn--uist22h.jp":true,"xn--djrs72d6uy.jp":true,"xn--mkru45i.jp":true,"xn--0trq7p7nn.jp":true,"xn--8ltr62k.jp":true,"xn--2m4a15e.jp":true,"xn--efvn9s.jp":true,"xn--32vp30h.jp":true,"xn--4it797k.jp":true,"xn--1lqs71d.jp":true,"xn--5rtp49c.jp":true,"xn--5js045d.jp":true,"xn--ehqz56n.jp":true,"xn--1lqs03n.jp":true,"xn--qqqt11m.jp":true,"xn--kbrq7o.jp":true,"xn--pssu33l.jp":true,"xn--ntsq17g.jp":true,"xn--uisz3g.jp":true,"xn--6btw5a.jp":true,"xn--1ctwo.jp":true,"xn--6orx2r.jp":true,"xn--rht61e.jp":true,"xn--rht27z.jp":true,"xn--djty4k.jp":true,"xn--nit225k.jp":true,"xn--rht3d.jp":true,"xn--klty5x.jp":true,"xn--kltx9a.jp":true,"xn--kltp7d.jp":true,"xn--uuwu58a.jp":true,"xn--zbx025d.jp":true,"xn--ntso0iqx3a.jp":true,"xn--elqq16h.jp":true,"xn--4it168d.jp":true,"xn--klt787d.jp":true,"xn--rny31h.jp":true,"xn--7t0a264c.jp":true,"xn--5rtq34k.jp":true,"xn--k7yn95e.jp":true,"xn--tor131o.jp":true,"xn--d5qv7z876c.jp":true,"*.kawasaki.jp":true,"*.kitakyushu.jp":true,"*.kobe.jp":true,"*.nagoya.jp":true,"*.sapporo.jp":true,"*.sendai.jp":true,"*.yokohama.jp":true,"city.kawasaki.jp":false,"city.kitakyushu.jp":false,"city.kobe.jp":false,"city.nagoya.jp":false,"city.sapporo.jp":false,"city.sendai.jp":false,"city.yokohama.jp":false,"aisai.aichi.jp":true,"ama.aichi.jp":true,"anjo.aichi.jp":true,"asuke.aichi.jp":true,"chiryu.aichi.jp":true,"chita.aichi.jp":true,"fuso.aichi.jp":true,"gamagori.aichi.jp":true,"handa.aichi.jp":true,"hazu.aichi.jp":true,"hekinan.aichi.jp":true,"higashiura.aichi.jp":true,"ichinomiya.aichi.jp":true,"inazawa.aichi.jp":true,"inuyama.aichi.jp":true,"isshiki.aichi.jp":true,"iwakura.aichi.jp":true,"kanie.aichi.jp":true,"kariya.aichi.jp":true,"kasugai.aichi.jp":true,"kira.aichi.jp":true,"kiyosu.aichi.jp":true,"komaki.aichi.jp":true,"konan.aichi.jp":true,"kota.aichi.jp":true,"mihama.aichi.jp":true,"miyoshi.aichi.jp":true,"nishio.aichi.jp":true,"nisshin.aichi.jp":true,"obu.aichi.jp":true,"oguchi.aichi.jp":true,"oharu.aichi.jp":true,"okazaki.aichi.jp":true,"owariasahi.aichi.jp":true,"seto.aichi.jp":true,"shikatsu.aichi.jp":true,"shinshiro.aichi.jp":true,"shitara.aichi.jp":true,"tahara.aichi.jp":true,"takahama.aichi.jp":true,"tobishima.aichi.jp":true,"toei.aichi.jp":true,"togo.aichi.jp":true,"tokai.aichi.jp":true,"tokoname.aichi.jp":true,"toyoake.aichi.jp":true,"toyohashi.aichi.jp":true,"toyokawa.aichi.jp":true,"toyone.aichi.jp":true,"toyota.aichi.jp":true,"tsushima.aichi.jp":true,"yatomi.aichi.jp":true,"akita.akita.jp":true,"daisen.akita.jp":true,"fujisato.akita.jp":true,"gojome.akita.jp":true,"hachirogata.akita.jp":true,"happou.akita.jp":true,"higashinaruse.akita.jp":true,"honjo.akita.jp":true,"honjyo.akita.jp":true,"ikawa.akita.jp":true,"kamikoani.akita.jp":true,"kamioka.akita.jp":true,"katagami.akita.jp":true,"kazuno.akita.jp":true,"kitaakita.akita.jp":true,"kosaka.akita.jp":true,"kyowa.akita.jp":true,"misato.akita.jp":true,"mitane.akita.jp":true,"moriyoshi.akita.jp":true,"nikaho.akita.jp":true,"noshiro.akita.jp":true,"odate.akita.jp":true,"oga.akita.jp":true,"ogata.akita.jp":true,"semboku.akita.jp":true,"yokote.akita.jp":true,"yurihonjo.akita.jp":true,"aomori.aomori.jp":true,"gonohe.aomori.jp":true,"hachinohe.aomori.jp":true,"hashikami.aomori.jp":true,"hiranai.aomori.jp":true,"hirosaki.aomori.jp":true,"itayanagi.aomori.jp":true,"kuroishi.aomori.jp":true,"misawa.aomori.jp":true,"mutsu.aomori.jp":true,"nakadomari.aomori.jp":true,"noheji.aomori.jp":true,"oirase.aomori.jp":true,"owani.aomori.jp":true,"rokunohe.aomori.jp":true,"sannohe.aomori.jp":true,"shichinohe.aomori.jp":true,"shingo.aomori.jp":true,"takko.aomori.jp":true,"towada.aomori.jp":true,"tsugaru.aomori.jp":true,"tsuruta.aomori.jp":true,"abiko.chiba.jp":true,"asahi.chiba.jp":true,"chonan.chiba.jp":true,"chosei.chiba.jp":true,"choshi.chiba.jp":true,"chuo.chiba.jp":true,"funabashi.chiba.jp":true,"futtsu.chiba.jp":true,"hanamigawa.chiba.jp":true,"ichihara.chiba.jp":true,"ichikawa.chiba.jp":true,"ichinomiya.chiba.jp":true,"inzai.chiba.jp":true,"isumi.chiba.jp":true,"kamagaya.chiba.jp":true,"kamogawa.chiba.jp":true,"kashiwa.chiba.jp":true,"katori.chiba.jp":true,"katsuura.chiba.jp":true,"kimitsu.chiba.jp":true,"kisarazu.chiba.jp":true,"kozaki.chiba.jp":true,"kujukuri.chiba.jp":true,"kyonan.chiba.jp":true,"matsudo.chiba.jp":true,"midori.chiba.jp":true,"mihama.chiba.jp":true,"minamiboso.chiba.jp":true,"mobara.chiba.jp":true,"mutsuzawa.chiba.jp":true,"nagara.chiba.jp":true,"nagareyama.chiba.jp":true,"narashino.chiba.jp":true,"narita.chiba.jp":true,"noda.chiba.jp":true,"oamishirasato.chiba.jp":true,"omigawa.chiba.jp":true,"onjuku.chiba.jp":true,"otaki.chiba.jp":true,"sakae.chiba.jp":true,"sakura.chiba.jp":true,"shimofusa.chiba.jp":true,"shirako.chiba.jp":true,"shiroi.chiba.jp":true,"shisui.chiba.jp":true,"sodegaura.chiba.jp":true,"sosa.chiba.jp":true,"tako.chiba.jp":true,"tateyama.chiba.jp":true,"togane.chiba.jp":true,"tohnosho.chiba.jp":true,"tomisato.chiba.jp":true,"urayasu.chiba.jp":true,"yachimata.chiba.jp":true,"yachiyo.chiba.jp":true,"yokaichiba.chiba.jp":true,"yokoshibahikari.chiba.jp":true,"yotsukaido.chiba.jp":true,"ainan.ehime.jp":true,"honai.ehime.jp":true,"ikata.ehime.jp":true,"imabari.ehime.jp":true,"iyo.ehime.jp":true,"kamijima.ehime.jp":true,"kihoku.ehime.jp":true,"kumakogen.ehime.jp":true,"masaki.ehime.jp":true,"matsuno.ehime.jp":true,"matsuyama.ehime.jp":true,"namikata.ehime.jp":true,"niihama.ehime.jp":true,"ozu.ehime.jp":true,"saijo.ehime.jp":true,"seiyo.ehime.jp":true,"shikokuchuo.ehime.jp":true,"tobe.ehime.jp":true,"toon.ehime.jp":true,"uchiko.ehime.jp":true,"uwajima.ehime.jp":true,"yawatahama.ehime.jp":true,"echizen.fukui.jp":true,"eiheiji.fukui.jp":true,"fukui.fukui.jp":true,"ikeda.fukui.jp":true,"katsuyama.fukui.jp":true,"mihama.fukui.jp":true,"minamiechizen.fukui.jp":true,"obama.fukui.jp":true,"ohi.fukui.jp":true,"ono.fukui.jp":true,"sabae.fukui.jp":true,"sakai.fukui.jp":true,"takahama.fukui.jp":true,"tsuruga.fukui.jp":true,"wakasa.fukui.jp":true,"ashiya.fukuoka.jp":true,"buzen.fukuoka.jp":true,"chikugo.fukuoka.jp":true,"chikuho.fukuoka.jp":true,"chikujo.fukuoka.jp":true,"chikushino.fukuoka.jp":true,"chikuzen.fukuoka.jp":true,"chuo.fukuoka.jp":true,"dazaifu.fukuoka.jp":true,"fukuchi.fukuoka.jp":true,"hakata.fukuoka.jp":true,"higashi.fukuoka.jp":true,"hirokawa.fukuoka.jp":true,"hisayama.fukuoka.jp":true,"iizuka.fukuoka.jp":true,"inatsuki.fukuoka.jp":true,"kaho.fukuoka.jp":true,"kasuga.fukuoka.jp":true,"kasuya.fukuoka.jp":true,"kawara.fukuoka.jp":true,"keisen.fukuoka.jp":true,"koga.fukuoka.jp":true,"kurate.fukuoka.jp":true,"kurogi.fukuoka.jp":true,"kurume.fukuoka.jp":true,"minami.fukuoka.jp":true,"miyako.fukuoka.jp":true,"miyama.fukuoka.jp":true,"miyawaka.fukuoka.jp":true,"mizumaki.fukuoka.jp":true,"munakata.fukuoka.jp":true,"nakagawa.fukuoka.jp":true,"nakama.fukuoka.jp":true,"nishi.fukuoka.jp":true,"nogata.fukuoka.jp":true,"ogori.fukuoka.jp":true,"okagaki.fukuoka.jp":true,"okawa.fukuoka.jp":true,"oki.fukuoka.jp":true,"omuta.fukuoka.jp":true,"onga.fukuoka.jp":true,"onojo.fukuoka.jp":true,"oto.fukuoka.jp":true,"saigawa.fukuoka.jp":true,"sasaguri.fukuoka.jp":true,"shingu.fukuoka.jp":true,"shinyoshitomi.fukuoka.jp":true,"shonai.fukuoka.jp":true,"soeda.fukuoka.jp":true,"sue.fukuoka.jp":true,"tachiarai.fukuoka.jp":true,"tagawa.fukuoka.jp":true,"takata.fukuoka.jp":true,"toho.fukuoka.jp":true,"toyotsu.fukuoka.jp":true,"tsuiki.fukuoka.jp":true,"ukiha.fukuoka.jp":true,"umi.fukuoka.jp":true,"usui.fukuoka.jp":true,"yamada.fukuoka.jp":true,"yame.fukuoka.jp":true,"yanagawa.fukuoka.jp":true,"yukuhashi.fukuoka.jp":true,"aizubange.fukushima.jp":true,"aizumisato.fukushima.jp":true,"aizuwakamatsu.fukushima.jp":true,"asakawa.fukushima.jp":true,"bandai.fukushima.jp":true,"date.fukushima.jp":true,"fukushima.fukushima.jp":true,"furudono.fukushima.jp":true,"futaba.fukushima.jp":true,"hanawa.fukushima.jp":true,"higashi.fukushima.jp":true,"hirata.fukushima.jp":true,"hirono.fukushima.jp":true,"iitate.fukushima.jp":true,"inawashiro.fukushima.jp":true,"ishikawa.fukushima.jp":true,"iwaki.fukushima.jp":true,"izumizaki.fukushima.jp":true,"kagamiishi.fukushima.jp":true,"kaneyama.fukushima.jp":true,"kawamata.fukushima.jp":true,"kitakata.fukushima.jp":true,"kitashiobara.fukushima.jp":true,"koori.fukushima.jp":true,"koriyama.fukushima.jp":true,"kunimi.fukushima.jp":true,"miharu.fukushima.jp":true,"mishima.fukushima.jp":true,"namie.fukushima.jp":true,"nango.fukushima.jp":true,"nishiaizu.fukushima.jp":true,"nishigo.fukushima.jp":true,"okuma.fukushima.jp":true,"omotego.fukushima.jp":true,"ono.fukushima.jp":true,"otama.fukushima.jp":true,"samegawa.fukushima.jp":true,"shimogo.fukushima.jp":true,"shirakawa.fukushima.jp":true,"showa.fukushima.jp":true,"soma.fukushima.jp":true,"sukagawa.fukushima.jp":true,"taishin.fukushima.jp":true,"tamakawa.fukushima.jp":true,"tanagura.fukushima.jp":true,"tenei.fukushima.jp":true,"yabuki.fukushima.jp":true,"yamato.fukushima.jp":true,"yamatsuri.fukushima.jp":true,"yanaizu.fukushima.jp":true,"yugawa.fukushima.jp":true,"anpachi.gifu.jp":true,"ena.gifu.jp":true,"gifu.gifu.jp":true,"ginan.gifu.jp":true,"godo.gifu.jp":true,"gujo.gifu.jp":true,"hashima.gifu.jp":true,"hichiso.gifu.jp":true,"hida.gifu.jp":true,"higashishirakawa.gifu.jp":true,"ibigawa.gifu.jp":true,"ikeda.gifu.jp":true,"kakamigahara.gifu.jp":true,"kani.gifu.jp":true,"kasahara.gifu.jp":true,"kasamatsu.gifu.jp":true,"kawaue.gifu.jp":true,"kitagata.gifu.jp":true,"mino.gifu.jp":true,"minokamo.gifu.jp":true,"mitake.gifu.jp":true,"mizunami.gifu.jp":true,"motosu.gifu.jp":true,"nakatsugawa.gifu.jp":true,"ogaki.gifu.jp":true,"sakahogi.gifu.jp":true,"seki.gifu.jp":true,"sekigahara.gifu.jp":true,"shirakawa.gifu.jp":true,"tajimi.gifu.jp":true,"takayama.gifu.jp":true,"tarui.gifu.jp":true,"toki.gifu.jp":true,"tomika.gifu.jp":true,"wanouchi.gifu.jp":true,"yamagata.gifu.jp":true,"yaotsu.gifu.jp":true,"yoro.gifu.jp":true,"annaka.gunma.jp":true,"chiyoda.gunma.jp":true,"fujioka.gunma.jp":true,"higashiagatsuma.gunma.jp":true,"isesaki.gunma.jp":true,"itakura.gunma.jp":true,"kanna.gunma.jp":true,"kanra.gunma.jp":true,"katashina.gunma.jp":true,"kawaba.gunma.jp":true,"kiryu.gunma.jp":true,"kusatsu.gunma.jp":true,"maebashi.gunma.jp":true,"meiwa.gunma.jp":true,"midori.gunma.jp":true,"minakami.gunma.jp":true,"naganohara.gunma.jp":true,"nakanojo.gunma.jp":true,"nanmoku.gunma.jp":true,"numata.gunma.jp":true,"oizumi.gunma.jp":true,"ora.gunma.jp":true,"ota.gunma.jp":true,"shibukawa.gunma.jp":true,"shimonita.gunma.jp":true,"shinto.gunma.jp":true,"showa.gunma.jp":true,"takasaki.gunma.jp":true,"takayama.gunma.jp":true,"tamamura.gunma.jp":true,"tatebayashi.gunma.jp":true,"tomioka.gunma.jp":true,"tsukiyono.gunma.jp":true,"tsumagoi.gunma.jp":true,"ueno.gunma.jp":true,"yoshioka.gunma.jp":true,"asaminami.hiroshima.jp":true,"daiwa.hiroshima.jp":true,"etajima.hiroshima.jp":true,"fuchu.hiroshima.jp":true,"fukuyama.hiroshima.jp":true,"hatsukaichi.hiroshima.jp":true,"higashihiroshima.hiroshima.jp":true,"hongo.hiroshima.jp":true,"jinsekikogen.hiroshima.jp":true,"kaita.hiroshima.jp":true,"kui.hiroshima.jp":true,"kumano.hiroshima.jp":true,"kure.hiroshima.jp":true,"mihara.hiroshima.jp":true,"miyoshi.hiroshima.jp":true,"naka.hiroshima.jp":true,"onomichi.hiroshima.jp":true,"osakikamijima.hiroshima.jp":true,"otake.hiroshima.jp":true,"saka.hiroshima.jp":true,"sera.hiroshima.jp":true,"seranishi.hiroshima.jp":true,"shinichi.hiroshima.jp":true,"shobara.hiroshima.jp":true,"takehara.hiroshima.jp":true,"abashiri.hokkaido.jp":true,"abira.hokkaido.jp":true,"aibetsu.hokkaido.jp":true,"akabira.hokkaido.jp":true,"akkeshi.hokkaido.jp":true,"asahikawa.hokkaido.jp":true,"ashibetsu.hokkaido.jp":true,"ashoro.hokkaido.jp":true,"assabu.hokkaido.jp":true,"atsuma.hokkaido.jp":true,"bibai.hokkaido.jp":true,"biei.hokkaido.jp":true,"bifuka.hokkaido.jp":true,"bihoro.hokkaido.jp":true,"biratori.hokkaido.jp":true,"chippubetsu.hokkaido.jp":true,"chitose.hokkaido.jp":true,"date.hokkaido.jp":true,"ebetsu.hokkaido.jp":true,"embetsu.hokkaido.jp":true,"eniwa.hokkaido.jp":true,"erimo.hokkaido.jp":true,"esan.hokkaido.jp":true,"esashi.hokkaido.jp":true,"fukagawa.hokkaido.jp":true,"fukushima.hokkaido.jp":true,"furano.hokkaido.jp":true,"furubira.hokkaido.jp":true,"haboro.hokkaido.jp":true,"hakodate.hokkaido.jp":true,"hamatonbetsu.hokkaido.jp":true,"hidaka.hokkaido.jp":true,"higashikagura.hokkaido.jp":true,"higashikawa.hokkaido.jp":true,"hiroo.hokkaido.jp":true,"hokuryu.hokkaido.jp":true,"hokuto.hokkaido.jp":true,"honbetsu.hokkaido.jp":true,"horokanai.hokkaido.jp":true,"horonobe.hokkaido.jp":true,"ikeda.hokkaido.jp":true,"imakane.hokkaido.jp":true,"ishikari.hokkaido.jp":true,"iwamizawa.hokkaido.jp":true,"iwanai.hokkaido.jp":true,"kamifurano.hokkaido.jp":true,"kamikawa.hokkaido.jp":true,"kamishihoro.hokkaido.jp":true,"kamisunagawa.hokkaido.jp":true,"kamoenai.hokkaido.jp":true,"kayabe.hokkaido.jp":true,"kembuchi.hokkaido.jp":true,"kikonai.hokkaido.jp":true,"kimobetsu.hokkaido.jp":true,"kitahiroshima.hokkaido.jp":true,"kitami.hokkaido.jp":true,"kiyosato.hokkaido.jp":true,"koshimizu.hokkaido.jp":true,"kunneppu.hokkaido.jp":true,"kuriyama.hokkaido.jp":true,"kuromatsunai.hokkaido.jp":true,"kushiro.hokkaido.jp":true,"kutchan.hokkaido.jp":true,"kyowa.hokkaido.jp":true,"mashike.hokkaido.jp":true,"matsumae.hokkaido.jp":true,"mikasa.hokkaido.jp":true,"minamifurano.hokkaido.jp":true,"mombetsu.hokkaido.jp":true,"moseushi.hokkaido.jp":true,"mukawa.hokkaido.jp":true,"muroran.hokkaido.jp":true,"naie.hokkaido.jp":true,"nakagawa.hokkaido.jp":true,"nakasatsunai.hokkaido.jp":true,"nakatombetsu.hokkaido.jp":true,"nanae.hokkaido.jp":true,"nanporo.hokkaido.jp":true,"nayoro.hokkaido.jp":true,"nemuro.hokkaido.jp":true,"niikappu.hokkaido.jp":true,"niki.hokkaido.jp":true,"nishiokoppe.hokkaido.jp":true,"noboribetsu.hokkaido.jp":true,"numata.hokkaido.jp":true,"obihiro.hokkaido.jp":true,"obira.hokkaido.jp":true,"oketo.hokkaido.jp":true,"okoppe.hokkaido.jp":true,"otaru.hokkaido.jp":true,"otobe.hokkaido.jp":true,"otofuke.hokkaido.jp":true,"otoineppu.hokkaido.jp":true,"oumu.hokkaido.jp":true,"ozora.hokkaido.jp":true,"pippu.hokkaido.jp":true,"rankoshi.hokkaido.jp":true,"rebun.hokkaido.jp":true,"rikubetsu.hokkaido.jp":true,"rishiri.hokkaido.jp":true,"rishirifuji.hokkaido.jp":true,"saroma.hokkaido.jp":true,"sarufutsu.hokkaido.jp":true,"shakotan.hokkaido.jp":true,"shari.hokkaido.jp":true,"shibecha.hokkaido.jp":true,"shibetsu.hokkaido.jp":true,"shikabe.hokkaido.jp":true,"shikaoi.hokkaido.jp":true,"shimamaki.hokkaido.jp":true,"shimizu.hokkaido.jp":true,"shimokawa.hokkaido.jp":true,"shinshinotsu.hokkaido.jp":true,"shintoku.hokkaido.jp":true,"shiranuka.hokkaido.jp":true,"shiraoi.hokkaido.jp":true,"shiriuchi.hokkaido.jp":true,"sobetsu.hokkaido.jp":true,"sunagawa.hokkaido.jp":true,"taiki.hokkaido.jp":true,"takasu.hokkaido.jp":true,"takikawa.hokkaido.jp":true,"takinoue.hokkaido.jp":true,"teshikaga.hokkaido.jp":true,"tobetsu.hokkaido.jp":true,"tohma.hokkaido.jp":true,"tomakomai.hokkaido.jp":true,"tomari.hokkaido.jp":true,"toya.hokkaido.jp":true,"toyako.hokkaido.jp":true,"toyotomi.hokkaido.jp":true,"toyoura.hokkaido.jp":true,"tsubetsu.hokkaido.jp":true,"tsukigata.hokkaido.jp":true,"urakawa.hokkaido.jp":true,"urausu.hokkaido.jp":true,"uryu.hokkaido.jp":true,"utashinai.hokkaido.jp":true,"wakkanai.hokkaido.jp":true,"wassamu.hokkaido.jp":true,"yakumo.hokkaido.jp":true,"yoichi.hokkaido.jp":true,"aioi.hyogo.jp":true,"akashi.hyogo.jp":true,"ako.hyogo.jp":true,"amagasaki.hyogo.jp":true,"aogaki.hyogo.jp":true,"asago.hyogo.jp":true,"ashiya.hyogo.jp":true,"awaji.hyogo.jp":true,"fukusaki.hyogo.jp":true,"goshiki.hyogo.jp":true,"harima.hyogo.jp":true,"himeji.hyogo.jp":true,"ichikawa.hyogo.jp":true,"inagawa.hyogo.jp":true,"itami.hyogo.jp":true,"kakogawa.hyogo.jp":true,"kamigori.hyogo.jp":true,"kamikawa.hyogo.jp":true,"kasai.hyogo.jp":true,"kasuga.hyogo.jp":true,"kawanishi.hyogo.jp":true,"miki.hyogo.jp":true,"minamiawaji.hyogo.jp":true,"nishinomiya.hyogo.jp":true,"nishiwaki.hyogo.jp":true,"ono.hyogo.jp":true,"sanda.hyogo.jp":true,"sannan.hyogo.jp":true,"sasayama.hyogo.jp":true,"sayo.hyogo.jp":true,"shingu.hyogo.jp":true,"shinonsen.hyogo.jp":true,"shiso.hyogo.jp":true,"sumoto.hyogo.jp":true,"taishi.hyogo.jp":true,"taka.hyogo.jp":true,"takarazuka.hyogo.jp":true,"takasago.hyogo.jp":true,"takino.hyogo.jp":true,"tamba.hyogo.jp":true,"tatsuno.hyogo.jp":true,"toyooka.hyogo.jp":true,"yabu.hyogo.jp":true,"yashiro.hyogo.jp":true,"yoka.hyogo.jp":true,"yokawa.hyogo.jp":true,"ami.ibaraki.jp":true,"asahi.ibaraki.jp":true,"bando.ibaraki.jp":true,"chikusei.ibaraki.jp":true,"daigo.ibaraki.jp":true,"fujishiro.ibaraki.jp":true,"hitachi.ibaraki.jp":true,"hitachinaka.ibaraki.jp":true,"hitachiomiya.ibaraki.jp":true,"hitachiota.ibaraki.jp":true,"ibaraki.ibaraki.jp":true,"ina.ibaraki.jp":true,"inashiki.ibaraki.jp":true,"itako.ibaraki.jp":true,"iwama.ibaraki.jp":true,"joso.ibaraki.jp":true,"kamisu.ibaraki.jp":true,"kasama.ibaraki.jp":true,"kashima.ibaraki.jp":true,"kasumigaura.ibaraki.jp":true,"koga.ibaraki.jp":true,"miho.ibaraki.jp":true,"mito.ibaraki.jp":true,"moriya.ibaraki.jp":true,"naka.ibaraki.jp":true,"namegata.ibaraki.jp":true,"oarai.ibaraki.jp":true,"ogawa.ibaraki.jp":true,"omitama.ibaraki.jp":true,"ryugasaki.ibaraki.jp":true,"sakai.ibaraki.jp":true,"sakuragawa.ibaraki.jp":true,"shimodate.ibaraki.jp":true,"shimotsuma.ibaraki.jp":true,"shirosato.ibaraki.jp":true,"sowa.ibaraki.jp":true,"suifu.ibaraki.jp":true,"takahagi.ibaraki.jp":true,"tamatsukuri.ibaraki.jp":true,"tokai.ibaraki.jp":true,"tomobe.ibaraki.jp":true,"tone.ibaraki.jp":true,"toride.ibaraki.jp":true,"tsuchiura.ibaraki.jp":true,"tsukuba.ibaraki.jp":true,"uchihara.ibaraki.jp":true,"ushiku.ibaraki.jp":true,"yachiyo.ibaraki.jp":true,"yamagata.ibaraki.jp":true,"yawara.ibaraki.jp":true,"yuki.ibaraki.jp":true,"anamizu.ishikawa.jp":true,"hakui.ishikawa.jp":true,"hakusan.ishikawa.jp":true,"kaga.ishikawa.jp":true,"kahoku.ishikawa.jp":true,"kanazawa.ishikawa.jp":true,"kawakita.ishikawa.jp":true,"komatsu.ishikawa.jp":true,"nakanoto.ishikawa.jp":true,"nanao.ishikawa.jp":true,"nomi.ishikawa.jp":true,"nonoichi.ishikawa.jp":true,"noto.ishikawa.jp":true,"shika.ishikawa.jp":true,"suzu.ishikawa.jp":true,"tsubata.ishikawa.jp":true,"tsurugi.ishikawa.jp":true,"uchinada.ishikawa.jp":true,"wajima.ishikawa.jp":true,"fudai.iwate.jp":true,"fujisawa.iwate.jp":true,"hanamaki.iwate.jp":true,"hiraizumi.iwate.jp":true,"hirono.iwate.jp":true,"ichinohe.iwate.jp":true,"ichinoseki.iwate.jp":true,"iwaizumi.iwate.jp":true,"iwate.iwate.jp":true,"joboji.iwate.jp":true,"kamaishi.iwate.jp":true,"kanegasaki.iwate.jp":true,"karumai.iwate.jp":true,"kawai.iwate.jp":true,"kitakami.iwate.jp":true,"kuji.iwate.jp":true,"kunohe.iwate.jp":true,"kuzumaki.iwate.jp":true,"miyako.iwate.jp":true,"mizusawa.iwate.jp":true,"morioka.iwate.jp":true,"ninohe.iwate.jp":true,"noda.iwate.jp":true,"ofunato.iwate.jp":true,"oshu.iwate.jp":true,"otsuchi.iwate.jp":true,"rikuzentakata.iwate.jp":true,"shiwa.iwate.jp":true,"shizukuishi.iwate.jp":true,"sumita.iwate.jp":true,"tanohata.iwate.jp":true,"tono.iwate.jp":true,"yahaba.iwate.jp":true,"yamada.iwate.jp":true,"ayagawa.kagawa.jp":true,"higashikagawa.kagawa.jp":true,"kanonji.kagawa.jp":true,"kotohira.kagawa.jp":true,"manno.kagawa.jp":true,"marugame.kagawa.jp":true,"mitoyo.kagawa.jp":true,"naoshima.kagawa.jp":true,"sanuki.kagawa.jp":true,"tadotsu.kagawa.jp":true,"takamatsu.kagawa.jp":true,"tonosho.kagawa.jp":true,"uchinomi.kagawa.jp":true,"utazu.kagawa.jp":true,"zentsuji.kagawa.jp":true,"akune.kagoshima.jp":true,"amami.kagoshima.jp":true,"hioki.kagoshima.jp":true,"isa.kagoshima.jp":true,"isen.kagoshima.jp":true,"izumi.kagoshima.jp":true,"kagoshima.kagoshima.jp":true,"kanoya.kagoshima.jp":true,"kawanabe.kagoshima.jp":true,"kinko.kagoshima.jp":true,"kouyama.kagoshima.jp":true,"makurazaki.kagoshima.jp":true,"matsumoto.kagoshima.jp":true,"minamitane.kagoshima.jp":true,"nakatane.kagoshima.jp":true,"nishinoomote.kagoshima.jp":true,"satsumasendai.kagoshima.jp":true,"soo.kagoshima.jp":true,"tarumizu.kagoshima.jp":true,"yusui.kagoshima.jp":true,"aikawa.kanagawa.jp":true,"atsugi.kanagawa.jp":true,"ayase.kanagawa.jp":true,"chigasaki.kanagawa.jp":true,"ebina.kanagawa.jp":true,"fujisawa.kanagawa.jp":true,"hadano.kanagawa.jp":true,"hakone.kanagawa.jp":true,"hiratsuka.kanagawa.jp":true,"isehara.kanagawa.jp":true,"kaisei.kanagawa.jp":true,"kamakura.kanagawa.jp":true,"kiyokawa.kanagawa.jp":true,"matsuda.kanagawa.jp":true,"minamiashigara.kanagawa.jp":true,"miura.kanagawa.jp":true,"nakai.kanagawa.jp":true,"ninomiya.kanagawa.jp":true,"odawara.kanagawa.jp":true,"oi.kanagawa.jp":true,"oiso.kanagawa.jp":true,"sagamihara.kanagawa.jp":true,"samukawa.kanagawa.jp":true,"tsukui.kanagawa.jp":true,"yamakita.kanagawa.jp":true,"yamato.kanagawa.jp":true,"yokosuka.kanagawa.jp":true,"yugawara.kanagawa.jp":true,"zama.kanagawa.jp":true,"zushi.kanagawa.jp":true,"aki.kochi.jp":true,"geisei.kochi.jp":true,"hidaka.kochi.jp":true,"higashitsuno.kochi.jp":true,"ino.kochi.jp":true,"kagami.kochi.jp":true,"kami.kochi.jp":true,"kitagawa.kochi.jp":true,"kochi.kochi.jp":true,"mihara.kochi.jp":true,"motoyama.kochi.jp":true,"muroto.kochi.jp":true,"nahari.kochi.jp":true,"nakamura.kochi.jp":true,"nankoku.kochi.jp":true,"nishitosa.kochi.jp":true,"niyodogawa.kochi.jp":true,"ochi.kochi.jp":true,"okawa.kochi.jp":true,"otoyo.kochi.jp":true,"otsuki.kochi.jp":true,"sakawa.kochi.jp":true,"sukumo.kochi.jp":true,"susaki.kochi.jp":true,"tosa.kochi.jp":true,"tosashimizu.kochi.jp":true,"toyo.kochi.jp":true,"tsuno.kochi.jp":true,"umaji.kochi.jp":true,"yasuda.kochi.jp":true,"yusuhara.kochi.jp":true,"amakusa.kumamoto.jp":true,"arao.kumamoto.jp":true,"aso.kumamoto.jp":true,"choyo.kumamoto.jp":true,"gyokuto.kumamoto.jp":true,"hitoyoshi.kumamoto.jp":true,"kamiamakusa.kumamoto.jp":true,"kashima.kumamoto.jp":true,"kikuchi.kumamoto.jp":true,"kosa.kumamoto.jp":true,"kumamoto.kumamoto.jp":true,"mashiki.kumamoto.jp":true,"mifune.kumamoto.jp":true,"minamata.kumamoto.jp":true,"minamioguni.kumamoto.jp":true,"nagasu.kumamoto.jp":true,"nishihara.kumamoto.jp":true,"oguni.kumamoto.jp":true,"ozu.kumamoto.jp":true,"sumoto.kumamoto.jp":true,"takamori.kumamoto.jp":true,"uki.kumamoto.jp":true,"uto.kumamoto.jp":true,"yamaga.kumamoto.jp":true,"yamato.kumamoto.jp":true,"yatsushiro.kumamoto.jp":true,"ayabe.kyoto.jp":true,"fukuchiyama.kyoto.jp":true,"higashiyama.kyoto.jp":true,"ide.kyoto.jp":true,"ine.kyoto.jp":true,"joyo.kyoto.jp":true,"kameoka.kyoto.jp":true,"kamo.kyoto.jp":true,"kita.kyoto.jp":true,"kizu.kyoto.jp":true,"kumiyama.kyoto.jp":true,"kyotamba.kyoto.jp":true,"kyotanabe.kyoto.jp":true,"kyotango.kyoto.jp":true,"maizuru.kyoto.jp":true,"minami.kyoto.jp":true,"minamiyamashiro.kyoto.jp":true,"miyazu.kyoto.jp":true,"muko.kyoto.jp":true,"nagaokakyo.kyoto.jp":true,"nakagyo.kyoto.jp":true,"nantan.kyoto.jp":true,"oyamazaki.kyoto.jp":true,"sakyo.kyoto.jp":true,"seika.kyoto.jp":true,"tanabe.kyoto.jp":true,"uji.kyoto.jp":true,"ujitawara.kyoto.jp":true,"wazuka.kyoto.jp":true,"yamashina.kyoto.jp":true,"yawata.kyoto.jp":true,"asahi.mie.jp":true,"inabe.mie.jp":true,"ise.mie.jp":true,"kameyama.mie.jp":true,"kawagoe.mie.jp":true,"kiho.mie.jp":true,"kisosaki.mie.jp":true,"kiwa.mie.jp":true,"komono.mie.jp":true,"kumano.mie.jp":true,"kuwana.mie.jp":true,"matsusaka.mie.jp":true,"meiwa.mie.jp":true,"mihama.mie.jp":true,"minamiise.mie.jp":true,"misugi.mie.jp":true,"miyama.mie.jp":true,"nabari.mie.jp":true,"shima.mie.jp":true,"suzuka.mie.jp":true,"tado.mie.jp":true,"taiki.mie.jp":true,"taki.mie.jp":true,"tamaki.mie.jp":true,"toba.mie.jp":true,"tsu.mie.jp":true,"udono.mie.jp":true,"ureshino.mie.jp":true,"watarai.mie.jp":true,"yokkaichi.mie.jp":true,"furukawa.miyagi.jp":true,"higashimatsushima.miyagi.jp":true,"ishinomaki.miyagi.jp":true,"iwanuma.miyagi.jp":true,"kakuda.miyagi.jp":true,"kami.miyagi.jp":true,"kawasaki.miyagi.jp":true,"kesennuma.miyagi.jp":true,"marumori.miyagi.jp":true,"matsushima.miyagi.jp":true,"minamisanriku.miyagi.jp":true,"misato.miyagi.jp":true,"murata.miyagi.jp":true,"natori.miyagi.jp":true,"ogawara.miyagi.jp":true,"ohira.miyagi.jp":true,"onagawa.miyagi.jp":true,"osaki.miyagi.jp":true,"rifu.miyagi.jp":true,"semine.miyagi.jp":true,"shibata.miyagi.jp":true,"shichikashuku.miyagi.jp":true,"shikama.miyagi.jp":true,"shiogama.miyagi.jp":true,"shiroishi.miyagi.jp":true,"tagajo.miyagi.jp":true,"taiwa.miyagi.jp":true,"tome.miyagi.jp":true,"tomiya.miyagi.jp":true,"wakuya.miyagi.jp":true,"watari.miyagi.jp":true,"yamamoto.miyagi.jp":true,"zao.miyagi.jp":true,"aya.miyazaki.jp":true,"ebino.miyazaki.jp":true,"gokase.miyazaki.jp":true,"hyuga.miyazaki.jp":true,"kadogawa.miyazaki.jp":true,"kawaminami.miyazaki.jp":true,"kijo.miyazaki.jp":true,"kitagawa.miyazaki.jp":true,"kitakata.miyazaki.jp":true,"kitaura.miyazaki.jp":true,"kobayashi.miyazaki.jp":true,"kunitomi.miyazaki.jp":true,"kushima.miyazaki.jp":true,"mimata.miyazaki.jp":true,"miyakonojo.miyazaki.jp":true,"miyazaki.miyazaki.jp":true,"morotsuka.miyazaki.jp":true,"nichinan.miyazaki.jp":true,"nishimera.miyazaki.jp":true,"nobeoka.miyazaki.jp":true,"saito.miyazaki.jp":true,"shiiba.miyazaki.jp":true,"shintomi.miyazaki.jp":true,"takaharu.miyazaki.jp":true,"takanabe.miyazaki.jp":true,"takazaki.miyazaki.jp":true,"tsuno.miyazaki.jp":true,"achi.nagano.jp":true,"agematsu.nagano.jp":true,"anan.nagano.jp":true,"aoki.nagano.jp":true,"asahi.nagano.jp":true,"azumino.nagano.jp":true,"chikuhoku.nagano.jp":true,"chikuma.nagano.jp":true,"chino.nagano.jp":true,"fujimi.nagano.jp":true,"hakuba.nagano.jp":true,"hara.nagano.jp":true,"hiraya.nagano.jp":true,"iida.nagano.jp":true,"iijima.nagano.jp":true,"iiyama.nagano.jp":true,"iizuna.nagano.jp":true,"ikeda.nagano.jp":true,"ikusaka.nagano.jp":true,"ina.nagano.jp":true,"karuizawa.nagano.jp":true,"kawakami.nagano.jp":true,"kiso.nagano.jp":true,"kisofukushima.nagano.jp":true,"kitaaiki.nagano.jp":true,"komagane.nagano.jp":true,"komoro.nagano.jp":true,"matsukawa.nagano.jp":true,"matsumoto.nagano.jp":true,"miasa.nagano.jp":true,"minamiaiki.nagano.jp":true,"minamimaki.nagano.jp":true,"minamiminowa.nagano.jp":true,"minowa.nagano.jp":true,"miyada.nagano.jp":true,"miyota.nagano.jp":true,"mochizuki.nagano.jp":true,"nagano.nagano.jp":true,"nagawa.nagano.jp":true,"nagiso.nagano.jp":true,"nakagawa.nagano.jp":true,"nakano.nagano.jp":true,"nozawaonsen.nagano.jp":true,"obuse.nagano.jp":true,"ogawa.nagano.jp":true,"okaya.nagano.jp":true,"omachi.nagano.jp":true,"omi.nagano.jp":true,"ookuwa.nagano.jp":true,"ooshika.nagano.jp":true,"otaki.nagano.jp":true,"otari.nagano.jp":true,"sakae.nagano.jp":true,"sakaki.nagano.jp":true,"saku.nagano.jp":true,"sakuho.nagano.jp":true,"shimosuwa.nagano.jp":true,"shinanomachi.nagano.jp":true,"shiojiri.nagano.jp":true,"suwa.nagano.jp":true,"suzaka.nagano.jp":true,"takagi.nagano.jp":true,"takamori.nagano.jp":true,"takayama.nagano.jp":true,"tateshina.nagano.jp":true,"tatsuno.nagano.jp":true,"togakushi.nagano.jp":true,"togura.nagano.jp":true,"tomi.nagano.jp":true,"ueda.nagano.jp":true,"wada.nagano.jp":true,"yamagata.nagano.jp":true,"yamanouchi.nagano.jp":true,"yasaka.nagano.jp":true,"yasuoka.nagano.jp":true,"chijiwa.nagasaki.jp":true,"futsu.nagasaki.jp":true,"goto.nagasaki.jp":true,"hasami.nagasaki.jp":true,"hirado.nagasaki.jp":true,"iki.nagasaki.jp":true,"isahaya.nagasaki.jp":true,"kawatana.nagasaki.jp":true,"kuchinotsu.nagasaki.jp":true,"matsuura.nagasaki.jp":true,"nagasaki.nagasaki.jp":true,"obama.nagasaki.jp":true,"omura.nagasaki.jp":true,"oseto.nagasaki.jp":true,"saikai.nagasaki.jp":true,"sasebo.nagasaki.jp":true,"seihi.nagasaki.jp":true,"shimabara.nagasaki.jp":true,"shinkamigoto.nagasaki.jp":true,"togitsu.nagasaki.jp":true,"tsushima.nagasaki.jp":true,"unzen.nagasaki.jp":true,"ando.nara.jp":true,"gose.nara.jp":true,"heguri.nara.jp":true,"higashiyoshino.nara.jp":true,"ikaruga.nara.jp":true,"ikoma.nara.jp":true,"kamikitayama.nara.jp":true,"kanmaki.nara.jp":true,"kashiba.nara.jp":true,"kashihara.nara.jp":true,"katsuragi.nara.jp":true,"kawai.nara.jp":true,"kawakami.nara.jp":true,"kawanishi.nara.jp":true,"koryo.nara.jp":true,"kurotaki.nara.jp":true,"mitsue.nara.jp":true,"miyake.nara.jp":true,"nara.nara.jp":true,"nosegawa.nara.jp":true,"oji.nara.jp":true,"ouda.nara.jp":true,"oyodo.nara.jp":true,"sakurai.nara.jp":true,"sango.nara.jp":true,"shimoichi.nara.jp":true,"shimokitayama.nara.jp":true,"shinjo.nara.jp":true,"soni.nara.jp":true,"takatori.nara.jp":true,"tawaramoto.nara.jp":true,"tenkawa.nara.jp":true,"tenri.nara.jp":true,"uda.nara.jp":true,"yamatokoriyama.nara.jp":true,"yamatotakada.nara.jp":true,"yamazoe.nara.jp":true,"yoshino.nara.jp":true,"aga.niigata.jp":true,"agano.niigata.jp":true,"gosen.niigata.jp":true,"itoigawa.niigata.jp":true,"izumozaki.niigata.jp":true,"joetsu.niigata.jp":true,"kamo.niigata.jp":true,"kariwa.niigata.jp":true,"kashiwazaki.niigata.jp":true,"minamiuonuma.niigata.jp":true,"mitsuke.niigata.jp":true,"muika.niigata.jp":true,"murakami.niigata.jp":true,"myoko.niigata.jp":true,"nagaoka.niigata.jp":true,"niigata.niigata.jp":true,"ojiya.niigata.jp":true,"omi.niigata.jp":true,"sado.niigata.jp":true,"sanjo.niigata.jp":true,"seiro.niigata.jp":true,"seirou.niigata.jp":true,"sekikawa.niigata.jp":true,"shibata.niigata.jp":true,"tagami.niigata.jp":true,"tainai.niigata.jp":true,"tochio.niigata.jp":true,"tokamachi.niigata.jp":true,"tsubame.niigata.jp":true,"tsunan.niigata.jp":true,"uonuma.niigata.jp":true,"yahiko.niigata.jp":true,"yoita.niigata.jp":true,"yuzawa.niigata.jp":true,"beppu.oita.jp":true,"bungoono.oita.jp":true,"bungotakada.oita.jp":true,"hasama.oita.jp":true,"hiji.oita.jp":true,"himeshima.oita.jp":true,"hita.oita.jp":true,"kamitsue.oita.jp":true,"kokonoe.oita.jp":true,"kuju.oita.jp":true,"kunisaki.oita.jp":true,"kusu.oita.jp":true,"oita.oita.jp":true,"saiki.oita.jp":true,"taketa.oita.jp":true,"tsukumi.oita.jp":true,"usa.oita.jp":true,"usuki.oita.jp":true,"yufu.oita.jp":true,"akaiwa.okayama.jp":true,"asakuchi.okayama.jp":true,"bizen.okayama.jp":true,"hayashima.okayama.jp":true,"ibara.okayama.jp":true,"kagamino.okayama.jp":true,"kasaoka.okayama.jp":true,"kibichuo.okayama.jp":true,"kumenan.okayama.jp":true,"kurashiki.okayama.jp":true,"maniwa.okayama.jp":true,"misaki.okayama.jp":true,"nagi.okayama.jp":true,"niimi.okayama.jp":true,"nishiawakura.okayama.jp":true,"okayama.okayama.jp":true,"satosho.okayama.jp":true,"setouchi.okayama.jp":true,"shinjo.okayama.jp":true,"shoo.okayama.jp":true,"soja.okayama.jp":true,"takahashi.okayama.jp":true,"tamano.okayama.jp":true,"tsuyama.okayama.jp":true,"wake.okayama.jp":true,"yakage.okayama.jp":true,"aguni.okinawa.jp":true,"ginowan.okinawa.jp":true,"ginoza.okinawa.jp":true,"gushikami.okinawa.jp":true,"haebaru.okinawa.jp":true,"higashi.okinawa.jp":true,"hirara.okinawa.jp":true,"iheya.okinawa.jp":true,"ishigaki.okinawa.jp":true,"ishikawa.okinawa.jp":true,"itoman.okinawa.jp":true,"izena.okinawa.jp":true,"kadena.okinawa.jp":true,"kin.okinawa.jp":true,"kitadaito.okinawa.jp":true,"kitanakagusuku.okinawa.jp":true,"kumejima.okinawa.jp":true,"kunigami.okinawa.jp":true,"minamidaito.okinawa.jp":true,"motobu.okinawa.jp":true,"nago.okinawa.jp":true,"naha.okinawa.jp":true,"nakagusuku.okinawa.jp":true,"nakijin.okinawa.jp":true,"nanjo.okinawa.jp":true,"nishihara.okinawa.jp":true,"ogimi.okinawa.jp":true,"okinawa.okinawa.jp":true,"onna.okinawa.jp":true,"shimoji.okinawa.jp":true,"taketomi.okinawa.jp":true,"tarama.okinawa.jp":true,"tokashiki.okinawa.jp":true,"tomigusuku.okinawa.jp":true,"tonaki.okinawa.jp":true,"urasoe.okinawa.jp":true,"uruma.okinawa.jp":true,"yaese.okinawa.jp":true,"yomitan.okinawa.jp":true,"yonabaru.okinawa.jp":true,"yonaguni.okinawa.jp":true,"zamami.okinawa.jp":true,"abeno.osaka.jp":true,"chihayaakasaka.osaka.jp":true,"chuo.osaka.jp":true,"daito.osaka.jp":true,"fujiidera.osaka.jp":true,"habikino.osaka.jp":true,"hannan.osaka.jp":true,"higashiosaka.osaka.jp":true,"higashisumiyoshi.osaka.jp":true,"higashiyodogawa.osaka.jp":true,"hirakata.osaka.jp":true,"ibaraki.osaka.jp":true,"ikeda.osaka.jp":true,"izumi.osaka.jp":true,"izumiotsu.osaka.jp":true,"izumisano.osaka.jp":true,"kadoma.osaka.jp":true,"kaizuka.osaka.jp":true,"kanan.osaka.jp":true,"kashiwara.osaka.jp":true,"katano.osaka.jp":true,"kawachinagano.osaka.jp":true,"kishiwada.osaka.jp":true,"kita.osaka.jp":true,"kumatori.osaka.jp":true,"matsubara.osaka.jp":true,"minato.osaka.jp":true,"minoh.osaka.jp":true,"misaki.osaka.jp":true,"moriguchi.osaka.jp":true,"neyagawa.osaka.jp":true,"nishi.osaka.jp":true,"nose.osaka.jp":true,"osakasayama.osaka.jp":true,"sakai.osaka.jp":true,"sayama.osaka.jp":true,"sennan.osaka.jp":true,"settsu.osaka.jp":true,"shijonawate.osaka.jp":true,"shimamoto.osaka.jp":true,"suita.osaka.jp":true,"tadaoka.osaka.jp":true,"taishi.osaka.jp":true,"tajiri.osaka.jp":true,"takaishi.osaka.jp":true,"takatsuki.osaka.jp":true,"tondabayashi.osaka.jp":true,"toyonaka.osaka.jp":true,"toyono.osaka.jp":true,"yao.osaka.jp":true,"ariake.saga.jp":true,"arita.saga.jp":true,"fukudomi.saga.jp":true,"genkai.saga.jp":true,"hamatama.saga.jp":true,"hizen.saga.jp":true,"imari.saga.jp":true,"kamimine.saga.jp":true,"kanzaki.saga.jp":true,"karatsu.saga.jp":true,"kashima.saga.jp":true,"kitagata.saga.jp":true,"kitahata.saga.jp":true,"kiyama.saga.jp":true,"kouhoku.saga.jp":true,"kyuragi.saga.jp":true,"nishiarita.saga.jp":true,"ogi.saga.jp":true,"omachi.saga.jp":true,"ouchi.saga.jp":true,"saga.saga.jp":true,"shiroishi.saga.jp":true,"taku.saga.jp":true,"tara.saga.jp":true,"tosu.saga.jp":true,"yoshinogari.saga.jp":true,"arakawa.saitama.jp":true,"asaka.saitama.jp":true,"chichibu.saitama.jp":true,"fujimi.saitama.jp":true,"fujimino.saitama.jp":true,"fukaya.saitama.jp":true,"hanno.saitama.jp":true,"hanyu.saitama.jp":true,"hasuda.saitama.jp":true,"hatogaya.saitama.jp":true,"hatoyama.saitama.jp":true,"hidaka.saitama.jp":true,"higashichichibu.saitama.jp":true,"higashimatsuyama.saitama.jp":true,"honjo.saitama.jp":true,"ina.saitama.jp":true,"iruma.saitama.jp":true,"iwatsuki.saitama.jp":true,"kamiizumi.saitama.jp":true,"kamikawa.saitama.jp":true,"kamisato.saitama.jp":true,"kasukabe.saitama.jp":true,"kawagoe.saitama.jp":true,"kawaguchi.saitama.jp":true,"kawajima.saitama.jp":true,"kazo.saitama.jp":true,"kitamoto.saitama.jp":true,"koshigaya.saitama.jp":true,"kounosu.saitama.jp":true,"kuki.saitama.jp":true,"kumagaya.saitama.jp":true,"matsubushi.saitama.jp":true,"minano.saitama.jp":true,"misato.saitama.jp":true,"miyashiro.saitama.jp":true,"miyoshi.saitama.jp":true,"moroyama.saitama.jp":true,"nagatoro.saitama.jp":true,"namegawa.saitama.jp":true,"niiza.saitama.jp":true,"ogano.saitama.jp":true,"ogawa.saitama.jp":true,"ogose.saitama.jp":true,"okegawa.saitama.jp":true,"omiya.saitama.jp":true,"otaki.saitama.jp":true,"ranzan.saitama.jp":true,"ryokami.saitama.jp":true,"saitama.saitama.jp":true,"sakado.saitama.jp":true,"satte.saitama.jp":true,"sayama.saitama.jp":true,"shiki.saitama.jp":true,"shiraoka.saitama.jp":true,"soka.saitama.jp":true,"sugito.saitama.jp":true,"toda.saitama.jp":true,"tokigawa.saitama.jp":true,"tokorozawa.saitama.jp":true,"tsurugashima.saitama.jp":true,"urawa.saitama.jp":true,"warabi.saitama.jp":true,"yashio.saitama.jp":true,"yokoze.saitama.jp":true,"yono.saitama.jp":true,"yorii.saitama.jp":true,"yoshida.saitama.jp":true,"yoshikawa.saitama.jp":true,"yoshimi.saitama.jp":true,"aisho.shiga.jp":true,"gamo.shiga.jp":true,"higashiomi.shiga.jp":true,"hikone.shiga.jp":true,"koka.shiga.jp":true,"konan.shiga.jp":true,"kosei.shiga.jp":true,"koto.shiga.jp":true,"kusatsu.shiga.jp":true,"maibara.shiga.jp":true,"moriyama.shiga.jp":true,"nagahama.shiga.jp":true,"nishiazai.shiga.jp":true,"notogawa.shiga.jp":true,"omihachiman.shiga.jp":true,"otsu.shiga.jp":true,"ritto.shiga.jp":true,"ryuoh.shiga.jp":true,"takashima.shiga.jp":true,"takatsuki.shiga.jp":true,"torahime.shiga.jp":true,"toyosato.shiga.jp":true,"yasu.shiga.jp":true,"akagi.shimane.jp":true,"ama.shimane.jp":true,"gotsu.shimane.jp":true,"hamada.shimane.jp":true,"higashiizumo.shimane.jp":true,"hikawa.shimane.jp":true,"hikimi.shimane.jp":true,"izumo.shimane.jp":true,"kakinoki.shimane.jp":true,"masuda.shimane.jp":true,"matsue.shimane.jp":true,"misato.shimane.jp":true,"nishinoshima.shimane.jp":true,"ohda.shimane.jp":true,"okinoshima.shimane.jp":true,"okuizumo.shimane.jp":true,"shimane.shimane.jp":true,"tamayu.shimane.jp":true,"tsuwano.shimane.jp":true,"unnan.shimane.jp":true,"yakumo.shimane.jp":true,"yasugi.shimane.jp":true,"yatsuka.shimane.jp":true,"arai.shizuoka.jp":true,"atami.shizuoka.jp":true,"fuji.shizuoka.jp":true,"fujieda.shizuoka.jp":true,"fujikawa.shizuoka.jp":true,"fujinomiya.shizuoka.jp":true,"fukuroi.shizuoka.jp":true,"gotemba.shizuoka.jp":true,"haibara.shizuoka.jp":true,"hamamatsu.shizuoka.jp":true,"higashiizu.shizuoka.jp":true,"ito.shizuoka.jp":true,"iwata.shizuoka.jp":true,"izu.shizuoka.jp":true,"izunokuni.shizuoka.jp":true,"kakegawa.shizuoka.jp":true,"kannami.shizuoka.jp":true,"kawanehon.shizuoka.jp":true,"kawazu.shizuoka.jp":true,"kikugawa.shizuoka.jp":true,"kosai.shizuoka.jp":true,"makinohara.shizuoka.jp":true,"matsuzaki.shizuoka.jp":true,"minamiizu.shizuoka.jp":true,"mishima.shizuoka.jp":true,"morimachi.shizuoka.jp":true,"nishiizu.shizuoka.jp":true,"numazu.shizuoka.jp":true,"omaezaki.shizuoka.jp":true,"shimada.shizuoka.jp":true,"shimizu.shizuoka.jp":true,"shimoda.shizuoka.jp":true,"shizuoka.shizuoka.jp":true,"susono.shizuoka.jp":true,"yaizu.shizuoka.jp":true,"yoshida.shizuoka.jp":true,"ashikaga.tochigi.jp":true,"bato.tochigi.jp":true,"haga.tochigi.jp":true,"ichikai.tochigi.jp":true,"iwafune.tochigi.jp":true,"kaminokawa.tochigi.jp":true,"kanuma.tochigi.jp":true,"karasuyama.tochigi.jp":true,"kuroiso.tochigi.jp":true,"mashiko.tochigi.jp":true,"mibu.tochigi.jp":true,"moka.tochigi.jp":true,"motegi.tochigi.jp":true,"nasu.tochigi.jp":true,"nasushiobara.tochigi.jp":true,"nikko.tochigi.jp":true,"nishikata.tochigi.jp":true,"nogi.tochigi.jp":true,"ohira.tochigi.jp":true,"ohtawara.tochigi.jp":true,"oyama.tochigi.jp":true,"sakura.tochigi.jp":true,"sano.tochigi.jp":true,"shimotsuke.tochigi.jp":true,"shioya.tochigi.jp":true,"takanezawa.tochigi.jp":true,"tochigi.tochigi.jp":true,"tsuga.tochigi.jp":true,"ujiie.tochigi.jp":true,"utsunomiya.tochigi.jp":true,"yaita.tochigi.jp":true,"aizumi.tokushima.jp":true,"anan.tokushima.jp":true,"ichiba.tokushima.jp":true,"itano.tokushima.jp":true,"kainan.tokushima.jp":true,"komatsushima.tokushima.jp":true,"matsushige.tokushima.jp":true,"mima.tokushima.jp":true,"minami.tokushima.jp":true,"miyoshi.tokushima.jp":true,"mugi.tokushima.jp":true,"nakagawa.tokushima.jp":true,"naruto.tokushima.jp":true,"sanagochi.tokushima.jp":true,"shishikui.tokushima.jp":true,"tokushima.tokushima.jp":true,"wajiki.tokushima.jp":true,"adachi.tokyo.jp":true,"akiruno.tokyo.jp":true,"akishima.tokyo.jp":true,"aogashima.tokyo.jp":true,"arakawa.tokyo.jp":true,"bunkyo.tokyo.jp":true,"chiyoda.tokyo.jp":true,"chofu.tokyo.jp":true,"chuo.tokyo.jp":true,"edogawa.tokyo.jp":true,"fuchu.tokyo.jp":true,"fussa.tokyo.jp":true,"hachijo.tokyo.jp":true,"hachioji.tokyo.jp":true,"hamura.tokyo.jp":true,"higashikurume.tokyo.jp":true,"higashimurayama.tokyo.jp":true,"higashiyamato.tokyo.jp":true,"hino.tokyo.jp":true,"hinode.tokyo.jp":true,"hinohara.tokyo.jp":true,"inagi.tokyo.jp":true,"itabashi.tokyo.jp":true,"katsushika.tokyo.jp":true,"kita.tokyo.jp":true,"kiyose.tokyo.jp":true,"kodaira.tokyo.jp":true,"koganei.tokyo.jp":true,"kokubunji.tokyo.jp":true,"komae.tokyo.jp":true,"koto.tokyo.jp":true,"kouzushima.tokyo.jp":true,"kunitachi.tokyo.jp":true,"machida.tokyo.jp":true,"meguro.tokyo.jp":true,"minato.tokyo.jp":true,"mitaka.tokyo.jp":true,"mizuho.tokyo.jp":true,"musashimurayama.tokyo.jp":true,"musashino.tokyo.jp":true,"nakano.tokyo.jp":true,"nerima.tokyo.jp":true,"ogasawara.tokyo.jp":true,"okutama.tokyo.jp":true,"ome.tokyo.jp":true,"oshima.tokyo.jp":true,"ota.tokyo.jp":true,"setagaya.tokyo.jp":true,"shibuya.tokyo.jp":true,"shinagawa.tokyo.jp":true,"shinjuku.tokyo.jp":true,"suginami.tokyo.jp":true,"sumida.tokyo.jp":true,"tachikawa.tokyo.jp":true,"taito.tokyo.jp":true,"tama.tokyo.jp":true,"toshima.tokyo.jp":true,"chizu.tottori.jp":true,"hino.tottori.jp":true,"kawahara.tottori.jp":true,"koge.tottori.jp":true,"kotoura.tottori.jp":true,"misasa.tottori.jp":true,"nanbu.tottori.jp":true,"nichinan.tottori.jp":true,"sakaiminato.tottori.jp":true,"tottori.tottori.jp":true,"wakasa.tottori.jp":true,"yazu.tottori.jp":true,"yonago.tottori.jp":true,"asahi.toyama.jp":true,"fuchu.toyama.jp":true,"fukumitsu.toyama.jp":true,"funahashi.toyama.jp":true,"himi.toyama.jp":true,"imizu.toyama.jp":true,"inami.toyama.jp":true,"johana.toyama.jp":true,"kamiichi.toyama.jp":true,"kurobe.toyama.jp":true,"nakaniikawa.toyama.jp":true,"namerikawa.toyama.jp":true,"nanto.toyama.jp":true,"nyuzen.toyama.jp":true,"oyabe.toyama.jp":true,"taira.toyama.jp":true,"takaoka.toyama.jp":true,"tateyama.toyama.jp":true,"toga.toyama.jp":true,"tonami.toyama.jp":true,"toyama.toyama.jp":true,"unazuki.toyama.jp":true,"uozu.toyama.jp":true,"yamada.toyama.jp":true,"arida.wakayama.jp":true,"aridagawa.wakayama.jp":true,"gobo.wakayama.jp":true,"hashimoto.wakayama.jp":true,"hidaka.wakayama.jp":true,"hirogawa.wakayama.jp":true,"inami.wakayama.jp":true,"iwade.wakayama.jp":true,"kainan.wakayama.jp":true,"kamitonda.wakayama.jp":true,"katsuragi.wakayama.jp":true,"kimino.wakayama.jp":true,"kinokawa.wakayama.jp":true,"kitayama.wakayama.jp":true,"koya.wakayama.jp":true,"koza.wakayama.jp":true,"kozagawa.wakayama.jp":true,"kudoyama.wakayama.jp":true,"kushimoto.wakayama.jp":true,"mihama.wakayama.jp":true,"misato.wakayama.jp":true,"nachikatsuura.wakayama.jp":true,"shingu.wakayama.jp":true,"shirahama.wakayama.jp":true,"taiji.wakayama.jp":true,"tanabe.wakayama.jp":true,"wakayama.wakayama.jp":true,"yuasa.wakayama.jp":true,"yura.wakayama.jp":true,"asahi.yamagata.jp":true,"funagata.yamagata.jp":true,"higashine.yamagata.jp":true,"iide.yamagata.jp":true,"kahoku.yamagata.jp":true,"kaminoyama.yamagata.jp":true,"kaneyama.yamagata.jp":true,"kawanishi.yamagata.jp":true,"mamurogawa.yamagata.jp":true,"mikawa.yamagata.jp":true,"murayama.yamagata.jp":true,"nagai.yamagata.jp":true,"nakayama.yamagata.jp":true,"nanyo.yamagata.jp":true,"nishikawa.yamagata.jp":true,"obanazawa.yamagata.jp":true,"oe.yamagata.jp":true,"oguni.yamagata.jp":true,"ohkura.yamagata.jp":true,"oishida.yamagata.jp":true,"sagae.yamagata.jp":true,"sakata.yamagata.jp":true,"sakegawa.yamagata.jp":true,"shinjo.yamagata.jp":true,"shirataka.yamagata.jp":true,"shonai.yamagata.jp":true,"takahata.yamagata.jp":true,"tendo.yamagata.jp":true,"tozawa.yamagata.jp":true,"tsuruoka.yamagata.jp":true,"yamagata.yamagata.jp":true,"yamanobe.yamagata.jp":true,"yonezawa.yamagata.jp":true,"yuza.yamagata.jp":true,"abu.yamaguchi.jp":true,"hagi.yamaguchi.jp":true,"hikari.yamaguchi.jp":true,"hofu.yamaguchi.jp":true,"iwakuni.yamaguchi.jp":true,"kudamatsu.yamaguchi.jp":true,"mitou.yamaguchi.jp":true,"nagato.yamaguchi.jp":true,"oshima.yamaguchi.jp":true,"shimonoseki.yamaguchi.jp":true,"shunan.yamaguchi.jp":true,"tabuse.yamaguchi.jp":true,"tokuyama.yamaguchi.jp":true,"toyota.yamaguchi.jp":true,"ube.yamaguchi.jp":true,"yuu.yamaguchi.jp":true,"chuo.yamanashi.jp":true,"doshi.yamanashi.jp":true,"fuefuki.yamanashi.jp":true,"fujikawa.yamanashi.jp":true,"fujikawaguchiko.yamanashi.jp":true,"fujiyoshida.yamanashi.jp":true,"hayakawa.yamanashi.jp":true,"hokuto.yamanashi.jp":true,"ichikawamisato.yamanashi.jp":true,"kai.yamanashi.jp":true,"kofu.yamanashi.jp":true,"koshu.yamanashi.jp":true,"kosuge.yamanashi.jp":true,"minami-alps.yamanashi.jp":true,"minobu.yamanashi.jp":true,"nakamichi.yamanashi.jp":true,"nanbu.yamanashi.jp":true,"narusawa.yamanashi.jp":true,"nirasaki.yamanashi.jp":true,"nishikatsura.yamanashi.jp":true,"oshino.yamanashi.jp":true,"otsuki.yamanashi.jp":true,"showa.yamanashi.jp":true,"tabayama.yamanashi.jp":true,"tsuru.yamanashi.jp":true,"uenohara.yamanashi.jp":true,"yamanakako.yamanashi.jp":true,"yamanashi.yamanashi.jp":true,"*.ke":true,"kg":true,"org.kg":true,"net.kg":true,"com.kg":true,"edu.kg":true,"gov.kg":true,"mil.kg":true,"*.kh":true,"ki":true,"edu.ki":true,"biz.ki":true,"net.ki":true,"org.ki":true,"gov.ki":true,"info.ki":true,"com.ki":true,"km":true,"org.km":true,"nom.km":true,"gov.km":true,"prd.km":true,"tm.km":true,"edu.km":true,"mil.km":true,"ass.km":true,"com.km":true,"coop.km":true,"asso.km":true,"presse.km":true,"medecin.km":true,"notaires.km":true,"pharmaciens.km":true,"veterinaire.km":true,"gouv.km":true,"kn":true,"net.kn":true,"org.kn":true,"edu.kn":true,"gov.kn":true,"kp":true,"com.kp":true,"edu.kp":true,"gov.kp":true,"org.kp":true,"rep.kp":true,"tra.kp":true,"kr":true,"ac.kr":true,"co.kr":true,"es.kr":true,"go.kr":true,"hs.kr":true,"kg.kr":true,"mil.kr":true,"ms.kr":true,"ne.kr":true,"or.kr":true,"pe.kr":true,"re.kr":true,"sc.kr":true,"busan.kr":true,"chungbuk.kr":true,"chungnam.kr":true,"daegu.kr":true,"daejeon.kr":true,"gangwon.kr":true,"gwangju.kr":true,"gyeongbuk.kr":true,"gyeonggi.kr":true,"gyeongnam.kr":true,"incheon.kr":true,"jeju.kr":true,"jeonbuk.kr":true,"jeonnam.kr":true,"seoul.kr":true,"ulsan.kr":true,"*.kw":true,"ky":true,"edu.ky":true,"gov.ky":true,"com.ky":true,"org.ky":true,"net.ky":true,"kz":true,"org.kz":true,"edu.kz":true,"net.kz":true,"gov.kz":true,"mil.kz":true,"com.kz":true,"la":true,"int.la":true,"net.la":true,"info.la":true,"edu.la":true,"gov.la":true,"per.la":true,"com.la":true,"org.la":true,"lb":true,"com.lb":true,"edu.lb":true,"gov.lb":true,"net.lb":true,"org.lb":true,"lc":true,"com.lc":true,"net.lc":true,"co.lc":true,"org.lc":true,"edu.lc":true,"gov.lc":true,"li":true,"lk":true,"gov.lk":true,"sch.lk":true,"net.lk":true,"int.lk":true,"com.lk":true,"org.lk":true,"edu.lk":true,"ngo.lk":true,"soc.lk":true,"web.lk":true,"ltd.lk":true,"assn.lk":true,"grp.lk":true,"hotel.lk":true,"lr":true,"com.lr":true,"edu.lr":true,"gov.lr":true,"org.lr":true,"net.lr":true,"ls":true,"co.ls":true,"org.ls":true,"lt":true,"gov.lt":true,"lu":true,"lv":true,"com.lv":true,"edu.lv":true,"gov.lv":true,"org.lv":true,"mil.lv":true,"id.lv":true,"net.lv":true,"asn.lv":true,"conf.lv":true,"ly":true,"com.ly":true,"net.ly":true,"gov.ly":true,"plc.ly":true,"edu.ly":true,"sch.ly":true,"med.ly":true,"org.ly":true,"id.ly":true,"ma":true,"co.ma":true,"net.ma":true,"gov.ma":true,"org.ma":true,"ac.ma":true,"press.ma":true,"mc":true,"tm.mc":true,"asso.mc":true,"md":true,"me":true,"co.me":true,"net.me":true,"org.me":true,"edu.me":true,"ac.me":true,"gov.me":true,"its.me":true,"priv.me":true,"mg":true,"org.mg":true,"nom.mg":true,"gov.mg":true,"prd.mg":true,"tm.mg":true,"edu.mg":true,"mil.mg":true,"com.mg":true,"mh":true,"mil":true,"mk":true,"com.mk":true,"org.mk":true,"net.mk":true,"edu.mk":true,"gov.mk":true,"inf.mk":true,"name.mk":true,"ml":true,"com.ml":true,"edu.ml":true,"gouv.ml":true,"gov.ml":true,"net.ml":true,"org.ml":true,"presse.ml":true,"*.mm":true,"mn":true,"gov.mn":true,"edu.mn":true,"org.mn":true,"mo":true,"com.mo":true,"net.mo":true,"org.mo":true,"edu.mo":true,"gov.mo":true,"mobi":true,"mp":true,"mq":true,"mr":true,"gov.mr":true,"ms":true,"com.ms":true,"edu.ms":true,"gov.ms":true,"net.ms":true,"org.ms":true,"mt":true,"com.mt":true,"edu.mt":true,"net.mt":true,"org.mt":true,"mu":true,"com.mu":true,"net.mu":true,"org.mu":true,"gov.mu":true,"ac.mu":true,"co.mu":true,"or.mu":true,"museum":true,"academy.museum":true,"agriculture.museum":true,"air.museum":true,"airguard.museum":true,"alabama.museum":true,"alaska.museum":true,"amber.museum":true,"ambulance.museum":true,"american.museum":true,"americana.museum":true,"americanantiques.museum":true,"americanart.museum":true,"amsterdam.museum":true,"and.museum":true,"annefrank.museum":true,"anthro.museum":true,"anthropology.museum":true,"antiques.museum":true,"aquarium.museum":true,"arboretum.museum":true,"archaeological.museum":true,"archaeology.museum":true,"architecture.museum":true,"art.museum":true,"artanddesign.museum":true,"artcenter.museum":true,"artdeco.museum":true,"arteducation.museum":true,"artgallery.museum":true,"arts.museum":true,"artsandcrafts.museum":true,"asmatart.museum":true,"assassination.museum":true,"assisi.museum":true,"association.museum":true,"astronomy.museum":true,"atlanta.museum":true,"austin.museum":true,"australia.museum":true,"automotive.museum":true,"aviation.museum":true,"axis.museum":true,"badajoz.museum":true,"baghdad.museum":true,"bahn.museum":true,"bale.museum":true,"baltimore.museum":true,"barcelona.museum":true,"baseball.museum":true,"basel.museum":true,"baths.museum":true,"bauern.museum":true,"beauxarts.museum":true,"beeldengeluid.museum":true,"bellevue.museum":true,"bergbau.museum":true,"berkeley.museum":true,"berlin.museum":true,"bern.museum":true,"bible.museum":true,"bilbao.museum":true,"bill.museum":true,"birdart.museum":true,"birthplace.museum":true,"bonn.museum":true,"boston.museum":true,"botanical.museum":true,"botanicalgarden.museum":true,"botanicgarden.museum":true,"botany.museum":true,"brandywinevalley.museum":true,"brasil.museum":true,"bristol.museum":true,"british.museum":true,"britishcolumbia.museum":true,"broadcast.museum":true,"brunel.museum":true,"brussel.museum":true,"brussels.museum":true,"bruxelles.museum":true,"building.museum":true,"burghof.museum":true,"bus.museum":true,"bushey.museum":true,"cadaques.museum":true,"california.museum":true,"cambridge.museum":true,"can.museum":true,"canada.museum":true,"capebreton.museum":true,"carrier.museum":true,"cartoonart.museum":true,"casadelamoneda.museum":true,"castle.museum":true,"castres.museum":true,"celtic.museum":true,"center.museum":true,"chattanooga.museum":true,"cheltenham.museum":true,"chesapeakebay.museum":true,"chicago.museum":true,"children.museum":true,"childrens.museum":true,"childrensgarden.museum":true,"chiropractic.museum":true,"chocolate.museum":true,"christiansburg.museum":true,"cincinnati.museum":true,"cinema.museum":true,"circus.museum":true,"civilisation.museum":true,"civilization.museum":true,"civilwar.museum":true,"clinton.museum":true,"clock.museum":true,"coal.museum":true,"coastaldefence.museum":true,"cody.museum":true,"coldwar.museum":true,"collection.museum":true,"colonialwilliamsburg.museum":true,"coloradoplateau.museum":true,"columbia.museum":true,"columbus.museum":true,"communication.museum":true,"communications.museum":true,"community.museum":true,"computer.museum":true,"computerhistory.museum":true,"xn--comunicaes-v6a2o.museum":true,"contemporary.museum":true,"contemporaryart.museum":true,"convent.museum":true,"copenhagen.museum":true,"corporation.museum":true,"xn--correios-e-telecomunicaes-ghc29a.museum":true,"corvette.museum":true,"costume.museum":true,"countryestate.museum":true,"county.museum":true,"crafts.museum":true,"cranbrook.museum":true,"creation.museum":true,"cultural.museum":true,"culturalcenter.museum":true,"culture.museum":true,"cyber.museum":true,"cymru.museum":true,"dali.museum":true,"dallas.museum":true,"database.museum":true,"ddr.museum":true,"decorativearts.museum":true,"delaware.museum":true,"delmenhorst.museum":true,"denmark.museum":true,"depot.museum":true,"design.museum":true,"detroit.museum":true,"dinosaur.museum":true,"discovery.museum":true,"dolls.museum":true,"donostia.museum":true,"durham.museum":true,"eastafrica.museum":true,"eastcoast.museum":true,"education.museum":true,"educational.museum":true,"egyptian.museum":true,"eisenbahn.museum":true,"elburg.museum":true,"elvendrell.museum":true,"embroidery.museum":true,"encyclopedic.museum":true,"england.museum":true,"entomology.museum":true,"environment.museum":true,"environmentalconservation.museum":true,"epilepsy.museum":true,"essex.museum":true,"estate.museum":true,"ethnology.museum":true,"exeter.museum":true,"exhibition.museum":true,"family.museum":true,"farm.museum":true,"farmequipment.museum":true,"farmers.museum":true,"farmstead.museum":true,"field.museum":true,"figueres.museum":true,"filatelia.museum":true,"film.museum":true,"fineart.museum":true,"finearts.museum":true,"finland.museum":true,"flanders.museum":true,"florida.museum":true,"force.museum":true,"fortmissoula.museum":true,"fortworth.museum":true,"foundation.museum":true,"francaise.museum":true,"frankfurt.museum":true,"franziskaner.museum":true,"freemasonry.museum":true,"freiburg.museum":true,"fribourg.museum":true,"frog.museum":true,"fundacio.museum":true,"furniture.museum":true,"gallery.museum":true,"garden.museum":true,"gateway.museum":true,"geelvinck.museum":true,"gemological.museum":true,"geology.museum":true,"georgia.museum":true,"giessen.museum":true,"glas.museum":true,"glass.museum":true,"gorge.museum":true,"grandrapids.museum":true,"graz.museum":true,"guernsey.museum":true,"halloffame.museum":true,"hamburg.museum":true,"handson.museum":true,"harvestcelebration.museum":true,"hawaii.museum":true,"health.museum":true,"heimatunduhren.museum":true,"hellas.museum":true,"helsinki.museum":true,"hembygdsforbund.museum":true,"heritage.museum":true,"histoire.museum":true,"historical.museum":true,"historicalsociety.museum":true,"historichouses.museum":true,"historisch.museum":true,"historisches.museum":true,"history.museum":true,"historyofscience.museum":true,"horology.museum":true,"house.museum":true,"humanities.museum":true,"illustration.museum":true,"imageandsound.museum":true,"indian.museum":true,"indiana.museum":true,"indianapolis.museum":true,"indianmarket.museum":true,"intelligence.museum":true,"interactive.museum":true,"iraq.museum":true,"iron.museum":true,"isleofman.museum":true,"jamison.museum":true,"jefferson.museum":true,"jerusalem.museum":true,"jewelry.museum":true,"jewish.museum":true,"jewishart.museum":true,"jfk.museum":true,"journalism.museum":true,"judaica.museum":true,"judygarland.museum":true,"juedisches.museum":true,"juif.museum":true,"karate.museum":true,"karikatur.museum":true,"kids.museum":true,"koebenhavn.museum":true,"koeln.museum":true,"kunst.museum":true,"kunstsammlung.museum":true,"kunstunddesign.museum":true,"labor.museum":true,"labour.museum":true,"lajolla.museum":true,"lancashire.museum":true,"landes.museum":true,"lans.museum":true,"xn--lns-qla.museum":true,"larsson.museum":true,"lewismiller.museum":true,"lincoln.museum":true,"linz.museum":true,"living.museum":true,"livinghistory.museum":true,"localhistory.museum":true,"london.museum":true,"losangeles.museum":true,"louvre.museum":true,"loyalist.museum":true,"lucerne.museum":true,"luxembourg.museum":true,"luzern.museum":true,"mad.museum":true,"madrid.museum":true,"mallorca.museum":true,"manchester.museum":true,"mansion.museum":true,"mansions.museum":true,"manx.museum":true,"marburg.museum":true,"maritime.museum":true,"maritimo.museum":true,"maryland.museum":true,"marylhurst.museum":true,"media.museum":true,"medical.museum":true,"medizinhistorisches.museum":true,"meeres.museum":true,"memorial.museum":true,"mesaverde.museum":true,"michigan.museum":true,"midatlantic.museum":true,"military.museum":true,"mill.museum":true,"miners.museum":true,"mining.museum":true,"minnesota.museum":true,"missile.museum":true,"missoula.museum":true,"modern.museum":true,"moma.museum":true,"money.museum":true,"monmouth.museum":true,"monticello.museum":true,"montreal.museum":true,"moscow.museum":true,"motorcycle.museum":true,"muenchen.museum":true,"muenster.museum":true,"mulhouse.museum":true,"muncie.museum":true,"museet.museum":true,"museumcenter.museum":true,"museumvereniging.museum":true,"music.museum":true,"national.museum":true,"nationalfirearms.museum":true,"nationalheritage.museum":true,"nativeamerican.museum":true,"naturalhistory.museum":true,"naturalhistorymuseum.museum":true,"naturalsciences.museum":true,"nature.museum":true,"naturhistorisches.museum":true,"natuurwetenschappen.museum":true,"naumburg.museum":true,"naval.museum":true,"nebraska.museum":true,"neues.museum":true,"newhampshire.museum":true,"newjersey.museum":true,"newmexico.museum":true,"newport.museum":true,"newspaper.museum":true,"newyork.museum":true,"niepce.museum":true,"norfolk.museum":true,"north.museum":true,"nrw.museum":true,"nuernberg.museum":true,"nuremberg.museum":true,"nyc.museum":true,"nyny.museum":true,"oceanographic.museum":true,"oceanographique.museum":true,"omaha.museum":true,"online.museum":true,"ontario.museum":true,"openair.museum":true,"oregon.museum":true,"oregontrail.museum":true,"otago.museum":true,"oxford.museum":true,"pacific.museum":true,"paderborn.museum":true,"palace.museum":true,"paleo.museum":true,"palmsprings.museum":true,"panama.museum":true,"paris.museum":true,"pasadena.museum":true,"pharmacy.museum":true,"philadelphia.museum":true,"philadelphiaarea.museum":true,"philately.museum":true,"phoenix.museum":true,"photography.museum":true,"pilots.museum":true,"pittsburgh.museum":true,"planetarium.museum":true,"plantation.museum":true,"plants.museum":true,"plaza.museum":true,"portal.museum":true,"portland.museum":true,"portlligat.museum":true,"posts-and-telecommunications.museum":true,"preservation.museum":true,"presidio.museum":true,"press.museum":true,"project.museum":true,"public.museum":true,"pubol.museum":true,"quebec.museum":true,"railroad.museum":true,"railway.museum":true,"research.museum":true,"resistance.museum":true,"riodejaneiro.museum":true,"rochester.museum":true,"rockart.museum":true,"roma.museum":true,"russia.museum":true,"saintlouis.museum":true,"salem.museum":true,"salvadordali.museum":true,"salzburg.museum":true,"sandiego.museum":true,"sanfrancisco.museum":true,"santabarbara.museum":true,"santacruz.museum":true,"santafe.museum":true,"saskatchewan.museum":true,"satx.museum":true,"savannahga.museum":true,"schlesisches.museum":true,"schoenbrunn.museum":true,"schokoladen.museum":true,"school.museum":true,"schweiz.museum":true,"science.museum":true,"scienceandhistory.museum":true,"scienceandindustry.museum":true,"sciencecenter.museum":true,"sciencecenters.museum":true,"science-fiction.museum":true,"sciencehistory.museum":true,"sciences.museum":true,"sciencesnaturelles.museum":true,"scotland.museum":true,"seaport.museum":true,"settlement.museum":true,"settlers.museum":true,"shell.museum":true,"sherbrooke.museum":true,"sibenik.museum":true,"silk.museum":true,"ski.museum":true,"skole.museum":true,"society.museum":true,"sologne.museum":true,"soundandvision.museum":true,"southcarolina.museum":true,"southwest.museum":true,"space.museum":true,"spy.museum":true,"square.museum":true,"stadt.museum":true,"stalbans.museum":true,"starnberg.museum":true,"state.museum":true,"stateofdelaware.museum":true,"station.museum":true,"steam.museum":true,"steiermark.museum":true,"stjohn.museum":true,"stockholm.museum":true,"stpetersburg.museum":true,"stuttgart.museum":true,"suisse.museum":true,"surgeonshall.museum":true,"surrey.museum":true,"svizzera.museum":true,"sweden.museum":true,"sydney.museum":true,"tank.museum":true,"tcm.museum":true,"technology.museum":true,"telekommunikation.museum":true,"television.museum":true,"texas.museum":true,"textile.museum":true,"theater.museum":true,"time.museum":true,"timekeeping.museum":true,"topology.museum":true,"torino.museum":true,"touch.museum":true,"town.museum":true,"transport.museum":true,"tree.museum":true,"trolley.museum":true,"trust.museum":true,"trustee.museum":true,"uhren.museum":true,"ulm.museum":true,"undersea.museum":true,"university.museum":true,"usa.museum":true,"usantiques.museum":true,"usarts.museum":true,"uscountryestate.museum":true,"usculture.museum":true,"usdecorativearts.museum":true,"usgarden.museum":true,"ushistory.museum":true,"ushuaia.museum":true,"uslivinghistory.museum":true,"utah.museum":true,"uvic.museum":true,"valley.museum":true,"vantaa.museum":true,"versailles.museum":true,"viking.museum":true,"village.museum":true,"virginia.museum":true,"virtual.museum":true,"virtuel.museum":true,"vlaanderen.museum":true,"volkenkunde.museum":true,"wales.museum":true,"wallonie.museum":true,"war.museum":true,"washingtondc.museum":true,"watchandclock.museum":true,"watch-and-clock.museum":true,"western.museum":true,"westfalen.museum":true,"whaling.museum":true,"wildlife.museum":true,"williamsburg.museum":true,"windmill.museum":true,"workshop.museum":true,"york.museum":true,"yorkshire.museum":true,"yosemite.museum":true,"youth.museum":true,"zoological.museum":true,"zoology.museum":true,"xn--9dbhblg6di.museum":true,"xn--h1aegh.museum":true,"mv":true,"aero.mv":true,"biz.mv":true,"com.mv":true,"coop.mv":true,"edu.mv":true,"gov.mv":true,"info.mv":true,"int.mv":true,"mil.mv":true,"museum.mv":true,"name.mv":true,"net.mv":true,"org.mv":true,"pro.mv":true,"mw":true,"ac.mw":true,"biz.mw":true,"co.mw":true,"com.mw":true,"coop.mw":true,"edu.mw":true,"gov.mw":true,"int.mw":true,"museum.mw":true,"net.mw":true,"org.mw":true,"mx":true,"com.mx":true,"org.mx":true,"gob.mx":true,"edu.mx":true,"net.mx":true,"my":true,"com.my":true,"net.my":true,"org.my":true,"gov.my":true,"edu.my":true,"mil.my":true,"name.my":true,"*.mz":true,"teledata.mz":false,"na":true,"info.na":true,"pro.na":true,"name.na":true,"school.na":true,"or.na":true,"dr.na":true,"us.na":true,"mx.na":true,"ca.na":true,"in.na":true,"cc.na":true,"tv.na":true,"ws.na":true,"mobi.na":true,"co.na":true,"com.na":true,"org.na":true,"name":true,"nc":true,"asso.nc":true,"ne":true,"net":true,"nf":true,"com.nf":true,"net.nf":true,"per.nf":true,"rec.nf":true,"web.nf":true,"arts.nf":true,"firm.nf":true,"info.nf":true,"other.nf":true,"store.nf":true,"ng":true,"com.ng":true,"edu.ng":true,"name.ng":true,"net.ng":true,"org.ng":true,"sch.ng":true,"gov.ng":true,"mil.ng":true,"mobi.ng":true,"*.ni":true,"nl":true,"bv.nl":true,"no":true,"fhs.no":true,"vgs.no":true,"fylkesbibl.no":true,"folkebibl.no":true,"museum.no":true,"idrett.no":true,"priv.no":true,"mil.no":true,"stat.no":true,"dep.no":true,"kommune.no":true,"herad.no":true,"aa.no":true,"ah.no":true,"bu.no":true,"fm.no":true,"hl.no":true,"hm.no":true,"jan-mayen.no":true,"mr.no":true,"nl.no":true,"nt.no":true,"of.no":true,"ol.no":true,"oslo.no":true,"rl.no":true,"sf.no":true,"st.no":true,"svalbard.no":true,"tm.no":true,"tr.no":true,"va.no":true,"vf.no":true,"gs.aa.no":true,"gs.ah.no":true,"gs.bu.no":true,"gs.fm.no":true,"gs.hl.no":true,"gs.hm.no":true,"gs.jan-mayen.no":true,"gs.mr.no":true,"gs.nl.no":true,"gs.nt.no":true,"gs.of.no":true,"gs.ol.no":true,"gs.oslo.no":true,"gs.rl.no":true,"gs.sf.no":true,"gs.st.no":true,"gs.svalbard.no":true,"gs.tm.no":true,"gs.tr.no":true,"gs.va.no":true,"gs.vf.no":true,"akrehamn.no":true,"xn--krehamn-dxa.no":true,"algard.no":true,"xn--lgrd-poac.no":true,"arna.no":true,"brumunddal.no":true,"bryne.no":true,"bronnoysund.no":true,"xn--brnnysund-m8ac.no":true,"drobak.no":true,"xn--drbak-wua.no":true,"egersund.no":true,"fetsund.no":true,"floro.no":true,"xn--flor-jra.no":true,"fredrikstad.no":true,"hokksund.no":true,"honefoss.no":true,"xn--hnefoss-q1a.no":true,"jessheim.no":true,"jorpeland.no":true,"xn--jrpeland-54a.no":true,"kirkenes.no":true,"kopervik.no":true,"krokstadelva.no":true,"langevag.no":true,"xn--langevg-jxa.no":true,"leirvik.no":true,"mjondalen.no":true,"xn--mjndalen-64a.no":true,"mo-i-rana.no":true,"mosjoen.no":true,"xn--mosjen-eya.no":true,"nesoddtangen.no":true,"orkanger.no":true,"osoyro.no":true,"xn--osyro-wua.no":true,"raholt.no":true,"xn--rholt-mra.no":true,"sandnessjoen.no":true,"xn--sandnessjen-ogb.no":true,"skedsmokorset.no":true,"slattum.no":true,"spjelkavik.no":true,"stathelle.no":true,"stavern.no":true,"stjordalshalsen.no":true,"xn--stjrdalshalsen-sqb.no":true,"tananger.no":true,"tranby.no":true,"vossevangen.no":true,"afjord.no":true,"xn--fjord-lra.no":true,"agdenes.no":true,"al.no":true,"xn--l-1fa.no":true,"alesund.no":true,"xn--lesund-hua.no":true,"alstahaug.no":true,"alta.no":true,"xn--lt-liac.no":true,"alaheadju.no":true,"xn--laheadju-7ya.no":true,"alvdal.no":true,"amli.no":true,"xn--mli-tla.no":true,"amot.no":true,"xn--mot-tla.no":true,"andebu.no":true,"andoy.no":true,"xn--andy-ira.no":true,"andasuolo.no":true,"ardal.no":true,"xn--rdal-poa.no":true,"aremark.no":true,"arendal.no":true,"xn--s-1fa.no":true,"aseral.no":true,"xn--seral-lra.no":true,"asker.no":true,"askim.no":true,"askvoll.no":true,"askoy.no":true,"xn--asky-ira.no":true,"asnes.no":true,"xn--snes-poa.no":true,"audnedaln.no":true,"aukra.no":true,"aure.no":true,"aurland.no":true,"aurskog-holand.no":true,"xn--aurskog-hland-jnb.no":true,"austevoll.no":true,"austrheim.no":true,"averoy.no":true,"xn--avery-yua.no":true,"balestrand.no":true,"ballangen.no":true,"balat.no":true,"xn--blt-elab.no":true,"balsfjord.no":true,"bahccavuotna.no":true,"xn--bhccavuotna-k7a.no":true,"bamble.no":true,"bardu.no":true,"beardu.no":true,"beiarn.no":true,"bajddar.no":true,"xn--bjddar-pta.no":true,"baidar.no":true,"xn--bidr-5nac.no":true,"berg.no":true,"bergen.no":true,"berlevag.no":true,"xn--berlevg-jxa.no":true,"bearalvahki.no":true,"xn--bearalvhki-y4a.no":true,"bindal.no":true,"birkenes.no":true,"bjarkoy.no":true,"xn--bjarky-fya.no":true,"bjerkreim.no":true,"bjugn.no":true,"bodo.no":true,"xn--bod-2na.no":true,"badaddja.no":true,"xn--bdddj-mrabd.no":true,"budejju.no":true,"bokn.no":true,"bremanger.no":true,"bronnoy.no":true,"xn--brnny-wuac.no":true,"bygland.no":true,"bykle.no":true,"barum.no":true,"xn--brum-voa.no":true,"bo.telemark.no":true,"xn--b-5ga.telemark.no":true,"bo.nordland.no":true,"xn--b-5ga.nordland.no":true,"bievat.no":true,"xn--bievt-0qa.no":true,"bomlo.no":true,"xn--bmlo-gra.no":true,"batsfjord.no":true,"xn--btsfjord-9za.no":true,"bahcavuotna.no":true,"xn--bhcavuotna-s4a.no":true,"dovre.no":true,"drammen.no":true,"drangedal.no":true,"dyroy.no":true,"xn--dyry-ira.no":true,"donna.no":true,"xn--dnna-gra.no":true,"eid.no":true,"eidfjord.no":true,"eidsberg.no":true,"eidskog.no":true,"eidsvoll.no":true,"eigersund.no":true,"elverum.no":true,"enebakk.no":true,"engerdal.no":true,"etne.no":true,"etnedal.no":true,"evenes.no":true,"evenassi.no":true,"xn--eveni-0qa01ga.no":true,"evje-og-hornnes.no":true,"farsund.no":true,"fauske.no":true,"fuossko.no":true,"fuoisku.no":true,"fedje.no":true,"fet.no":true,"finnoy.no":true,"xn--finny-yua.no":true,"fitjar.no":true,"fjaler.no":true,"fjell.no":true,"flakstad.no":true,"flatanger.no":true,"flekkefjord.no":true,"flesberg.no":true,"flora.no":true,"fla.no":true,"xn--fl-zia.no":true,"folldal.no":true,"forsand.no":true,"fosnes.no":true,"frei.no":true,"frogn.no":true,"froland.no":true,"frosta.no":true,"frana.no":true,"xn--frna-woa.no":true,"froya.no":true,"xn--frya-hra.no":true,"fusa.no":true,"fyresdal.no":true,"forde.no":true,"xn--frde-gra.no":true,"gamvik.no":true,"gangaviika.no":true,"xn--ggaviika-8ya47h.no":true,"gaular.no":true,"gausdal.no":true,"gildeskal.no":true,"xn--gildeskl-g0a.no":true,"giske.no":true,"gjemnes.no":true,"gjerdrum.no":true,"gjerstad.no":true,"gjesdal.no":true,"gjovik.no":true,"xn--gjvik-wua.no":true,"gloppen.no":true,"gol.no":true,"gran.no":true,"grane.no":true,"granvin.no":true,"gratangen.no":true,"grimstad.no":true,"grong.no":true,"kraanghke.no":true,"xn--kranghke-b0a.no":true,"grue.no":true,"gulen.no":true,"hadsel.no":true,"halden.no":true,"halsa.no":true,"hamar.no":true,"hamaroy.no":true,"habmer.no":true,"xn--hbmer-xqa.no":true,"hapmir.no":true,"xn--hpmir-xqa.no":true,"hammerfest.no":true,"hammarfeasta.no":true,"xn--hmmrfeasta-s4ac.no":true,"haram.no":true,"hareid.no":true,"harstad.no":true,"hasvik.no":true,"aknoluokta.no":true,"xn--koluokta-7ya57h.no":true,"hattfjelldal.no":true,"aarborte.no":true,"haugesund.no":true,"hemne.no":true,"hemnes.no":true,"hemsedal.no":true,"heroy.more-og-romsdal.no":true,"xn--hery-ira.xn--mre-og-romsdal-qqb.no":true,"heroy.nordland.no":true,"xn--hery-ira.nordland.no":true,"hitra.no":true,"hjartdal.no":true,"hjelmeland.no":true,"hobol.no":true,"xn--hobl-ira.no":true,"hof.no":true,"hol.no":true,"hole.no":true,"holmestrand.no":true,"holtalen.no":true,"xn--holtlen-hxa.no":true,"hornindal.no":true,"horten.no":true,"hurdal.no":true,"hurum.no":true,"hvaler.no":true,"hyllestad.no":true,"hagebostad.no":true,"xn--hgebostad-g3a.no":true,"hoyanger.no":true,"xn--hyanger-q1a.no":true,"hoylandet.no":true,"xn--hylandet-54a.no":true,"ha.no":true,"xn--h-2fa.no":true,"ibestad.no":true,"inderoy.no":true,"xn--indery-fya.no":true,"iveland.no":true,"jevnaker.no":true,"jondal.no":true,"jolster.no":true,"xn--jlster-bya.no":true,"karasjok.no":true,"karasjohka.no":true,"xn--krjohka-hwab49j.no":true,"karlsoy.no":true,"galsa.no":true,"xn--gls-elac.no":true,"karmoy.no":true,"xn--karmy-yua.no":true,"kautokeino.no":true,"guovdageaidnu.no":true,"klepp.no":true,"klabu.no":true,"xn--klbu-woa.no":true,"kongsberg.no":true,"kongsvinger.no":true,"kragero.no":true,"xn--krager-gya.no":true,"kristiansand.no":true,"kristiansund.no":true,"krodsherad.no":true,"xn--krdsherad-m8a.no":true,"kvalsund.no":true,"rahkkeravju.no":true,"xn--rhkkervju-01af.no":true,"kvam.no":true,"kvinesdal.no":true,"kvinnherad.no":true,"kviteseid.no":true,"kvitsoy.no":true,"xn--kvitsy-fya.no":true,"kvafjord.no":true,"xn--kvfjord-nxa.no":true,"giehtavuoatna.no":true,"kvanangen.no":true,"xn--kvnangen-k0a.no":true,"navuotna.no":true,"xn--nvuotna-hwa.no":true,"kafjord.no":true,"xn--kfjord-iua.no":true,"gaivuotna.no":true,"xn--givuotna-8ya.no":true,"larvik.no":true,"lavangen.no":true,"lavagis.no":true,"loabat.no":true,"xn--loabt-0qa.no":true,"lebesby.no":true,"davvesiida.no":true,"leikanger.no":true,"leirfjord.no":true,"leka.no":true,"leksvik.no":true,"lenvik.no":true,"leangaviika.no":true,"xn--leagaviika-52b.no":true,"lesja.no":true,"levanger.no":true,"lier.no":true,"lierne.no":true,"lillehammer.no":true,"lillesand.no":true,"lindesnes.no":true,"lindas.no":true,"xn--linds-pra.no":true,"lom.no":true,"loppa.no":true,"lahppi.no":true,"xn--lhppi-xqa.no":true,"lund.no":true,"lunner.no":true,"luroy.no":true,"xn--lury-ira.no":true,"luster.no":true,"lyngdal.no":true,"lyngen.no":true,"ivgu.no":true,"lardal.no":true,"lerdal.no":true,"xn--lrdal-sra.no":true,"lodingen.no":true,"xn--ldingen-q1a.no":true,"lorenskog.no":true,"xn--lrenskog-54a.no":true,"loten.no":true,"xn--lten-gra.no":true,"malvik.no":true,"masoy.no":true,"xn--msy-ula0h.no":true,"muosat.no":true,"xn--muost-0qa.no":true,"mandal.no":true,"marker.no":true,"marnardal.no":true,"masfjorden.no":true,"meland.no":true,"meldal.no":true,"melhus.no":true,"meloy.no":true,"xn--mely-ira.no":true,"meraker.no":true,"xn--merker-kua.no":true,"moareke.no":true,"xn--moreke-jua.no":true,"midsund.no":true,"midtre-gauldal.no":true,"modalen.no":true,"modum.no":true,"molde.no":true,"moskenes.no":true,"moss.no":true,"mosvik.no":true,"malselv.no":true,"xn--mlselv-iua.no":true,"malatvuopmi.no":true,"xn--mlatvuopmi-s4a.no":true,"namdalseid.no":true,"aejrie.no":true,"namsos.no":true,"namsskogan.no":true,"naamesjevuemie.no":true,"xn--nmesjevuemie-tcba.no":true,"laakesvuemie.no":true,"nannestad.no":true,"narvik.no":true,"narviika.no":true,"naustdal.no":true,"nedre-eiker.no":true,"nes.akershus.no":true,"nes.buskerud.no":true,"nesna.no":true,"nesodden.no":true,"nesseby.no":true,"unjarga.no":true,"xn--unjrga-rta.no":true,"nesset.no":true,"nissedal.no":true,"nittedal.no":true,"nord-aurdal.no":true,"nord-fron.no":true,"nord-odal.no":true,"norddal.no":true,"nordkapp.no":true,"davvenjarga.no":true,"xn--davvenjrga-y4a.no":true,"nordre-land.no":true,"nordreisa.no":true,"raisa.no":true,"xn--risa-5na.no":true,"nore-og-uvdal.no":true,"notodden.no":true,"naroy.no":true,"xn--nry-yla5g.no":true,"notteroy.no":true,"xn--nttery-byae.no":true,"odda.no":true,"oksnes.no":true,"xn--ksnes-uua.no":true,"oppdal.no":true,"oppegard.no":true,"xn--oppegrd-ixa.no":true,"orkdal.no":true,"orland.no":true,"xn--rland-uua.no":true,"orskog.no":true,"xn--rskog-uua.no":true,"orsta.no":true,"xn--rsta-fra.no":true,"os.hedmark.no":true,"os.hordaland.no":true,"osen.no":true,"osteroy.no":true,"xn--ostery-fya.no":true,"ostre-toten.no":true,"xn--stre-toten-zcb.no":true,"overhalla.no":true,"ovre-eiker.no":true,"xn--vre-eiker-k8a.no":true,"oyer.no":true,"xn--yer-zna.no":true,"oygarden.no":true,"xn--ygarden-p1a.no":true,"oystre-slidre.no":true,"xn--ystre-slidre-ujb.no":true,"porsanger.no":true,"porsangu.no":true,"xn--porsgu-sta26f.no":true,"porsgrunn.no":true,"radoy.no":true,"xn--rady-ira.no":true,"rakkestad.no":true,"rana.no":true,"ruovat.no":true,"randaberg.no":true,"rauma.no":true,"rendalen.no":true,"rennebu.no":true,"rennesoy.no":true,"xn--rennesy-v1a.no":true,"rindal.no":true,"ringebu.no":true,"ringerike.no":true,"ringsaker.no":true,"rissa.no":true,"risor.no":true,"xn--risr-ira.no":true,"roan.no":true,"rollag.no":true,"rygge.no":true,"ralingen.no":true,"xn--rlingen-mxa.no":true,"rodoy.no":true,"xn--rdy-0nab.no":true,"romskog.no":true,"xn--rmskog-bya.no":true,"roros.no":true,"xn--rros-gra.no":true,"rost.no":true,"xn--rst-0na.no":true,"royken.no":true,"xn--ryken-vua.no":true,"royrvik.no":true,"xn--ryrvik-bya.no":true,"rade.no":true,"xn--rde-ula.no":true,"salangen.no":true,"siellak.no":true,"saltdal.no":true,"salat.no":true,"xn--slt-elab.no":true,"xn--slat-5na.no":true,"samnanger.no":true,"sande.more-og-romsdal.no":true,"sande.xn--mre-og-romsdal-qqb.no":true,"sande.vestfold.no":true,"sandefjord.no":true,"sandnes.no":true,"sandoy.no":true,"xn--sandy-yua.no":true,"sarpsborg.no":true,"sauda.no":true,"sauherad.no":true,"sel.no":true,"selbu.no":true,"selje.no":true,"seljord.no":true,"sigdal.no":true,"siljan.no":true,"sirdal.no":true,"skaun.no":true,"skedsmo.no":true,"ski.no":true,"skien.no":true,"skiptvet.no":true,"skjervoy.no":true,"xn--skjervy-v1a.no":true,"skierva.no":true,"xn--skierv-uta.no":true,"skjak.no":true,"xn--skjk-soa.no":true,"skodje.no":true,"skanland.no":true,"xn--sknland-fxa.no":true,"skanit.no":true,"xn--sknit-yqa.no":true,"smola.no":true,"xn--smla-hra.no":true,"snillfjord.no":true,"snasa.no":true,"xn--snsa-roa.no":true,"snoasa.no":true,"snaase.no":true,"xn--snase-nra.no":true,"sogndal.no":true,"sokndal.no":true,"sola.no":true,"solund.no":true,"songdalen.no":true,"sortland.no":true,"spydeberg.no":true,"stange.no":true,"stavanger.no":true,"steigen.no":true,"steinkjer.no":true,"stjordal.no":true,"xn--stjrdal-s1a.no":true,"stokke.no":true,"stor-elvdal.no":true,"stord.no":true,"stordal.no":true,"storfjord.no":true,"omasvuotna.no":true,"strand.no":true,"stranda.no":true,"stryn.no":true,"sula.no":true,"suldal.no":true,"sund.no":true,"sunndal.no":true,"surnadal.no":true,"sveio.no":true,"svelvik.no":true,"sykkylven.no":true,"sogne.no":true,"xn--sgne-gra.no":true,"somna.no":true,"xn--smna-gra.no":true,"sondre-land.no":true,"xn--sndre-land-0cb.no":true,"sor-aurdal.no":true,"xn--sr-aurdal-l8a.no":true,"sor-fron.no":true,"xn--sr-fron-q1a.no":true,"sor-odal.no":true,"xn--sr-odal-q1a.no":true,"sor-varanger.no":true,"xn--sr-varanger-ggb.no":true,"matta-varjjat.no":true,"xn--mtta-vrjjat-k7af.no":true,"sorfold.no":true,"xn--srfold-bya.no":true,"sorreisa.no":true,"xn--srreisa-q1a.no":true,"sorum.no":true,"xn--srum-gra.no":true,"tana.no":true,"deatnu.no":true,"time.no":true,"tingvoll.no":true,"tinn.no":true,"tjeldsund.no":true,"dielddanuorri.no":true,"tjome.no":true,"xn--tjme-hra.no":true,"tokke.no":true,"tolga.no":true,"torsken.no":true,"tranoy.no":true,"xn--trany-yua.no":true,"tromso.no":true,"xn--troms-zua.no":true,"tromsa.no":true,"romsa.no":true,"trondheim.no":true,"troandin.no":true,"trysil.no":true,"trana.no":true,"xn--trna-woa.no":true,"trogstad.no":true,"xn--trgstad-r1a.no":true,"tvedestrand.no":true,"tydal.no":true,"tynset.no":true,"tysfjord.no":true,"divtasvuodna.no":true,"divttasvuotna.no":true,"tysnes.no":true,"tysvar.no":true,"xn--tysvr-vra.no":true,"tonsberg.no":true,"xn--tnsberg-q1a.no":true,"ullensaker.no":true,"ullensvang.no":true,"ulvik.no":true,"utsira.no":true,"vadso.no":true,"xn--vads-jra.no":true,"cahcesuolo.no":true,"xn--hcesuolo-7ya35b.no":true,"vaksdal.no":true,"valle.no":true,"vang.no":true,"vanylven.no":true,"vardo.no":true,"xn--vard-jra.no":true,"varggat.no":true,"xn--vrggt-xqad.no":true,"vefsn.no":true,"vaapste.no":true,"vega.no":true,"vegarshei.no":true,"xn--vegrshei-c0a.no":true,"vennesla.no":true,"verdal.no":true,"verran.no":true,"vestby.no":true,"vestnes.no":true,"vestre-slidre.no":true,"vestre-toten.no":true,"vestvagoy.no":true,"xn--vestvgy-ixa6o.no":true,"vevelstad.no":true,"vik.no":true,"vikna.no":true,"vindafjord.no":true,"volda.no":true,"voss.no":true,"varoy.no":true,"xn--vry-yla5g.no":true,"vagan.no":true,"xn--vgan-qoa.no":true,"voagat.no":true,"vagsoy.no":true,"xn--vgsy-qoa0j.no":true,"vaga.no":true,"xn--vg-yiab.no":true,"valer.ostfold.no":true,"xn--vler-qoa.xn--stfold-9xa.no":true,"valer.hedmark.no":true,"xn--vler-qoa.hedmark.no":true,"*.np":true,"nr":true,"biz.nr":true,"info.nr":true,"gov.nr":true,"edu.nr":true,"org.nr":true,"net.nr":true,"com.nr":true,"nu":true,"nz":true,"ac.nz":true,"co.nz":true,"cri.nz":true,"geek.nz":true,"gen.nz":true,"govt.nz":true,"health.nz":true,"iwi.nz":true,"kiwi.nz":true,"maori.nz":true,"mil.nz":true,"xn--mori-qsa.nz":true,"net.nz":true,"org.nz":true,"parliament.nz":true,"school.nz":true,"om":true,"co.om":true,"com.om":true,"edu.om":true,"gov.om":true,"med.om":true,"museum.om":true,"net.om":true,"org.om":true,"pro.om":true,"org":true,"pa":true,"ac.pa":true,"gob.pa":true,"com.pa":true,"org.pa":true,"sld.pa":true,"edu.pa":true,"net.pa":true,"ing.pa":true,"abo.pa":true,"med.pa":true,"nom.pa":true,"pe":true,"edu.pe":true,"gob.pe":true,"nom.pe":true,"mil.pe":true,"org.pe":true,"com.pe":true,"net.pe":true,"pf":true,"com.pf":true,"org.pf":true,"edu.pf":true,"*.pg":true,"ph":true,"com.ph":true,"net.ph":true,"org.ph":true,"gov.ph":true,"edu.ph":true,"ngo.ph":true,"mil.ph":true,"i.ph":true,"pk":true,"com.pk":true,"net.pk":true,"edu.pk":true,"org.pk":true,"fam.pk":true,"biz.pk":true,"web.pk":true,"gov.pk":true,"gob.pk":true,"gok.pk":true,"gon.pk":true,"gop.pk":true,"gos.pk":true,"info.pk":true,"pl":true,"com.pl":true,"net.pl":true,"org.pl":true,"info.pl":true,"waw.pl":true,"gov.pl":true,"aid.pl":true,"agro.pl":true,"atm.pl":true,"auto.pl":true,"biz.pl":true,"edu.pl":true,"gmina.pl":true,"gsm.pl":true,"mail.pl":true,"miasta.pl":true,"media.pl":true,"mil.pl":true,"nieruchomosci.pl":true,"nom.pl":true,"pc.pl":true,"powiat.pl":true,"priv.pl":true,"realestate.pl":true,"rel.pl":true,"sex.pl":true,"shop.pl":true,"sklep.pl":true,"sos.pl":true,"szkola.pl":true,"targi.pl":true,"tm.pl":true,"tourism.pl":true,"travel.pl":true,"turystyka.pl":true,"uw.gov.pl":true,"um.gov.pl":true,"ug.gov.pl":true,"upow.gov.pl":true,"starostwo.gov.pl":true,"so.gov.pl":true,"sr.gov.pl":true,"po.gov.pl":true,"pa.gov.pl":true,"augustow.pl":true,"babia-gora.pl":true,"bedzin.pl":true,"beskidy.pl":true,"bialowieza.pl":true,"bialystok.pl":true,"bielawa.pl":true,"bieszczady.pl":true,"boleslawiec.pl":true,"bydgoszcz.pl":true,"bytom.pl":true,"cieszyn.pl":true,"czeladz.pl":true,"czest.pl":true,"dlugoleka.pl":true,"elblag.pl":true,"elk.pl":true,"glogow.pl":true,"gniezno.pl":true,"gorlice.pl":true,"grajewo.pl":true,"ilawa.pl":true,"jaworzno.pl":true,"jelenia-gora.pl":true,"jgora.pl":true,"kalisz.pl":true,"kazimierz-dolny.pl":true,"karpacz.pl":true,"kartuzy.pl":true,"kaszuby.pl":true,"katowice.pl":true,"kepno.pl":true,"ketrzyn.pl":true,"klodzko.pl":true,"kobierzyce.pl":true,"kolobrzeg.pl":true,"konin.pl":true,"konskowola.pl":true,"kutno.pl":true,"lapy.pl":true,"lebork.pl":true,"legnica.pl":true,"lezajsk.pl":true,"limanowa.pl":true,"lomza.pl":true,"lowicz.pl":true,"lubin.pl":true,"lukow.pl":true,"malbork.pl":true,"malopolska.pl":true,"mazowsze.pl":true,"mazury.pl":true,"mielec.pl":true,"mielno.pl":true,"mragowo.pl":true,"naklo.pl":true,"nowaruda.pl":true,"nysa.pl":true,"olawa.pl":true,"olecko.pl":true,"olkusz.pl":true,"olsztyn.pl":true,"opoczno.pl":true,"opole.pl":true,"ostroda.pl":true,"ostroleka.pl":true,"ostrowiec.pl":true,"ostrowwlkp.pl":true,"pila.pl":true,"pisz.pl":true,"podhale.pl":true,"podlasie.pl":true,"polkowice.pl":true,"pomorze.pl":true,"pomorskie.pl":true,"prochowice.pl":true,"pruszkow.pl":true,"przeworsk.pl":true,"pulawy.pl":true,"radom.pl":true,"rawa-maz.pl":true,"rybnik.pl":true,"rzeszow.pl":true,"sanok.pl":true,"sejny.pl":true,"slask.pl":true,"slupsk.pl":true,"sosnowiec.pl":true,"stalowa-wola.pl":true,"skoczow.pl":true,"starachowice.pl":true,"stargard.pl":true,"suwalki.pl":true,"swidnica.pl":true,"swiebodzin.pl":true,"swinoujscie.pl":true,"szczecin.pl":true,"szczytno.pl":true,"tarnobrzeg.pl":true,"tgory.pl":true,"turek.pl":true,"tychy.pl":true,"ustka.pl":true,"walbrzych.pl":true,"warmia.pl":true,"warszawa.pl":true,"wegrow.pl":true,"wielun.pl":true,"wlocl.pl":true,"wloclawek.pl":true,"wodzislaw.pl":true,"wolomin.pl":true,"wroclaw.pl":true,"zachpomor.pl":true,"zagan.pl":true,"zarow.pl":true,"zgora.pl":true,"zgorzelec.pl":true,"pm":true,"pn":true,"gov.pn":true,"co.pn":true,"org.pn":true,"edu.pn":true,"net.pn":true,"post":true,"pr":true,"com.pr":true,"net.pr":true,"org.pr":true,"gov.pr":true,"edu.pr":true,"isla.pr":true,"pro.pr":true,"biz.pr":true,"info.pr":true,"name.pr":true,"est.pr":true,"prof.pr":true,"ac.pr":true,"pro":true,"aca.pro":true,"bar.pro":true,"cpa.pro":true,"jur.pro":true,"law.pro":true,"med.pro":true,"eng.pro":true,"ps":true,"edu.ps":true,"gov.ps":true,"sec.ps":true,"plo.ps":true,"com.ps":true,"org.ps":true,"net.ps":true,"pt":true,"net.pt":true,"gov.pt":true,"org.pt":true,"edu.pt":true,"int.pt":true,"publ.pt":true,"com.pt":true,"nome.pt":true,"pw":true,"co.pw":true,"ne.pw":true,"or.pw":true,"ed.pw":true,"go.pw":true,"belau.pw":true,"py":true,"com.py":true,"coop.py":true,"edu.py":true,"gov.py":true,"mil.py":true,"net.py":true,"org.py":true,"qa":true,"com.qa":true,"edu.qa":true,"gov.qa":true,"mil.qa":true,"name.qa":true,"net.qa":true,"org.qa":true,"sch.qa":true,"re":true,"com.re":true,"asso.re":true,"nom.re":true,"ro":true,"com.ro":true,"org.ro":true,"tm.ro":true,"nt.ro":true,"nom.ro":true,"info.ro":true,"rec.ro":true,"arts.ro":true,"firm.ro":true,"store.ro":true,"www.ro":true,"rs":true,"co.rs":true,"org.rs":true,"edu.rs":true,"ac.rs":true,"gov.rs":true,"in.rs":true,"ru":true,"ac.ru":true,"com.ru":true,"edu.ru":true,"int.ru":true,"net.ru":true,"org.ru":true,"pp.ru":true,"adygeya.ru":true,"altai.ru":true,"amur.ru":true,"arkhangelsk.ru":true,"astrakhan.ru":true,"bashkiria.ru":true,"belgorod.ru":true,"bir.ru":true,"bryansk.ru":true,"buryatia.ru":true,"cbg.ru":true,"chel.ru":true,"chelyabinsk.ru":true,"chita.ru":true,"chukotka.ru":true,"chuvashia.ru":true,"dagestan.ru":true,"dudinka.ru":true,"e-burg.ru":true,"grozny.ru":true,"irkutsk.ru":true,"ivanovo.ru":true,"izhevsk.ru":true,"jar.ru":true,"joshkar-ola.ru":true,"kalmykia.ru":true,"kaluga.ru":true,"kamchatka.ru":true,"karelia.ru":true,"kazan.ru":true,"kchr.ru":true,"kemerovo.ru":true,"khabarovsk.ru":true,"khakassia.ru":true,"khv.ru":true,"kirov.ru":true,"koenig.ru":true,"komi.ru":true,"kostroma.ru":true,"krasnoyarsk.ru":true,"kuban.ru":true,"kurgan.ru":true,"kursk.ru":true,"lipetsk.ru":true,"magadan.ru":true,"mari.ru":true,"mari-el.ru":true,"marine.ru":true,"mordovia.ru":true,"msk.ru":true,"murmansk.ru":true,"nalchik.ru":true,"nnov.ru":true,"nov.ru":true,"novosibirsk.ru":true,"nsk.ru":true,"omsk.ru":true,"orenburg.ru":true,"oryol.ru":true,"palana.ru":true,"penza.ru":true,"perm.ru":true,"ptz.ru":true,"rnd.ru":true,"ryazan.ru":true,"sakhalin.ru":true,"samara.ru":true,"saratov.ru":true,"simbirsk.ru":true,"smolensk.ru":true,"spb.ru":true,"stavropol.ru":true,"stv.ru":true,"surgut.ru":true,"tambov.ru":true,"tatarstan.ru":true,"tom.ru":true,"tomsk.ru":true,"tsaritsyn.ru":true,"tsk.ru":true,"tula.ru":true,"tuva.ru":true,"tver.ru":true,"tyumen.ru":true,"udm.ru":true,"udmurtia.ru":true,"ulan-ude.ru":true,"vladikavkaz.ru":true,"vladimir.ru":true,"vladivostok.ru":true,"volgograd.ru":true,"vologda.ru":true,"voronezh.ru":true,"vrn.ru":true,"vyatka.ru":true,"yakutia.ru":true,"yamal.ru":true,"yaroslavl.ru":true,"yekaterinburg.ru":true,"yuzhno-sakhalinsk.ru":true,"amursk.ru":true,"baikal.ru":true,"cmw.ru":true,"fareast.ru":true,"jamal.ru":true,"kms.ru":true,"k-uralsk.ru":true,"kustanai.ru":true,"kuzbass.ru":true,"magnitka.ru":true,"mytis.ru":true,"nakhodka.ru":true,"nkz.ru":true,"norilsk.ru":true,"oskol.ru":true,"pyatigorsk.ru":true,"rubtsovsk.ru":true,"snz.ru":true,"syzran.ru":true,"vdonsk.ru":true,"zgrad.ru":true,"gov.ru":true,"mil.ru":true,"test.ru":true,"rw":true,"gov.rw":true,"net.rw":true,"edu.rw":true,"ac.rw":true,"com.rw":true,"co.rw":true,"int.rw":true,"mil.rw":true,"gouv.rw":true,"sa":true,"com.sa":true,"net.sa":true,"org.sa":true,"gov.sa":true,"med.sa":true,"pub.sa":true,"edu.sa":true,"sch.sa":true,"sb":true,"com.sb":true,"edu.sb":true,"gov.sb":true,"net.sb":true,"org.sb":true,"sc":true,"com.sc":true,"gov.sc":true,"net.sc":true,"org.sc":true,"edu.sc":true,"sd":true,"com.sd":true,"net.sd":true,"org.sd":true,"edu.sd":true,"med.sd":true,"tv.sd":true,"gov.sd":true,"info.sd":true,"se":true,"a.se":true,"ac.se":true,"b.se":true,"bd.se":true,"brand.se":true,"c.se":true,"d.se":true,"e.se":true,"f.se":true,"fh.se":true,"fhsk.se":true,"fhv.se":true,"g.se":true,"h.se":true,"i.se":true,"k.se":true,"komforb.se":true,"kommunalforbund.se":true,"komvux.se":true,"l.se":true,"lanbib.se":true,"m.se":true,"n.se":true,"naturbruksgymn.se":true,"o.se":true,"org.se":true,"p.se":true,"parti.se":true,"pp.se":true,"press.se":true,"r.se":true,"s.se":true,"t.se":true,"tm.se":true,"u.se":true,"w.se":true,"x.se":true,"y.se":true,"z.se":true,"sg":true,"com.sg":true,"net.sg":true,"org.sg":true,"gov.sg":true,"edu.sg":true,"per.sg":true,"sh":true,"com.sh":true,"net.sh":true,"gov.sh":true,"org.sh":true,"mil.sh":true,"si":true,"sj":true,"sk":true,"sl":true,"com.sl":true,"net.sl":true,"edu.sl":true,"gov.sl":true,"org.sl":true,"sm":true,"sn":true,"art.sn":true,"com.sn":true,"edu.sn":true,"gouv.sn":true,"org.sn":true,"perso.sn":true,"univ.sn":true,"so":true,"com.so":true,"net.so":true,"org.so":true,"sr":true,"st":true,"co.st":true,"com.st":true,"consulado.st":true,"edu.st":true,"embaixada.st":true,"gov.st":true,"mil.st":true,"net.st":true,"org.st":true,"principe.st":true,"saotome.st":true,"store.st":true,"su":true,"adygeya.su":true,"arkhangelsk.su":true,"balashov.su":true,"bashkiria.su":true,"bryansk.su":true,"dagestan.su":true,"grozny.su":true,"ivanovo.su":true,"kalmykia.su":true,"kaluga.su":true,"karelia.su":true,"khakassia.su":true,"krasnodar.su":true,"kurgan.su":true,"lenug.su":true,"mordovia.su":true,"msk.su":true,"murmansk.su":true,"nalchik.su":true,"nov.su":true,"obninsk.su":true,"penza.su":true,"pokrovsk.su":true,"sochi.su":true,"spb.su":true,"togliatti.su":true,"troitsk.su":true,"tula.su":true,"tuva.su":true,"vladikavkaz.su":true,"vladimir.su":true,"vologda.su":true,"sv":true,"com.sv":true,"edu.sv":true,"gob.sv":true,"org.sv":true,"red.sv":true,"sx":true,"gov.sx":true,"sy":true,"edu.sy":true,"gov.sy":true,"net.sy":true,"mil.sy":true,"com.sy":true,"org.sy":true,"sz":true,"co.sz":true,"ac.sz":true,"org.sz":true,"tc":true,"td":true,"tel":true,"tf":true,"tg":true,"th":true,"ac.th":true,"co.th":true,"go.th":true,"in.th":true,"mi.th":true,"net.th":true,"or.th":true,"tj":true,"ac.tj":true,"biz.tj":true,"co.tj":true,"com.tj":true,"edu.tj":true,"go.tj":true,"gov.tj":true,"int.tj":true,"mil.tj":true,"name.tj":true,"net.tj":true,"nic.tj":true,"org.tj":true,"test.tj":true,"web.tj":true,"tk":true,"tl":true,"gov.tl":true,"tm":true,"com.tm":true,"co.tm":true,"org.tm":true,"net.tm":true,"nom.tm":true,"gov.tm":true,"mil.tm":true,"edu.tm":true,"tn":true,"com.tn":true,"ens.tn":true,"fin.tn":true,"gov.tn":true,"ind.tn":true,"intl.tn":true,"nat.tn":true,"net.tn":true,"org.tn":true,"info.tn":true,"perso.tn":true,"tourism.tn":true,"edunet.tn":true,"rnrt.tn":true,"rns.tn":true,"rnu.tn":true,"mincom.tn":true,"agrinet.tn":true,"defense.tn":true,"turen.tn":true,"to":true,"com.to":true,"gov.to":true,"net.to":true,"org.to":true,"edu.to":true,"mil.to":true,"tp":true,"tr":true,"com.tr":true,"info.tr":true,"biz.tr":true,"net.tr":true,"org.tr":true,"web.tr":true,"gen.tr":true,"tv.tr":true,"av.tr":true,"dr.tr":true,"bbs.tr":true,"name.tr":true,"tel.tr":true,"gov.tr":true,"bel.tr":true,"pol.tr":true,"mil.tr":true,"k12.tr":true,"edu.tr":true,"kep.tr":true,"nc.tr":true,"gov.nc.tr":true,"travel":true,"tt":true,"co.tt":true,"com.tt":true,"org.tt":true,"net.tt":true,"biz.tt":true,"info.tt":true,"pro.tt":true,"int.tt":true,"coop.tt":true,"jobs.tt":true,"mobi.tt":true,"travel.tt":true,"museum.tt":true,"aero.tt":true,"name.tt":true,"gov.tt":true,"edu.tt":true,"tv":true,"tw":true,"edu.tw":true,"gov.tw":true,"mil.tw":true,"com.tw":true,"net.tw":true,"org.tw":true,"idv.tw":true,"game.tw":true,"ebiz.tw":true,"club.tw":true,"xn--zf0ao64a.tw":true,"xn--uc0atv.tw":true,"xn--czrw28b.tw":true,"tz":true,"ac.tz":true,"co.tz":true,"go.tz":true,"hotel.tz":true,"info.tz":true,"me.tz":true,"mil.tz":true,"mobi.tz":true,"ne.tz":true,"or.tz":true,"sc.tz":true,"tv.tz":true,"ua":true,"com.ua":true,"edu.ua":true,"gov.ua":true,"in.ua":true,"net.ua":true,"org.ua":true,"cherkassy.ua":true,"cherkasy.ua":true,"chernigov.ua":true,"chernihiv.ua":true,"chernivtsi.ua":true,"chernovtsy.ua":true,"ck.ua":true,"cn.ua":true,"cr.ua":true,"crimea.ua":true,"cv.ua":true,"dn.ua":true,"dnepropetrovsk.ua":true,"dnipropetrovsk.ua":true,"dominic.ua":true,"donetsk.ua":true,"dp.ua":true,"if.ua":true,"ivano-frankivsk.ua":true,"kh.ua":true,"kharkiv.ua":true,"kharkov.ua":true,"kherson.ua":true,"khmelnitskiy.ua":true,"khmelnytskyi.ua":true,"kiev.ua":true,"kirovograd.ua":true,"km.ua":true,"kr.ua":true,"krym.ua":true,"ks.ua":true,"kv.ua":true,"kyiv.ua":true,"lg.ua":true,"lt.ua":true,"lugansk.ua":true,"lutsk.ua":true,"lv.ua":true,"lviv.ua":true,"mk.ua":true,"mykolaiv.ua":true,"nikolaev.ua":true,"od.ua":true,"odesa.ua":true,"odessa.ua":true,"pl.ua":true,"poltava.ua":true,"rivne.ua":true,"rovno.ua":true,"rv.ua":true,"sb.ua":true,"sebastopol.ua":true,"sevastopol.ua":true,"sm.ua":true,"sumy.ua":true,"te.ua":true,"ternopil.ua":true,"uz.ua":true,"uzhgorod.ua":true,"vinnica.ua":true,"vinnytsia.ua":true,"vn.ua":true,"volyn.ua":true,"yalta.ua":true,"zaporizhzhe.ua":true,"zaporizhzhia.ua":true,"zhitomir.ua":true,"zhytomyr.ua":true,"zp.ua":true,"zt.ua":true,"co.ua":true,"pp.ua":true,"ug":true,"co.ug":true,"or.ug":true,"ac.ug":true,"sc.ug":true,"go.ug":true,"ne.ug":true,"com.ug":true,"org.ug":true,"uk":true,"ac.uk":true,"co.uk":true,"gov.uk":true,"ltd.uk":true,"me.uk":true,"net.uk":true,"nhs.uk":true,"org.uk":true,"plc.uk":true,"police.uk":true,"*.sch.uk":true,"us":true,"dni.us":true,"fed.us":true,"isa.us":true,"kids.us":true,"nsn.us":true,"ak.us":true,"al.us":true,"ar.us":true,"as.us":true,"az.us":true,"ca.us":true,"co.us":true,"ct.us":true,"dc.us":true,"de.us":true,"fl.us":true,"ga.us":true,"gu.us":true,"hi.us":true,"ia.us":true,"id.us":true,"il.us":true,"in.us":true,"ks.us":true,"ky.us":true,"la.us":true,"ma.us":true,"md.us":true,"me.us":true,"mi.us":true,"mn.us":true,"mo.us":true,"ms.us":true,"mt.us":true,"nc.us":true,"nd.us":true,"ne.us":true,"nh.us":true,"nj.us":true,"nm.us":true,"nv.us":true,"ny.us":true,"oh.us":true,"ok.us":true,"or.us":true,"pa.us":true,"pr.us":true,"ri.us":true,"sc.us":true,"sd.us":true,"tn.us":true,"tx.us":true,"ut.us":true,"vi.us":true,"vt.us":true,"va.us":true,"wa.us":true,"wi.us":true,"wv.us":true,"wy.us":true,"k12.ak.us":true,"k12.al.us":true,"k12.ar.us":true,"k12.as.us":true,"k12.az.us":true,"k12.ca.us":true,"k12.co.us":true,"k12.ct.us":true,"k12.dc.us":true,"k12.de.us":true,"k12.fl.us":true,"k12.ga.us":true,"k12.gu.us":true,"k12.ia.us":true,"k12.id.us":true,"k12.il.us":true,"k12.in.us":true,"k12.ks.us":true,"k12.ky.us":true,"k12.la.us":true,"k12.ma.us":true,"k12.md.us":true,"k12.me.us":true,"k12.mi.us":true,"k12.mn.us":true,"k12.mo.us":true,"k12.ms.us":true,"k12.mt.us":true,"k12.nc.us":true,"k12.ne.us":true,"k12.nh.us":true,"k12.nj.us":true,"k12.nm.us":true,"k12.nv.us":true,"k12.ny.us":true,"k12.oh.us":true,"k12.ok.us":true,"k12.or.us":true,"k12.pa.us":true,"k12.pr.us":true,"k12.ri.us":true,"k12.sc.us":true,"k12.tn.us":true,"k12.tx.us":true,"k12.ut.us":true,"k12.vi.us":true,"k12.vt.us":true,"k12.va.us":true,"k12.wa.us":true,"k12.wi.us":true,"k12.wy.us":true,"cc.ak.us":true,"cc.al.us":true,"cc.ar.us":true,"cc.as.us":true,"cc.az.us":true,"cc.ca.us":true,"cc.co.us":true,"cc.ct.us":true,"cc.dc.us":true,"cc.de.us":true,"cc.fl.us":true,"cc.ga.us":true,"cc.gu.us":true,"cc.hi.us":true,"cc.ia.us":true,"cc.id.us":true,"cc.il.us":true,"cc.in.us":true,"cc.ks.us":true,"cc.ky.us":true,"cc.la.us":true,"cc.ma.us":true,"cc.md.us":true,"cc.me.us":true,"cc.mi.us":true,"cc.mn.us":true,"cc.mo.us":true,"cc.ms.us":true,"cc.mt.us":true,"cc.nc.us":true,"cc.nd.us":true,"cc.ne.us":true,"cc.nh.us":true,"cc.nj.us":true,"cc.nm.us":true,"cc.nv.us":true,"cc.ny.us":true,"cc.oh.us":true,"cc.ok.us":true,"cc.or.us":true,"cc.pa.us":true,"cc.pr.us":true,"cc.ri.us":true,"cc.sc.us":true,"cc.sd.us":true,"cc.tn.us":true,"cc.tx.us":true,"cc.ut.us":true,"cc.vi.us":true,"cc.vt.us":true,"cc.va.us":true,"cc.wa.us":true,"cc.wi.us":true,"cc.wv.us":true,"cc.wy.us":true,"lib.ak.us":true,"lib.al.us":true,"lib.ar.us":true,"lib.as.us":true,"lib.az.us":true,"lib.ca.us":true,"lib.co.us":true,"lib.ct.us":true,"lib.dc.us":true,"lib.de.us":true,"lib.fl.us":true,"lib.ga.us":true,"lib.gu.us":true,"lib.hi.us":true,"lib.ia.us":true,"lib.id.us":true,"lib.il.us":true,"lib.in.us":true,"lib.ks.us":true,"lib.ky.us":true,"lib.la.us":true,"lib.ma.us":true,"lib.md.us":true,"lib.me.us":true,"lib.mi.us":true,"lib.mn.us":true,"lib.mo.us":true,"lib.ms.us":true,"lib.mt.us":true,"lib.nc.us":true,"lib.nd.us":true,"lib.ne.us":true,"lib.nh.us":true,"lib.nj.us":true,"lib.nm.us":true,"lib.nv.us":true,"lib.ny.us":true,"lib.oh.us":true,"lib.ok.us":true,"lib.or.us":true,"lib.pa.us":true,"lib.pr.us":true,"lib.ri.us":true,"lib.sc.us":true,"lib.sd.us":true,"lib.tn.us":true,"lib.tx.us":true,"lib.ut.us":true,"lib.vi.us":true,"lib.vt.us":true,"lib.va.us":true,"lib.wa.us":true,"lib.wi.us":true,"lib.wy.us":true,"pvt.k12.ma.us":true,"chtr.k12.ma.us":true,"paroch.k12.ma.us":true,"uy":true,"com.uy":true,"edu.uy":true,"gub.uy":true,"mil.uy":true,"net.uy":true,"org.uy":true,"uz":true,"co.uz":true,"com.uz":true,"net.uz":true,"org.uz":true,"va":true,"vc":true,"com.vc":true,"net.vc":true,"org.vc":true,"gov.vc":true,"mil.vc":true,"edu.vc":true,"ve":true,"arts.ve":true,"co.ve":true,"com.ve":true,"e12.ve":true,"edu.ve":true,"firm.ve":true,"gob.ve":true,"gov.ve":true,"info.ve":true,"int.ve":true,"mil.ve":true,"net.ve":true,"org.ve":true,"rec.ve":true,"store.ve":true,"tec.ve":true,"web.ve":true,"vg":true,"vi":true,"co.vi":true,"com.vi":true,"k12.vi":true,"net.vi":true,"org.vi":true,"vn":true,"com.vn":true,"net.vn":true,"org.vn":true,"edu.vn":true,"gov.vn":true,"int.vn":true,"ac.vn":true,"biz.vn":true,"info.vn":true,"name.vn":true,"pro.vn":true,"health.vn":true,"vu":true,"com.vu":true,"edu.vu":true,"net.vu":true,"org.vu":true,"wf":true,"ws":true,"com.ws":true,"net.ws":true,"org.ws":true,"gov.ws":true,"edu.ws":true,"yt":true,"xn--mgbaam7a8h":true,"xn--54b7fta0cc":true,"xn--fiqs8s":true,"xn--fiqz9s":true,"xn--lgbbat1ad8j":true,"xn--wgbh1c":true,"xn--node":true,"xn--j6w193g":true,"xn--h2brj9c":true,"xn--mgbbh1a71e":true,"xn--fpcrj9c3d":true,"xn--gecrj9c":true,"xn--s9brj9c":true,"xn--45brj9c":true,"xn--xkc2dl3a5ee0h":true,"xn--mgba3a4f16a":true,"xn--mgba3a4fra":true,"xn--mgbayh7gpa":true,"xn--3e0b707e":true,"xn--80ao21a":true,"xn--fzc2c9e2c":true,"xn--xkc2al3hye2a":true,"xn--mgbc0a9azcg":true,"xn--l1acc":true,"xn--mgbx4cd0ab":true,"xn--mgb9awbf":true,"xn--ygbi2ammx":true,"xn--90a3ac":true,"xn--o1ac.xn--90a3ac":true,"xn--c1avg.xn--90a3ac":true,"xn--90azh.xn--90a3ac":true,"xn--d1at.xn--90a3ac":true,"xn--o1ach.xn--90a3ac":true,"xn--80au.xn--90a3ac":true,"xn--p1ai":true,"xn--wgbl6a":true,"xn--mgberp4a5d4ar":true,"xn--mgberp4a5d4a87g":true,"xn--mgbqly7c0a67fbc":true,"xn--mgbqly7cvafr":true,"xn--ogbpf8fl":true,"xn--mgbtf8fl":true,"xn--yfro4i67o":true,"xn--clchc0ea0b2g2a9gcd":true,"xn--o3cw4h":true,"xn--pgbs0dh":true,"xn--kpry57d":true,"xn--kprw13d":true,"xn--nnx388a":true,"xn--j1amh":true,"xn--mgb2ddes":true,"xxx":true,"*.ye":true,"*.za":true,"*.zm":true,"*.zw":true,"aaa":true,"abb":true,"abbott":true,"abogado":true,"academy":true,"accenture":true,"accountant":true,"accountants":true,"aco":true,"active":true,"actor":true,"ads":true,"adult":true,"aeg":true,"afl":true,"africa":true,"africamagic":true,"agency":true,"aig":true,"airforce":true,"airtel":true,"alibaba":true,"alipay":true,"allfinanz":true,"alsace":true,"amsterdam":true,"analytics":true,"android":true,"anquan":true,"apartments":true,"aquarelle":true,"aramco":true,"archi":true,"army":true,"arte":true,"associates":true,"attorney":true,"auction":true,"audio":true,"author":true,"auto":true,"autos":true,"avianca":true,"axa":true,"azure":true,"baidu":true,"band":true,"bank":true,"bar":true,"barcelona":true,"barclaycard":true,"barclays":true,"bargains":true,"bauhaus":true,"bayern":true,"bbc":true,"bbva":true,"bcg":true,"bcn":true,"beer":true,"bentley":true,"berlin":true,"best":true,"bharti":true,"bible":true,"bid":true,"bike":true,"bing":true,"bingo":true,"bio":true,"black":true,"blackfriday":true,"bloomberg":true,"blue":true,"bms":true,"bmw":true,"bnl":true,"bnpparibas":true,"boats":true,"bom":true,"bond":true,"boo":true,"boots":true,"bot":true,"boutique":true,"bradesco":true,"bridgestone":true,"broadway":true,"broker":true,"brother":true,"brussels":true,"budapest":true,"build":true,"builders":true,"business":true,"buy":true,"buzz":true,"bzh":true,"cab":true,"cafe":true,"cal":true,"call":true,"camera":true,"camp":true,"cancerresearch":true,"canon":true,"capetown":true,"capital":true,"car":true,"caravan":true,"cards":true,"care":true,"career":true,"careers":true,"cars":true,"cartier":true,"casa":true,"cash":true,"casino":true,"catering":true,"cba":true,"cbn":true,"center":true,"ceo":true,"cern":true,"cfa":true,"cfd":true,"channel":true,"chat":true,"cheap":true,"chloe":true,"christmas":true,"chrome":true,"church":true,"cipriani":true,"circle":true,"cisco":true,"citic":true,"city":true,"cityeats":true,"claims":true,"cleaning":true,"click":true,"clinic":true,"clothing":true,"club":true,"coach":true,"codes":true,"coffee":true,"college":true,"cologne":true,"commbank":true,"community":true,"company":true,"computer":true,"comsec":true,"condos":true,"construction":true,"consulting":true,"contact":true,"contractors":true,"cooking":true,"cool":true,"corsica":true,"country":true,"coupon":true,"coupons":true,"courses":true,"credit":true,"creditcard":true,"creditunion":true,"cricket":true,"crown":true,"crs":true,"cruises":true,"csc":true,"cuisinella":true,"cymru":true,"cyou":true,"dabur":true,"dad":true,"dance":true,"date":true,"dating":true,"datsun":true,"day":true,"dclk":true,"dealer":true,"deals":true,"degree":true,"delivery":true,"dell":true,"delta":true,"democrat":true,"dental":true,"dentist":true,"desi":true,"design":true,"dev":true,"diamonds":true,"diet":true,"digital":true,"direct":true,"directory":true,"discount":true,"dnp":true,"docs":true,"dog":true,"doha":true,"domains":true,"doosan":true,"download":true,"drive":true,"dstv":true,"dubai":true,"durban":true,"dvag":true,"earth":true,"eat":true,"edeka":true,"education":true,"email":true,"emerck":true,"energy":true,"engineer":true,"engineering":true,"enterprises":true,"epson":true,"equipment":true,"erni":true,"esq":true,"estate":true,"eurovision":true,"eus":true,"events":true,"everbank":true,"exchange":true,"expert":true,"exposed":true,"express":true,"fage":true,"fail":true,"fairwinds":true,"faith":true,"family":true,"fan":true,"fans":true,"farm":true,"fashion":true,"fast":true,"feedback":true,"ferrero":true,"film":true,"final":true,"finance":true,"financial":true,"firestone":true,"firmdale":true,"fish":true,"fishing":true,"fit":true,"fitness":true,"flickr":true,"flights":true,"florist":true,"flowers":true,"flsmidth":true,"fly":true,"foo":true,"football":true,"ford":true,"forex":true,"forsale":true,"forum":true,"foundation":true,"frl":true,"frogans":true,"frontier":true,"fund":true,"furniture":true,"futbol":true,"fyi":true,"gal":true,"gallery":true,"gallup":true,"garden":true,"gbiz":true,"gdn":true,"gea":true,"gent":true,"genting":true,"ggee":true,"gift":true,"gifts":true,"gives":true,"giving":true,"glass":true,"gle":true,"global":true,"globo":true,"gmail":true,"gmo":true,"gmx":true,"gold":true,"goldpoint":true,"golf":true,"goo":true,"goog":true,"google":true,"gop":true,"got":true,"gotv":true,"graphics":true,"gratis":true,"green":true,"gripe":true,"group":true,"gucci":true,"guge":true,"guide":true,"guitars":true,"guru":true,"hamburg":true,"hangout":true,"haus":true,"hdfcbank":true,"health":true,"healthcare":true,"help":true,"helsinki":true,"here":true,"hermes":true,"hiphop":true,"hitachi":true,"hiv":true,"hockey":true,"holdings":true,"holiday":true,"homedepot":true,"homes":true,"honda":true,"horse":true,"host":true,"hosting":true,"hoteles":true,"hotmail":true,"house":true,"how":true,"hsbc":true,"htc":true,"ibm":true,"icbc":true,"ice":true,"icu":true,"ifm":true,"iinet":true,"immo":true,"immobilien":true,"industries":true,"infiniti":true,"ing":true,"ink":true,"institute":true,"insurance":true,"insure":true,"international":true,"investments":true,"ipiranga":true,"irish":true,"iselect":true,"ist":true,"istanbul":true,"itau":true,"iwc":true,"jaguar":true,"java":true,"jcb":true,"jetzt":true,"jewelry":true,"jio":true,"jlc":true,"jll":true,"jmp":true,"joburg":true,"jot":true,"joy":true,"jprs":true,"juegos":true,"kaufen":true,"kddi":true,"kfh":true,"kim":true,"kinder":true,"kitchen":true,"kiwi":true,"koeln":true,"komatsu":true,"kpn":true,"krd":true,"kred":true,"kyknet":true,"kyoto":true,"lacaixa":true,"lancaster":true,"land":true,"landrover":true,"lasalle":true,"lat":true,"latrobe":true,"law":true,"lawyer":true,"lds":true,"lease":true,"leclerc":true,"legal":true,"lgbt":true,"liaison":true,"lidl":true,"life":true,"lifeinsurance":true,"lifestyle":true,"lighting":true,"like":true,"limited":true,"limo":true,"lincoln":true,"linde":true,"link":true,"live":true,"lixil":true,"loan":true,"loans":true,"lol":true,"london":true,"lotte":true,"lotto":true,"love":true,"ltd":true,"ltda":true,"lupin":true,"luxe":true,"luxury":true,"madrid":true,"maif":true,"maison":true,"makeup":true,"man":true,"management":true,"mango":true,"market":true,"marketing":true,"markets":true,"marriott":true,"mba":true,"media":true,"meet":true,"melbourne":true,"meme":true,"memorial":true,"men":true,"menu":true,"meo":true,"miami":true,"microsoft":true,"mini":true,"mma":true,"mnet":true,"mobily":true,"moda":true,"moe":true,"moi":true,"monash":true,"money":true,"montblanc":true,"mormon":true,"mortgage":true,"moscow":true,"motorcycles":true,"mov":true,"movie":true,"movistar":true,"mtn":true,"mtpc":true,"mtr":true,"multichoice":true,"mutual":true,"mzansimagic":true,"nadex":true,"nagoya":true,"naspers":true,"natura":true,"navy":true,"nec":true,"netbank":true,"network":true,"neustar":true,"new":true,"news":true,"nexus":true,"ngo":true,"nhk":true,"nico":true,"ninja":true,"nissan":true,"nokia":true,"norton":true,"nowruz":true,"nra":true,"nrw":true,"ntt":true,"nyc":true,"obi":true,"office":true,"okinawa":true,"omega":true,"one":true,"ong":true,"onl":true,"online":true,"ooo":true,"oracle":true,"orange":true,"organic":true,"orientexpress":true,"osaka":true,"otsuka":true,"ovh":true,"page":true,"pamperedchef":true,"panerai":true,"paris":true,"pars":true,"partners":true,"parts":true,"party":true,"passagens":true,"payu":true,"pharmacy":true,"philips":true,"photo":true,"photography":true,"photos":true,"physio":true,"piaget":true,"pics":true,"pictet":true,"pictures":true,"pid":true,"pin":true,"pink":true,"pizza":true,"place":true,"play":true,"plumbing":true,"plus":true,"pohl":true,"poker":true,"porn":true,"praxi":true,"press":true,"prod":true,"productions":true,"prof":true,"promo":true,"properties":true,"property":true,"pub":true,"qpon":true,"quebec":true,"quest":true,"racing":true,"read":true,"realtor":true,"realty":true,"recipes":true,"red":true,"redstone":true,"redumbrella":true,"rehab":true,"reise":true,"reisen":true,"reit":true,"reliance":true,"ren":true,"rent":true,"rentals":true,"repair":true,"report":true,"republican":true,"rest":true,"restaurant":true,"review":true,"reviews":true,"rich":true,"ricoh":true,"ril":true,"rio":true,"rip":true,"rocher":true,"rocks":true,"rodeo":true,"room":true,"rsvp":true,"ruhr":true,"run":true,"rwe":true,"ryukyu":true,"saarland":true,"safe":true,"safety":true,"sakura":true,"sale":true,"salon":true,"samsung":true,"sandvik":true,"sandvikcoromant":true,"sanofi":true,"sap":true,"sapo":true,"sarl":true,"sas":true,"saxo":true,"sbi":true,"sbs":true,"sca":true,"scb":true,"schmidt":true,"scholarships":true,"school":true,"schule":true,"schwarz":true,"science":true,"scor":true,"scot":true,"seat":true,"seek":true,"sener":true,"services":true,"sew":true,"sex":true,"sexy":true,"sharp":true,"shia":true,"shiksha":true,"shoes":true,"shouji":true,"show":true,"shriram":true,"sina":true,"singles":true,"site":true,"skin":true,"sky":true,"skype":true,"smile":true,"sncf":true,"soccer":true,"social":true,"software":true,"sohu":true,"solar":true,"solutions":true,"song":true,"sony":true,"soy":true,"space":true,"spiegel":true,"spot":true,"spreadbetting":true,"stada":true,"star":true,"starhub":true,"statebank":true,"statoil":true,"stc":true,"stcgroup":true,"stockholm":true,"storage":true,"studio":true,"study":true,"style":true,"sucks":true,"supersport":true,"supplies":true,"supply":true,"support":true,"surf":true,"surgery":true,"suzuki":true,"swatch":true,"swiss":true,"sydney":true,"symantec":true,"systems":true,"tab":true,"taipei":true,"taobao":true,"tatamotors":true,"tatar":true,"tattoo":true,"tax":true,"taxi":true,"tci":true,"team":true,"tech":true,"technology":true,"telecity":true,"telefonica":true,"temasek":true,"tennis":true,"thd":true,"theater":true,"tickets":true,"tienda":true,"tiffany":true,"tips":true,"tires":true,"tirol":true,"tmall":true,"today":true,"tokyo":true,"tools":true,"top":true,"toray":true,"toshiba":true,"tours":true,"town":true,"toys":true,"trade":true,"trading":true,"training":true,"travelers":true,"travelersinsurance":true,"trust":true,"trv":true,"tui":true,"tunes":true,"tushu":true,"tvs":true,"ubs":true,"university":true,"uno":true,"uol":true,"vacations":true,"vana":true,"vegas":true,"ventures":true,"versicherung":true,"vet":true,"viajes":true,"video":true,"viking":true,"villas":true,"vip":true,"virgin":true,"vision":true,"vista":true,"vistaprint":true,"viva":true,"vlaanderen":true,"vodka":true,"vote":true,"voting":true,"voto":true,"voyage":true,"vuelos":true,"wales":true,"walter":true,"wang":true,"wanggou":true,"watch":true,"watches":true,"weather":true,"weatherchannel":true,"webcam":true,"website":true,"wed":true,"wedding":true,"weibo":true,"weir":true,"whoswho":true,"wien":true,"wiki":true,"williamhill":true,"win":true,"windows":true,"wme":true,"work":true,"works":true,"world":true,"wtc":true,"wtf":true,"xbox":true,"xerox":true,"xihuan":true,"xin":true,"xn--11b4c3d":true,"xn--1ck2e1b":true,"xn--1qqw23a":true,"xn--30rr7y":true,"xn--3bst00m":true,"xn--3ds443g":true,"xn--3pxu8k":true,"xn--42c2d9a":true,"xn--45q11c":true,"xn--4gbrim":true,"xn--55qw42g":true,"xn--55qx5d":true,"xn--5tzm5g":true,"xn--6frz82g":true,"xn--6qq986b3xl":true,"xn--80adxhks":true,"xn--80asehdb":true,"xn--80aswg":true,"xn--8y0a063a":true,"xn--9dbq2a":true,"xn--9et52u":true,"xn--9krt00a":true,"xn--b4w605ferd":true,"xn--bck1b9a5dre4c":true,"xn--c1avg":true,"xn--c2br7g":true,"xn--cck2b3b":true,"xn--cg4bki":true,"xn--czr694b":true,"xn--czrs0t":true,"xn--czru2d":true,"xn--d1acj3b":true,"xn--eckvdtc9d":true,"xn--efvy88h":true,"xn--estv75g":true,"xn--fhbei":true,"xn--fiq228c5hs":true,"xn--fiq64b":true,"xn--fjq720a":true,"xn--flw351e":true,"xn--g2xx48c":true,"xn--gckr3f0f":true,"xn--hxt814e":true,"xn--i1b6b1a6a2e":true,"xn--imr513n":true,"xn--io0a7i":true,"xn--j1aef":true,"xn--jlq61u9w7b":true,"xn--jvr189m":true,"xn--kcrx77d1x4a":true,"xn--kpu716f":true,"xn--kput3i":true,"xn--mgba3a3ejt":true,"xn--mgbab2bd":true,"xn--mgbb9fbpob":true,"xn--mgbt3dhd":true,"xn--mk1bu44c":true,"xn--mxtq1m":true,"xn--ngbc5azd":true,"xn--ngbe9e0a":true,"xn--nqv7f":true,"xn--nqv7fs00ema":true,"xn--nyqy26a":true,"xn--p1acf":true,"xn--pbt977c":true,"xn--pssy2u":true,"xn--q9jyb4c":true,"xn--qcka1pmc":true,"xn--rhqv96g":true,"xn--rovu88b":true,"xn--ses554g":true,"xn--t60b56a":true,"xn--tckwe":true,"xn--unup4y":true,"xn--vermgensberater-ctb":true,"xn--vermgensberatung-pwb":true,"xn--vhquv":true,"xn--vuq861b":true,"xn--xhq521b":true,"xn--zfr164b":true,"xyz":true,"yachts":true,"yahoo":true,"yamaxun":true,"yandex":true,"yodobashi":true,"yoga":true,"yokohama":true,"youtube":true,"yun":true,"zara":true,"zero":true,"zip":true,"zone":true,"zuerich":true,"cloudfront.net":true,"ap-northeast-1.compute.amazonaws.com":true,"ap-southeast-1.compute.amazonaws.com":true,"ap-southeast-2.compute.amazonaws.com":true,"cn-north-1.compute.amazonaws.cn":true,"compute.amazonaws.cn":true,"compute.amazonaws.com":true,"compute-1.amazonaws.com":true,"eu-west-1.compute.amazonaws.com":true,"eu-central-1.compute.amazonaws.com":true,"sa-east-1.compute.amazonaws.com":true,"us-east-1.amazonaws.com":true,"us-gov-west-1.compute.amazonaws.com":true,"us-west-1.compute.amazonaws.com":true,"us-west-2.compute.amazonaws.com":true,"z-1.compute-1.amazonaws.com":true,"z-2.compute-1.amazonaws.com":true,"elasticbeanstalk.com":true,"elb.amazonaws.com":true,"s3.amazonaws.com":true,"s3-us-west-2.amazonaws.com":true,"s3-us-west-1.amazonaws.com":true,"s3-eu-west-1.amazonaws.com":true,"s3-ap-southeast-1.amazonaws.com":true,"s3-ap-southeast-2.amazonaws.com":true,"s3-ap-northeast-1.amazonaws.com":true,"s3-sa-east-1.amazonaws.com":true,"s3-us-gov-west-1.amazonaws.com":true,"s3-fips-us-gov-west-1.amazonaws.com":true,"s3-website-us-east-1.amazonaws.com":true,"s3-website-us-west-2.amazonaws.com":true,"s3-website-us-west-1.amazonaws.com":true,"s3-website-eu-west-1.amazonaws.com":true,"s3-website-ap-southeast-1.amazonaws.com":true,"s3-website-ap-southeast-2.amazonaws.com":true,"s3-website-ap-northeast-1.amazonaws.com":true,"s3-website-sa-east-1.amazonaws.com":true,"s3-website-us-gov-west-1.amazonaws.com":true,"betainabox.com":true,"ae.org":true,"ar.com":true,"br.com":true,"cn.com":true,"com.de":true,"com.se":true,"de.com":true,"eu.com":true,"gb.com":true,"gb.net":true,"hu.com":true,"hu.net":true,"jp.net":true,"jpn.com":true,"kr.com":true,"mex.com":true,"no.com":true,"qc.com":true,"ru.com":true,"sa.com":true,"se.com":true,"se.net":true,"uk.com":true,"uk.net":true,"us.com":true,"uy.com":true,"za.bz":true,"za.com":true,"africa.com":true,"gr.com":true,"in.net":true,"us.org":true,"co.com":true,"c.la":true,"cloudcontrolled.com":true,"cloudcontrolapp.com":true,"co.ca":true,"co.nl":true,"co.no":true,"*.platform.sh":true,"cupcake.is":true,"dreamhosters.com":true,"dyndns-at-home.com":true,"dyndns-at-work.com":true,"dyndns-blog.com":true,"dyndns-free.com":true,"dyndns-home.com":true,"dyndns-ip.com":true,"dyndns-mail.com":true,"dyndns-office.com":true,"dyndns-pics.com":true,"dyndns-remote.com":true,"dyndns-server.com":true,"dyndns-web.com":true,"dyndns-wiki.com":true,"dyndns-work.com":true,"dyndns.biz":true,"dyndns.info":true,"dyndns.org":true,"dyndns.tv":true,"at-band-camp.net":true,"ath.cx":true,"barrel-of-knowledge.info":true,"barrell-of-knowledge.info":true,"better-than.tv":true,"blogdns.com":true,"blogdns.net":true,"blogdns.org":true,"blogsite.org":true,"boldlygoingnowhere.org":true,"broke-it.net":true,"buyshouses.net":true,"cechire.com":true,"dnsalias.com":true,"dnsalias.net":true,"dnsalias.org":true,"dnsdojo.com":true,"dnsdojo.net":true,"dnsdojo.org":true,"does-it.net":true,"doesntexist.com":true,"doesntexist.org":true,"dontexist.com":true,"dontexist.net":true,"dontexist.org":true,"doomdns.com":true,"doomdns.org":true,"dvrdns.org":true,"dyn-o-saur.com":true,"dynalias.com":true,"dynalias.net":true,"dynalias.org":true,"dynathome.net":true,"dyndns.ws":true,"endofinternet.net":true,"endofinternet.org":true,"endoftheinternet.org":true,"est-a-la-maison.com":true,"est-a-la-masion.com":true,"est-le-patron.com":true,"est-mon-blogueur.com":true,"for-better.biz":true,"for-more.biz":true,"for-our.info":true,"for-some.biz":true,"for-the.biz":true,"forgot.her.name":true,"forgot.his.name":true,"from-ak.com":true,"from-al.com":true,"from-ar.com":true,"from-az.net":true,"from-ca.com":true,"from-co.net":true,"from-ct.com":true,"from-dc.com":true,"from-de.com":true,"from-fl.com":true,"from-ga.com":true,"from-hi.com":true,"from-ia.com":true,"from-id.com":true,"from-il.com":true,"from-in.com":true,"from-ks.com":true,"from-ky.com":true,"from-la.net":true,"from-ma.com":true,"from-md.com":true,"from-me.org":true,"from-mi.com":true,"from-mn.com":true,"from-mo.com":true,"from-ms.com":true,"from-mt.com":true,"from-nc.com":true,"from-nd.com":true,"from-ne.com":true,"from-nh.com":true,"from-nj.com":true,"from-nm.com":true,"from-nv.com":true,"from-ny.net":true,"from-oh.com":true,"from-ok.com":true,"from-or.com":true,"from-pa.com":true,"from-pr.com":true,"from-ri.com":true,"from-sc.com":true,"from-sd.com":true,"from-tn.com":true,"from-tx.com":true,"from-ut.com":true,"from-va.com":true,"from-vt.com":true,"from-wa.com":true,"from-wi.com":true,"from-wv.com":true,"from-wy.com":true,"ftpaccess.cc":true,"fuettertdasnetz.de":true,"game-host.org":true,"game-server.cc":true,"getmyip.com":true,"gets-it.net":true,"go.dyndns.org":true,"gotdns.com":true,"gotdns.org":true,"groks-the.info":true,"groks-this.info":true,"ham-radio-op.net":true,"here-for-more.info":true,"hobby-site.com":true,"hobby-site.org":true,"home.dyndns.org":true,"homedns.org":true,"homeftp.net":true,"homeftp.org":true,"homeip.net":true,"homelinux.com":true,"homelinux.net":true,"homelinux.org":true,"homeunix.com":true,"homeunix.net":true,"homeunix.org":true,"iamallama.com":true,"in-the-band.net":true,"is-a-anarchist.com":true,"is-a-blogger.com":true,"is-a-bookkeeper.com":true,"is-a-bruinsfan.org":true,"is-a-bulls-fan.com":true,"is-a-candidate.org":true,"is-a-caterer.com":true,"is-a-celticsfan.org":true,"is-a-chef.com":true,"is-a-chef.net":true,"is-a-chef.org":true,"is-a-conservative.com":true,"is-a-cpa.com":true,"is-a-cubicle-slave.com":true,"is-a-democrat.com":true,"is-a-designer.com":true,"is-a-doctor.com":true,"is-a-financialadvisor.com":true,"is-a-geek.com":true,"is-a-geek.net":true,"is-a-geek.org":true,"is-a-green.com":true,"is-a-guru.com":true,"is-a-hard-worker.com":true,"is-a-hunter.com":true,"is-a-knight.org":true,"is-a-landscaper.com":true,"is-a-lawyer.com":true,"is-a-liberal.com":true,"is-a-libertarian.com":true,"is-a-linux-user.org":true,"is-a-llama.com":true,"is-a-musician.com":true,"is-a-nascarfan.com":true,"is-a-nurse.com":true,"is-a-painter.com":true,"is-a-patsfan.org":true,"is-a-personaltrainer.com":true,"is-a-photographer.com":true,"is-a-player.com":true,"is-a-republican.com":true,"is-a-rockstar.com":true,"is-a-socialist.com":true,"is-a-soxfan.org":true,"is-a-student.com":true,"is-a-teacher.com":true,"is-a-techie.com":true,"is-a-therapist.com":true,"is-an-accountant.com":true,"is-an-actor.com":true,"is-an-actress.com":true,"is-an-anarchist.com":true,"is-an-artist.com":true,"is-an-engineer.com":true,"is-an-entertainer.com":true,"is-by.us":true,"is-certified.com":true,"is-found.org":true,"is-gone.com":true,"is-into-anime.com":true,"is-into-cars.com":true,"is-into-cartoons.com":true,"is-into-games.com":true,"is-leet.com":true,"is-lost.org":true,"is-not-certified.com":true,"is-saved.org":true,"is-slick.com":true,"is-uberleet.com":true,"is-very-bad.org":true,"is-very-evil.org":true,"is-very-good.org":true,"is-very-nice.org":true,"is-very-sweet.org":true,"is-with-theband.com":true,"isa-geek.com":true,"isa-geek.net":true,"isa-geek.org":true,"isa-hockeynut.com":true,"issmarterthanyou.com":true,"isteingeek.de":true,"istmein.de":true,"kicks-ass.net":true,"kicks-ass.org":true,"knowsitall.info":true,"land-4-sale.us":true,"lebtimnetz.de":true,"leitungsen.de":true,"likes-pie.com":true,"likescandy.com":true,"merseine.nu":true,"mine.nu":true,"misconfused.org":true,"mypets.ws":true,"myphotos.cc":true,"neat-url.com":true,"office-on-the.net":true,"on-the-web.tv":true,"podzone.net":true,"podzone.org":true,"readmyblog.org":true,"saves-the-whales.com":true,"scrapper-site.net":true,"scrapping.cc":true,"selfip.biz":true,"selfip.com":true,"selfip.info":true,"selfip.net":true,"selfip.org":true,"sells-for-less.com":true,"sells-for-u.com":true,"sells-it.net":true,"sellsyourhome.org":true,"servebbs.com":true,"servebbs.net":true,"servebbs.org":true,"serveftp.net":true,"serveftp.org":true,"servegame.org":true,"shacknet.nu":true,"simple-url.com":true,"space-to-rent.com":true,"stuff-4-sale.org":true,"stuff-4-sale.us":true,"teaches-yoga.com":true,"thruhere.net":true,"traeumtgerade.de":true,"webhop.biz":true,"webhop.info":true,"webhop.net":true,"webhop.org":true,"worse-than.tv":true,"writesthisblog.com":true,"a.ssl.fastly.net":true,"b.ssl.fastly.net":true,"global.ssl.fastly.net":true,"a.prod.fastly.net":true,"global.prod.fastly.net":true,"firebaseapp.com":true,"flynnhub.com":true,"service.gov.uk":true,"github.io":true,"githubusercontent.com":true,"ro.com":true,"appspot.com":true,"blogspot.ae":true,"blogspot.be":true,"blogspot.bj":true,"blogspot.ca":true,"blogspot.cf":true,"blogspot.ch":true,"blogspot.co.at":true,"blogspot.co.il":true,"blogspot.co.nz":true,"blogspot.co.uk":true,"blogspot.com":true,"blogspot.com.ar":true,"blogspot.com.au":true,"blogspot.com.br":true,"blogspot.com.es":true,"blogspot.com.tr":true,"blogspot.cv":true,"blogspot.cz":true,"blogspot.de":true,"blogspot.dk":true,"blogspot.fi":true,"blogspot.fr":true,"blogspot.gr":true,"blogspot.hk":true,"blogspot.hu":true,"blogspot.ie":true,"blogspot.in":true,"blogspot.it":true,"blogspot.jp":true,"blogspot.kr":true,"blogspot.mr":true,"blogspot.mx":true,"blogspot.nl":true,"blogspot.no":true,"blogspot.pt":true,"blogspot.re":true,"blogspot.ro":true,"blogspot.ru":true,"blogspot.se":true,"blogspot.sg":true,"blogspot.sk":true,"blogspot.td":true,"blogspot.tw":true,"codespot.com":true,"googleapis.com":true,"googlecode.com":true,"pagespeedmobilizer.com":true,"withgoogle.com":true,"herokuapp.com":true,"herokussl.com":true,"iki.fi":true,"biz.at":true,"info.at":true,"co.pl":true,"azurewebsites.net":true,"azure-mobile.net":true,"cloudapp.net":true,"nfshost.com":true,"nyc.mn":true,"nid.io":true,"operaunite.com":true,"outsystemscloud.com":true,"art.pl":true,"gliwice.pl":true,"krakow.pl":true,"poznan.pl":true,"wroc.pl":true,"zakopane.pl":true,"priv.at":true,"rhcloud.com":true,"sinaapp.com":true,"vipsinaapp.com":true,"1kapp.com":true,"gda.pl":true,"gdansk.pl":true,"gdynia.pl":true,"med.pl":true,"sopot.pl":true,"hk.com":true,"hk.org":true,"ltd.hk":true,"inc.hk":true,"yolasite.com":true,"za.net":true,"za.org":true});
    
    // END of automatically generated file
    
  provide("tough-cookie/lib/pubsuffix", module.exports);
}(global));

// pakmanager:tough-cookie/lib/store
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */
    'use strict';
    /*jshint unused:false */
    
    function Store() {
    }
    exports.Store = Store;
    
    // Stores may be synchronous, but are still required to use a
    // Continuation-Passing Style API.  The CookieJar itself will expose a "*Sync"
    // API that converts from synchronous-callbacks to imperative style.
    Store.prototype.synchronous = false;
    
    Store.prototype.findCookie = function(domain, path, key, cb) {
      throw new Error('findCookie is not implemented');
    };
    
    Store.prototype.findCookies = function(domain, path, cb) {
      throw new Error('findCookies is not implemented');
    };
    
    Store.prototype.putCookie = function(cookie, cb) {
      throw new Error('putCookie is not implemented');
    };
    
    Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
      // recommended default implementation:
      // return this.putCookie(newCookie, cb);
      throw new Error('updateCookie is not implemented');
    };
    
    Store.prototype.removeCookie = function(domain, path, key, cb) {
      throw new Error('removeCookie is not implemented');
    };
    
    Store.prototype.removeCookies = function(domain, path, cb) {
      throw new Error('removeCookies is not implemented');
    };
    
    Store.prototype.getAllCookies = function(cb) {
      throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');
    };
    
  provide("tough-cookie/lib/store", module.exports);
}(global));

// pakmanager:tough-cookie/lib/permuteDomain
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */
    "use strict";
    var pubsuffix =  require('tough-cookie/lib/pubsuffix');
    
    // Gives the permutation of all possible domainMatch()es of a given domain. The
    // array is in shortest-to-longest order.  Handy for indexing.
    function permuteDomain (domain) {
      var pubSuf = pubsuffix.getPublicSuffix(domain);
      if (!pubSuf) {
        return null;
      }
      if (pubSuf == domain) {
        return [domain];
      }
    
      var prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
      var parts = prefix.split('.').reverse();
      var cur = pubSuf;
      var permutations = [cur];
      while (parts.length) {
        cur = parts.shift() + '.' + cur;
        permutations.push(cur);
      }
      return permutations;
    }
    
    exports.permuteDomain = permuteDomain;
    
  provide("tough-cookie/lib/permuteDomain", module.exports);
}(global));

// pakmanager:tough-cookie/lib/pathMatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */
    "use strict";
    /*
     * "A request-path path-matches a given cookie-path if at least one of the
     * following conditions holds:"
     */
    function pathMatch (reqPath, cookiePath) {
      // "o  The cookie-path and the request-path are identical."
      if (cookiePath === reqPath) {
        return true;
      }
    
      var idx = reqPath.indexOf(cookiePath);
      if (idx === 0) {
        // "o  The cookie-path is a prefix of the request-path, and the last
        // character of the cookie-path is %x2F ("/")."
        if (cookiePath.substr(-1) === "/") {
          return true;
        }
    
        // " o  The cookie-path is a prefix of the request-path, and the first
        // character of the request-path that is not included in the cookie- path
        // is a %x2F ("/") character."
        if (reqPath.substr(cookiePath.length, 1) === "/") {
          return true;
        }
      }
    
      return false;
    }
    
    exports.pathMatch = pathMatch;
    
  provide("tough-cookie/lib/pathMatch", module.exports);
}(global));

// pakmanager:tough-cookie/lib/memstore
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */
    'use strict';
    var Store =  require('tough-cookie/lib/store').Store;
    var permuteDomain =  require('tough-cookie/lib/permuteDomain').permuteDomain;
    var pathMatch =  require('tough-cookie/lib/pathMatch').pathMatch;
    var util = require('util');
    
    function MemoryCookieStore() {
      Store.call(this);
      this.idx = {};
    }
    util.inherits(MemoryCookieStore, Store);
    exports.MemoryCookieStore = MemoryCookieStore;
    MemoryCookieStore.prototype.idx = null;
    
    // Since it's just a struct in RAM, this Store is synchronous
    MemoryCookieStore.prototype.synchronous = true;
    
    // force a default depth:
    MemoryCookieStore.prototype.inspect = function() {
      return "{ idx: "+util.inspect(this.idx, false, 2)+' }';
    };
    
    MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
      if (!this.idx[domain]) {
        return cb(null,undefined);
      }
      if (!this.idx[domain][path]) {
        return cb(null,undefined);
      }
      return cb(null,this.idx[domain][path][key]||null);
    };
    
    MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
      var results = [];
      if (!domain) {
        return cb(null,[]);
      }
    
      var pathMatcher;
      if (!path) {
        // null means "all paths"
        pathMatcher = function matchAll(domainIndex) {
          for (var curPath in domainIndex) {
            var pathIndex = domainIndex[curPath];
            for (var key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        };
    
      } else {
        pathMatcher = function matchRFC(domainIndex) {
           //NOTE: we should use path-match algorithm from S5.1.4 here
           //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
           Object.keys(domainIndex).forEach(function (cookiePath) {
             if (pathMatch(path, cookiePath)) {
               var pathIndex = domainIndex[cookiePath];
    
               for (var key in pathIndex) {
                 results.push(pathIndex[key]);
               }
             }
           });
         };
      }
    
      var domains = permuteDomain(domain) || [domain];
      var idx = this.idx;
      domains.forEach(function(curDomain) {
        var domainIndex = idx[curDomain];
        if (!domainIndex) {
          return;
        }
        pathMatcher(domainIndex);
      });
    
      cb(null,results);
    };
    
    MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
      if (!this.idx[cookie.domain]) {
        this.idx[cookie.domain] = {};
      }
      if (!this.idx[cookie.domain][cookie.path]) {
        this.idx[cookie.domain][cookie.path] = {};
      }
      this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
      cb(null);
    };
    
    MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
      // updateCookie() may avoid updating cookies that are identical.  For example,
      // lastAccessed may not be important to some stores and an equality
      // comparison could exclude that field.
      this.putCookie(newCookie,cb);
    };
    
    MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
      if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
        delete this.idx[domain][path][key];
      }
      cb(null);
    };
    
    MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
      if (this.idx[domain]) {
        if (path) {
          delete this.idx[domain][path];
        } else {
          delete this.idx[domain];
        }
      }
      return cb(null);
    };
    
    MemoryCookieStore.prototype.getAllCookies = function(cb) {
      var cookies = [];
      var idx = this.idx;
    
      var domains = Object.keys(idx);
      domains.forEach(function(domain) {
        var paths = Object.keys(idx[domain]);
        paths.forEach(function(path) {
          var keys = Object.keys(idx[domain][path]);
          keys.forEach(function(key) {
            if (key !== null) {
              cookies.push(idx[domain][path][key]);
            }
          });
        });
      });
    
      // Sort by creationIndex so deserializing retains the creation order.
      // When implementing your own store, this SHOULD retain the order too
      cookies.sort(function(a,b) {
        return (a.creationIndex||0) - (b.creationIndex||0);
      });
    
      cb(null, cookies);
    };
    
  provide("tough-cookie/lib/memstore", module.exports);
}(global));

// pakmanager:tough-cookie
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */
    'use strict';
    var net = require('net');
    var urlParse = require('url').parse;
    var pubsuffix =  require('tough-cookie/lib/pubsuffix');
    var Store =  require('tough-cookie/lib/store').Store;
    var MemoryCookieStore =  require('tough-cookie/lib/memstore').MemoryCookieStore;
    var pathMatch =  require('tough-cookie/lib/pathMatch').pathMatch;
    var VERSION = require('../package.json').version;
    
    var punycode;
    try {
      punycode = require('punycode');
    } catch(e) {
      console.warn("cookie: can't load punycode; won't use punycode for domain normalization");
    }
    
    var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
    
    // From RFC6265 S4.1.1
    // note that it excludes \x3B ";"
    var COOKIE_OCTET  = /[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]/;
    var COOKIE_OCTETS = new RegExp('^'+COOKIE_OCTET.source+'$');
    
    // Double quotes are part of the value (see: S4.1.1).
    // '\r', '\n' and '\0' should be treated as a terminator in the "relaxed" mode
    // (see: https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60)
    // '=' and ';' are attribute/values separators
    // (see: https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L64)
    var COOKIE_PAIR = /^([^=;]+)\s*=\s*(("?)[^\n\r\0]*\3)/;
    
    // RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
    // Note ';' is \x3B
    var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
    
    // Used for checking whether or not there is a trailing semi-colon
    var TRAILING_SEMICOLON = /;+$/;
    
    var DAY_OF_MONTH = /^(\d{1,2})[^\d]*$/;
    var TIME = /^(\d{1,2})[^\d]*:(\d{1,2})[^\d]*:(\d{1,2})[^\d]*$/;
    var MONTH = /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i;
    
    var MONTH_TO_NUM = {
      jan:0, feb:1, mar:2, apr:3, may:4, jun:5,
      jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
    };
    var NUM_TO_MONTH = [
      'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'
    ];
    var NUM_TO_DAY = [
      'Sun','Mon','Tue','Wed','Thu','Fri','Sat'
    ];
    
    var YEAR = /^(\d{2}|\d{4})$/; // 2 to 4 digits
    
    var MAX_TIME = 2147483647000; // 31-bit max
    var MIN_TIME = 0; // 31-bit min
    
    
    // RFC6265 S5.1.1 date parser:
    function parseDate(str) {
      if (!str) {
        return;
      }
    
      /* RFC6265 S5.1.1:
       * 2. Process each date-token sequentially in the order the date-tokens
       * appear in the cookie-date
       */
      var tokens = str.split(DATE_DELIM);
      if (!tokens) {
        return;
      }
    
      var hour = null;
      var minutes = null;
      var seconds = null;
      var day = null;
      var month = null;
      var year = null;
    
      for (var i=0; i<tokens.length; i++) {
        var token = tokens[i].trim();
        if (!token.length) {
          continue;
        }
    
        var result;
    
        /* 2.1. If the found-time flag is not set and the token matches the time
         * production, set the found-time flag and set the hour- value,
         * minute-value, and second-value to the numbers denoted by the digits in
         * the date-token, respectively.  Skip the remaining sub-steps and continue
         * to the next date-token.
         */
        if (seconds === null) {
          result = TIME.exec(token);
          if (result) {
            hour = parseInt(result[1], 10);
            minutes = parseInt(result[2], 10);
            seconds = parseInt(result[3], 10);
            /* RFC6265 S5.1.1.5:
             * [fail if]
             * *  the hour-value is greater than 23,
             * *  the minute-value is greater than 59, or
             * *  the second-value is greater than 59.
             */
            if(hour > 23 || minutes > 59 || seconds > 59) {
              return;
            }
    
            continue;
          }
        }
    
        /* 2.2. If the found-day-of-month flag is not set and the date-token matches
         * the day-of-month production, set the found-day-of- month flag and set
         * the day-of-month-value to the number denoted by the date-token.  Skip
         * the remaining sub-steps and continue to the next date-token.
         */
        if (day === null) {
          result = DAY_OF_MONTH.exec(token);
          if (result) {
            day = parseInt(result, 10);
            /* RFC6265 S5.1.1.5:
             * [fail if] the day-of-month-value is less than 1 or greater than 31
             */
            if(day < 1 || day > 31) {
              return;
            }
            continue;
          }
        }
    
        /* 2.3. If the found-month flag is not set and the date-token matches the
         * month production, set the found-month flag and set the month-value to
         * the month denoted by the date-token.  Skip the remaining sub-steps and
         * continue to the next date-token.
         */
        if (month === null) {
          result = MONTH.exec(token);
          if (result) {
            month = MONTH_TO_NUM[result[1].toLowerCase()];
            continue;
          }
        }
    
        /* 2.4. If the found-year flag is not set and the date-token matches the year
         * production, set the found-year flag and set the year-value to the number
         * denoted by the date-token.  Skip the remaining sub-steps and continue to
         * the next date-token.
         */
        if (year === null) {
          result = YEAR.exec(token);
          if (result) {
            year = parseInt(result[0], 10);
            /* From S5.1.1:
             * 3.  If the year-value is greater than or equal to 70 and less
             * than or equal to 99, increment the year-value by 1900.
             * 4.  If the year-value is greater than or equal to 0 and less
             * than or equal to 69, increment the year-value by 2000.
             */
            if (70 <= year && year <= 99) {
              year += 1900;
            } else if (0 <= year && year <= 69) {
              year += 2000;
            }
    
            if (year < 1601) {
              return; // 5. ... the year-value is less than 1601
            }
          }
        }
      }
    
      if (seconds === null || day === null || month === null || year === null) {
        return; // 5. ... at least one of the found-day-of-month, found-month, found-
                // year, or found-time flags is not set,
      }
    
      return new Date(Date.UTC(year, month, day, hour, minutes, seconds));
    }
    
    function formatDate(date) {
      var d = date.getUTCDate(); d = d >= 10 ? d : '0'+d;
      var h = date.getUTCHours(); h = h >= 10 ? h : '0'+h;
      var m = date.getUTCMinutes(); m = m >= 10 ? m : '0'+m;
      var s = date.getUTCSeconds(); s = s >= 10 ? s : '0'+s;
      return NUM_TO_DAY[date.getUTCDay()] + ', ' +
        d+' '+ NUM_TO_MONTH[date.getUTCMonth()] +' '+ date.getUTCFullYear() +' '+
        h+':'+m+':'+s+' GMT';
    }
    
    // S5.1.2 Canonicalized Host Names
    function canonicalDomain(str) {
      if (str == null) {
        return null;
      }
      str = str.trim().replace(/^\./,''); // S4.1.2.3 & S5.2.3: ignore leading .
    
      // convert to IDN if any non-ASCII characters
      if (punycode && /[^\u0001-\u007f]/.test(str)) {
        str = punycode.toASCII(str);
      }
    
      return str.toLowerCase();
    }
    
    // S5.1.3 Domain Matching
    function domainMatch(str, domStr, canonicalize) {
      if (str == null || domStr == null) {
        return null;
      }
      if (canonicalize !== false) {
        str = canonicalDomain(str);
        domStr = canonicalDomain(domStr);
      }
    
      /*
       * "The domain string and the string are identical. (Note that both the
       * domain string and the string will have been canonicalized to lower case at
       * this point)"
       */
      if (str == domStr) {
        return true;
      }
    
      /* "All of the following [three] conditions hold:" (order adjusted from the RFC) */
    
      /* "* The string is a host name (i.e., not an IP address)." */
      if (net.isIP(str)) {
        return false;
      }
    
      /* "* The domain string is a suffix of the string" */
      var idx = str.indexOf(domStr);
      if (idx <= 0) {
        return false; // it's a non-match (-1) or prefix (0)
      }
    
      // e.g "a.b.c".indexOf("b.c") === 2
      // 5 === 3+2
      if (str.length !== domStr.length + idx) { // it's not a suffix
        return false;
      }
    
      /* "* The last character of the string that is not included in the domain
      * string is a %x2E (".") character." */
      if (str.substr(idx-1,1) !== '.') {
        return false;
      }
    
      return true;
    }
    
    
    // RFC6265 S5.1.4 Paths and Path-Match
    
    /*
     * "The user agent MUST use an algorithm equivalent to the following algorithm
     * to compute the default-path of a cookie:"
     *
     * Assumption: the path (and not query part or absolute uri) is passed in.
     */
    function defaultPath(path) {
      // "2. If the uri-path is empty or if the first character of the uri-path is not
      // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
      if (!path || path.substr(0,1) !== "/") {
        return "/";
      }
    
      // "3. If the uri-path contains no more than one %x2F ("/") character, output
      // %x2F ("/") and skip the remaining step."
      if (path === "/") {
        return path;
      }
    
      var rightSlash = path.lastIndexOf("/");
      if (rightSlash === 0) {
        return "/";
      }
    
      // "4. Output the characters of the uri-path from the first character up to,
      // but not including, the right-most %x2F ("/")."
      return path.slice(0, rightSlash);
    }
    
    
    function parse(str) {
      str = str.trim();
    
      // S4.1.1 Trailing semi-colons are not part of the specification.
      var semiColonCheck = TRAILING_SEMICOLON.exec(str);
      if (semiColonCheck) {
        str = str.slice(0, semiColonCheck.index);
      }
    
      // We use a regex to parse the "name-value-pair" part of S5.2
      var firstSemi = str.indexOf(';'); // S5.2 step 1
      var result = COOKIE_PAIR.exec(firstSemi === -1 ? str : str.substr(0,firstSemi));
    
      // Rx satisfies the "the name string is empty" and "lacks a %x3D ("=")"
      // constraints as well as trimming any whitespace.
      if (!result) {
        return;
      }
    
      var c = new Cookie();
      c.key = result[1].trim();
      c.value = result[2].trim();
    
      if (firstSemi === -1) {
        return c;
      }
    
      // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
      // (including the %x3B (";") in question)." plus later on in the same section
      // "discard the first ";" and trim".
      var unparsed = str.slice(firstSemi).replace(/^\s*;\s*/,'').trim();
    
      // "If the unparsed-attributes string is empty, skip the rest of these
      // steps."
      if (unparsed.length === 0) {
        return c;
      }
    
      /*
       * S5.2 says that when looping over the items "[p]rocess the attribute-name
       * and attribute-value according to the requirements in the following
       * subsections" for every item.  Plus, for many of the individual attributes
       * in S5.3 it says to use the "attribute-value of the last attribute in the
       * cookie-attribute-list".  Therefore, in this implementation, we overwrite
       * the previous value.
       */
      var cookie_avs = unparsed.split(/\s*;\s*/);
      while (cookie_avs.length) {
        var av = cookie_avs.shift();
        var av_sep = av.indexOf('=');
        var av_key, av_value;
    
        if (av_sep === -1) {
          av_key = av;
          av_value = null;
        } else {
          av_key = av.substr(0,av_sep);
          av_value = av.substr(av_sep+1);
        }
    
        av_key = av_key.trim().toLowerCase();
    
        if (av_value) {
          av_value = av_value.trim();
        }
    
        switch(av_key) {
        case 'expires': // S5.2.1
          if (av_value) {
            var exp = parseDate(av_value);
            // "If the attribute-value failed to parse as a cookie date, ignore the
            // cookie-av."
            if (exp) {
              // over and underflow not realistically a concern: V8's getTime() seems to
              // store something larger than a 32-bit time_t (even with 32-bit node)
              c.expires = exp;
            }
          }
          break;
    
        case 'max-age': // S5.2.2
          if (av_value) {
            // "If the first character of the attribute-value is not a DIGIT or a "-"
            // character ...[or]... If the remainder of attribute-value contains a
            // non-DIGIT character, ignore the cookie-av."
            if (/^-?[0-9]+$/.test(av_value)) {
              var delta = parseInt(av_value, 10);
              // "If delta-seconds is less than or equal to zero (0), let expiry-time
              // be the earliest representable date and time."
              c.setMaxAge(delta);
            }
          }
          break;
    
        case 'domain': // S5.2.3
          // "If the attribute-value is empty, the behavior is undefined.  However,
          // the user agent SHOULD ignore the cookie-av entirely."
          if (av_value) {
            // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
            // (".") character."
            var domain = av_value.trim().replace(/^\./, '');
            if (domain) {
              // "Convert the cookie-domain to lower case."
              c.domain = domain.toLowerCase();
            }
          }
          break;
    
        case 'path': // S5.2.4
          /*
           * "If the attribute-value is empty or if the first character of the
           * attribute-value is not %x2F ("/"):
           *   Let cookie-path be the default-path.
           * Otherwise:
           *   Let cookie-path be the attribute-value."
           *
           * We'll represent the default-path as null since it depends on the
           * context of the parsing.
           */
          c.path = av_value && av_value[0] === "/" ? av_value : null;
          break;
    
        case 'secure': // S5.2.5
          /*
           * "If the attribute-name case-insensitively matches the string "Secure",
           * the user agent MUST append an attribute to the cookie-attribute-list
           * with an attribute-name of Secure and an empty attribute-value."
           */
          c.secure = true;
          break;
    
        case 'httponly': // S5.2.6 -- effectively the same as 'secure'
          c.httpOnly = true;
          break;
    
        default:
          c.extensions = c.extensions || [];
          c.extensions.push(av);
          break;
        }
      }
    
      return c;
    }
    
    // avoid the V8 deoptimization monster!
    function jsonParse(str) {
      var obj;
      try {
        obj = JSON.parse(str);
      } catch (e) {
        return e;
      }
      return obj;
    }
    
    function fromJSON(str) {
      if (!str) {
        return null;
      }
    
      var obj;
      if (typeof str === 'string') {
        obj = jsonParse(str);
        if (obj instanceof Error) {
          return null;
        }
      } else {
        // assume it's an Object
        obj = str;
      }
    
      var c = new Cookie();
      for (var i=0; i<Cookie.serializableProperties.length; i++) {
        var prop = Cookie.serializableProperties[i];
        if (obj[prop] === undefined ||
            obj[prop] === Cookie.prototype[prop])
        {
          continue; // leave as prototype default
        }
    
        if (prop === 'expires' ||
            prop === 'creation' ||
            prop === 'lastAccessed')
        {
          if (obj[prop] === null) {
            c[prop] = null;
          } else {
            c[prop] = obj[prop] == "Infinity" ?
              "Infinity" : new Date(obj[prop]);
          }
        } else {
          c[prop] = obj[prop];
        }
      }
    
      return c;
    }
    
    /* Section 5.4 part 2:
     * "*  Cookies with longer paths are listed before cookies with
     *     shorter paths.
     *
     *  *  Among cookies that have equal-length path fields, cookies with
     *     earlier creation-times are listed before cookies with later
     *     creation-times."
     */
    
    function cookieCompare(a,b) {
      var cmp = 0;
    
      // descending for length: b CMP a
      var aPathLen = a.path ? a.path.length : 0;
      var bPathLen = b.path ? b.path.length : 0;
      cmp = bPathLen - aPathLen;
      if (cmp !== 0) {
        return cmp;
      }
    
      // ascending for time: a CMP b
      var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
      var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
      cmp = aTime - bTime;
      if (cmp !== 0) {
        return cmp;
      }
    
      // break ties for the same millisecond (precision of JavaScript's clock)
      cmp = a.creationIndex - b.creationIndex;
    
      return cmp;
    }
    
    // Gives the permutation of all possible pathMatch()es of a given path. The
    // array is in longest-to-shortest order.  Handy for indexing.
    function permutePath(path) {
      if (path === '/') {
        return ['/'];
      }
      if (path.lastIndexOf('/') === path.length-1) {
        path = path.substr(0,path.length-1);
      }
      var permutations = [path];
      while (path.length > 1) {
        var lindex = path.lastIndexOf('/');
        if (lindex === 0) {
          break;
        }
        path = path.substr(0,lindex);
        permutations.push(path);
      }
      permutations.push('/');
      return permutations;
    }
    
    function getCookieContext(url) {
      if (url instanceof Object) {
        return url;
      }
      // NOTE: decodeURI will throw on malformed URIs (see GH-32).
      // Therefore, we will just skip decoding for such URIs.
      try {
        url = decodeURI(url);
      }
      catch(err) {
        // Silently swallow error
      }
    
      return urlParse(url);
    }
    
    function Cookie(opts) {
      opts = opts || {};
    
      Object.keys(opts).forEach(function(prop) {
        if (Cookie.prototype.hasOwnProperty(prop) &&
            Cookie.prototype[prop] !== opts[prop] &&
            prop.substr(0,1) !== '_')
        {
          this[prop] = opts[prop];
        }
      }, this);
    
      this.creation = this.creation || new Date();
    
      // used to break creation ties in cookieCompare():
      Object.defineProperty(this, 'creationIndex', {
        configurable: false,
        enumerable: false, // important for assert.deepEqual checks
        writable: true,
        value: ++Cookie.cookiesCreated
      });
    }
    
    Cookie.cookiesCreated = 0; // incremented each time a cookie is created
    
    Cookie.parse = parse;
    Cookie.fromJSON = fromJSON;
    
    Cookie.prototype.key = "";
    Cookie.prototype.value = "";
    
    // the order in which the RFC has them:
    Cookie.prototype.expires = "Infinity"; // coerces to literal Infinity
    Cookie.prototype.maxAge = null; // takes precedence over expires for TTL
    Cookie.prototype.domain = null;
    Cookie.prototype.path = null;
    Cookie.prototype.secure = false;
    Cookie.prototype.httpOnly = false;
    Cookie.prototype.extensions = null;
    
    // set by the CookieJar:
    Cookie.prototype.hostOnly = null; // boolean when set
    Cookie.prototype.pathIsDefault = null; // boolean when set
    Cookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse
    Cookie.prototype.lastAccessed = null; // Date when set
    Object.defineProperty(Cookie.prototype, 'creationIndex', {
      configurable: true,
      enumerable: false,
      writable: true,
      value: 0
    });
    
    Cookie.serializableProperties = Object.keys(Cookie.prototype)
      .filter(function(prop) {
        return !(
          Cookie.prototype[prop] instanceof Function ||
          prop === 'creationIndex' ||
          prop.substr(0,1) === '_'
        );
      });
    
    Cookie.prototype.inspect = function inspect() {
      var now = Date.now();
      return 'Cookie="'+this.toString() +
        '; hostOnly='+(this.hostOnly != null ? this.hostOnly : '?') +
        '; aAge='+(this.lastAccessed ? (now-this.lastAccessed.getTime())+'ms' : '?') +
        '; cAge='+(this.creation ? (now-this.creation.getTime())+'ms' : '?') +
        '"';
    };
    
    Cookie.prototype.toJSON = function() {
      var obj = {};
    
      var props = Cookie.serializableProperties;
      for (var i=0; i<props.length; i++) {
        var prop = props[i];
        if (this[prop] === Cookie.prototype[prop]) {
          continue; // leave as prototype default
        }
    
        if (prop === 'expires' ||
            prop === 'creation' ||
            prop === 'lastAccessed')
        {
          if (this[prop] === null) {
            obj[prop] = null;
          } else {
            obj[prop] = this[prop] == "Infinity" ? // intentionally not ===
              "Infinity" : this[prop].toISOString();
          }
        } else if (prop === 'maxAge') {
          if (this[prop] !== null) {
            // again, intentionally not ===
            obj[prop] = (this[prop] == Infinity || this[prop] == -Infinity) ?
              this[prop].toString() : this[prop];
          }
        } else {
          if (this[prop] !== Cookie.prototype[prop]) {
            obj[prop] = this[prop];
          }
        }
      }
    
      return obj;
    };
    
    Cookie.prototype.clone = function() {
      return fromJSON(this.toJSON());
    };
    
    Cookie.prototype.validate = function validate() {
      if (!COOKIE_OCTETS.test(this.value)) {
        return false;
      }
      if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
        return false;
      }
      if (this.maxAge != null && this.maxAge <= 0) {
        return false; // "Max-Age=" non-zero-digit *DIGIT
      }
      if (this.path != null && !PATH_VALUE.test(this.path)) {
        return false;
      }
    
      var cdomain = this.cdomain();
      if (cdomain) {
        if (cdomain.match(/\.$/)) {
          return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
        }
        var suffix = pubsuffix.getPublicSuffix(cdomain);
        if (suffix == null) { // it's a public suffix
          return false;
        }
      }
      return true;
    };
    
    Cookie.prototype.setExpires = function setExpires(exp) {
      if (exp instanceof Date) {
        this.expires = exp;
      } else {
        this.expires = parseDate(exp) || "Infinity";
      }
    };
    
    Cookie.prototype.setMaxAge = function setMaxAge(age) {
      if (age === Infinity || age === -Infinity) {
        this.maxAge = age.toString(); // so JSON.stringify() works
      } else {
        this.maxAge = age;
      }
    };
    
    // gives Cookie header format
    Cookie.prototype.cookieString = function cookieString() {
      var val = this.value;
      if (val == null) {
        val = '';
      }
      return this.key+'='+val;
    };
    
    // gives Set-Cookie header format
    Cookie.prototype.toString = function toString() {
      var str = this.cookieString();
    
      if (this.expires != Infinity) {
        if (this.expires instanceof Date) {
          str += '; Expires='+formatDate(this.expires);
        } else {
          str += '; Expires='+this.expires;
        }
      }
    
      if (this.maxAge != null && this.maxAge != Infinity) {
        str += '; Max-Age='+this.maxAge;
      }
    
      if (this.domain && !this.hostOnly) {
        str += '; Domain='+this.domain;
      }
      if (this.path) {
        str += '; Path='+this.path;
      }
    
      if (this.secure) {
        str += '; Secure';
      }
      if (this.httpOnly) {
        str += '; HttpOnly';
      }
      if (this.extensions) {
        this.extensions.forEach(function(ext) {
          str += '; '+ext;
        });
      }
    
      return str;
    };
    
    // TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
    // elsewhere)
    // S5.3 says to give the "latest representable date" for which we use Infinity
    // For "expired" we use 0
    Cookie.prototype.TTL = function TTL(now) {
      /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
       * attribute, the Max-Age attribute has precedence and controls the
       * expiration date of the cookie.
       * (Concurs with S5.3 step 3)
       */
      if (this.maxAge != null) {
        return this.maxAge<=0 ? 0 : this.maxAge*1000;
      }
    
      var expires = this.expires;
      if (expires != Infinity) {
        if (!(expires instanceof Date)) {
          expires = parseDate(expires) || Infinity;
        }
    
        if (expires == Infinity) {
          return Infinity;
        }
    
        return expires.getTime() - (now || Date.now());
      }
    
      return Infinity;
    };
    
    // expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
    // elsewhere)
    Cookie.prototype.expiryTime = function expiryTime(now) {
      if (this.maxAge != null) {
        var relativeTo = now || this.creation || new Date();
        var age = (this.maxAge <= 0) ? -Infinity : this.maxAge*1000;
        return relativeTo.getTime() + age;
      }
    
      if (this.expires == Infinity) {
        return Infinity;
      }
      return this.expires.getTime();
    };
    
    // expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
    // elsewhere), except it returns a Date
    Cookie.prototype.expiryDate = function expiryDate(now) {
      var millisec = this.expiryTime(now);
      if (millisec == Infinity) {
        return new Date(MAX_TIME);
      } else if (millisec == -Infinity) {
        return new Date(MIN_TIME);
      } else {
        return new Date(millisec);
      }
    };
    
    // This replaces the "persistent-flag" parts of S5.3 step 3
    Cookie.prototype.isPersistent = function isPersistent() {
      return (this.maxAge != null || this.expires != Infinity);
    };
    
    // Mostly S5.1.2 and S5.2.3:
    Cookie.prototype.cdomain =
    Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
      if (this.domain == null) {
        return null;
      }
      return canonicalDomain(this.domain);
    };
    
    function CookieJar(store, rejectPublicSuffixes) {
      if (rejectPublicSuffixes != null) {
        this.rejectPublicSuffixes = rejectPublicSuffixes;
      }
    
      if (!store) {
        store = new MemoryCookieStore();
      }
      this.store = store;
    }
    CookieJar.prototype.store = null;
    CookieJar.prototype.rejectPublicSuffixes = true;
    var CAN_BE_SYNC = [];
    
    CAN_BE_SYNC.push('setCookie');
    CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
      var err;
      var context = getCookieContext(url);
      if (options instanceof Function) {
        cb = options;
        options = {};
      }
    
      var host = canonicalDomain(context.hostname);
    
      // S5.3 step 1
      if (!(cookie instanceof Cookie)) {
        cookie = Cookie.parse(cookie);
      }
      if (!cookie) {
        err = new Error("Cookie failed to parse");
        return cb(options.ignoreError ? null : err);
      }
    
      // S5.3 step 2
      var now = options.now || new Date(); // will assign later to save effort in the face of errors
    
      // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()
    
      // S5.3 step 4: NOOP; domain is null by default
    
      // S5.3 step 5: public suffixes
      if (this.rejectPublicSuffixes && cookie.domain) {
        var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
        if (suffix == null) { // e.g. "com"
          err = new Error("Cookie has domain set to a public suffix");
          return cb(options.ignoreError ? null : err);
        }
      }
    
      // S5.3 step 6:
      if (cookie.domain) {
        if (!domainMatch(host, cookie.cdomain(), false)) {
          err = new Error("Cookie not in this host's domain. Cookie:"+cookie.cdomain()+" Request:"+host);
          return cb(options.ignoreError ? null : err);
        }
    
        if (cookie.hostOnly == null) { // don't reset if already set
          cookie.hostOnly = false;
        }
    
      } else {
        cookie.hostOnly = true;
        cookie.domain = host;
      }
    
      //S5.2.4 If the attribute-value is empty or if the first character of the
      //attribute-value is not %x2F ("/"):
      //Let cookie-path be the default-path.
      if (!cookie.path || cookie.path[0] !== '/') {
        cookie.path = defaultPath(context.pathname);
        cookie.pathIsDefault = true;
      }
    
      // S5.3 step 8: NOOP; secure attribute
      // S5.3 step 9: NOOP; httpOnly attribute
    
      // S5.3 step 10
      if (options.http === false && cookie.httpOnly) {
        err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
        return cb(options.ignoreError ? null : err);
      }
    
      var store = this.store;
    
      if (!store.updateCookie) {
        store.updateCookie = function(oldCookie, newCookie, cb) {
          this.putCookie(newCookie, cb);
        };
      }
    
      function withCookie(err, oldCookie) {
        if (err) {
          return cb(err);
        }
    
        var next = function(err) {
          if (err) {
            return cb(err);
          } else {
            cb(null, cookie);
          }
        };
    
        if (oldCookie) {
          // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
          // domain, and path as the newly created cookie:"
          if (options.http === false && oldCookie.httpOnly) { // step 11.2
            err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
            return cb(options.ignoreError ? null : err);
          }
          cookie.creation = oldCookie.creation; // step 11.3
          cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
          cookie.lastAccessed = now;
          // Step 11.4 (delete cookie) is implied by just setting the new one:
          store.updateCookie(oldCookie, cookie, next); // step 12
    
        } else {
          cookie.creation = cookie.lastAccessed = now;
          store.putCookie(cookie, next); // step 12
        }
      }
    
      store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
    };
    
    // RFC6365 S5.4
    CAN_BE_SYNC.push('getCookies');
    CookieJar.prototype.getCookies = function(url, options, cb) {
      var context = getCookieContext(url);
      if (options instanceof Function) {
        cb = options;
        options = {};
      }
    
      var host = canonicalDomain(context.hostname);
      var path = context.pathname || '/';
    
      var secure = options.secure;
      if (secure == null && context.protocol &&
          (context.protocol == 'https:' || context.protocol == 'wss:'))
      {
        secure = true;
      }
    
      var http = options.http;
      if (http == null) {
        http = true;
      }
    
      var now = options.now || Date.now();
      var expireCheck = options.expire !== false;
      var allPaths = !!options.allPaths;
      var store = this.store;
    
      function matchingCookie(c) {
        // "Either:
        //   The cookie's host-only-flag is true and the canonicalized
        //   request-host is identical to the cookie's domain.
        // Or:
        //   The cookie's host-only-flag is false and the canonicalized
        //   request-host domain-matches the cookie's domain."
        if (c.hostOnly) {
          if (c.domain != host) {
            return false;
          }
        } else {
          if (!domainMatch(host, c.domain, false)) {
            return false;
          }
        }
    
        // "The request-uri's path path-matches the cookie's path."
        if (!allPaths && !pathMatch(path, c.path)) {
          return false;
        }
    
        // "If the cookie's secure-only-flag is true, then the request-uri's
        // scheme must denote a "secure" protocol"
        if (c.secure && !secure) {
          return false;
        }
    
        // "If the cookie's http-only-flag is true, then exclude the cookie if the
        // cookie-string is being generated for a "non-HTTP" API"
        if (c.httpOnly && !http) {
          return false;
        }
    
        // deferred from S5.3
        // non-RFC: allow retention of expired cookies by choice
        if (expireCheck && c.expiryTime() <= now) {
          store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored
          return false;
        }
    
        return true;
      }
    
      store.findCookies(host, allPaths ? null : path, function(err,cookies) {
        if (err) {
          return cb(err);
        }
    
        cookies = cookies.filter(matchingCookie);
    
        // sorting of S5.4 part 2
        if (options.sort !== false) {
          cookies = cookies.sort(cookieCompare);
        }
    
        // S5.4 part 3
        var now = new Date();
        cookies.forEach(function(c) {
          c.lastAccessed = now;
        });
        // TODO persist lastAccessed
    
        cb(null,cookies);
      });
    };
    
    CAN_BE_SYNC.push('getCookieString');
    CookieJar.prototype.getCookieString = function(/*..., cb*/) {
      var args = Array.prototype.slice.call(arguments,0);
      var cb = args.pop();
      var next = function(err,cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies
            .sort(cookieCompare)
            .map(function(c){
              return c.cookieString();
            })
            .join('; '));
        }
      };
      args.push(next);
      this.getCookies.apply(this,args);
    };
    
    CAN_BE_SYNC.push('getSetCookieStrings');
    CookieJar.prototype.getSetCookieStrings = function(/*..., cb*/) {
      var args = Array.prototype.slice.call(arguments,0);
      var cb = args.pop();
      var next = function(err,cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies.map(function(c){
            return c.toString();
          }));
        }
      };
      args.push(next);
      this.getCookies.apply(this,args);
    };
    
    CAN_BE_SYNC.push('serialize');
    CookieJar.prototype.serialize = function(cb) {
      var type = this.store.constructor.name;
      if (type === 'Object') {
        type = null;
      }
    
      // update README.md "Serialization Format" if you change this, please!
      var serialized = {
        // The version of tough-cookie that serialized this jar. Generally a good
        // practice since future versions can make data import decisions based on
        // known past behavior. When/if this matters, use `semver`.
        version: 'tough-cookie@'+VERSION,
    
        // add the store type, to make humans happy:
        storeType: type,
    
        // CookieJar configuration:
        rejectPublicSuffixes: !!this.rejectPublicSuffixes,
    
        // this gets filled from getAllCookies:
        cookies: []
      };
    
      if (!(this.store.getAllCookies &&
            typeof this.store.getAllCookies === 'function'))
      {
        return cb(new Error('store does not support getAllCookies and cannot be serialized'));
      }
    
      this.store.getAllCookies(function(err,cookies) {
        if (err) {
          return cb(err);
        }
    
        serialized.cookies = cookies.map(function(cookie) {
          // convert to serialized 'raw' cookies
          cookie = (cookie instanceof Cookie) ? cookie.toJSON() : cookie;
    
          // Remove the index so new ones get assigned during deserialization
          delete cookie.creationIndex;
    
          return cookie;
        });
    
        return cb(null, serialized);
      });
    };
    
    // well-known name that JSON.stringify calls
    CookieJar.prototype.toJSON = function() {
      return this.serializeSync();
    };
    
    // use the class method CookieJar.deserialize instead of calling this directly
    CAN_BE_SYNC.push('_importCookies');
    CookieJar.prototype._importCookies = function(serialized, cb) {
      var jar = this;
      var cookies = serialized.cookies;
      if (!cookies || !Array.isArray(cookies)) {
        return cb(new Error('serialized jar has no cookies array'));
      }
    
      function putNext(err) {
        if (err) {
          return cb(err);
        }
    
        if (!cookies.length) {
          return cb(err, jar);
        }
    
        var cookie;
        try {
          cookie = fromJSON(cookies.shift());
        } catch (e) {
          return cb(e);
        }
    
        if (cookie === null) {
          return putNext(null); // skip this cookie
        }
    
        jar.store.putCookie(cookie, putNext);
      }
    
      putNext();
    };
    
    CookieJar.deserialize = function(strOrObj, store, cb) {
      if (arguments.length !== 3) {
        // store is optional
        cb = store;
        store = null;
      }
    
      var serialized;
      if (typeof strOrObj === 'string') {
        serialized = jsonParse(strOrObj);
        if (serialized instanceof Error) {
          return cb(serialized);
        }
      } else {
        serialized = strOrObj;
      }
    
      var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
      jar._importCookies(serialized, function(err) {
        if (err) {
          return cb(err);
        }
        cb(null, jar);
      });
    };
    
    CookieJar.fromJSON = CookieJar.deserializeSync;
    CookieJar.deserializeSync = function(strOrObj, store) {
      var serialized = typeof strOrObj === 'string' ?
        JSON.parse(strOrObj) : strOrObj;
      var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
    
      // catch this mistake early:
      if (!jar.store.synchronous) {
        throw new Error('CookieJar store is not synchronous; use async API instead.');
      }
    
      jar._importCookiesSync(serialized);
      return jar;
    };
    
    CAN_BE_SYNC.push('clone');
    CookieJar.prototype.clone = function(newStore, cb) {
      if (arguments.length === 1) {
        cb = newStore;
        newStore = null;
      }
    
      this.serialize(function(err,serialized) {
        if (err) {
          return cb(err);
        }
        CookieJar.deserialize(newStore, serialized, cb);
      });
    };
    
    // Use a closure to provide a true imperative API for synchronous stores.
    function syncWrap(method) {
      return function() {
        if (!this.store.synchronous) {
          throw new Error('CookieJar store is not synchronous; use async API instead.');
        }
    
        var args = Array.prototype.slice.call(arguments);
        var syncErr, syncResult;
        args.push(function syncCb(err, result) {
          syncErr = err;
          syncResult = result;
        });
        this[method].apply(this, args);
    
        if (syncErr) {
          throw syncErr;
        }
        return syncResult;
      };
    }
    
    // wrap all declared CAN_BE_SYNC methods in the sync wrapper
    CAN_BE_SYNC.forEach(function(method) {
      CookieJar.prototype[method+'Sync'] = syncWrap(method);
    });
    
    module.exports = {
      CookieJar: CookieJar,
      Cookie: Cookie,
      Store: Store,
      MemoryCookieStore: MemoryCookieStore,
      parseDate: parseDate,
      formatDate: formatDate,
      parse: parse,
      fromJSON: fromJSON,
      domainMatch: domainMatch,
      defaultPath: defaultPath,
      pathMatch: pathMatch,
      getPublicSuffix: pubsuffix.getPublicSuffix,
      cookieCompare: cookieCompare,
      permuteDomain:  require('tough-cookie/lib/permuteDomain').permuteDomain,
      permutePath: permutePath,
      canonicalDomain: canonicalDomain
    };
    
  provide("tough-cookie", module.exports);
}(global));

// pakmanager:http-signature/lib/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2012 Joyent, Inc.  All rights reserved.
    
    var assert = require('assert-plus');
    var util = require('util');
    
    
    
    ///--- Globals
    
    var Algorithms = {
      'rsa-sha1': true,
      'rsa-sha256': true,
      'rsa-sha512': true,
      'dsa-sha1': true,
      'hmac-sha1': true,
      'hmac-sha256': true,
      'hmac-sha512': true
    };
    
    var State = {
      New: 0,
      Params: 1
    };
    
    var ParamsState = {
      Name: 0,
      Quote: 1,
      Value: 2,
      Comma: 3
    };
    
    
    
    ///--- Specific Errors
    
    function HttpSignatureError(message, caller) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, caller || HttpSignatureError);
    
      this.message = message;
      this.name = caller.name;
    }
    util.inherits(HttpSignatureError, Error);
    
    function ExpiredRequestError(message) {
      HttpSignatureError.call(this, message, ExpiredRequestError);
    }
    util.inherits(ExpiredRequestError, HttpSignatureError);
    
    
    function InvalidHeaderError(message) {
      HttpSignatureError.call(this, message, InvalidHeaderError);
    }
    util.inherits(InvalidHeaderError, HttpSignatureError);
    
    
    function InvalidParamsError(message) {
      HttpSignatureError.call(this, message, InvalidParamsError);
    }
    util.inherits(InvalidParamsError, HttpSignatureError);
    
    
    function MissingHeaderError(message) {
      HttpSignatureError.call(this, message, MissingHeaderError);
    }
    util.inherits(MissingHeaderError, HttpSignatureError);
    
    
    
    ///--- Exported API
    
    module.exports = {
    
      /**
       * Parses the 'Authorization' header out of an http.ServerRequest object.
       *
       * Note that this API will fully validate the Authorization header, and throw
       * on any error.  It will not however check the signature, or the keyId format
       * as those are specific to your environment.  You can use the options object
       * to pass in extra constraints.
       *
       * As a response object you can expect this:
       *
       *     {
       *       "scheme": "Signature",
       *       "params": {
       *         "keyId": "foo",
       *         "algorithm": "rsa-sha256",
       *         "headers": [
       *           "date" or "x-date",
       *           "content-md5"
       *         ],
       *         "signature": "base64"
       *       },
       *       "signingString": "ready to be passed to crypto.verify()"
       *     }
       *
       * @param {Object} request an http.ServerRequest.
       * @param {Object} options an optional options object with:
       *                   - clockSkew: allowed clock skew in seconds (default 300).
       *                   - headers: required header names (def: date or x-date)
       *                   - algorithms: algorithms to support (default: all).
       * @return {Object} parsed out object (see above).
       * @throws {TypeError} on invalid input.
       * @throws {InvalidHeaderError} on an invalid Authorization header error.
       * @throws {InvalidParamsError} if the params in the scheme are invalid.
       * @throws {MissingHeaderError} if the params indicate a header not present,
       *                              either in the request headers from the params,
       *                              or not in the params from a required header
       *                              in options.
       * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
       */
      parseRequest: function parseRequest(request, options) {
        assert.object(request, 'request');
        assert.object(request.headers, 'request.headers');
        if (options === undefined) {
          options = {};
        }
        if (options.headers === undefined) {
          options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
        }
        assert.object(options, 'options');
        assert.arrayOfString(options.headers, 'options.headers');
        assert.optionalNumber(options.clockSkew, 'options.clockSkew');
    
        if (!request.headers.authorization)
          throw new MissingHeaderError('no authorization header present in ' +
                                       'the request');
    
        options.clockSkew = options.clockSkew || 300;
    
    
        var i = 0;
        var state = State.New;
        var substate = ParamsState.Name;
        var tmpName = '';
        var tmpValue = '';
    
        var parsed = {
          scheme: '',
          params: {},
          signingString: '',
    
          get algorithm() {
            return this.params.algorithm.toUpperCase();
          },
    
          get keyId() {
            return this.params.keyId;
          }
    
        };
    
        var authz = request.headers.authorization;
        for (i = 0; i < authz.length; i++) {
          var c = authz.charAt(i);
    
          switch (Number(state)) {
    
          case State.New:
            if (c !== ' ') parsed.scheme += c;
            else state = State.Params;
            break;
    
          case State.Params:
            switch (Number(substate)) {
    
            case ParamsState.Name:
              var code = c.charCodeAt(0);
              // restricted name of A-Z / a-z
              if ((code >= 0x41 && code <= 0x5a) || // A-Z
                  (code >= 0x61 && code <= 0x7a)) { // a-z
                tmpName += c;
              } else if (c === '=') {
                if (tmpName.length === 0)
                  throw new InvalidHeaderError('bad param format');
                substate = ParamsState.Quote;
              } else {
                throw new InvalidHeaderError('bad param format');
              }
              break;
    
            case ParamsState.Quote:
              if (c === '"') {
                tmpValue = '';
                substate = ParamsState.Value;
              } else {
                throw new InvalidHeaderError('bad param format');
              }
              break;
    
            case ParamsState.Value:
              if (c === '"') {
                parsed.params[tmpName] = tmpValue;
                substate = ParamsState.Comma;
              } else {
                tmpValue += c;
              }
              break;
    
            case ParamsState.Comma:
              if (c === ',') {
                tmpName = '';
                substate = ParamsState.Name;
              } else {
                throw new InvalidHeaderError('bad param format');
              }
              break;
    
            default:
              throw new Error('Invalid substate');
            }
            break;
    
          default:
            throw new Error('Invalid substate');
          }
    
        }
    
        if (!parsed.params.headers || parsed.params.headers === '') {
          if (request.headers['x-date']) {
            parsed.params.headers = ['x-date'];
          } else {
            parsed.params.headers = ['date'];
          }
        } else {
          parsed.params.headers = parsed.params.headers.split(' ');
        }
    
        // Minimally validate the parsed object
        if (!parsed.scheme || parsed.scheme !== 'Signature')
          throw new InvalidHeaderError('scheme was not "Signature"');
    
        if (!parsed.params.keyId)
          throw new InvalidHeaderError('keyId was not specified');
    
        if (!parsed.params.algorithm)
          throw new InvalidHeaderError('algorithm was not specified');
    
        if (!parsed.params.signature)
          throw new InvalidHeaderError('signature was not specified');
    
        // Check the algorithm against the official list
        parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
        if (!Algorithms[parsed.params.algorithm])
          throw new InvalidParamsError(parsed.params.algorithm +
                                       ' is not supported');
    
        // Build the signingString
        for (i = 0; i < parsed.params.headers.length; i++) {
          var h = parsed.params.headers[i].toLowerCase();
          parsed.params.headers[i] = h;
    
          if (h !== 'request-line') {
            var value = request.headers[h];
            if (!value)
              throw new MissingHeaderError(h + ' was not in the request');
            parsed.signingString += h + ': ' + value;
          } else {
            parsed.signingString +=
              request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
          }
    
          if ((i + 1) < parsed.params.headers.length)
            parsed.signingString += '\n';
        }
    
        // Check against the constraints
        var date;
        if (request.headers.date || request.headers['x-date']) {
            if (request.headers['x-date']) {
              date = new Date(request.headers['x-date']);
            } else {
              date = new Date(request.headers.date);
            }
          var now = new Date();
          var skew = Math.abs(now.getTime() - date.getTime());
    
          if (skew > options.clockSkew * 1000) {
            throw new ExpiredRequestError('clock skew of ' +
                                          (skew / 1000) +
                                          's was greater than ' +
                                          options.clockSkew + 's');
          }
        }
    
        options.headers.forEach(function (hdr) {
          // Remember that we already checked any headers in the params
          // were in the request, so if this passes we're good.
          if (parsed.params.headers.indexOf(hdr) < 0)
            throw new MissingHeaderError(hdr + ' was not a signed header');
        });
    
        if (options.algorithms) {
          if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
            throw new InvalidParamsError(parsed.params.algorithm +
                                         ' is not a supported algorithm');
        }
    
        return parsed;
      }
    
    };
    
  provide("http-signature/lib/parser", module.exports);
}(global));

// pakmanager:http-signature/lib/signer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2012 Joyent, Inc.  All rights reserved.
    
    var assert = require('assert-plus');
    var crypto = require('crypto');
    var http = require('http');
    
    var sprintf = require('util').format;
    
    
    
    ///--- Globals
    
    var Algorithms = {
      'rsa-sha1': true,
      'rsa-sha256': true,
      'rsa-sha512': true,
      'dsa-sha1': true,
      'hmac-sha1': true,
      'hmac-sha256': true,
      'hmac-sha512': true
    };
    
    var Authorization =
      'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
    
    
    
    ///--- Specific Errors
    
    function MissingHeaderError(message) {
        this.name = 'MissingHeaderError';
        this.message = message;
        this.stack = (new Error()).stack;
    }
    MissingHeaderError.prototype = new Error();
    
    
    function InvalidAlgorithmError(message) {
        this.name = 'InvalidAlgorithmError';
        this.message = message;
        this.stack = (new Error()).stack;
    }
    InvalidAlgorithmError.prototype = new Error();
    
    
    
    ///--- Internal Functions
    
    function _pad(val) {
      if (parseInt(val, 10) < 10) {
        val = '0' + val;
      }
      return val;
    }
    
    
    function _rfc1123() {
      var date = new Date();
    
      var months = ['Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'];
      var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      return days[date.getUTCDay()] + ', ' +
        _pad(date.getUTCDate()) + ' ' +
        months[date.getUTCMonth()] + ' ' +
        date.getUTCFullYear() + ' ' +
        _pad(date.getUTCHours()) + ':' +
        _pad(date.getUTCMinutes()) + ':' +
        _pad(date.getUTCSeconds()) +
        ' GMT';
    }
    
    
    
    ///--- Exported API
    
    module.exports = {
    
      /**
       * Adds an 'Authorization' header to an http.ClientRequest object.
       *
       * Note that this API will add a Date header if it's not already set. Any
       * other headers in the options.headers array MUST be present, or this
       * will throw.
       *
       * You shouldn't need to check the return type; it's just there if you want
       * to be pedantic.
       *
       * @param {Object} request an instance of http.ClientRequest.
       * @param {Object} options signing parameters object:
       *                   - {String} keyId required.
       *                   - {String} key required (either a PEM or HMAC key).
       *                   - {Array} headers optional; defaults to ['date'].
       *                   - {String} algorithm optional; defaults to 'rsa-sha256'.
       *                   - {String} httpVersion optional; defaults to '1.1'.
       * @return {Boolean} true if Authorization (and optionally Date) were added.
       * @throws {TypeError} on bad parameter types (input).
       * @throws {InvalidAlgorithmError} if algorithm was bad.
       * @throws {MissingHeaderError} if a header to be signed was specified but
       *                              was not present.
       */
      signRequest: function signRequest(request, options) {
        assert.object(request, 'request');
        assert.object(options, 'options');
        assert.optionalString(options.algorithm, 'options.algorithm');
        assert.string(options.keyId, 'options.keyId');
        assert.optionalArrayOfString(options.headers, 'options.headers');
        assert.optionalString(options.httpVersion, 'options.httpVersion');
    
        if (!request.getHeader('Date'))
          request.setHeader('Date', _rfc1123());
        if (!options.headers)
          options.headers = ['date'];
        if (!options.algorithm)
          options.algorithm = 'rsa-sha256';
        if (!options.httpVersion)
          options.httpVersion = '1.1';
    
        options.algorithm = options.algorithm.toLowerCase();
    
        if (!Algorithms[options.algorithm])
          throw new InvalidAlgorithmError(options.algorithm + ' is not supported');
    
        var i;
        var stringToSign = '';
        for (i = 0; i < options.headers.length; i++) {
          if (typeof (options.headers[i]) !== 'string')
            throw new TypeError('options.headers must be an array of Strings');
    
          var h = options.headers[i].toLowerCase();
    
          if (h !== 'request-line') {
            var value = request.getHeader(h);
            if (!value) {
              throw new MissingHeaderError(h + ' was not in the request');
            }
            stringToSign += h + ': ' + value;
          } else {
            stringToSign +=
              request.method + ' ' + request.path + ' HTTP/' + options.httpVersion;
          }
    
          if ((i + 1) < options.headers.length)
            stringToSign += '\n';
        }
    
        var alg = options.algorithm.match(/(hmac|rsa)-(\w+)/);
        var signature;
        if (alg[1] === 'hmac') {
          var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);
          hmac.update(stringToSign);
          signature = hmac.digest('base64');
        } else {
          var signer = crypto.createSign(options.algorithm.toUpperCase());
          signer.update(stringToSign);
          signature = signer.sign(options.key, 'base64');
        }
    
        request.setHeader('Authorization', sprintf(Authorization,
                                                   options.keyId,
                                                   options.algorithm,
                                                   options.headers.join(' '),
                                                   signature));
    
        return true;
      }
    
    };
    
  provide("http-signature/lib/signer", module.exports);
}(global));

// pakmanager:http-signature/lib/verify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2015 Joyent, Inc.
    
    var assert = require('assert-plus');
    var crypto = require('crypto');
    
    
    
    ///--- Exported API
    
    module.exports = {
      /**
       * Verify RSA/DSA signature against public key.  You are expected to pass in
       * an object that was returned from `parse()`.
       *
       * @param {Object} parsedSignature the object you got from `parse`.
       * @param {String} pubkey RSA/DSA private key PEM.
       * @return {Boolean} true if valid, false otherwise.
       * @throws {TypeError} if you pass in bad arguments.
       */
      verifySignature: function verifySignature(parsedSignature, pubkey) {
        assert.object(parsedSignature, 'parsedSignature');
        assert.string(pubkey, 'pubkey');
    
        var alg = parsedSignature.algorithm.match(/^(RSA|DSA)-(\w+)/);
        if (!alg || alg.length !== 3)
          throw new TypeError('parsedSignature: unsupported algorithm ' +
                              parsedSignature.algorithm);
    
        var verify = crypto.createVerify(alg[0]);
        verify.update(parsedSignature.signingString);
        return verify.verify(pubkey, parsedSignature.params.signature, 'base64');
      },
    
      /**
       * Verify HMAC against shared secret.  You are expected to pass in an object
       * that was returned from `parse()`.
       *
       * @param {Object} parsedSignature the object you got from `parse`.
       * @param {String} secret HMAC shared secret.
       * @return {Boolean} true if valid, false otherwise.
       * @throws {TypeError} if you pass in bad arguments.
       */
      verifyHMAC: function verifyHMAC(parsedSignature, secret) {
        assert.object(parsedSignature, 'parsedHMAC');
        assert.string(secret, 'secret');
    
        var alg = parsedSignature.algorithm.match(/^HMAC-(\w+)/);
        if (!alg || alg.length !== 2)
          throw new TypeError('parsedSignature: unsupported algorithm ' +
                              parsedSignature.algorithm);
    
        var hmac = crypto.createHmac(alg[1].toUpperCase(), secret);
        hmac.update(parsedSignature.signingString);
        return (hmac.digest('base64') === parsedSignature.params.signature);
      }
    };
    
  provide("http-signature/lib/verify", module.exports);
}(global));

// pakmanager:http-signature/lib/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2012 Joyent, Inc.  All rights reserved.
    
    var assert = require('assert-plus');
    var crypto = require('crypto');
    
    var asn1 = require('asn1');
    var ctype = require('ctype');
    
    
    
    ///--- Helpers
    
    function readNext(buffer, offset) {
      var len = ctype.ruint32(buffer, 'big', offset);
      offset += 4;
    
      var newOffset = offset + len;
    
      return {
        data: buffer.slice(offset, newOffset),
        offset: newOffset
      };
    }
    
    
    function writeInt(writer, buffer) {
      writer.writeByte(0x02); // ASN1.Integer
      writer.writeLength(buffer.length);
    
      for (var i = 0; i < buffer.length; i++)
        writer.writeByte(buffer[i]);
    
      return writer;
    }
    
    
    function rsaToPEM(key) {
      var buffer;
      var der;
      var exponent;
      var i;
      var modulus;
      var newKey = '';
      var offset = 0;
      var type;
      var tmp;
    
      try {
        buffer = new Buffer(key.split(' ')[1], 'base64');
    
        tmp = readNext(buffer, offset);
        type = tmp.data.toString();
        offset = tmp.offset;
    
        if (type !== 'ssh-rsa')
          throw new Error('Invalid ssh key type: ' + type);
    
        tmp = readNext(buffer, offset);
        exponent = tmp.data;
        offset = tmp.offset;
    
        tmp = readNext(buffer, offset);
        modulus = tmp.data;
      } catch (e) {
        throw new Error('Invalid ssh key: ' + key);
      }
    
      // DER is a subset of BER
      der = new asn1.BerWriter();
    
      der.startSequence();
    
      der.startSequence();
      der.writeOID('1.2.840.113549.1.1.1');
      der.writeNull();
      der.endSequence();
    
      der.startSequence(0x03); // bit string
      der.writeByte(0x00);
    
      // Actual key
      der.startSequence();
      writeInt(der, modulus);
      writeInt(der, exponent);
      der.endSequence();
    
      // bit string
      der.endSequence();
    
      der.endSequence();
    
      tmp = der.buffer.toString('base64');
      for (i = 0; i < tmp.length; i++) {
        if ((i % 64) === 0)
          newKey += '\n';
        newKey += tmp.charAt(i);
      }
    
      if (!/\\n$/.test(newKey))
        newKey += '\n';
    
      return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
    }
    
    
    function dsaToPEM(key) {
      var buffer;
      var offset = 0;
      var tmp;
      var der;
      var newKey = '';
    
      var type;
      var p;
      var q;
      var g;
      var y;
    
      try {
        buffer = new Buffer(key.split(' ')[1], 'base64');
    
        tmp = readNext(buffer, offset);
        type = tmp.data.toString();
        offset = tmp.offset;
    
        /* JSSTYLED */
        if (!/^ssh-ds[as].*/.test(type))
          throw new Error('Invalid ssh key type: ' + type);
    
        tmp = readNext(buffer, offset);
        p = tmp.data;
        offset = tmp.offset;
    
        tmp = readNext(buffer, offset);
        q = tmp.data;
        offset = tmp.offset;
    
        tmp = readNext(buffer, offset);
        g = tmp.data;
        offset = tmp.offset;
    
        tmp = readNext(buffer, offset);
        y = tmp.data;
      } catch (e) {
        console.log(e.stack);
        throw new Error('Invalid ssh key: ' + key);
      }
    
      // DER is a subset of BER
      der = new asn1.BerWriter();
    
      der.startSequence();
    
      der.startSequence();
      der.writeOID('1.2.840.10040.4.1');
    
      der.startSequence();
      writeInt(der, p);
      writeInt(der, q);
      writeInt(der, g);
      der.endSequence();
    
      der.endSequence();
    
      der.startSequence(0x03); // bit string
      der.writeByte(0x00);
      writeInt(der, y);
      der.endSequence();
    
      der.endSequence();
    
      tmp = der.buffer.toString('base64');
      for (var i = 0; i < tmp.length; i++) {
        if ((i % 64) === 0)
          newKey += '\n';
        newKey += tmp.charAt(i);
      }
    
      if (!/\\n$/.test(newKey))
        newKey += '\n';
    
      return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
    }
    
    
    ///--- API
    
    module.exports = {
    
      /**
       * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
       *
       * The intent of this module is to interoperate with OpenSSL only,
       * specifically the node crypto module's `verify` method.
       *
       * @param {String} key an OpenSSH public key.
       * @return {String} PEM encoded form of the RSA public key.
       * @throws {TypeError} on bad input.
       * @throws {Error} on invalid ssh key formatted data.
       */
      sshKeyToPEM: function sshKeyToPEM(key) {
        assert.string(key, 'ssh_key');
    
        /* JSSTYLED */
        if (/^ssh-rsa.*/.test(key))
          return rsaToPEM(key);
    
        /* JSSTYLED */
        if (/^ssh-ds[as].*/.test(key))
          return dsaToPEM(key);
    
        throw new Error('Only RSA and DSA public keys are allowed');
      },
    
    
      /**
       * Generates an OpenSSH fingerprint from an ssh public key.
       *
       * @param {String} key an OpenSSH public key.
       * @return {String} key fingerprint.
       * @throws {TypeError} on bad input.
       * @throws {Error} if what you passed doesn't look like an ssh public key.
       */
      fingerprint: function fingerprint(key) {
        assert.string(key, 'ssh_key');
    
        var pieces = key.split(' ');
        if (!pieces || !pieces.length || pieces.length < 2)
          throw new Error('invalid ssh key');
    
        var data = new Buffer(pieces[1], 'base64');
    
        var hash = crypto.createHash('md5');
        hash.update(data);
        var digest = hash.digest('hex');
    
        var fp = '';
        for (var i = 0; i < digest.length; i++) {
          if (i && i % 2 === 0)
            fp += ':';
    
          fp += digest[i];
        }
    
        return fp;
      },
    
      /**
       * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)
       *
       * The reverse of the above function.
       */
      pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
        assert.equal('string', typeof (pem), 'typeof pem');
    
        // chop off the BEGIN PUBLIC KEY and END PUBLIC KEY portion
        var cleaned = pem.split('\n').slice(1, -2).join('');
    
        var buf = new Buffer(cleaned, 'base64');
    
        var der = new asn1.BerReader(buf);
    
        der.readSequence();
        der.readSequence();
    
        var oid = der.readOID();
        assert.equal(oid, '1.2.840.113549.1.1.1', 'pem not in RSA format');
    
        // Null -- XXX this probably isn't good practice
        der.readByte();
        der.readByte();
    
        // bit string sequence
        der.readSequence(0x03);
        der.readByte();
        der.readSequence();
    
        // modulus
        assert.equal(der.peek(), asn1.Ber.Integer, 'modulus not an integer');
        der._offset = der.readLength(der.offset + 1);
        var modulus = der._buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
    
        // exponent
        assert.equal(der.peek(), asn1.Ber.Integer, 'exponent not an integer');
        der._offset = der.readLength(der.offset + 1);
        var exponent = der._buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
    
        // now, make the key
        var type = new Buffer('ssh-rsa');
        var buffer = new Buffer(4 + type.length + 4 + modulus.length +
          4 + exponent.length);
        var i = 0;
        buffer.writeUInt32BE(type.length, i);     i += 4;
        type.copy(buffer, i);                     i += type.length;
        buffer.writeUInt32BE(exponent.length, i); i += 4;
        exponent.copy(buffer, i);                 i += exponent.length;
        buffer.writeUInt32BE(modulus.length, i);  i += 4;
        modulus.copy(buffer, i);                  i += modulus.length;
    
        var s = (type.toString() + ' ' + buffer.toString('base64') + ' ' +
          (comment || ''));
        return s;
      }
    };
    
  provide("http-signature/lib/util", module.exports);
}(global));

// pakmanager:http-signature
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2015 Joyent, Inc.
    
    var parser =  require('http-signature/lib/parser');
    var signer =  require('http-signature/lib/signer');
    var verify =  require('http-signature/lib/verify');
    var util =  require('http-signature/lib/util');
    
    
    
    ///--- API
    
    module.exports = {
    
      parse: parser.parseRequest,
      parseRequest: parser.parseRequest,
    
      sign: signer.signRequest,
      signRequest: signer.signRequest,
    
      sshKeyToPEM: util.sshKeyToPEM,
      sshKeyFingerprint: util.fingerprint,
      pemToRsaSSHKey: util.pemToRsaSSHKey,
    
      verify: verify.verifySignature,
      verifySignature: verify.verifySignature,
      verifyHMAC: verify.verifyHMAC
    };
    
  provide("http-signature", module.exports);
}(global));

// pakmanager:oauth-sign
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var crypto = require('crypto')
      , qs = require('querystring')
      ;
    
    function sha1 (key, body) {
      return crypto.createHmac('sha1', key).update(body).digest('base64')
    }
    
    function rsa (key, body) {
      return crypto.createSign("RSA-SHA1").update(body).sign(key, 'base64');
    }
    
    function rfc3986 (str) {
      return encodeURIComponent(str)
        .replace(/!/g,'%21')
        .replace(/\*/g,'%2A')
        .replace(/\(/g,'%28')
        .replace(/\)/g,'%29')
        .replace(/'/g,'%27')
        ;
    }
    
    // Maps object to bi-dimensional array
    // Converts { foo: 'A', bar: [ 'b', 'B' ]} to
    // [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]
    function map (obj) {
      var key, val, arr = []
      for (key in obj) {
        val = obj[key]
        if (Array.isArray(val))
          for (var i = 0; i < val.length; i++)
            arr.push([key, val[i]])
        else if (typeof val === "object")
          for (var prop in val)
            arr.push([key + '[' + prop + ']', val[prop]]);
        else
          arr.push([key, val])
      }
      return arr
    }
    
    // Compare function for sort
    function compare (a, b) {
      return a > b ? 1 : a < b ? -1 : 0
    }
    
    function generateBase (httpMethod, base_uri, params) {
      // adapted from https://dev.twitter.com/docs/auth/oauth and 
      // https://dev.twitter.com/docs/auth/creating-signature
    
      // Parameter normalization
      // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
      var normalized = map(params)
      // 1.  First, the name and value of each parameter are encoded
      .map(function (p) {
        return [ rfc3986(p[0]), rfc3986(p[1] || '') ]
      })
      // 2.  The parameters are sorted by name, using ascending byte value
      //     ordering.  If two or more parameters share the same name, they
      //     are sorted by their value.
      .sort(function (a, b) {
        return compare(a[0], b[0]) || compare(a[1], b[1])
      })
      // 3.  The name of each parameter is concatenated to its corresponding
      //     value using an "=" character (ASCII code 61) as a separator, even
      //     if the value is empty.
      .map(function (p) { return p.join('=') })
       // 4.  The sorted name/value pairs are concatenated together into a
       //     single string by using an "&" character (ASCII code 38) as
       //     separator.
      .join('&')
    
      var base = [
        rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),
        rfc3986(base_uri),
        rfc3986(normalized)
      ].join('&')
    
      return base
    }
    
    function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
      var base = generateBase(httpMethod, base_uri, params)
      var key = [
        consumer_secret || '',
        token_secret || ''
      ].map(rfc3986).join('&')
    
      return sha1(key, base)
    }
    
    function rsasign (httpMethod, base_uri, params, private_key, token_secret) {
      var base = generateBase(httpMethod, base_uri, params)
      var key = private_key || ''
    
      return rsa(key, base)
    }
    
    function plaintext (consumer_secret, token_secret) {
      var key = [
        consumer_secret || '',
        token_secret || ''
      ].map(rfc3986).join('&')
    
      return key
    }
    
    function sign (signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
      var method
      var skipArgs = 1
    
      switch (signMethod) {
        case 'RSA-SHA1':
          method = rsasign
          break
        case 'HMAC-SHA1':
          method = hmacsign
          break
        case 'PLAINTEXT':
          method = plaintext
          skipArgs = 4
          break
        default:
         throw new Error("Signature method not supported: " + signMethod)
      }
    
      return method.apply(null, [].slice.call(arguments, skipArgs))
    }
    
    exports.hmacsign = hmacsign
    exports.rsasign = rsasign
    exports.plaintext = plaintext
    exports.sign = sign
    exports.rfc3986 = rfc3986
    
  provide("oauth-sign", module.exports);
}(global));

// pakmanager:hawk/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Sntp = require('sntp');
    var Boom = require('boom');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.version = function () {
    
        return require('../package.json').version;
    };
    
    
    // Extract host and port from request
    
    //                                            $1                            $2
    internals.hostHeaderRegex = /^(?:(?:\r\n)?\s)*((?:[^:]+)|(?:\[[^\]]+\]))(?::(\d+))?(?:(?:\r\n)?\s)*$/;              // (IPv4, hostname)|(IPv6)
    
    
    exports.parseHost = function (req, hostHeaderName) {
    
        hostHeaderName = (hostHeaderName ? hostHeaderName.toLowerCase() : 'host');
        var hostHeader = req.headers[hostHeaderName];
        if (!hostHeader) {
            return null;
        }
    
        var hostParts = hostHeader.match(internals.hostHeaderRegex);
        if (!hostParts) {
            return null;
        }
    
        return {
            name: hostParts[1],
            port: (hostParts[2] ? hostParts[2] : (req.connection && req.connection.encrypted ? 443 : 80))
        };
    };
    
    
    // Parse Content-Type header content
    
    exports.parseContentType = function (header) {
    
        if (!header) {
            return '';
        }
    
        return header.split(';')[0].trim().toLowerCase();
    };
    
    
    // Convert node's  to request configuration object
    
    exports.parseRequest = function (req, options) {
    
        if (!req.headers) {
            return req;
        }
    
        // Obtain host and port information
    
        if (!options.host || !options.port) {
            var host = exports.parseHost(req, options.hostHeaderName);
            if (!host) {
                return new Error('Invalid Host header');
            }
        }
    
        var request = {
            method: req.method,
            url: req.url,
            host: options.host || host.name,
            port: options.port || host.port,
            authorization: req.headers.authorization,
            contentType: req.headers['content-type'] || ''
        };
    
        return request;
    };
    
    
    exports.now = function (localtimeOffsetMsec) {
    
        return Sntp.now() + (localtimeOffsetMsec || 0);
    };
    
    
    exports.nowSecs = function (localtimeOffsetMsec) {
    
        return Math.floor(exports.now(localtimeOffsetMsec) / 1000);
    };
    
    
    // Parse Hawk HTTP Authorization header
    
    exports.parseAuthorizationHeader = function (header, keys) {
    
        keys = keys || ['id', 'ts', 'nonce', 'hash', 'ext', 'mac', 'app', 'dlg'];
    
        if (!header) {
            return Boom.unauthorized(null, 'Hawk');
        }
    
        var headerParts = header.match(/^(\w+)(?:\s+(.*))?$/);       // Header: scheme[ something]
        if (!headerParts) {
            return Boom.badRequest('Invalid header syntax');
        }
    
        var scheme = headerParts[1];
        if (scheme.toLowerCase() !== 'hawk') {
            return Boom.unauthorized(null, 'Hawk');
        }
    
        var attributesString = headerParts[2];
        if (!attributesString) {
            return Boom.badRequest('Invalid header syntax');
        }
    
        var attributes = {};
        var errorMessage = '';
        var verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function ($0, $1, $2) {
    
            // Check valid attribute names
    
            if (keys.indexOf($1) === -1) {
                errorMessage = 'Unknown attribute: ' + $1;
                return;
            }
    
            // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9
    
            if ($2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) === null) {
                errorMessage = 'Bad attribute value: ' + $1;
                return;
            }
    
            // Check for duplicates
    
            if (attributes.hasOwnProperty($1)) {
                errorMessage = 'Duplicate attribute: ' + $1;
                return;
            }
    
            attributes[$1] = $2;
            return '';
        });
    
        if (verify !== '') {
            return Boom.badRequest(errorMessage || 'Bad header format');
        }
    
        return attributes;
    };
    
    
    exports.unauthorized = function (message, attributes) {
    
        return Boom.unauthorized(message, 'Hawk', attributes);
    };
    
    
  provide("hawk/lib/utils", module.exports);
}(global));

// pakmanager:hawk/lib/crypto
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Crypto = require('crypto');
    var Url = require('url');
    var Utils =  require('hawk/lib/utils');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // MAC normalization format version
    
    exports.headerVersion = '1';                        // Prevent comparison of mac values generated with different normalized string formats
    
    
    // Supported HMAC algorithms
    
    exports.algorithms = ['sha1', 'sha256'];
    
    
    // Calculate the request MAC
    
    /*
        type: 'header',                                 // 'header', 'bewit', 'response'
        credentials: {
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                         // 'sha1', 'sha256'
        },
        options: {
            method: 'GET',
            resource: '/resource?a=1&b=2',
            host: 'example.com',
            port: 8080,
            ts: 1357718381034,
            nonce: 'd3d345f',
            hash: 'U4MKKSmiVxk37JCCrAVIjV/OhB3y+NdwoCr6RShbVkE=',
            ext: 'app-specific-data',
            app: 'hf48hd83qwkj',                        // Application id (Oz)
            dlg: 'd8djwekds9cj'                         // Delegated by application id (Oz), requires options.app
        }
    */
    
    exports.calculateMac = function (type, credentials, options) {
    
        var normalized = exports.generateNormalizedString(type, options);
    
        var hmac = Crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
        var digest = hmac.digest('base64');
        return digest;
    };
    
    
    exports.generateNormalizedString = function (type, options) {
    
        var resource = options.resource || '';
        if (resource &&
            resource[0] !== '/') {
    
            var url = Url.parse(resource, false);
            resource = url.path;                        // Includes query
        }
    
        var normalized = 'hawk.' + exports.headerVersion + '.' + type + '\n' +
                         options.ts + '\n' +
                         options.nonce + '\n' +
                         (options.method || '').toUpperCase() + '\n' +
                         resource + '\n' +
                         options.host.toLowerCase() + '\n' +
                         options.port + '\n' +
                         (options.hash || '') + '\n';
    
        if (options.ext) {
            normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
        }
    
        normalized += '\n';
    
        if (options.app) {
            normalized += options.app + '\n' +
                          (options.dlg || '') + '\n';
        }
    
        return normalized;
    };
    
    
    exports.calculatePayloadHash = function (payload, algorithm, contentType) {
    
        var hash = exports.initializePayloadHash(algorithm, contentType);
        hash.update(payload || '');
        return exports.finalizePayloadHash(hash);
    };
    
    
    exports.initializePayloadHash = function (algorithm, contentType) {
    
        var hash = Crypto.createHash(algorithm);
        hash.update('hawk.' + exports.headerVersion + '.payload\n');
        hash.update(Utils.parseContentType(contentType) + '\n');
        return hash;
    };
    
    
    exports.finalizePayloadHash = function (hash) {
    
        hash.update('\n');
        return hash.digest('base64');
    };
    
    
    exports.calculateTsMac = function (ts, credentials) {
    
        var hmac = Crypto.createHmac(credentials.algorithm, credentials.key);
        hmac.update('hawk.' + exports.headerVersion + '.ts\n' + ts + '\n');
        return hmac.digest('base64');
    };
    
    
    exports.timestampMessage = function (credentials, localtimeOffsetMsec) {
    
        var now = Utils.nowSecs(localtimeOffsetMsec);
        var tsm = exports.calculateTsMac(now, credentials);
        return { ts: now, tsm: tsm };
    };
    
  provide("hawk/lib/crypto", module.exports);
}(global));

// pakmanager:hawk/lib/server
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Cryptiles = require('cryptiles');
    var Crypto =  require('hawk/lib/crypto');
    var Utils =  require('hawk/lib/utils');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Hawk authentication
    
    /*
       req:                 node's HTTP request object or an object as follows:
    
                            var request = {
                                method: 'GET',
                                url: '/resource/4?a=1&b=2',
                                host: 'example.com',
                                port: 8080,
                                authorization: 'Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2", ext="some-app-ext-data", mac="6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE="'
                            };
    
       credentialsFunc:     required function to lookup the set of Hawk credentials based on the provided credentials id.
                            The credentials include the MAC key, MAC algorithm, and other attributes (such as username)
                            needed by the application. This function is the equivalent of verifying the username and
                            password in Basic authentication.
    
                            var credentialsFunc = function (id, callback) {
    
                                // Lookup credentials in database
                                db.lookup(id, function (err, item) {
    
                                    if (err || !item) {
                                        return callback(err);
                                    }
    
                                    var credentials = {
                                        // Required
                                        key: item.key,
                                        algorithm: item.algorithm,
                                        // Application specific
                                        user: item.user
                                    };
    
                                    return callback(null, credentials);
                                });
                            };
    
       options: {
    
            hostHeaderName:        optional header field name, used to override the default 'Host' header when used
                                   behind a cache of a proxy. Apache2 changes the value of the 'Host' header while preserving
                                   the original (which is what the module must verify) in the 'x-forwarded-host' header field.
                                   Only used when passed a node Http.ServerRequest object.
    
            nonceFunc:             optional nonce validation function. The function signature is function(key, nonce, ts, callback)
                                   where 'callback' must be called using the signature function(err).
    
            timestampSkewSec:      optional number of seconds of permitted clock skew for incoming timestamps. Defaults to 60 seconds.
                                   Provides a +/- skew which means actual allowed window is double the number of seconds.
    
            localtimeOffsetMsec:   optional local clock time offset express in a number of milliseconds (positive or negative).
                                   Defaults to 0.
    
            payload:               optional payload for validation. The client calculates the hash value and includes it via the 'hash'
                                   header attribute. The server always ensures the value provided has been included in the request
                                   MAC. When this option is provided, it validates the hash value itself. Validation is done by calculating
                                   a hash value over the entire payload (assuming it has already be normalized to the same format and
                                   encoding used by the client to calculate the hash on request). If the payload is not available at the time
                                   of authentication, the authenticatePayload() method can be used by passing it the credentials and
                                   attributes.hash returned in the authenticate callback.
    
            host:                  optional host name override. Only used when passed a node request object.
            port:                  optional port override. Only used when passed a node request object.
        }
    
        callback: function (err, credentials, artifacts) { }
     */
    
    exports.authenticate = function (req, credentialsFunc, options, callback) {
    
        callback = Hoek.nextTick(callback);
    
        // Default options
    
        options.nonceFunc = options.nonceFunc || internals.nonceFunc;
        options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds
    
        // Application time
    
        var now = Utils.now(options.localtimeOffsetMsec);                           // Measure now before any other processing
    
        // Convert node Http request object to a request configuration object
    
        var request = Utils.parseRequest(req, options);
        if (request instanceof Error) {
            return callback(Boom.badRequest(request.message));
        }
    
        // Parse HTTP Authorization header
    
        var attributes = Utils.parseAuthorizationHeader(request.authorization);
        if (attributes instanceof Error) {
            return callback(attributes);
        }
    
        // Construct artifacts container
    
        var artifacts = {
            method: request.method,
            host: request.host,
            port: request.port,
            resource: request.url,
            ts: attributes.ts,
            nonce: attributes.nonce,
            hash: attributes.hash,
            ext: attributes.ext,
            app: attributes.app,
            dlg: attributes.dlg,
            mac: attributes.mac,
            id: attributes.id
        };
    
        // Verify required header attributes
    
        if (!attributes.id ||
            !attributes.ts ||
            !attributes.nonce ||
            !attributes.mac) {
    
            return callback(Boom.badRequest('Missing attributes'), null, artifacts);
        }
    
        // Fetch Hawk credentials
    
        credentialsFunc(attributes.id, function (err, credentials) {
    
            if (err) {
                return callback(err, credentials || null, artifacts);
            }
    
            if (!credentials) {
                return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, artifacts);
            }
    
            if (!credentials.key ||
                !credentials.algorithm) {
    
                return callback(Boom.internal('Invalid credentials'), credentials, artifacts);
            }
    
            if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
                return callback(Boom.internal('Unknown algorithm'), credentials, artifacts);
            }
    
            // Calculate MAC
    
            var mac = Crypto.calculateMac('header', credentials, artifacts);
            if (!Cryptiles.fixedTimeComparison(mac, attributes.mac)) {
                return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, artifacts);
            }
    
            // Check payload hash
    
            if (options.payload ||
                options.payload === '') {
    
                if (!attributes.hash) {
                    return callback(Boom.unauthorized('Missing required payload hash', 'Hawk'), credentials, artifacts);
                }
    
                var hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, request.contentType);
                if (!Cryptiles.fixedTimeComparison(hash, attributes.hash)) {
                    return callback(Boom.unauthorized('Bad payload hash', 'Hawk'), credentials, artifacts);
                }
            }
    
            // Check nonce
    
            options.nonceFunc(credentials.key, attributes.nonce, attributes.ts, function (err) {
    
                if (err) {
                    return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials, artifacts);
                }
    
                // Check timestamp staleness
    
                if (Math.abs((attributes.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
                    var tsm = Crypto.timestampMessage(credentials, options.localtimeOffsetMsec);
                    return callback(Boom.unauthorized('Stale timestamp', 'Hawk', tsm), credentials, artifacts);
                }
    
                // Successful authentication
    
                return callback(null, credentials, artifacts);
            });
        });
    };
    
    
    // Authenticate payload hash - used when payload cannot be provided during authenticate()
    
    /*
        payload:        raw request payload
        credentials:    from authenticate callback
        artifacts:      from authenticate callback
        contentType:    req.headers['content-type']
    */
    
    exports.authenticatePayload = function (payload, credentials, artifacts, contentType) {
    
        var calculatedHash = Crypto.calculatePayloadHash(payload, credentials.algorithm, contentType);
        return Cryptiles.fixedTimeComparison(calculatedHash, artifacts.hash);
    };
    
    
    // Authenticate payload hash - used when payload cannot be provided during authenticate()
    
    /*
        calculatedHash: the payload hash calculated using Crypto.calculatePayloadHash()
        artifacts:      from authenticate callback
    */
    
    exports.authenticatePayloadHash = function (calculatedHash, artifacts) {
    
        return Cryptiles.fixedTimeComparison(calculatedHash, artifacts.hash);
    };
    
    
    // Generate a Server-Authorization header for a given response
    
    /*
        credentials: {},                                        // Object received from authenticate()
        artifacts: {}                                           // Object received from authenticate(); 'mac', 'hash', and 'ext' - ignored
        options: {
            ext: 'application-specific',                        // Application specific data sent via the ext attribute
            payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
            contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
            hash: 'U4MKKSmiVxk37JCCrAVIjV='                     // Pre-calculated payload hash
        }
    */
    
    exports.header = function (credentials, artifacts, options) {
    
        // Prepare inputs
    
        options = options || {};
    
        if (!artifacts ||
            typeof artifacts !== 'object' ||
            typeof options !== 'object') {
    
            return '';
        }
    
        artifacts = Hoek.clone(artifacts);
        delete artifacts.mac;
        artifacts.hash = options.hash;
        artifacts.ext = options.ext;
    
        // Validate credentials
    
        if (!credentials ||
            !credentials.key ||
            !credentials.algorithm) {
    
            // Invalid credential object
            return '';
        }
    
        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return '';
        }
    
        // Calculate payload hash
    
        if (!artifacts.hash &&
            (options.payload || options.payload === '')) {
    
            artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
        }
    
        var mac = Crypto.calculateMac('response', credentials, artifacts);
    
        // Construct header
    
        var header = 'Hawk mac="' + mac + '"' +
                     (artifacts.hash ? ', hash="' + artifacts.hash + '"' : '');
    
        if (artifacts.ext !== null &&
            artifacts.ext !== undefined &&
            artifacts.ext !== '') {                       // Other falsey values allowed
    
            header += ', ext="' + Hoek.escapeHeaderAttribute(artifacts.ext) + '"';
        }
    
        return header;
    };
    
    
    /*
     * Arguments and options are the same as authenticate() with the exception that the only supported options are:
     * 'hostHeaderName', 'localtimeOffsetMsec', 'host', 'port'
     */
    
    exports.authenticateBewit = function (req, credentialsFunc, options, callback) {
    
        callback = Hoek.nextTick(callback);
    
        // Application time
    
        var now = Utils.now(options.localtimeOffsetMsec);
    
        // Convert node Http request object to a request configuration object
    
        var request = Utils.parseRequest(req, options);
        if (request instanceof Error) {
            return callback(Boom.badRequest(request.message));
        }
    
        // Extract bewit
    
        //                                 1     2             3           4
        var resource = request.url.match(/^(\/.*)([\?&])bewit\=([^&$]*)(?:&(.+))?$/);
        if (!resource) {
            return callback(Boom.unauthorized(null, 'Hawk'));
        }
    
        // Bewit not empty
    
        if (!resource[3]) {
            return callback(Boom.unauthorized('Empty bewit', 'Hawk'));
        }
    
        // Verify method is GET
    
        if (request.method !== 'GET' &&
            request.method !== 'HEAD') {
    
            return callback(Boom.unauthorized('Invalid method', 'Hawk'));
        }
    
        // No other authentication
    
        if (request.authorization) {
            return callback(Boom.badRequest('Multiple authentications'));
        }
    
        // Parse bewit
    
        var bewitString = Hoek.base64urlDecode(resource[3]);
        if (bewitString instanceof Error) {
            return callback(Boom.badRequest('Invalid bewit encoding'));
        }
    
        // Bewit format: id\exp\mac\ext ('\' is used because it is a reserved header attribute character)
    
        var bewitParts = bewitString.split('\\');
        if (bewitParts.length !== 4) {
            return callback(Boom.badRequest('Invalid bewit structure'));
        }
    
        var bewit = {
            id: bewitParts[0],
            exp: parseInt(bewitParts[1], 10),
            mac: bewitParts[2],
            ext: bewitParts[3] || ''
        };
    
        if (!bewit.id ||
            !bewit.exp ||
            !bewit.mac) {
    
            return callback(Boom.badRequest('Missing bewit attributes'));
        }
    
        // Construct URL without bewit
    
        var url = resource[1];
        if (resource[4]) {
            url += resource[2] + resource[4];
        }
    
        // Check expiration
    
        if (bewit.exp * 1000 <= now) {
            return callback(Boom.unauthorized('Access expired', 'Hawk'), null, bewit);
        }
    
        // Fetch Hawk credentials
    
        credentialsFunc(bewit.id, function (err, credentials) {
    
            if (err) {
                return callback(err, credentials || null, bewit.ext);
            }
    
            if (!credentials) {
                return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, bewit);
            }
    
            if (!credentials.key ||
                !credentials.algorithm) {
    
                return callback(Boom.internal('Invalid credentials'), credentials, bewit);
            }
    
            if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
                return callback(Boom.internal('Unknown algorithm'), credentials, bewit);
            }
    
            // Calculate MAC
    
            var mac = Crypto.calculateMac('bewit', credentials, {
                ts: bewit.exp,
                nonce: '',
                method: 'GET',
                resource: url,
                host: request.host,
                port: request.port,
                ext: bewit.ext
            });
    
            if (!Cryptiles.fixedTimeComparison(mac, bewit.mac)) {
                return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, bewit);
            }
    
            // Successful authentication
    
            return callback(null, credentials, bewit);
        });
    };
    
    
    /*
     *  options are the same as authenticate() with the exception that the only supported options are:
     * 'nonceFunc', 'timestampSkewSec', 'localtimeOffsetMsec'
     */
    
    exports.authenticateMessage = function (host, port, message, authorization, credentialsFunc, options, callback) {
    
        callback = Hoek.nextTick(callback);
    
        // Default options
    
        options.nonceFunc = options.nonceFunc || internals.nonceFunc;
        options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds
    
        // Application time
    
        var now = Utils.now(options.localtimeOffsetMsec);                       // Measure now before any other processing
    
        // Validate authorization
    
        if (!authorization.id ||
            !authorization.ts ||
            !authorization.nonce ||
            !authorization.hash ||
            !authorization.mac) {
    
            return callback(Boom.badRequest('Invalid authorization'));
        }
    
        // Fetch Hawk credentials
    
        credentialsFunc(authorization.id, function (err, credentials) {
    
            if (err) {
                return callback(err, credentials || null);
            }
    
            if (!credentials) {
                return callback(Boom.unauthorized('Unknown credentials', 'Hawk'));
            }
    
            if (!credentials.key ||
                !credentials.algorithm) {
    
                return callback(Boom.internal('Invalid credentials'), credentials);
            }
    
            if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
                return callback(Boom.internal('Unknown algorithm'), credentials);
            }
    
            // Construct artifacts container
    
            var artifacts = {
                ts: authorization.ts,
                nonce: authorization.nonce,
                host: host,
                port: port,
                hash: authorization.hash
            };
    
            // Calculate MAC
    
            var mac = Crypto.calculateMac('message', credentials, artifacts);
            if (!Cryptiles.fixedTimeComparison(mac, authorization.mac)) {
                return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials);
            }
    
            // Check payload hash
    
            var hash = Crypto.calculatePayloadHash(message, credentials.algorithm);
            if (!Cryptiles.fixedTimeComparison(hash, authorization.hash)) {
                return callback(Boom.unauthorized('Bad message hash', 'Hawk'), credentials);
            }
    
            // Check nonce
    
            options.nonceFunc(credentials.key, authorization.nonce, authorization.ts, function (err) {
    
                if (err) {
                    return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials);
                }
    
                // Check timestamp staleness
    
                if (Math.abs((authorization.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
                    return callback(Boom.unauthorized('Stale timestamp'), credentials);
                }
    
                // Successful authentication
    
                return callback(null, credentials);
            });
        });
    };
    
    
    internals.nonceFunc = function (key, nonce, ts, nonceCallback) {
    
        return nonceCallback();         // No validation
    };
    
  provide("hawk/lib/server", module.exports);
}(global));

// pakmanager:hawk/lib/client
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Url = require('url');
    var Hoek = require('hoek');
    var Cryptiles = require('cryptiles');
    var Crypto =  require('hawk/lib/crypto');
    var Utils =  require('hawk/lib/utils');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Generate an Authorization header for a given request
    
    /*
        uri: 'http://example.com/resource?a=b' or object from Url.parse()
        method: HTTP verb (e.g. 'GET', 'POST')
        options: {
    
            // Required
    
            credentials: {
                id: 'dh37fgj492je',
                key: 'aoijedoaijsdlaksjdl',
                algorithm: 'sha256'                                 // 'sha1', 'sha256'
            },
    
            // Optional
    
            ext: 'application-specific',                        // Application specific data sent via the ext attribute
            timestamp: Date.now(),                              // A pre-calculated timestamp
            nonce: '2334f34f',                                  // A pre-generated nonce
            localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
            payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
            contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
            hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
            app: '24s23423f34dx',                               // Oz application id
            dlg: '234sz34tww3sd'                                // Oz delegated-by application id
        }
    */
    
    exports.header = function (uri, method, options) {
    
        var result = {
            field: '',
            artifacts: {}
        };
    
        // Validate inputs
    
        if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||
            !method || typeof method !== 'string' ||
            !options || typeof options !== 'object') {
    
            result.err = 'Invalid argument type';
            return result;
        }
    
        // Application time
    
        var timestamp = options.timestamp || Utils.nowSecs(options.localtimeOffsetMsec);
    
        // Validate credentials
    
        var credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) {
    
            result.err = 'Invalid credential object';
            return result;
        }
    
        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            result.err = 'Unknown algorithm';
            return result;
        }
    
        // Parse URI
    
        if (typeof uri === 'string') {
            uri = Url.parse(uri);
        }
    
        // Calculate signature
    
        var artifacts = {
            ts: timestamp,
            nonce: options.nonce || Cryptiles.randomString(6),
            method: method,
            resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
            host: uri.hostname,
            port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
            hash: options.hash,
            ext: options.ext,
            app: options.app,
            dlg: options.dlg
        };
    
        result.artifacts = artifacts;
    
        // Calculate payload hash
    
        if (!artifacts.hash &&
            (options.payload || options.payload === '')) {
    
            artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
        }
    
        var mac = Crypto.calculateMac('header', credentials, artifacts);
    
        // Construct header
    
        var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
        var header = 'Hawk id="' + credentials.id +
                     '", ts="' + artifacts.ts +
                     '", nonce="' + artifacts.nonce +
                     (artifacts.hash ? '", hash="' + artifacts.hash : '') +
                     (hasExt ? '", ext="' + Hoek.escapeHeaderAttribute(artifacts.ext) : '') +
                     '", mac="' + mac + '"';
    
        if (artifacts.app) {
            header += ', app="' + artifacts.app +
                      (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
        }
    
        result.field = header;
    
        return result;
    };
    
    
    // Validate server response
    
    /*
        res:        node's response object
        artifacts:  object received from header().artifacts
        options: {
            payload:    optional payload received
            required:   specifies if a Server-Authorization header is required. Defaults to 'false'
        }
    */
    
    exports.authenticate = function (res, credentials, artifacts, options) {
    
        artifacts = Hoek.clone(artifacts);
        options = options || {};
    
        if (res.headers['www-authenticate']) {
    
            // Parse HTTP WWW-Authenticate header
    
            var wwwAttributes = Utils.parseAuthorizationHeader(res.headers['www-authenticate'], ['ts', 'tsm', 'error']);
            if (wwwAttributes instanceof Error) {
                return false;
            }
    
            // Validate server timestamp (not used to update clock since it is done via the SNPT client)
    
            if (wwwAttributes.ts) {
                var tsm = Crypto.calculateTsMac(wwwAttributes.ts, credentials);
                if (tsm !== wwwAttributes.tsm) {
                    return false;
                }
            }
        }
    
        // Parse HTTP Server-Authorization header
    
        if (!res.headers['server-authorization'] &&
            !options.required) {
    
            return true;
        }
    
        var attributes = Utils.parseAuthorizationHeader(res.headers['server-authorization'], ['mac', 'ext', 'hash']);
        if (attributes instanceof Error) {
            return false;
        }
    
        artifacts.ext = attributes.ext;
        artifacts.hash = attributes.hash;
    
        var mac = Crypto.calculateMac('response', credentials, artifacts);
        if (mac !== attributes.mac) {
            return false;
        }
    
        if (!options.payload &&
            options.payload !== '') {
    
            return true;
        }
    
        if (!attributes.hash) {
            return false;
        }
    
        var calculatedHash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, res.headers['content-type']);
        return (calculatedHash === attributes.hash);
    };
    
    
    // Generate a bewit value for a given URI
    
    /*
        uri: 'http://example.com/resource?a=b' or object from Url.parse()
        options: {
    
            // Required
    
            credentials: {
                id: 'dh37fgj492je',
                key: 'aoijedoaijsdlaksjdl',
                algorithm: 'sha256'                             // 'sha1', 'sha256'
            },
            ttlSec: 60 * 60,                                    // TTL in seconds
    
            // Optional
    
            ext: 'application-specific',                        // Application specific data sent via the ext attribute
            localtimeOffsetMsec: 400                            // Time offset to sync with server time
        };
    */
    
    exports.getBewit = function (uri, options) {
    
        // Validate inputs
    
        if (!uri ||
            (typeof uri !== 'string' && typeof uri !== 'object') ||
            !options ||
            typeof options !== 'object' ||
            !options.ttlSec) {
    
            return '';
        }
    
        options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value
    
        // Application time
    
        var now = Utils.now(options.localtimeOffsetMsec);
    
        // Validate credentials
    
        var credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) {
    
            return '';
        }
    
        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return '';
        }
    
        // Parse URI
    
        if (typeof uri === 'string') {
            uri = Url.parse(uri);
        }
    
        // Calculate signature
    
        var exp = Math.floor(now / 1000) + options.ttlSec;
        var mac = Crypto.calculateMac('bewit', credentials, {
            ts: exp,
            nonce: '',
            method: 'GET',
            resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
            host: uri.hostname,
            port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
            ext: options.ext
        });
    
        // Construct bewit: id\exp\mac\ext
    
        var bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
        return Hoek.base64urlEncode(bewit);
    };
    
    
    // Generate an authorization string for a message
    
    /*
        host: 'example.com',
        port: 8000,
        message: '{"some":"payload"}',                          // UTF-8 encoded string for body hash generation
        options: {
    
            // Required
    
            credentials: {
                id: 'dh37fgj492je',
                key: 'aoijedoaijsdlaksjdl',
                algorithm: 'sha256'                             // 'sha1', 'sha256'
            },
    
            // Optional
    
            timestamp: Date.now(),                              // A pre-calculated timestamp
            nonce: '2334f34f',                                  // A pre-generated nonce
            localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
        }
    */
    
    exports.message = function (host, port, message, options) {
    
        // Validate inputs
    
        if (!host || typeof host !== 'string' ||
            !port || typeof port !== 'number' ||
            message === null || message === undefined || typeof message !== 'string' ||
            !options || typeof options !== 'object') {
    
            return null;
        }
    
        // Application time
    
        var timestamp = options.timestamp || Utils.nowSecs(options.localtimeOffsetMsec);
    
        // Validate credentials
    
        var credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) {
    
            // Invalid credential object
            return null;
        }
    
        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return null;
        }
    
        // Calculate signature
    
        var artifacts = {
            ts: timestamp,
            nonce: options.nonce || Cryptiles.randomString(6),
            host: host,
            port: port,
            hash: Crypto.calculatePayloadHash(message, credentials.algorithm)
        };
    
        // Construct authorization
    
        var result = {
            id: credentials.id,
            ts: artifacts.ts,
            nonce: artifacts.nonce,
            hash: artifacts.hash,
            mac: Crypto.calculateMac('message', credentials, artifacts)
        };
    
        return result;
    };
    
    
    
    
  provide("hawk/lib/client", module.exports);
}(global));

// pakmanager:hawk
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Export sub-modules
    
    exports.error = exports.Error = require('boom');
    exports.sntp = require('sntp');
    
    exports.server =  require('hawk/lib/server');
    exports.client =  require('hawk/lib/client');
    exports.crypto =  require('hawk/lib/crypto');
    exports.utils =  require('hawk/lib/utils');
    
    exports.uri = {
        authenticate: exports.server.authenticateBewit,
        getBewit: exports.client.getBewit
    };
    
    
  provide("hawk", module.exports);
}(global));

// pakmanager:aws-sign2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /*!
     * knox - auth
     * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var crypto = require('crypto')
      , parse = require('url').parse
      ;
    
    /**
     * Valid keys.
     */
    
    var keys = 
      [ 'acl'
      , 'location'
      , 'logging'
      , 'notification'
      , 'partNumber'
      , 'policy'
      , 'requestPayment'
      , 'torrent'
      , 'uploadId'
      , 'uploads'
      , 'versionId'
      , 'versioning'
      , 'versions'
      , 'website'
      ]
    
    /**
     * Return an "Authorization" header value with the given `options`
     * in the form of "AWS <key>:<signature>"
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function authorization (options) {
      return 'AWS ' + options.key + ':' + sign(options)
    }
    
    module.exports = authorization
    module.exports.authorization = authorization
    
    /**
     * Simple HMAC-SHA1 Wrapper
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */ 
    
    function hmacSha1 (options) {
      return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
    }
    
    module.exports.hmacSha1 = hmacSha1
    
    /**
     * Create a base64 sha1 HMAC for `options`. 
     * 
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function sign (options) {
      options.message = stringToSign(options)
      return hmacSha1(options)
    }
    module.exports.sign = sign
    
    /**
     * Create a base64 sha1 HMAC for `options`. 
     *
     * Specifically to be used with S3 presigned URLs
     * 
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function signQuery (options) {
      options.message = queryStringToSign(options)
      return hmacSha1(options)
    }
    module.exports.signQuery= signQuery
    
    /**
     * Return a string for sign() with the given `options`.
     *
     * Spec:
     * 
     *    <verb>\n
     *    <md5>\n
     *    <content-type>\n
     *    <date>\n
     *    [headers\n]
     *    <resource>
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function stringToSign (options) {
      var headers = options.amazonHeaders || ''
      if (headers) headers += '\n'
      var r = 
        [ options.verb
        , options.md5
        , options.contentType
        , options.date ? options.date.toUTCString() : ''
        , headers + options.resource
        ]
      return r.join('\n')
    }
    module.exports.queryStringToSign = stringToSign
    
    /**
     * Return a string for sign() with the given `options`, but is meant exclusively
     * for S3 presigned URLs
     *
     * Spec:
     * 
     *    <date>\n
     *    <resource>
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function queryStringToSign (options){
      return 'GET\n\n\n' + options.date + '\n' + options.resource
    }
    module.exports.queryStringToSign = queryStringToSign
    
    /**
     * Perform the following:
     *
     *  - ignore non-amazon headers
     *  - lowercase fields
     *  - sort lexicographically
     *  - trim whitespace between ":"
     *  - join with newline
     *
     * @param {Object} headers
     * @return {String}
     * @api private
     */
    
    function canonicalizeHeaders (headers) {
      var buf = []
        , fields = Object.keys(headers)
        ;
      for (var i = 0, len = fields.length; i < len; ++i) {
        var field = fields[i]
          , val = headers[field]
          , field = field.toLowerCase()
          ;
        if (0 !== field.indexOf('x-amz')) continue
        buf.push(field + ':' + val)
      }
      return buf.sort().join('\n')
    }
    module.exports.canonicalizeHeaders = canonicalizeHeaders
    
    /**
     * Perform the following:
     *
     *  - ignore non sub-resources
     *  - sort lexicographically
     *
     * @param {String} resource
     * @return {String}
     * @api private
     */
    
    function canonicalizeResource (resource) {
      var url = parse(resource, true)
        , path = url.pathname
        , buf = []
        ;
    
      Object.keys(url.query).forEach(function(key){
        if (!~keys.indexOf(key)) return
        var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
        buf.push(key + val)
      })
    
      return path + (buf.length ? '?' + buf.sort().join('&') : '')
    }
    module.exports.canonicalizeResource = canonicalizeResource
    
  provide("aws-sign2", module.exports);
}(global));

// pakmanager:stringstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util')
    var Stream = require('stream')
    var StringDecoder = require('string_decoder').StringDecoder
    
    module.exports = StringStream
    module.exports.AlignedStringDecoder = AlignedStringDecoder
    
    function StringStream(from, to) {
      if (!(this instanceof StringStream)) return new StringStream(from, to)
    
      Stream.call(this)
    
      if (from == null) from = 'utf8'
    
      this.readable = this.writable = true
      this.paused = false
      this.toEncoding = (to == null ? from : to)
      this.fromEncoding = (to == null ? '' : from)
      this.decoder = new AlignedStringDecoder(this.toEncoding)
    }
    util.inherits(StringStream, Stream)
    
    StringStream.prototype.write = function(data) {
      if (!this.writable) {
        var err = new Error('stream not writable')
        err.code = 'EPIPE'
        this.emit('error', err)
        return false
      }
      if (this.fromEncoding) {
        if (Buffer.isBuffer(data)) data = data.toString()
        data = new Buffer(data, this.fromEncoding)
      }
      var string = this.decoder.write(data)
      if (string.length) this.emit('data', string)
      return !this.paused
    }
    
    StringStream.prototype.flush = function() {
      if (this.decoder.flush) {
        var string = this.decoder.flush()
        if (string.length) this.emit('data', string)
      }
    }
    
    StringStream.prototype.end = function() {
      if (!this.writable && !this.readable) return
      this.flush()
      this.emit('end')
      this.writable = this.readable = false
      this.destroy()
    }
    
    StringStream.prototype.destroy = function() {
      this.decoder = null
      this.writable = this.readable = false
      this.emit('close')
    }
    
    StringStream.prototype.pause = function() {
      this.paused = true
    }
    
    StringStream.prototype.resume = function () {
      if (this.paused) this.emit('drain')
      this.paused = false
    }
    
    function AlignedStringDecoder(encoding) {
      StringDecoder.call(this, encoding)
    
      switch (this.encoding) {
        case 'base64':
          this.write = alignedWrite
          this.alignedBuffer = new Buffer(3)
          this.alignedBytes = 0
          break
      }
    }
    util.inherits(AlignedStringDecoder, StringDecoder)
    
    AlignedStringDecoder.prototype.flush = function() {
      if (!this.alignedBuffer || !this.alignedBytes) return ''
      var leftover = this.alignedBuffer.toString(this.encoding, 0, this.alignedBytes)
      this.alignedBytes = 0
      return leftover
    }
    
    function alignedWrite(buffer) {
      var rem = (this.alignedBytes + buffer.length) % this.alignedBuffer.length
      if (!rem && !this.alignedBytes) return buffer.toString(this.encoding)
    
      var returnBuffer = new Buffer(this.alignedBytes + buffer.length - rem)
    
      this.alignedBuffer.copy(returnBuffer, 0, 0, this.alignedBytes)
      buffer.copy(returnBuffer, this.alignedBytes, 0, buffer.length - rem)
    
      buffer.copy(this.alignedBuffer, 0, buffer.length - rem, buffer.length)
      this.alignedBytes = rem
    
      return returnBuffer.toString(this.encoding)
    }
    
  provide("stringstream", module.exports);
}(global));

// pakmanager:isstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var stream = require('stream')
    
    
    function isStream (obj) {
      return obj instanceof stream.Stream
    }
    
    
    function isReadable (obj) {
      return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
    }
    
    
    function isWritable (obj) {
      return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
    }
    
    
    function isDuplex (obj) {
      return isReadable(obj) && isWritable(obj)
    }
    
    
    module.exports            = isStream
    module.exports.isReadable = isReadable
    module.exports.isWritable = isWritable
    module.exports.isDuplex   = isDuplex
    
  provide("isstream", module.exports);
}(global));

// pakmanager:har-validator/lib/schemas
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var schemas = {
      cache: require('./cache.json'),
      cacheEntry: require('./cacheEntry.json'),
      content: require('./content.json'),
      cookie: require('./cookie.json'),
      creator: require('./creator.json'),
      entry: require('./entry.json'),
      har: require('./har.json'),
      log: require('./log.json'),
      page: require('./page.json'),
      pageTimings: require('./pageTimings.json'),
      postData: require('./postData.json'),
      record: require('./record.json'),
      request: require('./request.json'),
      response: require('./response.json'),
      timings: require('./timings.json')
    }
    
    // is-my-json-valid does not provide meaningful error messages for external schemas
    // this is a workaround
    schemas.cache.properties.beforeRequest = schemas.cacheEntry
    schemas.cache.properties.afterRequest = schemas.cacheEntry
    
    schemas.page.properties.pageTimings = schemas.pageTimings
    
    schemas.request.properties.cookies.items = schemas.cookie
    schemas.request.properties.headers.items = schemas.record
    schemas.request.properties.queryString.items = schemas.record
    schemas.request.properties.postData = schemas.postData
    
    schemas.response.properties.cookies.items = schemas.cookie
    schemas.response.properties.headers.items = schemas.record
    schemas.response.properties.content = schemas.content
    
    schemas.entry.properties.request = schemas.request
    schemas.entry.properties.response = schemas.response
    schemas.entry.properties.cache = schemas.cache
    schemas.entry.properties.timings = schemas.timings
    
    schemas.log.properties.creator = schemas.creator
    schemas.log.properties.browser = schemas.creator
    schemas.log.properties.pages.items = schemas.page
    schemas.log.properties.entries.items = schemas.entry
    
    schemas.har.properties.log = schemas.log
    
    module.exports = schemas
    
  provide("har-validator/lib/schemas", module.exports);
}(global));

// pakmanager:har-validator/lib/error
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    function ValidationError (errors) {
      this.name = 'ValidationError'
      this.errors = errors
    }
    
    ValidationError.prototype = Error.prototype
    
    module.exports = ValidationError
    
  provide("har-validator/lib/error", module.exports);
}(global));

// pakmanager:har-validator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var schemas =  require('har-validator/lib/schemas')
    var ValidationError =  require('har-validator/lib/error')
    var validator = require('is-my-json-valid')
    
    var runner = function (schema, data, cb) {
      var validate = validator(schema, {
        greedy: true,
        verbose: true,
        schemas: schemas
      })
    
      var valid = false
    
      if (data !== undefined) {
        // execute is-my-json-valid
        valid = validate(data)
      }
    
      // callback?
      if (!cb) {
        return valid
      } else {
        return cb(validate.errors ? new ValidationError(validate.errors) : null, valid)
      }
    
      return valid
    }
    
    module.exports = function (data, cb) {
      return runner(schemas.har, data, cb)
    }
    
    Object.keys(schemas).map(function (name) {
      module.exports[name] = function (data, cb) {
        return runner(schemas[name], data, cb)
      }
    })
    
  provide("har-validator", module.exports);
}(global));

// pakmanager:data-uri-to-buffer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module exports.
     */
    
    module.exports = dataUriToBuffer;
    
    /**
     * Returns a `Buffer` instance from the given data URI `uri`.
     *
     * @param {String} uri Data URI to turn into a Buffer instance
     * @return {Buffer} Buffer instance from Data URI
     * @api public
     */
    
    function dataUriToBuffer (uri) {
      if (!/^data\:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
    
      // strip newlines
      uri = uri.replace(/\r?\n/g, '');
    
      // split the URI up into the "metadata" and the "data" portions
      var firstComma = uri.indexOf(',');
      if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data: URI');
    
      // remove the "data:" scheme and parse the metadata
      var meta = uri.substring(5, firstComma).split(';');
    
      var base64 = false;
      var charset = 'US-ASCII';
      for (var i = 0; i < meta.length; i++) {
        if ('base64' == meta[i]) {
          base64 = true;
        } else if (0 == meta[i].indexOf('charset=')) {
          charset = meta[i].substring(8);
        }
      }
    
      // get the encoded data portion and decode URI-encoded chars
      var data = unescape(uri.substring(firstComma + 1));
    
      var encoding = base64 ? 'base64' : 'ascii';
      var buffer = new Buffer(data, encoding);
    
      // set `.type` property to MIME type
      buffer.type = meta[0] || 'text/plain';
    
      // set the `.charset` property
      buffer.charset = charset;
    
      return buffer;
    }
    
  provide("data-uri-to-buffer", module.exports);
}(global));

// pakmanager:cwise-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    var esprima = require("esprima")
    var uniq = require("uniq")
    
    var PREFIX_COUNTER = 0
    
    function CompiledArgument(name, lvalue, rvalue) {
      this.name = name
      this.lvalue = lvalue
      this.rvalue = rvalue
      this.count = 0
    }
    
    function CompiledRoutine(body, args, thisVars, localVars) {
      this.body = body
      this.args = args
      this.thisVars = thisVars
      this.localVars = localVars
    }
    
    function isGlobal(identifier) {
      if(identifier === "eval") {
        throw new Error("cwise-parser: eval() not allowed")
      }
      if(typeof window !== "undefined") {
        return identifier in window
      } else if(typeof GLOBAL !== "undefined") {
        return identifier in GLOBAL
      } else if(typeof self !== "undefined") {
        return identifier in self
      } else {
        return false
      }
    }
    
    function getArgNames(ast) {
      var params = ast.body[0].expression.callee.params
      var names = new Array(params.length)
      for(var i=0; i<params.length; ++i) {
        names[i] = params[i].name
      }
      return names
    }
    
    function preprocess(func) {
      var src = ["(", func, ")()"].join("")
      var ast = esprima.parse(src, { range: true })
      
      //Compute new prefix
      var prefix = "_inline_" + (PREFIX_COUNTER++) + "_"
      
      //Parse out arguments
      var argNames = getArgNames(ast)
      var compiledArgs = new Array(argNames.length)
      for(var i=0; i<argNames.length; ++i) {
        compiledArgs[i] = new CompiledArgument([prefix, "arg", i, "_"].join(""), false, false)
      }
      
      //Create temporary data structure for source rewriting
      var exploded = new Array(src.length)
      for(var i=0, n=src.length; i<n; ++i) {
        exploded[i] = src.charAt(i)
      }
      
      //Local variables
      var localVars = []
      var thisVars = []
      var computedThis = false
      
      //Retrieves a local variable
      function createLocal(id) {
        var nstr = prefix + id.replace(/\_/g, "__")
        localVars.push(nstr)
        return nstr
      }
      
      //Creates a this variable
      function createThisVar(id) {
        var nstr = "this_" + id.replace(/\_/g, "__")
        thisVars.push(nstr)
        return nstr
      }
      
      //Rewrites an ast node
      function rewrite(node, nstr) {
        var lo = node.range[0], hi = node.range[1]
        for(var i=lo+1; i<hi; ++i) {
          exploded[i] = ""
        }
        exploded[lo] = nstr
      }
      
      //Remove any underscores
      function escapeString(str) {
        return "'"+(str.replace(/\_/g, "\\_").replace(/\'/g, "\'"))+"'"
      }
      
      //Returns the source of an identifier
      function source(node) {
        return exploded.slice(node.range[0], node.range[1]).join("")
      }
      
      //Computes the usage of a node
      var LVALUE = 1
      var RVALUE = 2
      function getUsage(node) {
        if(node.parent.type === "AssignmentExpression") {
          if(node.parent.left === node) {
            if(node.parent.operator === "=") {
              return LVALUE
            }
            return LVALUE|RVALUE
          }
        }
        if(node.parent.type === "UpdateExpression") {
          return LVALUE|RVALUE
        }
        return RVALUE
      }
      
      //Handle visiting a node
      (function visit(node, parent) {
        node.parent = parent
        if(node.type === "MemberExpression") {
          //Handle member expression
          if(node.computed) {
            visit(node.object, node)
            visit(node.property, node)
          } else if(node.object.type === "ThisExpression") {
            rewrite(node, createThisVar(node.property.name))
          } else {
            visit(node.object, node)
          }
        } else if(node.type === "ThisExpression") {
          throw new Error("cwise-parser: Computed this is not allowed")
        } else if(node.type === "Identifier") {
          //Handle identifier
          var name = node.name
          var argNo = argNames.indexOf(name)
          if(argNo >= 0) {
            var carg = compiledArgs[argNo]
            var usage = getUsage(node)
            if(usage & LVALUE) {
              carg.lvalue = true
            }
            if(usage & RVALUE) {
              carg.rvalue = true
            }
            ++carg.count
            rewrite(node, carg.name)
          } else if(isGlobal(name)) {
            //Don't rewrite globals
          } else {
            rewrite(node, createLocal(name))
          }
        } else if(node.type === "Literal") {
          if(typeof node.value === "string") {
            rewrite(node, escapeString(node.value))
          }
        } else if(node.type === "WithStatement") {
          throw new Error("cwise-parser: with() statements not allowed")
        } else {
          //Visit all children
          var keys = Object.keys(node)
          for(var i=0, n=keys.length; i<n; ++i) {
            if(keys[i] === "parent") {
              continue
            }
            var value = node[keys[i]]
            if(value) {
              if(value instanceof Array) {
                for(var j=0; j<value.length; ++j) {
                  if(value[j] && typeof value[j].type === "string") {
                    visit(value[j], node)
                  }
                }
              } else if(typeof value.type === "string") {
                visit(value, node)
              }
            }
          }
        }
      })(ast.body[0].expression.callee.body, undefined)
      
      //Remove duplicate variables
      uniq(localVars)
      uniq(thisVars)
      
      //Return body
      var routine = new CompiledRoutine(source(ast.body[0].expression.callee.body), compiledArgs, thisVars, localVars)
      return routine
    }
    
    module.exports = preprocess
  provide("cwise-parser", module.exports);
}(global));

// pakmanager:static-module
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs');
    var path = require('path');
    
    var through = require('through2');
    var Readable = require('readable-stream').Readable;
    
    var concat = require('concat-stream');
    var duplexer = require('duplexer2');
    var falafel = require('falafel');
    var unparse = require('escodegen').generate;
    var inspect = require('object-inspect');
    var evaluate = require('static-eval');
    var copy = require('shallow-copy');
    var has = require('has');
    
    module.exports = function parse (modules, opts) {
        if (!opts) opts = {};
        var vars = opts.vars || {};
        var varNames = opts.varNames || {};
        var varModules = opts.varModules || {};
        var skip = opts.skip || {};
        var skipOffset = opts.skipOffset || 0;
        var updates = [];
        
        function pushUpdate (node, s) {
            var rep = String(s);
            var prev = node.end - node.start;
            updates.push({ offset: prev - rep.length });
            node.update(rep);
        }
        
        var output = through();
        var body;
        return duplexer(concat(function (buf) {
            try {
                body = buf.toString('utf8').replace(/^#!/, '//#!');
                var src = falafel(body, { ecmaVersion: 6 }, walk)
            }
            catch (err) { return error(err) }
            finish(src);
        }), output);
        
        function finish (src) {
            var offset = 0, pos = 0;
            src = String(src);
            
            (function next () {
                if (updates.length === 0) return done();
                
                var s = updates.shift();
                if (!s.stream) {
                    offset += s.offset;
                    return next();
                }
                
                output.push(src.slice(pos, s.start - offset));
                pos = s.start - offset;
                offset += s.offset;
                //offset += s.end - s.start;
                
                s.stream.pipe(output, { end: false });
                s.stream.on('end', next);
            })();
            
            function done () {
                output.push(src.slice(pos));
                output.push(null);
            }
        }
        
        function error (msg) {
            var err = typeof msg === 'string' ? new Error(msg) : msg;
            output.emit('error', err);
        }
        
        function walk (node) {
            var isreq = isRequire(node);
            var isreqm = false, isreqv = false, reqid;
            if (isreq) {
                reqid = node.arguments[0].value;
                isreqm = has(modules, reqid);
                isreqv = has(varModules, reqid);
            }
            
            if (isreqv && node.parent.type === 'VariableDeclarator'
            && node.parent.id.type === 'Identifier') {
                vars[node.parent.id.name] = varModules[reqid];
            }
            else if (isreqv && node.parent.type === 'AssignmentExpression'
            && node.parent.left.type === 'Identifier') {
                vars[node.parent.left.name] = varModules[reqid];
            }
            else if (isreqv && node.parent.type === 'MemberExpression'
            && node.parent.property.type === 'Identifier'
            && node.parent.parent.type === 'VariableDeclarator'
            && node.parent.parent.id.type === 'Identifier') {
                var v = varModules[reqid][node.parent.property.name];
                vars[node.parent.parent.id.name] = v;
            }
            else if (isreqv && node.parent.type === 'MemberExpression'
            && node.parent.property.type === 'Identifier') {
                //vars[node.parent.parent.id.name] = varModules[reqid];
            }
            else if (isreqv && node.parent.type === 'CallExpression') {
                //
            }
            
            if (isreqm && node.parent.type === 'VariableDeclarator'
            && node.parent.id.type === 'Identifier') {
                varNames[node.parent.id.name] = reqid;
                var decs = node.parent.parent.declarations;
                var ix = decs.indexOf(node.parent);
                var dec;
                if (ix >= 0) {
                    dec = decs[ix];
                    decs.splice(ix, 1);
                }
                
                if (decs.length) {
                    var src = unparse(node.parent.parent);
                    updates.push({
                        start: node.parent.parent.start,
                        end: node.parent.parent.end + 1,
                        offset: node.parent.parent.end + 1
                            - node.parent.parent.start
                        ,
                        stream: st('var ')
                    });
                    decs.forEach(function (d, i) {
                        var key = (d.start + skipOffset)
                            + ',' + (d.end + skipOffset)
                        ;
                        skip[key] = true;
                        
                        var s = parse(modules, {
                            skip: skip,
                            skipOffset: skipOffset + d.init.start,
                            vars: vars,
                            varNames: varNames
                        });
                        var up = {
                            start: node.parent.parent.start,
                            end: node.parent.parent.end - d.init.start - 2,
                            stream: s
                        };
                        up.offset = up.end - up.start;
                        updates.push(up);
                        if (i < decs.length - 1) {
                            var comma;
                            if (i === ix - 1) {
                                comma = body.slice(d.end, dec.start);
                            }
                            else comma = body.slice(d.end, decs[i+1].start);
                            updates.push({
                                start: d.end,
                                end: d.end + comma.length,
                                offset: comma.length,
                                stream: st(comma)
                            });
                        }
                        s.end(unparse(d));
                    });
                }
                pushUpdate(node.parent.parent, '');
            }
            else if (isreqm && node.parent.type === 'AssignmentExpression'
            && node.parent.left.type === 'Identifier') {
                varNames[node.parent.left.name] = reqid;
                var cur = node.parent.parent;
                if (cur.type === 'SequenceExpression') {
                    var ex = cur.expressions;
                    var ix = ex.indexOf(node.parent);
                    if (ix >= 0) ex.splice(ix, 1);
                    pushUpdate(
                        node.parent.parent,
                        unparse(node.parent.parent)
                    );
                }
                else pushUpdate(cur, '');
            }
            else if (isreqm && node.parent.type === 'MemberExpression'
            && node.parent.property.type === 'Identifier'
            && node.parent.parent.type === 'VariableDeclarator'
            && node.parent.parent.id.type === 'Identifier') {
                varNames[node.parent.parent.id.name] = [
                    reqid, node.parent.property.name
                ];
                var decs = node.parent.parent.parent.declarations;
                var ix = decs.indexOf(node.parent.parent);
                if (ix >= 0) decs.splice(ix, 1);
                
                if (decs.length === 0) {
                    pushUpdate(node.parent.parent.parent, '');
                }
                else {
                    pushUpdate(
                        node.parent.parent.parent,
                        unparse(node.parent.parent.parent)
                    );
                }
            }
            else if (isreqm && node.parent.type === 'MemberExpression'
            && node.parent.property.type === 'Identifier') {
                var name = node.parent.property.name;
                var cur = copy(node.parent.parent);
                cur.callee = copy(node.parent.property);
                cur.callee.parent = cur;
                traverse(cur.callee, modules[reqid][name]);
            }
            else if (isreqm && node.parent.type === 'CallExpression') {
                var cur = copy(node.parent);
                var iname = Math.pow(16,8) * Math.random();
                cur.callee = {
                    type: 'Identifier',
                    name: '_' + Math.floor(iname).toString(16),
                    parent: cur
                };
                traverse(cur.callee, modules[reqid]);
            }
            
            if (node.type === 'Identifier' && has(varNames, node.name)) {
                var vn = varNames[node.name];
                if (Array.isArray(vn)) {
                    traverse(node, modules[vn[0]][vn[1]]);
                }
                else traverse(node, modules[vn]);
            }
        }
        
        function traverse (node, val) {
            for (var p = node; p; p = p.parent) {
                if (p.start === undefined || p.end === undefined) continue;
                var key = (p.start + skipOffset)
                    + ',' + (p.end + skipOffset)
                ;
                if (skip[key]) {
                    skip[key] = false;
                    return;
                }
            }
            
            if (skip[key]) {
                skip[key] = false;
                return;
            }
            
            if (node.parent.type === 'CallExpression') {
                if (typeof val !== 'function') {
                    return error(
                        'tried to statically call ' + inspect(val)
                        + ' as a function'
                    );
                }
                var xvars = copy(vars);
                xvars[node.name] = val;
                var res = evaluate(node.parent, xvars);
                
                if (isStream(res)) {
                    updates.push({
                        start: node.parent.start,
                        end: node.parent.end,
                        offset: 0,
                        stream: wrapStream(res)
                    });
                    pushUpdate(node.parent, '');
                }
                else if (res !== undefined) pushUpdate(node.parent, res);
            }
            else if (node.parent.type === 'MemberExpression') {
                if (node.parent.property.type !== 'Identifier') {
                    return error(
                        'dynamic property in member expression: '
                        + node.parent.source()
                    );
                }
                
                var cur = node.parent.parent;
                
                if (cur.type === 'MemberExpression') {
                    cur = cur.parent;
                    if (cur.type !== 'CallExpression'
                    && cur.parent.type === 'CallExpression') {
                        cur = cur.parent;
                    }
                }
                if (node.parent.type === 'MemberExpression'
                && (cur.type !== 'CallExpression'
                && cur.type !== 'MemberExpression')) {
                    cur = node.parent;
                }
                
                var xvars = copy(vars);
                xvars[node.name] = val;
                
                var res = evaluate(cur, xvars);
                if (isStream(res)) {
                    updates.push({
                        start: cur.start,
                        end: cur.end,
                        offset: cur.end - cur.start,
                        stream: wrapStream(res)
                    });
                    cur.update('');
                }
                else if (res !== undefined) {
                    pushUpdate(cur, res);
                }
            }
            else {
                output.emit('error', new Error(
                    'unsupported type for static module: ' + node.parent.type
                    + '\nat expression:\n\n  ' + unparse(node.parent) + '\n'
                ));
            }
        }
    }
    
    function isRequire (node) {
        var c = node.callee;
        return c
            && node.type === 'CallExpression'
            && c.type === 'Identifier'
            && c.name === 'require'
        ;
    }
    
    function isStream (s) {
        return s && typeof s === 'object' && typeof s.pipe === 'function';
    }
    
    function wrapStream (s) {
        if (typeof s.read === 'function') return s
        else return (new Readable).wrap(s)
    }
    
    function st (msg) {
        var r = new Readable;
        r._read = function () {};
        r.push(msg);
        r.push(null);
        return r;
    }
    
  provide("static-module", module.exports);
}(global));

// pakmanager:uglify-js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require("path");
    var fs = require("fs");
    var vm = require("vm");
    
    var UglifyJS = vm.createContext({
        console       : console,
        process       : process,
        Buffer        : Buffer,
        MOZ_SourceMap : require("source-map")
    });
    
    function load_global(file) {
        file = path.resolve(path.dirname(module.filename), file);
        try {
            var code = fs.readFileSync(file, "utf8");
            return vm.runInContext(code, UglifyJS, file);
        } catch(ex) {
            // XXX: in case of a syntax error, the message is kinda
            // useless. (no location information).
            console.log("ERROR in file: " + file + " / " + ex);
            process.exit(1);
        }
    };
    
    var FILES = exports.FILES = [
        "../lib/utils.js",
        "../lib/ast.js",
        "../lib/parse.js",
        "../lib/transform.js",
        "../lib/scope.js",
        "../lib/output.js",
        "../lib/compress.js",
        "../lib/sourcemap.js",
        "../lib/mozilla-ast.js",
        "../lib/propmangle.js"
    ].map(function(file){
        return fs.realpathSync(path.join(path.dirname(__filename), file));
    });
    
    FILES.forEach(load_global);
    
    UglifyJS.AST_Node.warn_function = function(txt) {
        console.error("WARN: %s", txt);
    };
    
    // XXX: perhaps we shouldn't export everything but heck, I'm lazy.
    for (var i in UglifyJS) {
        if (UglifyJS.hasOwnProperty(i)) {
            exports[i] = UglifyJS[i];
        }
    }
    
    exports.minify = function(files, options) {
        options = UglifyJS.defaults(options, {
            spidermonkey : false,
            outSourceMap : null,
            sourceRoot   : null,
            inSourceMap  : null,
            fromString   : false,
            warnings     : false,
            mangle       : {},
            output       : null,
            compress     : {}
        });
        UglifyJS.base54.reset();
    
        // 1. parse
        var toplevel = null,
            sourcesContent = {};
    
        if (options.spidermonkey) {
            toplevel = UglifyJS.AST_Node.from_mozilla_ast(files);
        } else {
            if (typeof files == "string")
                files = [ files ];
            files.forEach(function(file){
                var code = options.fromString
                    ? file
                    : fs.readFileSync(file, "utf8");
                sourcesContent[file] = code;
                toplevel = UglifyJS.parse(code, {
                    filename: options.fromString ? "?" : file,
                    toplevel: toplevel
                });
            });
        }
    
        // 2. compress
        if (options.compress) {
            var compress = { warnings: options.warnings };
            UglifyJS.merge(compress, options.compress);
            toplevel.figure_out_scope();
            var sq = UglifyJS.Compressor(compress);
            toplevel = toplevel.transform(sq);
        }
    
        // 3. mangle
        if (options.mangle) {
            toplevel.figure_out_scope(options.mangle);
            toplevel.compute_char_frequency(options.mangle);
            toplevel.mangle_names(options.mangle);
        }
    
        // 4. output
        var inMap = options.inSourceMap;
        var output = {};
        if (typeof options.inSourceMap == "string") {
            inMap = fs.readFileSync(options.inSourceMap, "utf8");
        }
        if (options.outSourceMap) {
            output.source_map = UglifyJS.SourceMap({
                file: options.outSourceMap,
                orig: inMap,
                root: options.sourceRoot
            });
            if (options.sourceMapIncludeSources) {
                for (var file in sourcesContent) {
                    if (sourcesContent.hasOwnProperty(file)) {
                        output.source_map.get().setSourceContent(file, sourcesContent[file]);
                    }
                }
            }
    
        }
        if (options.output) {
            UglifyJS.merge(output, options.output);
        }
        var stream = UglifyJS.OutputStream(output);
        toplevel.print(stream);
    
        if(options.outSourceMap){
            stream += "\n//# sourceMappingURL=" + options.outSourceMap;
        }
    
        var source_map = output.source_map;
        if (source_map) {
            source_map = source_map + "";
        }
    
        return {
            code : stream + "",
            map  : source_map
        };
    };
    
    // exports.describe_ast = function() {
    //     function doitem(ctor) {
    //         var sub = {};
    //         ctor.SUBCLASSES.forEach(function(ctor){
    //             sub[ctor.TYPE] = doitem(ctor);
    //         });
    //         var ret = {};
    //         if (ctor.SELF_PROPS.length > 0) ret.props = ctor.SELF_PROPS;
    //         if (ctor.SUBCLASSES.length > 0) ret.sub = sub;
    //         return ret;
    //     }
    //     return doitem(UglifyJS.AST_Node).sub;
    // }
    
    exports.describe_ast = function() {
        var out = UglifyJS.OutputStream({ beautify: true });
        function doitem(ctor) {
            out.print("AST_" + ctor.TYPE);
            var props = ctor.SELF_PROPS.filter(function(prop){
                return !/^\$/.test(prop);
            });
            if (props.length > 0) {
                out.space();
                out.with_parens(function(){
                    props.forEach(function(prop, i){
                        if (i) out.space();
                        out.print(prop);
                    });
                });
            }
            if (ctor.documentation) {
                out.space();
                out.print_string(ctor.documentation);
            }
            if (ctor.SUBCLASSES.length > 0) {
                out.space();
                out.with_block(function(){
                    ctor.SUBCLASSES.forEach(function(ctor, i){
                        out.indent();
                        doitem(ctor);
                        out.newline();
                    });
                });
            }
        };
        doitem(UglifyJS.AST_Node);
        return out + "";
    };
    
    function readReservedFile(filename, reserved) {
        if (!reserved) {
            reserved = { vars: [], props: [] };
        }
        var data = fs.readFileSync(filename, "utf8");
        data = JSON.parse(data);
        if (data.vars) {
            data.vars.forEach(function(name){
                UglifyJS.push_uniq(reserved.vars, name);
            });
        }
        if (data.props) {
            data.props.forEach(function(name){
                UglifyJS.push_uniq(reserved.props, name);
            });
        }
        return reserved;
    }
    
    exports.readReservedFile = readReservedFile;
    
    exports.readDefaultReservedFile = function(reserved) {
        return readReservedFile(path.join(__dirname, "domprops.json"), reserved);
    };
    
    exports.readNameCache = function(filename, key) {
        var cache = null;
        if (filename) {
            try {
                var cache = fs.readFileSync(filename, "utf8");
                cache = JSON.parse(cache)[key];
                if (!cache) throw "init";
                cache.props = UglifyJS.Dictionary.fromObject(cache.props);
            } catch(ex) {
                cache = {
                    cname: -1,
                    props: new UglifyJS.Dictionary()
                };
            }
        }
        return cache;
    };
    
    exports.writeNameCache = function(filename, key, cache) {
        if (filename) {
            var data;
            try {
                data = fs.readFileSync(filename, "utf8");
                data = JSON.parse(data);
            } catch(ex) {
                data = {};
            }
            data[key] = {
                cname: cache.cname,
                props: cache.props.toObject()
            };
            fs.writeFileSync(filename, JSON.stringify(data, null, 2), "utf8");
        }
    };
    
  provide("uglify-js", module.exports);
}(global));

// pakmanager:pngjs2/lib/interlace
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    // Adam 7
    //   0 1 2 3 4 5 6 7
    // 0 x 6 4 6 x 6 4 6
    // 1 7 7 7 7 7 7 7 7
    // 2 5 6 5 6 5 6 5 6
    // 3 7 7 7 7 7 7 7 7
    // 4 3 6 4 6 3 6 4 6
    // 5 7 7 7 7 7 7 7 7
    // 6 5 6 5 6 5 6 5 6
    // 7 7 7 7 7 7 7 7 7
    
    
    var imagePasses = [
      { // pass 1 - 1px
        x: [0],
        y: [0]
      },
      { // pass 2 - 1px
        x: [4],
        y: [0]
      },
      { // pass 3 - 2px
        x: [0, 4],
        y: [4]
      },
      { // pass 4 - 4px
        x: [2, 6],
        y: [0, 4]
      },
      { // pass 5 - 8px
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      { // pass 6 - 16px
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      { // pass 7 - 32px
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    
    exports.getImagePasses = function(width, height) {
      var images = [];
      var xLeftOver = width % 8;
      var yLeftOver = height % 8;
      var xRepeats = (width - xLeftOver) / 8;
      var yRepeats = (height - yLeftOver) / 8;
      for (var i = 0; i < imagePasses.length; i++) {
        var pass = imagePasses[i];
        var passWidth = xRepeats * pass.x.length;
        var passHeight = yRepeats * pass.y.length;
        for (var j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          }
          else {
            break;
          }
        }
        for (j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          }
          else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i });
        }
      }
      return images;
    };
    
    exports.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        var outerXLeftOver = x % imagePasses[pass].x.length;
        var outerX = (((x - outerXLeftOver) / imagePasses[pass].x.length) * 8) + imagePasses[pass].x[outerXLeftOver];
        var outerYLeftOver = y % imagePasses[pass].y.length;
        var outerY = (((y - outerYLeftOver) / imagePasses[pass].y.length) * 8) + imagePasses[pass].y[outerYLeftOver];
        return (outerX * 4) + (outerY * width * 4);
      };
    };
  provide("pngjs2/lib/interlace", module.exports);
}(global));

// pakmanager:pngjs2/lib/paeth-predictor
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = function paethPredictor(left, above, upLeft) {
    
      var paeth = left + above - upLeft;
      var pLeft = Math.abs(paeth - left);
      var pAbove = Math.abs(paeth - above);
      var pUpLeft = Math.abs(paeth - upLeft);
    
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  provide("pngjs2/lib/paeth-predictor", module.exports);
}(global));

// pakmanager:pngjs2/lib/sync-reader
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var SyncReader = module.exports = function(buffer) {
    
      this._buffer = buffer;
      this._reads = [];
    };
    
    SyncReader.prototype.read = function(length, callback) {
    
      this._reads.push({
        length: Math.abs(length),  // if length < 0 then at most this length
        allowLess: length < 0,
        func: callback
      });
    };
    
    SyncReader.prototype.process = function() {
    
      // as long as there is any data and read requests
      while (this._reads.length > 0 && this._buffer.length) {
    
        var read = this._reads[0];
    
        if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
    
          // ok there is any data so that we can satisfy this request
          this._reads.shift(); // == read
    
          var buf = this._buffer;
    
          this._buffer = buf.slice(read.length);
    
          read.func.call(this, buf.slice(0, read.length));
    
        }
        else {
          break;
        }
    
      }
    
      if (this._reads.length > 0) {
        return new Error('There are some read requests waitng on finished stream');
      }
    
      if (this._buffer.length > 0) {
        return new Error('unrecognised content at end of stream');
      }
    
    };
    
  provide("pngjs2/lib/sync-reader", module.exports);
}(global));

// pakmanager:pngjs2/lib/filter-parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var interlaceUtils =  require('pngjs2/lib/interlace');
    var paethPredictor =  require('pngjs2/lib/paeth-predictor');
    
    function getByteWidth(width, bpp, depth) {
      var byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    
    var Filter = module.exports = function(bitmapInfo, dependencies) {
    
      var width = bitmapInfo.width;
      var height = bitmapInfo.height;
      var interlace = bitmapInfo.interlace;
      var bpp = bitmapInfo.bpp;
      var depth = bitmapInfo.depth;
    
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
    
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        var passes = interlaceUtils.getImagePasses(width, height);
        for (var i = 0; i < passes.length; i++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i].width, bpp, depth),
            height: passes[i].height,
            lineIndex: 0
          });
        }
      }
      else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height: height,
          lineIndex: 0
        });
      }
    
      // when filtering the line we look at the pixel to the left
      // the spec also says it is done on a byte level regardless of the number of pixels
      // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back
      // a pixel rather than just a different byte part. However if we are sub byte, we ignore.
      if (depth === 8) {
        this._xComparison = bpp;
      }
      else if (depth === 16) {
        this._xComparison = bpp * 2;
      }
      else {
        this._xComparison = 1;
      }
    };
    
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
    
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    
      var lastLine = this._lastLine;
    
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      var lastLine = this._lastLine;
    
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f3Up = lastLine ? lastLine[x] : 0;
        var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        var f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      var lastLine = this._lastLine;
    
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f4Up = lastLine ? lastLine[x] : 0;
        var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    
    Filter.prototype._reverseFilterLine = function(rawData) {
    
      var filter = rawData[0];
      var unfilteredLine;
      var currentImage = this._images[this._imageIndex];
      var byteWidth = currentImage.byteWidth;
    
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      }
      else {
    
        unfilteredLine = new Buffer(byteWidth);
    
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error('Unrecognised filter type - ' + filter);
        }
      }
    
      this.write(unfilteredLine);
    
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      }
      else {
        this._lastLine = unfilteredLine;
      }
    
      if (currentImage) {
        // read, using the byte width that may be from the new current image
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      }
      else {
        this._lastLine = null;
        this.complete();
      }
    };
    
  provide("pngjs2/lib/filter-parse", module.exports);
}(global));

// pakmanager:pngjs2/lib/constants
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    
    module.exports = {
    
      PNG_SIGNATURE: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],
    
      TYPE_IHDR: 0x49484452,
      TYPE_IEND: 0x49454e44,
      TYPE_IDAT: 0x49444154,
      TYPE_PLTE: 0x504c5445,
      TYPE_tRNS: 0x74524e53, // eslint-disable-line camelcase
      TYPE_gAMA: 0x67414d41, // eslint-disable-line camelcase
    
      // color-type bits
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4, // e.g. grayscale and alpha
    
      // color-type combinations
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
    
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
    
      GAMMA_DIVISION: 100000
    };
    
  provide("pngjs2/lib/constants", module.exports);
}(global));

// pakmanager:pngjs2/lib/crc
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var crcTable = [];
    
    (function() {
      for (var i = 0; i < 256; i++) {
        var currentCrc = i;
        for (var j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 0xedb88320 ^ (currentCrc >>> 1);
          }
          else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i] = currentCrc;
      }
    }());
    
    var CrcCalculator = module.exports = function() {
      this._crc = -1;
    };
    
    CrcCalculator.prototype.write = function(data) {
    
      for (var i = 0; i < data.length; i++) {
        this._crc = crcTable[(this._crc ^ data[i]) & 0xff] ^ (this._crc >>> 8);
      }
      return true;
    };
    
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    
    
    CrcCalculator.crc32 = function(buf) {
    
      var crc = -1;
      for (var i = 0; i < buf.length; i++) {
        crc = crcTable[(crc ^ buf[i]) & 0xff] ^ (crc >>> 8);
      }
      return crc ^ -1;
    };
    
  provide("pngjs2/lib/crc", module.exports);
}(global));

// pakmanager:pngjs2/lib/chunkstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    
    var util = require('util');
    var Stream = require('stream');
    
    
    var ChunkStream = module.exports = function() {
      Stream.call(this);
    
      this._buffers = [];
      this._buffered = 0;
    
      this._reads = [];
      this._paused = false;
    
      this._encoding = 'utf8';
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream);
    
    
    ChunkStream.prototype.read = function(length, callback) {
    
      this._reads.push({
        length: Math.abs(length),  // if length < 0 then at most this length
        allowLess: length < 0,
        func: callback
      });
    
      process.nextTick(function() {
        this._process();
    
        // its paused and there is not enought data then ask for more
        if (this._paused && this._reads.length > 0) {
          this._paused = false;
    
          this.emit('drain');
        }
      }.bind(this));
    };
    
    ChunkStream.prototype.write = function(data, encoding) {
    
      if (!this.writable) {
        this.emit('error', new Error('Stream not writable'));
        return false;
      }
    
      var dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      }
      else {
        dataBuffer = new Buffer(data, encoding || this._encoding);
      }
    
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
    
      this._process();
    
      // ok if there are no more read requests
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
    
      return this.writable && !this._paused;
    };
    
    ChunkStream.prototype.end = function(data, encoding) {
    
      if (data) {
        this.write(data, encoding);
      }
    
      this.writable = false;
    
      // already destroyed
      if (!this._buffers) {
        return;
      }
    
      // enqueue or handle end
      if (this._buffers.length === 0) {
        this._end();
      }
      else {
        this._buffers.push(null);
        this._process();
      }
    };
    
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    
    ChunkStream.prototype._end = function() {
    
      if (this._reads.length > 0) {
        this.emit('error',
          new Error('There are some read requests waitng on finished stream')
        );
      }
    
      this.destroy();
    };
    
    ChunkStream.prototype.destroy = function() {
    
      if (!this._buffers) {
        return;
      }
    
      this.writable = false;
      this._reads = null;
      this._buffers = null;
    
      this.emit('close');
    };
    
    ChunkStream.prototype._processReadAllowingLess = function(read) {
      // ok there is any data so that we can satisfy this request
      this._reads.shift(); // == read
    
      // first we need to peek into first buffer
      var smallerBuf = this._buffers[0];
    
      // ok there is more data than we need
      if (smallerBuf.length > read.length) {
    
        this._buffered -= read.length;
        this._buffers[0] = smallerBuf.slice(read.length);
    
        read.func.call(this, smallerBuf.slice(0, read.length));
    
      }
      else {
        // ok this is less than maximum length so use it all
        this._buffered -= smallerBuf.length;
        this._buffers.shift(); // == smallerBuf
    
        read.func.call(this, smallerBuf);
      }
    };
    
    ChunkStream.prototype._processRead = function(read) {
      this._reads.shift(); // == read
    
      var pos = 0;
      var count = 0;
      var data = new Buffer(read.length);
    
      // create buffer for all data
      while (pos < read.length) {
    
        var buf = this._buffers[count++];
        var len = Math.min(buf.length, read.length - pos);
    
        buf.copy(data, pos, 0, len);
        pos += len;
    
        // last buffer wasn't used all so just slice it and leave
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
    
      // remove all used buffers
      if (count > 0) {
        this._buffers.splice(0, count);
      }
    
      this._buffered -= read.length;
    
      read.func.call(this, data);
    };
    
    ChunkStream.prototype._process = function() {
    
      try {
        // as long as there is any data and read requests
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
    
          var read = this._reads[0];
    
          // read any data (but no more than length)
          if (read.allowLess) {
            this._processReadAllowingLess(read);
    
          }
          else if (this._buffered >= read.length) {
            // ok we can meet some expectations
    
            this._processRead(read);
          }
          else {
            // not enought data to satisfy first request in queue
            // so we need to wait for more
            break;
          }
        }
    
        if (this._buffers && this._buffers.length > 0 && this._buffers[0] === null) {
          this._end();
        }
      }
      catch (ex) {
        this.emit('error', ex);
      }
    };
    
  provide("pngjs2/lib/chunkstream", module.exports);
}(global));

// pakmanager:pngjs2/lib/filter-parse-sync
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var SyncReader =  require('pngjs2/lib/sync-reader');
    var Filter =  require('pngjs2/lib/filter-parse');
    
    
    exports.process = function(inBuffer, bitmapInfo) {
    
      var outBuffers = [];
      var reader = new SyncReader(inBuffer);
      var filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
    
      filter.start();
      reader.process();
    
      return Buffer.concat(outBuffers);
    };
  provide("pngjs2/lib/filter-parse-sync", module.exports);
}(global));

// pakmanager:pngjs2/lib/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var constants =  require('pngjs2/lib/constants');
    var CrcCalculator =  require('pngjs2/lib/crc');
    
    
    var Parser = module.exports = function(options, dependencies) {
    
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
    
      this._hasIHDR = false;
      this._hasIEND = false;
    
      // input flags/metadata
      this._palette = [];
      this._colorType = 0;
    
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
    
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
    };
    
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length,
        this._parseSignature.bind(this)
      );
    };
    
    Parser.prototype._parseSignature = function(data) {
    
      var signature = constants.PNG_SIGNATURE;
    
      for (var i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error('Invalid file signature'));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    
    Parser.prototype._parseChunkBegin = function(data) {
    
      // chunk content length
      var length = data.readUInt32BE(0);
    
      // chunk type
      var type = data.readUInt32BE(4);
      var name = '';
      for (var i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }
    
      //console.log('chunk ', name, length);
    
      // chunk flags
      var ancillary = Boolean(data[4] & 0x20); // or critical
    //    priv = Boolean(data[5] & 0x20), // or public
    //    safeToCopy = Boolean(data[7] & 0x20); // or unsafe
    
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error('Expected IHDR on beggining'));
        return;
      }
    
      this._crc = new CrcCalculator();
      this._crc.write(new Buffer(name));
    
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
    
      if (!ancillary) {
        this.error(new Error('Unsupported critical chunk type ' + name));
        return;
      }
    
      this.read(length + 4, this._skipChunk.bind(this));
    };
    
    Parser.prototype._skipChunk = function(/*data*/) {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    
    Parser.prototype._parseChunkEnd = function(data) {
    
      var fileCrc = data.readInt32BE(0);
      var calcCrc = this._crc.crc32();
    
      // check CRC
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error('Crc error - ' + fileCrc + ' - ' + calcCrc));
        return;
      }
    
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
    
      this._crc.write(data);
    
      var width = data.readUInt32BE(0);
      var height = data.readUInt32BE(4);
      var depth = data[8];
      var colorType = data[9]; // bits: 1 palette, 2 color, 4 alpha
      var compr = data[10];
      var filter = data[11];
      var interlace = data[12];
    
      // console.log('    width', width, 'height', height,
      //     'depth', depth, 'colorType', colorType,
      //     'compr', compr, 'filter', filter, 'interlace', interlace
      // );
    
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error('Unsupported bit depth ' + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error('Unsupported color type'));
        return;
      }
      if (compr !== 0) {
        this.error(new Error('Unsupported compression method'));
        return;
      }
      if (filter !== 0) {
        this.error(new Error('Unsupported filter method'));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error('Unsupported interlace method'));
        return;
      }
    
      this._colorType = colorType;
    
      var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
    
      this._hasIHDR = true;
    
      this.metadata({
        width: width,
        height: height,
        depth: depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp: bpp,
        colorType: colorType
      });
    
      this._handleChunkEnd();
    };
    
    
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
    
      this._crc.write(data);
    
      var entries = Math.floor(data.length / 3);
      // console.log('Palette:', entries);
    
      for (var i = 0; i < entries; i++) {
        this._palette.push([
          data[i * 3],
          data[i * 3 + 1],
          data[i * 3 + 2],
          0xff
        ]);
      }
    
      this.palette(this._palette);
    
      this._handleChunkEnd();
    };
    
    Parser.prototype._handleTRNS = function(length) {
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
    
      this._crc.write(data);
    
      // palette
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error('Transparency chunk must be after palette'));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error('More transparent colors than palette size'));
          return;
        }
        for (var i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }
    
      // for colorType 0 (grayscale) and 2 (rgb)
      // there might be one gray/color defined as transparent
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        // grey, 2 bytes
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
      }
    
      this._handleChunkEnd();
    };
    
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
    
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
    
      this._handleChunkEnd();
    };
    
    Parser.prototype._handleIDAT = function(length) {
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
    
      this._crc.write(data);
    
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error('Expected palette not found');
      }
    
      this.inflateData(data);
      var leftOverLength = length - data.length;
    
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      }
      else {
        this._handleChunkEnd();
      }
    };
    
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
    
      this._crc.write(data);
    
      this._hasIEND = true;
      this._handleChunkEnd();
    
      if (this.finished) {
        this.finished();
      }
    };
    
  provide("pngjs2/lib/parser", module.exports);
}(global));

// pakmanager:pngjs2/lib/bitmapper
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var interlaceUtils =  require('pngjs2/lib/interlace');
    
    var pixelBppMap = {
      1: { // L
        0: 0,
        1: 0,
        2: 0,
        3: 0xff
      },
      2: { // LA
        0: 0,
        1: 0,
        2: 0,
        3: 1
      },
      3: { // RGB
        0: 0,
        1: 1,
        2: 2,
        3: 0xff
      },
      4: { // RGBA
        0: 0,
        1: 1,
        2: 2,
        3: 3
      }
    };
    
    function bitRetriever(data, depth) {
    
      var leftOver = [];
      var i = 0;
    
      function split() {
        if (i === data.length) {
          throw new Error('Ran out of data');
        }
        var byte = data[i];
        i++;
        var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error('unrecognised depth');
          case 16:
            byte2 = data[i];
            i++;
            leftOver.push(((byte << 8) + byte2));
            break;
          case 4:
            byte2 = byte & 0x0f;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
    
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          var returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i !== data.length) {
            throw new Error('extra data found');
          }
        }
      };
    }
    
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) { // eslint-disable-line max-params
      var imageWidth = image.width;
      var imageHeight = image.height;
      var imagePass = image.index;
      for (var y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
          var pxPos = getPxPos(x, y, imagePass);
    
          for (var i = 0; i < 4; i++) {
            var idx = pixelBppMap[bpp][i];
            if (i === data.length) {
              throw new Error('Ran out of data');
            }
            pxData[pxPos + i] = idx !== 0xff ? data[idx + rawPos] : 0xff;
          }
          rawPos += bpp; //eslint-disable-line no-param-reassign
        }
      }
      return rawPos;
    }
    
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) { // eslint-disable-line max-params
      var imageWidth = image.width;
      var imageHeight = image.height;
      var imagePass = image.index;
      for (var y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
          var pixelData = bits.get(bpp);
          var pxPos = getPxPos(x, y, imagePass);
    
          for (var i = 0; i < 4; i++) {
            var idx = pixelBppMap[bpp][i];
            pxData[pxPos + i] = idx !== 0xff ? pixelData[idx] : maxBit;
          }
        }
        bits.resetAfterLine();
      }
    }
    
    exports.dataToBitMap = function(data, bitmapInfo) {
    
      var width = bitmapInfo.width;
      var height = bitmapInfo.height;
      var depth = bitmapInfo.depth;
      var bpp = bitmapInfo.bpp;
      var interlace = bitmapInfo.interlace;
    
      if (depth !== 8) {
        var bits = bitRetriever(data, depth);
      }
      var pxData;
      if (depth <= 8) {
        pxData = new Buffer(width * height * 4);
      }
      else {
        pxData = new Uint16Array(width * height * 4);
      }
      var maxBit = Math.pow(2, depth) - 1;
      var rawPos = 0;
      var images;
      var getPxPos;
    
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      }
      else {
        var nonInterlacedPxPos = 0;
        getPxPos = function() {
          var returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width: width, height: height }];
      }
    
      for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        }
        else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error('extra data found');
        }
      }
      else {
        bits.end();
      }
    
      return pxData;
    };
    
  provide("pngjs2/lib/bitmapper", module.exports);
}(global));

// pakmanager:pngjs2/lib/format-normaliser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function dePalette(indata, outdata, width, height, palette) {
      var pxPos = 0;
      // use values from palette
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var color = palette[indata[pxPos]];
    
          if (!color) {
            throw new Error('index ' + indata[pxPos] + ' not in palette');
          }
    
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = color[i];
          }
          pxPos += 4;
        }
      }
    }
    
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var makeTrans = false;
    
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          }
          else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (var i = 0; i < 4; i++) {
              outdata[pxPos + i] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    
    function scaleDepth(indata, outdata, width, height, depth) {
      var maxOutSample = 255;
      var maxInSample = Math.pow(2, depth) - 1;
      var pxPos = 0;
    
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = Math.floor((indata[pxPos + i] * maxOutSample) / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    
    module.exports = function(indata, imageData) {
    
      var depth = imageData.depth;
      var width = imageData.width;
      var height = imageData.height;
      var colorType = imageData.colorType;
      var transColor = imageData.transColor;
      var palette = imageData.palette;
    
      var outdata = indata; // only different for 16 bits
    
      if (colorType === 3) { // paletted
        dePalette(indata, outdata, width, height, palette);
      }
      else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        // if it needs scaling
        if (depth !== 8) {
          // if we need to change the buffer size
          if (depth === 16) {
            outdata = new Buffer(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
    
  provide("pngjs2/lib/format-normaliser", module.exports);
}(global));

// pakmanager:pngjs2/lib/filter-parse-async
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var util = require('util');
    var ChunkStream =  require('pngjs2/lib/chunkstream');
    var Filter =  require('pngjs2/lib/filter-parse');
    
    
    var FilterAsync = module.exports = function(bitmapInfo) {
      ChunkStream.call(this);
    
      var buffers = [];
      var that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit('complete', Buffer.concat(buffers));
        }
      });
    
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
    
  provide("pngjs2/lib/filter-parse-async", module.exports);
}(global));

// pakmanager:pngjs2/lib/filter-pack
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var paethPredictor =  require('pngjs2/lib/paeth-predictor');
    
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      pxData.copy(rawData, rawPos, pxPos, pxPos + byteWidth);
    }
    
    function filterSumNone(pxData, pxPos, byteWidth) {
    
      var sum = 0;
      var length = pxPos + byteWidth;
    
      for (var i = pxPos; i < length; i++) {
        sum += Math.abs(pxData[i]);
      }
      return sum;
    }
    
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    
      for (var x = 0; x < byteWidth; x++) {
    
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var val = pxData[pxPos + x] - left;
    
        rawData[rawPos + x] = val;
      }
    }
    
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
    
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
    
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var val = pxData[pxPos + x] - left;
    
        sum += Math.abs(val);
      }
    
      return sum;
    }
    
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
    
      for (var x = 0; x < byteWidth; x++) {
    
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - up;
    
        rawData[rawPos + x] = val;
      }
    }
    
    function filterSumUp(pxData, pxPos, byteWidth) {
    
      var sum = 0;
      var length = pxPos + byteWidth;
      for (var x = pxPos; x < length; x++) {
    
        var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        var val = pxData[x] - up;
    
        sum += Math.abs(val);
      }
    
      return sum;
    }
    
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    
      for (var x = 0; x < byteWidth; x++) {
    
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - ((left + up) >> 1);
    
        rawData[rawPos + x] = val;
      }
    }
    
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
    
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
    
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - ((left + up) >> 1);
    
        sum += Math.abs(val);
      }
    
      return sum;
    }
    
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    
      for (var x = 0; x < byteWidth; x++) {
    
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
    
        rawData[rawPos + x] = val;
      }
    }
    
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
    
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
    
        sum += Math.abs(val);
      }
    
      return sum;
    }
    
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    
    module.exports = function(pxData, width, height, options, bpp) {
    
      var filterTypes;
      if (!('filterType' in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      }
      else if (typeof options.filterType === 'number') {
        filterTypes = [options.filterType];
      }
      else {
        throw new Error('unrecognised filter types');
      }
    
      var byteWidth = width * bpp;
      var rawPos = 0;
      var pxPos = 0;
      var rawData = new Buffer((byteWidth + 1) * height);
      var sel = filterTypes[0];
    
      for (var y = 0; y < height; y++) {
    
        if (filterTypes.length > 1) {
          // find best filter for this line (with lowest sum of values)
          var min = Infinity;
    
          for (var i = 0; i < filterTypes.length; i++) {
            var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i];
              min = sum;
            }
          }
        }
    
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
    
  provide("pngjs2/lib/filter-pack", module.exports);
}(global));

// pakmanager:pngjs2/lib/bitpacker
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var constants =  require('pngjs2/lib/constants');
    
    module.exports = function(data, width, height, options) {
      var outHasAlpha = options.colorType === constants.COLORTYPE_COLOR_ALPHA;
      if (options.inputHasAlpha && outHasAlpha) {
        return data;
      }
      if (!options.inputHasAlpha && !outHasAlpha) {
        return data;
      }
    
      var outBpp = outHasAlpha ? 4 : 3;
      var outData = new Buffer(width * height * outBpp);
      var inBpp = options.inputHasAlpha ? 4 : 3;
      var inIndex = 0;
      var outIndex = 0;
    
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var red = data[inIndex];
          var green = data[inIndex + 1];
          var blue = data[inIndex + 2];
    
          var alpha;
          if (options.inputHasAlpha) {
            alpha = data[inIndex + 3];
          }
          else {
            alpha = 255;
          }
    
          outData[outIndex] = red;
          outData[outIndex + 1] = green;
          outData[outIndex + 2] = blue;
          if (outHasAlpha) {
            outData[outIndex + 3] = alpha;
          }
    
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
    
      return outData;
    };
  provide("pngjs2/lib/bitpacker", module.exports);
}(global));

// pakmanager:pngjs2/lib/parser-sync
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    
    var zlib = require('zlib');
    var SyncReader =  require('pngjs2/lib/sync-reader');
    var FilterSync =  require('pngjs2/lib/filter-parse-sync');
    var Parser =  require('pngjs2/lib/parser');
    var bitmapper =  require('pngjs2/lib/bitmapper');
    var formatNormaliser =  require('pngjs2/lib/format-normaliser');
    
    
    module.exports = function(buffer, options) {
    
      var err;
      function handleError(_err_) {
        err = _err_;
      }
    
      var metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
    
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
    
      function handlePalette(palette) {
        metaData.palette = palette;
      }
    
      var gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
    
      var inflateDataList = [];
      function handleInflateData(inflatedData) {
        inflateDataList.push(inflatedData);
      }
    
      var reader = new SyncReader(buffer);
    
      var parser = new Parser(options, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData
      });
    
      parser.start();
      reader.process();
    
      if (err) {
        throw err;
      }
    
      //join together the inflate datas
      var inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
    
      var inflatedData = zlib.inflateSync(inflateData);
      inflateData = null;
    
      if (!inflatedData || !inflatedData.length) {
        throw new Error('bad png - invalid inflate data response');
      }
    
      var unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
    
      var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
    
      var normalisedBitmapData = formatNormaliser(bitmapData, metaData);
    
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
    
      return metaData;
    };
    
    
  provide("pngjs2/lib/parser-sync", module.exports);
}(global));

// pakmanager:pngjs2/lib/parser-async
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var util = require('util');
    var zlib = require('zlib');
    var ChunkStream =  require('pngjs2/lib/chunkstream');
    var FilterAsync =  require('pngjs2/lib/filter-parse-async');
    var Parser =  require('pngjs2/lib/parser');
    var bitmapper =  require('pngjs2/lib/bitmapper');
    var formatNormaliser =  require('pngjs2/lib/format-normaliser');
    
    var ParserAsync = module.exports = function(options) {
      ChunkStream.call(this);
    
      this._parser = new Parser(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, 'gamma'),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this)
      });
      this._options = options;
      this.writable = true;
    
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    
    
    ParserAsync.prototype._handleError = function(err) {
    
      this.emit('error', err);
    
      this.writable = false;
    
      this.destroy();
    
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
    
      this.errord = true;
    };
    
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        this._inflate = zlib.createInflate();
    
        this._inflate.on('error', this.emit.bind(this, 'error'));
        this._filter.on('complete', this._complete.bind(this));
    
        this._inflate.pipe(this._filter);
      }
      this._inflate.write(data);
    };
    
    ParserAsync.prototype._handleMetaData = function(metaData) {
    
      this.emit('metadata', metaData);
    
      this._bitmapInfo = Object.create(metaData);
    
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    
    
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
    
      if (!this._inflate) {
        this.emit('error', 'No Inflate block');
      }
      else {
        // no more data to inflate
        this._inflate.end();
      }
      this.destroySoon();
    };
    
    ParserAsync.prototype._complete = function(filteredData) {
    
      if (this.errord) {
        return;
      }
    
      try {
        var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
    
        var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      }
      catch (ex) {
        this._handleError(ex);
        return;
      }
    
      this.emit('parsed', normalisedBitmapData);
    };
    
  provide("pngjs2/lib/parser-async", module.exports);
}(global));

// pakmanager:pngjs2/lib/packer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var util = require('util');
    var Stream = require('stream');
    var zlib = require('zlib');
    var filter =  require('pngjs2/lib/filter-pack');
    var CrcStream =  require('pngjs2/lib/crc');
    var constants =  require('pngjs2/lib/constants');
    var bitPacker =  require('pngjs2/lib/bitpacker');
    
    var Packer = module.exports = function(options) {
      Stream.call(this);
    
      this._options = options;
    
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = (typeof options.colorType === 'number') ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
    
      if (options.colorType !== constants.COLORTYPE_COLOR && options.colorType !== constants.COLORTYPE_COLOR_ALPHA) {
        throw new Error('option color type:' + options.colorType + ' is not supported at present');
      }
      if (options.bitDepth !== 8) {
        throw new Error('option bit depth:' + options.bitDepth + ' is not supported at present');
      }
    
      this.readable = true;
    };
    util.inherits(Packer, Stream);
    
    
    Packer.prototype.pack = function(data, width, height, gamma) {
      // Signature
      this.emit('data', new Buffer(constants.PNG_SIGNATURE));
      this.emit('data', this._packIHDR(width, height, this._options.bitDepth, this._options.colorType));
    
      if (gamma) {
        this.emit('data', this._packGAMA(gamma));
      }
    
      // convert to correct format for filtering (e.g. right bpp and bit depth)
      var packedData = bitPacker(data, width, height, this._options);
    
      // filter pixel data
      var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      var filteredData = filter(packedData, width, height, this._options, bpp);
    
      // compress it
      var deflate = this._options.deflateFactory({
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      });
      deflate.on('error', this.emit.bind(this, 'error'));
    
      deflate.on('data', function(compressedData) {
        this.emit('data', this._packIDAT(compressedData));
      }.bind(this));
    
      deflate.on('end', function() {
        this.emit('data', this._packIEND());
        this.emit('end');
      }.bind(this));
    
      deflate.end(filteredData);
    };
    
    Packer.prototype._packChunk = function(type, data) {
    
      var len = (data ? data.length : 0);
      var buf = new Buffer(len + 12);
    
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
    
      if (data) {
        data.copy(buf, 8);
      }
    
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    
    Packer.prototype._packGAMA = function(gamma) {
      var buf = new Buffer(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    
    Packer.prototype._packIHDR = function(width, height, bitDepth, colorType) {
    
      var buf = new Buffer(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = bitDepth;  // Bit depth
      buf[9] = colorType; // colorType
      buf[10] = 0; // compression
      buf[11] = 0; // filter
      buf[12] = 0; // interlace
    
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    
    Packer.prototype._packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    
    Packer.prototype._packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
    
  provide("pngjs2/lib/packer", module.exports);
}(global));

// pakmanager:pngjs2/lib/png-sync
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    
    var parse =  require('pngjs2/lib/parser-sync');
    
    
    exports.read = function(buffer, options) {
    
      return parse(buffer, options || {});
    };
    
  provide("pngjs2/lib/png-sync", module.exports);
}(global));

// pakmanager:pngjs2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var util = require('util');
    var Stream = require('stream');
    var Parser =  require('pngjs2/lib/parser-async');
    var Packer =  require('pngjs2/lib/packer');
    var PNGSync =  require('pngjs2/lib/png-sync');
    
    
    var PNG = exports.PNG = function(options) {
      Stream.call(this);
    
      options = options || {}; // eslint-disable-line no-param-reassign
    
      this.width = options.width || 0;
      this.height = options.height || 0;
    
      this.data = this.width > 0 && this.height > 0 ?
        new Buffer(4 * this.width * this.height) : null;
    
      if (options.fill && this.data) {
        this.data.fill(0);
      }
    
      this.gamma = 0;
      this.readable = this.writable = true;
    
      this._parser = new Parser(options);
    
      this._parser.on('error', this.emit.bind(this, 'error'));
      this._parser.on('close', this._handleClose.bind(this));
      this._parser.on('metadata', this._metadata.bind(this));
      this._parser.on('gamma', this._gamma.bind(this));
      this._parser.on('parsed', function(data) {
        this.data = data;
        this.emit('parsed', data);
      }.bind(this));
    
      this._packer = new Packer(options);
      this._packer.on('data', this.emit.bind(this, 'data'));
      this._packer.on('end', this.emit.bind(this, 'end'));
      this._parser.on('close', this._handleClose.bind(this));
      this._packer.on('error', this.emit.bind(this, 'error'));
    
    };
    util.inherits(PNG, Stream);
    
    PNG.sync = PNGSync;
    
    PNG.prototype.pack = function() {
    
      if (!this.data || !this.data.length) {
        this.emit('error', 'No data provided');
        return this;
      }
    
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
    
      return this;
    };
    
    
    PNG.prototype.parse = function(data, callback) {
    
      if (callback) {
        var onParsed, onError;
    
        onParsed = function(parsedData) {
          this.removeListener('error', onError);
    
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
    
        onError = function(err) {
          this.removeListener('parsed', onParsed);
    
          callback(err, null);
        }.bind(this);
    
        this.once('parsed', onParsed);
        this.once('error', onError);
      }
    
      this.end(data);
      return this;
    };
    
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
    
      this.emit('metadata', metadata);
    };
    
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit('close');
      }
    };
    
    
    PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) { // eslint-disable-line max-params
    
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error('bitblt reading outside image');
      }
    
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error('bitblt writing outside image');
      }
    
      for (var y = 0; y < height; y++) {
        src.data.copy(dst.data,
          ((deltaY + y) * dst.width + deltaX) << 2,
          ((srcY + y) * src.width + srcX) << 2,
          ((srcY + y) * src.width + srcX + width) << 2
        );
      }
    };
    
    
    PNG.prototype.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) { // eslint-disable-line max-params
    
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    
    PNG.adjustGamma = function(src) {
      if (src.gamma) {
        for (var y = 0; y < src.height; y++) {
          for (var x = 0; x < src.width; x++) {
            var idx = (src.width * y + x) << 2;
    
            for (var i = 0; i < 3; i++) {
              var sample = src.data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
    
  provide("pngjs2", module.exports);
}(global));

// pakmanager:ndarray-pack/doConvert.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports=require('cwise-compiler')({"args":["array","scalar","index"],"pre":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"body":{"body":"{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}","args":[{"name":"_inline_1_arg0_","lvalue":true,"rvalue":false,"count":1},{"name":"_inline_1_arg1_","lvalue":false,"rvalue":true,"count":1},{"name":"_inline_1_arg2_","lvalue":false,"rvalue":true,"count":4}],"thisVars":[],"localVars":["_inline_1_i","_inline_1_v"]},"post":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"funcName":"convert","blockSize":64})
    
  provide("ndarray-pack/doConvert.js", module.exports);
}(global));

// pakmanager:ndarray-pack
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    var ndarray = require("ndarray")
    var do_convert =  require('ndarray-pack/doConvert.js')
    
    module.exports = function convert(arr, result) {
      var shape = [], c = arr, sz = 1
      while(c instanceof Array) {
        shape.push(c.length)
        sz *= c.length
        c = c[0]
      }
      if(shape.length === 0) {
        return ndarray()
      }
      if(!result) {
        result = ndarray(new Float64Array(sz), shape)
      }
      do_convert(result, arr)
      return result
    }
    
  provide("ndarray-pack", module.exports);
}(global));

// pakmanager:jpeg-js/lib/encoder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      Copyright (c) 2008, Adobe Systems Incorporated
      All rights reserved.
    
      Redistribution and use in source and binary forms, with or without 
      modification, are permitted provided that the following conditions are
      met:
    
      * Redistributions of source code must retain the above copyright notice, 
        this list of conditions and the following disclaimer.
      
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the 
        documentation and/or other materials provided with the distribution.
      
      * Neither the name of Adobe Systems Incorporated nor the names of its 
        contributors may be used to endorse or promote products derived from 
        this software without specific prior written permission.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
      IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
      THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
      PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
      CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
      EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
      PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
      PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
      LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
      SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    /*
    JPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009
    
    Basic GUI blocking jpeg encoder
    */
    
    var btoa = btoa || function(buf) {
      return new Buffer(buf).toString('base64');
    };
    
    function JPEGEncoder(quality) {
      var self = this;
    	var fround = Math.round;
    	var ffloor = Math.floor;
    	var YTable = new Array(64);
    	var UVTable = new Array(64);
    	var fdtbl_Y = new Array(64);
    	var fdtbl_UV = new Array(64);
    	var YDC_HT;
    	var UVDC_HT;
    	var YAC_HT;
    	var UVAC_HT;
    	
    	var bitcode = new Array(65535);
    	var category = new Array(65535);
    	var outputfDCTQuant = new Array(64);
    	var DU = new Array(64);
    	var byteout = [];
    	var bytenew = 0;
    	var bytepos = 7;
    	
    	var YDU = new Array(64);
    	var UDU = new Array(64);
    	var VDU = new Array(64);
    	var clt = new Array(256);
    	var RGB_YUV_TABLE = new Array(2048);
    	var currentQuality;
    	
    	var ZigZag = [
    			 0, 1, 5, 6,14,15,27,28,
    			 2, 4, 7,13,16,26,29,42,
    			 3, 8,12,17,25,30,41,43,
    			 9,11,18,24,31,40,44,53,
    			10,19,23,32,39,45,52,54,
    			20,22,33,38,46,51,55,60,
    			21,34,37,47,50,56,59,61,
    			35,36,48,49,57,58,62,63
    		];
    	
    	var std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];
    	var std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
    	var std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];
    	var std_ac_luminance_values = [
    			0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,
    			0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
    			0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
    			0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
    			0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,
    			0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
    			0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,
    			0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
    			0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
    			0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
    			0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
    			0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
    			0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
    			0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
    			0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
    			0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
    			0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,
    			0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
    			0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,
    			0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
    			0xf9,0xfa
    		];
    	
    	var std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];
    	var std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
    	var std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];
    	var std_ac_chrominance_values = [
    			0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,
    			0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
    			0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
    			0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
    			0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,
    			0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
    			0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,
    			0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
    			0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
    			0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
    			0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,
    			0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
    			0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,
    			0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
    			0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
    			0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
    			0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,
    			0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
    			0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,
    			0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
    			0xf9,0xfa
    		];
    	
    	function initQuantTables(sf){
    			var YQT = [
    				16, 11, 10, 16, 24, 40, 51, 61,
    				12, 12, 14, 19, 26, 58, 60, 55,
    				14, 13, 16, 24, 40, 57, 69, 56,
    				14, 17, 22, 29, 51, 87, 80, 62,
    				18, 22, 37, 56, 68,109,103, 77,
    				24, 35, 55, 64, 81,104,113, 92,
    				49, 64, 78, 87,103,121,120,101,
    				72, 92, 95, 98,112,100,103, 99
    			];
    			
    			for (var i = 0; i < 64; i++) {
    				var t = ffloor((YQT[i]*sf+50)/100);
    				if (t < 1) {
    					t = 1;
    				} else if (t > 255) {
    					t = 255;
    				}
    				YTable[ZigZag[i]] = t;
    			}
    			var UVQT = [
    				17, 18, 24, 47, 99, 99, 99, 99,
    				18, 21, 26, 66, 99, 99, 99, 99,
    				24, 26, 56, 99, 99, 99, 99, 99,
    				47, 66, 99, 99, 99, 99, 99, 99,
    				99, 99, 99, 99, 99, 99, 99, 99,
    				99, 99, 99, 99, 99, 99, 99, 99,
    				99, 99, 99, 99, 99, 99, 99, 99,
    				99, 99, 99, 99, 99, 99, 99, 99
    			];
    			for (var j = 0; j < 64; j++) {
    				var u = ffloor((UVQT[j]*sf+50)/100);
    				if (u < 1) {
    					u = 1;
    				} else if (u > 255) {
    					u = 255;
    				}
    				UVTable[ZigZag[j]] = u;
    			}
    			var aasf = [
    				1.0, 1.387039845, 1.306562965, 1.175875602,
    				1.0, 0.785694958, 0.541196100, 0.275899379
    			];
    			var k = 0;
    			for (var row = 0; row < 8; row++)
    			{
    				for (var col = 0; col < 8; col++)
    				{
    					fdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
    					fdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
    					k++;
    				}
    			}
    		}
    		
    		function computeHuffmanTbl(nrcodes, std_table){
    			var codevalue = 0;
    			var pos_in_table = 0;
    			var HT = new Array();
    			for (var k = 1; k <= 16; k++) {
    				for (var j = 1; j <= nrcodes[k]; j++) {
    					HT[std_table[pos_in_table]] = [];
    					HT[std_table[pos_in_table]][0] = codevalue;
    					HT[std_table[pos_in_table]][1] = k;
    					pos_in_table++;
    					codevalue++;
    				}
    				codevalue*=2;
    			}
    			return HT;
    		}
    		
    		function initHuffmanTbl()
    		{
    			YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);
    			UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);
    			YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);
    			UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);
    		}
    	
    		function initCategoryNumber()
    		{
    			var nrlower = 1;
    			var nrupper = 2;
    			for (var cat = 1; cat <= 15; cat++) {
    				//Positive numbers
    				for (var nr = nrlower; nr<nrupper; nr++) {
    					category[32767+nr] = cat;
    					bitcode[32767+nr] = [];
    					bitcode[32767+nr][1] = cat;
    					bitcode[32767+nr][0] = nr;
    				}
    				//Negative numbers
    				for (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {
    					category[32767+nrneg] = cat;
    					bitcode[32767+nrneg] = [];
    					bitcode[32767+nrneg][1] = cat;
    					bitcode[32767+nrneg][0] = nrupper-1+nrneg;
    				}
    				nrlower <<= 1;
    				nrupper <<= 1;
    			}
    		}
    		
    		function initRGBYUVTable() {
    			for(var i = 0; i < 256;i++) {
    				RGB_YUV_TABLE[i]      		=  19595 * i;
    				RGB_YUV_TABLE[(i+ 256)>>0] 	=  38470 * i;
    				RGB_YUV_TABLE[(i+ 512)>>0] 	=   7471 * i + 0x8000;
    				RGB_YUV_TABLE[(i+ 768)>>0] 	= -11059 * i;
    				RGB_YUV_TABLE[(i+1024)>>0] 	= -21709 * i;
    				RGB_YUV_TABLE[(i+1280)>>0] 	=  32768 * i + 0x807FFF;
    				RGB_YUV_TABLE[(i+1536)>>0] 	= -27439 * i;
    				RGB_YUV_TABLE[(i+1792)>>0] 	= - 5329 * i;
    			}
    		}
    		
    		// IO functions
    		function writeBits(bs)
    		{
    			var value = bs[0];
    			var posval = bs[1]-1;
    			while ( posval >= 0 ) {
    				if (value & (1 << posval) ) {
    					bytenew |= (1 << bytepos);
    				}
    				posval--;
    				bytepos--;
    				if (bytepos < 0) {
    					if (bytenew == 0xFF) {
    						writeByte(0xFF);
    						writeByte(0);
    					}
    					else {
    						writeByte(bytenew);
    					}
    					bytepos=7;
    					bytenew=0;
    				}
    			}
    		}
    	
    		function writeByte(value)
    		{
    			//byteout.push(clt[value]); // write char directly instead of converting later
          byteout.push(value);
    		}
    	
    		function writeWord(value)
    		{
    			writeByte((value>>8)&0xFF);
    			writeByte((value   )&0xFF);
    		}
    		
    		// DCT & quantization core
    		function fDCTQuant(data, fdtbl)
    		{
    			var d0, d1, d2, d3, d4, d5, d6, d7;
    			/* Pass 1: process rows. */
    			var dataOff=0;
    			var i;
    			const I8 = 8;
    			const I64 = 64;
    			for (i=0; i<I8; ++i)
    			{
    				d0 = data[dataOff];
    				d1 = data[dataOff+1];
    				d2 = data[dataOff+2];
    				d3 = data[dataOff+3];
    				d4 = data[dataOff+4];
    				d5 = data[dataOff+5];
    				d6 = data[dataOff+6];
    				d7 = data[dataOff+7];
    				
    				var tmp0 = d0 + d7;
    				var tmp7 = d0 - d7;
    				var tmp1 = d1 + d6;
    				var tmp6 = d1 - d6;
    				var tmp2 = d2 + d5;
    				var tmp5 = d2 - d5;
    				var tmp3 = d3 + d4;
    				var tmp4 = d3 - d4;
    	
    				/* Even part */
    				var tmp10 = tmp0 + tmp3;	/* phase 2 */
    				var tmp13 = tmp0 - tmp3;
    				var tmp11 = tmp1 + tmp2;
    				var tmp12 = tmp1 - tmp2;
    	
    				data[dataOff] = tmp10 + tmp11; /* phase 3 */
    				data[dataOff+4] = tmp10 - tmp11;
    	
    				var z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */
    				data[dataOff+2] = tmp13 + z1; /* phase 5 */
    				data[dataOff+6] = tmp13 - z1;
    	
    				/* Odd part */
    				tmp10 = tmp4 + tmp5; /* phase 2 */
    				tmp11 = tmp5 + tmp6;
    				tmp12 = tmp6 + tmp7;
    	
    				/* The rotator is modified from fig 4-8 to avoid extra negations. */
    				var z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */
    				var z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */
    				var z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */
    				var z3 = tmp11 * 0.707106781; /* c4 */
    	
    				var z11 = tmp7 + z3;	/* phase 5 */
    				var z13 = tmp7 - z3;
    	
    				data[dataOff+5] = z13 + z2;	/* phase 6 */
    				data[dataOff+3] = z13 - z2;
    				data[dataOff+1] = z11 + z4;
    				data[dataOff+7] = z11 - z4;
    	
    				dataOff += 8; /* advance pointer to next row */
    			}
    	
    			/* Pass 2: process columns. */
    			dataOff = 0;
    			for (i=0; i<I8; ++i)
    			{
    				d0 = data[dataOff];
    				d1 = data[dataOff + 8];
    				d2 = data[dataOff + 16];
    				d3 = data[dataOff + 24];
    				d4 = data[dataOff + 32];
    				d5 = data[dataOff + 40];
    				d6 = data[dataOff + 48];
    				d7 = data[dataOff + 56];
    				
    				var tmp0p2 = d0 + d7;
    				var tmp7p2 = d0 - d7;
    				var tmp1p2 = d1 + d6;
    				var tmp6p2 = d1 - d6;
    				var tmp2p2 = d2 + d5;
    				var tmp5p2 = d2 - d5;
    				var tmp3p2 = d3 + d4;
    				var tmp4p2 = d3 - d4;
    	
    				/* Even part */
    				var tmp10p2 = tmp0p2 + tmp3p2;	/* phase 2 */
    				var tmp13p2 = tmp0p2 - tmp3p2;
    				var tmp11p2 = tmp1p2 + tmp2p2;
    				var tmp12p2 = tmp1p2 - tmp2p2;
    	
    				data[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */
    				data[dataOff+32] = tmp10p2 - tmp11p2;
    	
    				var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */
    				data[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */
    				data[dataOff+48] = tmp13p2 - z1p2;
    	
    				/* Odd part */
    				tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */
    				tmp11p2 = tmp5p2 + tmp6p2;
    				tmp12p2 = tmp6p2 + tmp7p2;
    	
    				/* The rotator is modified from fig 4-8 to avoid extra negations. */
    				var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */
    				var z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */
    				var z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */
    				var z3p2 = tmp11p2 * 0.707106781; /* c4 */
    	
    				var z11p2 = tmp7p2 + z3p2;	/* phase 5 */
    				var z13p2 = tmp7p2 - z3p2;
    	
    				data[dataOff+40] = z13p2 + z2p2; /* phase 6 */
    				data[dataOff+24] = z13p2 - z2p2;
    				data[dataOff+ 8] = z11p2 + z4p2;
    				data[dataOff+56] = z11p2 - z4p2;
    	
    				dataOff++; /* advance pointer to next column */
    			}
    	
    			// Quantize/descale the coefficients
    			var fDCTQuant;
    			for (i=0; i<I64; ++i)
    			{
    				// Apply the quantization and scaling factor & Round to nearest integer
    				fDCTQuant = data[i]*fdtbl[i];
    				outputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);
    				//outputfDCTQuant[i] = fround(fDCTQuant);
    
    			}
    			return outputfDCTQuant;
    		}
    		
    		function writeAPP0()
    		{
    			writeWord(0xFFE0); // marker
    			writeWord(16); // length
    			writeByte(0x4A); // J
    			writeByte(0x46); // F
    			writeByte(0x49); // I
    			writeByte(0x46); // F
    			writeByte(0); // = "JFIF",'\0'
    			writeByte(1); // versionhi
    			writeByte(1); // versionlo
    			writeByte(0); // xyunits
    			writeWord(1); // xdensity
    			writeWord(1); // ydensity
    			writeByte(0); // thumbnwidth
    			writeByte(0); // thumbnheight
    		}
    	
    		function writeSOF0(width, height)
    		{
    			writeWord(0xFFC0); // marker
    			writeWord(17);   // length, truecolor YUV JPG
    			writeByte(8);    // precision
    			writeWord(height);
    			writeWord(width);
    			writeByte(3);    // nrofcomponents
    			writeByte(1);    // IdY
    			writeByte(0x11); // HVY
    			writeByte(0);    // QTY
    			writeByte(2);    // IdU
    			writeByte(0x11); // HVU
    			writeByte(1);    // QTU
    			writeByte(3);    // IdV
    			writeByte(0x11); // HVV
    			writeByte(1);    // QTV
    		}
    	
    		function writeDQT()
    		{
    			writeWord(0xFFDB); // marker
    			writeWord(132);	   // length
    			writeByte(0);
    			for (var i=0; i<64; i++) {
    				writeByte(YTable[i]);
    			}
    			writeByte(1);
    			for (var j=0; j<64; j++) {
    				writeByte(UVTable[j]);
    			}
    		}
    	
    		function writeDHT()
    		{
    			writeWord(0xFFC4); // marker
    			writeWord(0x01A2); // length
    	
    			writeByte(0); // HTYDCinfo
    			for (var i=0; i<16; i++) {
    				writeByte(std_dc_luminance_nrcodes[i+1]);
    			}
    			for (var j=0; j<=11; j++) {
    				writeByte(std_dc_luminance_values[j]);
    			}
    	
    			writeByte(0x10); // HTYACinfo
    			for (var k=0; k<16; k++) {
    				writeByte(std_ac_luminance_nrcodes[k+1]);
    			}
    			for (var l=0; l<=161; l++) {
    				writeByte(std_ac_luminance_values[l]);
    			}
    	
    			writeByte(1); // HTUDCinfo
    			for (var m=0; m<16; m++) {
    				writeByte(std_dc_chrominance_nrcodes[m+1]);
    			}
    			for (var n=0; n<=11; n++) {
    				writeByte(std_dc_chrominance_values[n]);
    			}
    	
    			writeByte(0x11); // HTUACinfo
    			for (var o=0; o<16; o++) {
    				writeByte(std_ac_chrominance_nrcodes[o+1]);
    			}
    			for (var p=0; p<=161; p++) {
    				writeByte(std_ac_chrominance_values[p]);
    			}
    		}
    	
    		function writeSOS()
    		{
    			writeWord(0xFFDA); // marker
    			writeWord(12); // length
    			writeByte(3); // nrofcomponents
    			writeByte(1); // IdY
    			writeByte(0); // HTY
    			writeByte(2); // IdU
    			writeByte(0x11); // HTU
    			writeByte(3); // IdV
    			writeByte(0x11); // HTV
    			writeByte(0); // Ss
    			writeByte(0x3f); // Se
    			writeByte(0); // Bf
    		}
    		
    		function processDU(CDU, fdtbl, DC, HTDC, HTAC){
    			var EOB = HTAC[0x00];
    			var M16zeroes = HTAC[0xF0];
    			var pos;
    			const I16 = 16;
    			const I63 = 63;
    			const I64 = 64;
    			var DU_DCT = fDCTQuant(CDU, fdtbl);
    			//ZigZag reorder
    			for (var j=0;j<I64;++j) {
    				DU[ZigZag[j]]=DU_DCT[j];
    			}
    			var Diff = DU[0] - DC; DC = DU[0];
    			//Encode DC
    			if (Diff==0) {
    				writeBits(HTDC[0]); // Diff might be 0
    			} else {
    				pos = 32767+Diff;
    				writeBits(HTDC[category[pos]]);
    				writeBits(bitcode[pos]);
    			}
    			//Encode ACs
    			var end0pos = 63; // was const... which is crazy
    			for (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {};
    			//end0pos = first element in reverse order !=0
    			if ( end0pos == 0) {
    				writeBits(EOB);
    				return DC;
    			}
    			var i = 1;
    			var lng;
    			while ( i <= end0pos ) {
    				var startpos = i;
    				for (; (DU[i]==0) && (i<=end0pos); ++i) {}
    				var nrzeroes = i-startpos;
    				if ( nrzeroes >= I16 ) {
    					lng = nrzeroes>>4;
    					for (var nrmarker=1; nrmarker <= lng; ++nrmarker)
    						writeBits(M16zeroes);
    					nrzeroes = nrzeroes&0xF;
    				}
    				pos = 32767+DU[i];
    				writeBits(HTAC[(nrzeroes<<4)+category[pos]]);
    				writeBits(bitcode[pos]);
    				i++;
    			}
    			if ( end0pos != I63 ) {
    				writeBits(EOB);
    			}
    			return DC;
    		}
    
    		function initCharLookupTable(){
    			var sfcc = String.fromCharCode;
    			for(var i=0; i < 256; i++){ ///// ACHTUNG // 255
    				clt[i] = sfcc(i);
    			}
    		}
    		
    		this.encode = function(image,quality) // image data object
    		{
    			var time_start = new Date().getTime();
    			
    			if(quality) setQuality(quality);
    			
    			// Initialize bit writer
    			byteout = new Array();
    			bytenew=0;
    			bytepos=7;
    	
    			// Add JPEG headers
    			writeWord(0xFFD8); // SOI
    			writeAPP0();
    			writeDQT();
    			writeSOF0(image.width,image.height);
    			writeDHT();
    			writeSOS();
    
    	
    			// Encode 8x8 macroblocks
    			var DCY=0;
    			var DCU=0;
    			var DCV=0;
    			
    			bytenew=0;
    			bytepos=7;
    			
    			
    			this.encode.displayName = "_encode_";
    
    			var imageData = image.data;
    			var width = image.width;
    			var height = image.height;
    
    			var quadWidth = width*4;
    			var tripleWidth = width*3;
    			
    			var x, y = 0;
    			var r, g, b;
    			var start,p, col,row,pos;
    			while(y < height){
    				x = 0;
    				while(x < quadWidth){
    				start = quadWidth * y + x;
    				p = start;
    				col = -1;
    				row = 0;
    				
    				for(pos=0; pos < 64; pos++){
    					row = pos >> 3;// /8
    					col = ( pos & 7 ) * 4; // %8
    					p = start + ( row * quadWidth ) + col;		
    					
    					if(y+row >= height){ // padding bottom
    						p-= (quadWidth*(y+1+row-height));
    					}
    
    					if(x+col >= quadWidth){ // padding right	
    						p-= ((x+col) - quadWidth +4)
    					}
    					
    					r = imageData[ p++ ];
    					g = imageData[ p++ ];
    					b = imageData[ p++ ];
    					
    					
    					/* // calculate YUV values dynamically
    					YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80
    					UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));
    					VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));
    					*/
    					
    					// use lookup table (slightly faster)
    					YDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;
    					UDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;
    					VDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;
    
    				}
    				
    				DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
    				DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
    				DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
    				x+=32;
    				}
    				y+=8;
    			}
    			
    			
    			////////////////////////////////////////////////////////////////
    	
    			// Do the bit alignment of the EOI marker
    			if ( bytepos >= 0 ) {
    				var fillbits = [];
    				fillbits[1] = bytepos+1;
    				fillbits[0] = (1<<(bytepos+1))-1;
    				writeBits(fillbits);
    			}
    	
    			writeWord(0xFFD9); //EOI
    
          //return new Uint8Array(byteout);
          return new Buffer(byteout);
    
    			var jpegDataUri = 'data:image/jpeg;base64,' + btoa(byteout.join(''));
    			
    			byteout = [];
    			
    			// benchmarking
    			var duration = new Date().getTime() - time_start;
        		//console.log('Encoding time: '+ duration + 'ms');
        		//
    			
    			return jpegDataUri			
    	}
    	
    	function setQuality(quality){
    		if (quality <= 0) {
    			quality = 1;
    		}
    		if (quality > 100) {
    			quality = 100;
    		}
    		
    		if(currentQuality == quality) return // don't recalc if unchanged
    		
    		var sf = 0;
    		if (quality < 50) {
    			sf = Math.floor(5000 / quality);
    		} else {
    			sf = Math.floor(200 - quality*2);
    		}
    		
    		initQuantTables(sf);
    		currentQuality = quality;
    		//console.log('Quality set to: '+quality +'%');
    	}
    	
    	function init(){
    		var time_start = new Date().getTime();
    		if(!quality) quality = 50;
    		// Create tables
    		initCharLookupTable()
    		initHuffmanTbl();
    		initCategoryNumber();
    		initRGBYUVTable();
    		
    		setQuality(quality);
    		var duration = new Date().getTime() - time_start;
        	//console.log('Initialization '+ duration + 'ms');
    	}
    	
    	init();
    	
    };
    module.exports = encode;
    
    function encode(imgData, qu) {
      if (typeof qu === 'undefined') qu = 50;
      var encoder = new JPEGEncoder(qu);
    	var data = encoder.encode(imgData, qu);
      return {
        data: data,
        width: imgData.width,
        height: imgData.height
      };
    }
    
    // helper function to get the imageData of an existing image on the current page.
    function getImageDataFromImage(idOrElement){
    	var theImg = (typeof(idOrElement)=='string')? document.getElementById(idOrElement):idOrElement;
    	var cvs = document.createElement('canvas');
    	cvs.width = theImg.width;
    	cvs.height = theImg.height;
    	var ctx = cvs.getContext("2d");
    	ctx.drawImage(theImg,0,0);
    	
    	return (ctx.getImageData(0, 0, cvs.width, cvs.height));
    }
    
  provide("jpeg-js/lib/encoder", module.exports);
}(global));

// pakmanager:jpeg-js/lib/decoder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
    /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
    /*
       Copyright 2011 notmasteryet
    
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
    
           http://www.apache.org/licenses/LICENSE-2.0
    
       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
    */
    
    // - The JPEG specification can be found in the ITU CCITT Recommendation T.81
    //   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
    // - The JFIF specification can be found in the JPEG File Interchange Format
    //   (www.w3.org/Graphics/JPEG/jfif3.pdf)
    // - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
    //   in PostScript Level 2, Technical Note #5116
    //   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)
    
    var JpegImage = (function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
         0,
         1,  8,
        16,  9,  2,
         3, 10, 17, 24,
        32, 25, 18, 11, 4,
         5, 12, 19, 26, 33, 40,
        48, 41, 34, 27, 20, 13,  6,
         7, 14, 21, 28, 35, 42, 49, 56,
        57, 50, 43, 36, 29, 22, 15,
        23, 30, 37, 44, 51, 58,
        59, 52, 45, 38, 31,
        39, 46, 53, 60,
        61, 54, 47,
        55, 62,
        63
      ]);
    
      var dctCos1  =  4017   // cos(pi/16)
      var dctSin1  =   799   // sin(pi/16)
      var dctCos3  =  3406   // cos(3*pi/16)
      var dctSin3  =  2276   // sin(3*pi/16)
      var dctCos6  =  1567   // cos(6*pi/16)
      var dctSin6  =  3784   // sin(6*pi/16)
      var dctSqrt2 =  5793   // sqrt(2)
      var dctSqrt1d2 = 2896  // sqrt(2) / 2
    
      function constructor() {
      }
    
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({children: [], index: 0});
        var p = code[0], q;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q = {children: [], index: 0});
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i + 1 < length) {
            // p here points to last code
            code.push(q = {children: [], index: 0});
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
    
      function decodeScan(data, offset,
                          frame, components, resetInterval,
                          spectralStart, spectralEnd,
                          successivePrev, successive) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
    
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return (bitsData >> bitsCount) & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 0xFF) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw "unexpected marker: " + ((bitsData << 8) | nextByte).toString(16);
            }
            // unstuff 0
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === 'number')
              return node;
            if (typeof node !== 'object')
              throw "invalid huffman sequence";
          }
          return null;
        }
        function receive(length) {
          var n = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null) return;
            n = (n << 1) | bit;
            length--;
          }
          return n;
        }
        function receiveAndExtend(length) {
          var n = receive(length);
          if (n >= 1 << (length - 1))
            return n;
          return n + (-1 << length) + 1;
        }
        function decodeBaseline(component, zz) {
          var t = decodeHuffman(component.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0]= (component.pred += diff);
          var k = 1;
          while (k < 64) {
            var rs = decodeHuffman(component.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k += 16;
              continue;
            }
            k += r;
            var z = dctZigZag[k];
            zz[z] = receiveAndExtend(s);
            k++;
          }
        }
        function decodeDCFirst(component, zz) {
          var t = decodeHuffman(component.huffmanTableDC);
          var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
          zz[0] = (component.pred += diff);
        }
        function decodeDCSuccessive(component, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k = spectralStart, e = spectralEnd;
          while (k <= e) {
            var rs = decodeHuffman(component.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k += 16;
              continue;
            }
            k += r;
            var z = dctZigZag[k];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component, zz) {
          var k = spectralStart, e = spectralEnd, r = 0;
          while (k <= e) {
            var z = dctZigZag[k];
            switch (successiveACState) {
            case 0: // initial state
              var rs = decodeHuffman(component.huffmanTableAC);
              var s = rs & 15, r = rs >> 4;
              if (s === 0) {
                if (r < 15) {
                  eobrun = receive(r) + (1 << r);
                  successiveACState = 4;
                } else {
                  r = 16;
                  successiveACState = 1;
                }
              } else {
                if (s !== 1)
                  throw "invalid ACn encoding";
                successiveACNextValue = receiveAndExtend(s);
                successiveACState = r ? 2 : 3;
              }
              continue;
            case 1: // skipping r zero items
            case 2:
              if (zz[z])
                zz[z] += (readBit() << successive);
              else {
                r--;
                if (r === 0)
                  successiveACState = successiveACState == 2 ? 3 : 0;
              }
              break;
            case 3: // set value for a zero item
              if (zz[z])
                zz[z] += (readBit() << successive);
              else {
                zz[z] = successiveACNextValue << successive;
                successiveACState = 0;
              }
              break;
            case 4: // eob
              if (zz[z])
                zz[z] += (readBit() << successive);
              break;
            }
            k++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component, decode, mcu, row, col) {
          var mcuRow = (mcu / mcusPerLine) | 0;
          var mcuCol = mcu % mcusPerLine;
          var blockRow = mcuRow * component.v + row;
          var blockCol = mcuCol * component.h + col;
          decode(component, component.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component, decode, mcu) {
          var blockRow = (mcu / component.blocksPerLine) | 0;
          var blockCol = mcu % component.blocksPerLine;
          decode(component, component.blocks[blockRow][blockCol]);
        }
    
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
    
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval) resetInterval = mcuExpected;
    
        var h, v;
        while (mcu < mcuExpected) {
          // reset interval stuff
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
    
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
    
              // If we've reached our expected MCU's, stop decoding
              if (mcu === mcuExpected) break;
            }
          }
    
          // find marker
          bitsCount = 0;
          marker = (data[offset] << 8) | data[offset + 1];
          if (marker < 0xFF00) {
            throw "marker was not found";
          }
    
          if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
            offset += 2;
          }
          else
            break;
        }
    
        return offset - startOffset;
      }
    
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
    
        // A port of poppler's IDCT method which in turn is taken from:
        //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
        //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
        //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
        //   988-991.
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i;
    
          // dequant
          for (i = 0; i < 64; i++)
            p[i] = zz[i] * qt[i];
    
          // inverse DCT on rows
          for (i = 0; i < 8; ++i) {
            var row = 8 * i;
    
            // check for all-zero AC coefficients
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&
                p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&
                p[7 + row] == 0) {
              t = (dctSqrt2 * p[0 + row] + 512) >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
    
            // stage 4
            v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
            v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
            v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
    
            // stage 3
            t = (v0 - v1+ 1) >> 1;
            v0 = (v0 + v1 + 1) >> 1;
            v1 = t;
            t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
            v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
            v3 = t;
            t = (v4 - v6 + 1) >> 1;
            v4 = (v4 + v6 + 1) >> 1;
            v6 = t;
            t = (v7 + v5 + 1) >> 1;
            v5 = (v7 - v5 + 1) >> 1;
            v7 = t;
    
            // stage 2
            t = (v0 - v3 + 1) >> 1;
            v0 = (v0 + v3 + 1) >> 1;
            v3 = t;
            t = (v1 - v2 + 1) >> 1;
            v1 = (v1 + v2 + 1) >> 1;
            v2 = t;
            t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
            v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
            v7 = t;
            t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
            v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
            v6 = t;
    
            // stage 1
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
    
          // inverse DCT on columns
          for (i = 0; i < 8; ++i) {
            var col = i;
    
            // check for all-zero AC coefficients
            if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&
                p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&
                p[7*8 + col] == 0) {
              t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;
              p[0*8 + col] = t;
              p[1*8 + col] = t;
              p[2*8 + col] = t;
              p[3*8 + col] = t;
              p[4*8 + col] = t;
              p[5*8 + col] = t;
              p[6*8 + col] = t;
              p[7*8 + col] = t;
              continue;
            }
    
            // stage 4
            v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;
            v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;
            v2 = p[2*8 + col];
            v3 = p[6*8 + col];
            v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;
            v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;
            v5 = p[3*8 + col];
            v6 = p[5*8 + col];
    
            // stage 3
            t = (v0 - v1 + 1) >> 1;
            v0 = (v0 + v1 + 1) >> 1;
            v1 = t;
            t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
            v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
            v3 = t;
            t = (v4 - v6 + 1) >> 1;
            v4 = (v4 + v6 + 1) >> 1;
            v6 = t;
            t = (v7 + v5 + 1) >> 1;
            v5 = (v7 - v5 + 1) >> 1;
            v7 = t;
    
            // stage 2
            t = (v0 - v3 + 1) >> 1;
            v0 = (v0 + v3 + 1) >> 1;
            v3 = t;
            t = (v1 - v2 + 1) >> 1;
            v1 = (v1 + v2 + 1) >> 1;
            v2 = t;
            t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
            v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
            v7 = t;
            t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
            v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
            v6 = t;
    
            // stage 1
            p[0*8 + col] = v0 + v7;
            p[7*8 + col] = v0 - v7;
            p[1*8 + col] = v1 + v6;
            p[6*8 + col] = v1 - v6;
            p[2*8 + col] = v2 + v5;
            p[5*8 + col] = v2 - v5;
            p[3*8 + col] = v3 + v4;
            p[4*8 + col] = v3 - v4;
          }
    
          // convert to 8-bit integers
          for (i = 0; i < 64; ++i) {
            var sample = 128 + ((p[i] + 8) >> 4);
            dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;
          }
        }
    
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
    
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
    
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
    
      constructor.prototype = {
        load: function load(path) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = (function() {
            // TODO catch parse error
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }).bind(this);
          xhr.send(null);
        },
        parse: function parse(data) {
          var offset = 0, length = data.length;
          function readUint16() {
            var value = (data[offset] << 8) | data[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length = readUint16();
            var array = data.subarray(offset, offset + length - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame) {
            var maxH = 0, maxV = 0;
            var component, componentId;
            for (componentId in frame.components) {
              if (frame.components.hasOwnProperty(componentId)) {
                component = frame.components[componentId];
                if (maxH < component.h) maxH = component.h;
                if (maxV < component.v) maxV = component.v;
              }
            }
            var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
            var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
            for (componentId in frame.components) {
              if (frame.components.hasOwnProperty(componentId)) {
                component = frame.components[componentId];
                var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
                var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);
                var blocksPerLineForMcu = mcusPerLine * component.h;
                var blocksPerColumnForMcu = mcusPerColumn * component.v;
                var blocks = [];
                for (var i = 0; i < blocksPerColumnForMcu; i++) {
                  var row = [];
                  for (var j = 0; j < blocksPerLineForMcu; j++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component.blocksPerLine = blocksPerLine;
                component.blocksPerColumn = blocksPerColumn;
                component.blocks = blocks;
              }
            }
            frame.maxH = maxH;
            frame.maxV = maxV;
            frame.mcusPerLine = mcusPerLine;
            frame.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          if (fileMarker != 0xFFD8) { // SOI (Start of Image)
            throw "SOI not found";
          }
    
          fileMarker = readUint16();
          while (fileMarker != 0xFFD9) { // EOI (End of image)
            var i, j, l;
            switch(fileMarker) {
              case 0xFF00: break;
              case 0xFFE0: // APP0 (Application Specific)
              case 0xFFE1: // APP1
              case 0xFFE2: // APP2
              case 0xFFE3: // APP3
              case 0xFFE4: // APP4
              case 0xFFE5: // APP5
              case 0xFFE6: // APP6
              case 0xFFE7: // APP7
              case 0xFFE8: // APP8
              case 0xFFE9: // APP9
              case 0xFFEA: // APP10
              case 0xFFEB: // APP11
              case 0xFFEC: // APP12
              case 0xFFED: // APP13
              case 0xFFEE: // APP14
              case 0xFFEF: // APP15
              case 0xFFFE: // COM (Comment)
                var appData = readDataBlock();
    
                if (fileMarker === 0xFFE0) {
                  if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                    appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: (appData[8] << 8) | appData[9],
                      yDensity: (appData[10] << 8) | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                // TODO APP1 - Exif
                if (fileMarker === 0xFFEE) {
                  if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                    appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                    adobe = {
                      version: appData[6],
                      flags0: (appData[7] << 8) | appData[8],
                      flags1: (appData[9] << 8) | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
    
              case 0xFFDB: // DQT (Define Quantization Tables)
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  var tableData = new Int32Array(64);
                  if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw "DQT: invalid table spec";
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
    
              case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
              case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
              case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
                readUint16(); // skip data length
                frame = {};
                frame.extended = (fileMarker === 0xFFC1);
                frame.progressive = (fileMarker === 0xFFC2);
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h: h,
                    v: v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
    
              case 0xFFC4: // DHT (Define Huffman Tables)
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength;) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++)
                    codeLengthSum += (codeLengths[j] = data[offset]);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
    
                  ((huffmanTableSpec >> 4) === 0 ? 
                    huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                    buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
    
              case 0xFFDD: // DRI (Define Restart Interval)
                readUint16(); // skip data length
                resetInterval = readUint16();
                break;
    
              case 0xFFDA: // SOS (Start of Scan)
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(data, offset,
                  frame, components, resetInterval,
                  spectralStart, spectralEnd,
                  successiveApproximation >> 4, successiveApproximation & 15);
                offset += processed;
                break;
              default:
                if (data[offset - 3] == 0xFF &&
                    data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
                  // could be incorrect encoding -- last 0xFF byte of the previous
                  // block was eaten by the encoder
                  offset -= 3;
                  break;
                }
                throw "unknown JPEG marker " + fileMarker.toString(16);
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw "only single frame JPEGs supported";
    
          // set each frame's components quantization table
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
    
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
    
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | (x * component1.scaleX * scaleX)];
    
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              // PDF might compress two component data in custom colorspace
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
                component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                  data[offset++] = Y;
                  Y = component2Line[0 | (x * component2.scaleX * scaleX)];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              // The default transform for three components is true
              colorTransform = true;
              // The adobe transform marker overrides any previous setting
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.colorTransform !== 'undefined')
                colorTransform = !!this.colorTransform;
    
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
                component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
                component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | (x * component1.scaleX * scaleX)];
                    G = component2Line[0 | (x * component2.scaleX * scaleX)];
                    B = component3Line[0 | (x * component3.scaleX * scaleX)];
                  } else {
                    Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                    Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
                    Cr = component3Line[0 | (x * component3.scaleX * scaleX)];
    
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
    
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw 'Unsupported color mode (4 components)';
              // The default transform for four components is false
              colorTransform = false;
              // The adobe transform marker overrides any previous setting
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.colorTransform !== 'undefined')
                colorTransform = !!this.colorTransform;
    
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
                component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
                component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
                component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | (x * component1.scaleX * scaleX)];
                    M = component2Line[0 | (x * component2.scaleX * scaleX)];
                    Ye = component3Line[0 | (x * component3.scaleX * scaleX)];
                    K = component4Line[0 | (x * component4.scaleX * scaleX)];
                  } else {
                    Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                    Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
                    Cr = component3Line[0 | (x * component3.scaleX * scaleX)];
                    K = component4Line[0 | (x * component4.scaleX * scaleX)];
    
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = C;
                  data[offset++] = M;
                  data[offset++] = Ye;
                  data[offset++] = K;
                }
              }
              break;
            default:
              throw 'Unsupported color mode';
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
    
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = 255;
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
    
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  imageDataArray[j++] = 255;
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
    
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
    
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  imageDataArray[j++] = 255;
                }
              }
              break;
            default:
              throw 'Unsupported color mode';
          }
        }
      };
    
      return constructor;
    })();
    module.exports = decode;
    
    function decode(jpegData) {
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.parse(arr);
    
      var image = {
        width: decoder.width,
        height: decoder.height,
        data: new Buffer(decoder.width * decoder.height * 4)
      };
      
      decoder.copyToImageData(image);
      
      return image;
    }
    
  provide("jpeg-js/lib/decoder", module.exports);
}(global));

// pakmanager:jpeg-js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var encode =  require('jpeg-js/lib/encoder'),
        decode =  require('jpeg-js/lib/decoder');
    
    module.exports = {
      encode: encode,
      decode: decode
    };
    
  provide("jpeg-js", module.exports);
}(global));

// pakmanager:omggif
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // (c) Dean McNamee <dean@gmail.com>, 2013.
    //
    // https://github.com/deanm/omggif
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to
    // deal in the Software without restriction, including without limitation the
    // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    // sell copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    // IN THE SOFTWARE.
    //
    // omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
    // including animation and compression.  It does not rely on any specific
    // underlying system, so should run in the browser, Node, or Plask.
    
    function GifWriter(buf, width, height, gopts) {
      var p = 0;
    
      var gopts = gopts === undefined ? { } : gopts;
      var loop_count = gopts.loop === undefined ? null : gopts.loop;
      var global_palette = gopts.palette === undefined ? null : gopts.palette;
    
      if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
        throw "Width/Height invalid."
    
      function check_palette_and_num_colors(palette) {
        var num_colors = palette.length;
        if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1))
          throw "Invalid code/color length, must be power of 2 and 2 .. 256.";
        return num_colors;
      }
    
      // - Header.
      buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF
      buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a
    
      // Handling of Global Color Table (palette) and background index.
      var gp_num_colors_pow2 = 0;
      var background = 0;
      if (global_palette !== null) {
        var gp_num_colors = check_palette_and_num_colors(global_palette);
        while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
        gp_num_colors = 1 << gp_num_colors_pow2;
        --gp_num_colors_pow2;
        if (gopts.background !== undefined) {
          background = gopts.background;
          if (background >= gp_num_colors) throw "Background index out of range.";
          // The GIF spec states that a background index of 0 should be ignored, so
          // this is probably a mistake and you really want to set it to another
          // slot in the palette.  But actually in the end most browsers, etc end
          // up ignoring this almost completely (including for dispose background).
          if (background === 0)
            throw "Background index explicitly passed as 0.";
        }
      }
    
      // - Logical Screen Descriptor.
      // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
      buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;
      buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;
      // NOTE: Indicates 0-bpp original color resolution (unused?).
      buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
                 gp_num_colors_pow2;  // NOTE: No sort flag (unused?).
      buf[p++] = background;  // Background Color Index.
      buf[p++] = 0;  // Pixel aspect ratio (unused?).
    
      // - Global Color Table
      if (global_palette !== null) {
        for (var i = 0, il = global_palette.length; i < il; ++i) {
          var rgb = global_palette[i];
          buf[p++] = rgb >> 16 & 0xff;
          buf[p++] = rgb >> 8 & 0xff;
          buf[p++] = rgb & 0xff;
        }
      }
    
      if (loop_count !== null) {  // Netscape block for looping.
        if (loop_count < 0 || loop_count > 65535)
          throw "Loop count invalid."
        // Extension code, label, and length.
        buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;
        // NETSCAPE2.0
        buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;
        buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;
        buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;
        // Sub-block
        buf[p++] = 0x03; buf[p++] = 0x01;
        buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;
        buf[p++] = 0x00;  // Terminator.
      }
    
    
      var ended = false;
    
      this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
        if (ended === true) { --p; ended = false; }  // Un-end.
    
        opts = opts === undefined ? { } : opts;
    
        // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
        // canvas width/height, I imagine?
        if (x < 0 || y < 0 || x > 65535 || y > 65535)
          throw "x/y invalid."
    
        if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
          throw "Width/Height invalid."
    
        if (indexed_pixels.length < w * h)
          throw "Not enough pixels for the frame size.";
    
        var using_local_palette = true;
        var palette = opts.palette;
        if (palette === undefined || palette === null) {
          using_local_palette = false;
          palette = global_palette;
        }
    
        if (palette === undefined || palette === null)
          throw "Must supply either a local or global palette.";
    
        var num_colors = check_palette_and_num_colors(palette);
    
        // Compute the min_code_size (power of 2), destroying num_colors.
        var min_code_size = 0;
        while (num_colors >>= 1) ++min_code_size;
        num_colors = 1 << min_code_size;  // Now we can easily get it back.
    
        var delay = opts.delay === undefined ? 0 : opts.delay;
    
        // From the spec:
        //     0 -   No disposal specified. The decoder is
        //           not required to take any action.
        //     1 -   Do not dispose. The graphic is to be left
        //           in place.
        //     2 -   Restore to background color. The area used by the
        //           graphic must be restored to the background color.
        //     3 -   Restore to previous. The decoder is required to
        //           restore the area overwritten by the graphic with
        //           what was there prior to rendering the graphic.
        //  4-7 -    To be defined.
        // NOTE(deanm): Dispose background doesn't really work, apparently most
        // browsers ignore the background palette index and clear to transparency.
        var disposal = opts.disposal === undefined ? 0 : opts.disposal;
        if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
          throw "Disposal out of range.";
    
        var use_transparency = false;
        var transparent_index = 0;
        if (opts.transparent !== undefined && opts.transparent !== null) {
          use_transparency = true;
          transparent_index = opts.transparent;
          if (transparent_index < 0 || transparent_index >= num_colors)
            throw "Transparent color index.";
        }
    
        if (disposal !== 0 || use_transparency || delay !== 0) {
          // - Graphics Control Extension
          buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.
          buf[p++] = 4;  // Byte size.
    
          buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
          buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;
          buf[p++] = transparent_index;  // Transparent color index.
          buf[p++] = 0;  // Block Terminator.
        }
    
        // - Image Descriptor
        buf[p++] = 0x2c;  // Image Seperator.
        buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.
        buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.
        buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;
        buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;
        // NOTE: No sort flag (unused?).
        // TODO(deanm): Support interlace.
        buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;
    
        // - Local Color Table
        if (using_local_palette === true) {
          for (var i = 0, il = palette.length; i < il; ++i) {
            var rgb = palette[i];
            buf[p++] = rgb >> 16 & 0xff;
            buf[p++] = rgb >> 8 & 0xff;
            buf[p++] = rgb & 0xff;
          }
        }
    
        p = GifWriterOutputLZWCodeStream(
                buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
      };
    
      this.end = function() {
        if (ended === false) {
          buf[p++] = 0x3b;  // Trailer.
          ended = true;
        }
        return p;
      };
    }
    
    // Main compression routine, palette indexes -> LZW code stream.
    // |index_stream| must have at least one entry.
    function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
      buf[p++] = min_code_size;
      var cur_subblock = p++;  // Pointing at the length field.
    
      var clear_code = 1 << min_code_size;
      var code_mask = clear_code - 1;
      var eoi_code = clear_code + 1;
      var next_code = eoi_code + 1;
    
      var cur_code_size = min_code_size + 1;  // Number of bits per code.
      var cur_shift = 0;
      // We have at most 12-bit codes, so we should have to hold a max of 19
      // bits here (and then we would write out).
      var cur = 0;
    
      function emit_bytes_to_buffer(bit_block_size) {
        while (cur_shift >= bit_block_size) {
          buf[p++] = cur & 0xff;
          cur >>= 8; cur_shift -= 8;
          if (p === cur_subblock + 256) {  // Finished a subblock.
            buf[cur_subblock] = 255;
            cur_subblock = p++;
          }
        }
      }
    
      function emit_code(c) {
        cur |= c << cur_shift;
        cur_shift += cur_code_size;
        emit_bytes_to_buffer(8);
      }
    
      // I am not an expert on the topic, and I don't want to write a thesis.
      // However, it is good to outline here the basic algorithm and the few data
      // structures and optimizations here that make this implementation fast.
      // The basic idea behind LZW is to build a table of previously seen runs
      // addressed by a short id (herein called output code).  All data is
      // referenced by a code, which represents one or more values from the
      // original input stream.  All input bytes can be referenced as the same
      // value as an output code.  So if you didn't want any compression, you
      // could more or less just output the original bytes as codes (there are
      // some details to this, but it is the idea).  In order to achieve
      // compression, values greater then the input range (codes can be up to
      // 12-bit while input only 8-bit) represent a sequence of previously seen
      // inputs.  The decompressor is able to build the same mapping while
      // decoding, so there is always a shared common knowledge between the
      // encoding and decoder, which is also important for "timing" aspects like
      // how to handle variable bit width code encoding.
      //
      // One obvious but very important consequence of the table system is there
      // is always a unique id (at most 12-bits) to map the runs.  'A' might be
      // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
      // can be used for an effecient lookup strategy for the code mapping.  We
      // need to know if a run has been seen before, and be able to map that run
      // to the output code.  Since we start with known unique ids (input bytes),
      // and then from those build more unique ids (table entries), we can
      // continue this chain (almost like a linked list) to always have small
      // integer values that represent the current byte chains in the encoder.
      // This means instead of tracking the input bytes (AAAABCD) to know our
      // current state, we can track the table entry for AAAABC (it is guaranteed
      // to exist by the nature of the algorithm) and the next character D.
      // Therefor the tuple of (table_entry, byte) is guaranteed to also be
      // unique.  This allows us to create a simple lookup key for mapping input
      // sequences to codes (table indices) without having to store or search
      // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
      // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
      // key.  This leads to a integer value at most 20-bits, which can always
      // fit in an SMI value and be used as a fast sparse array / object key.
    
      // Output code for the current contents of the index buffer.
      var ib_code = index_stream[0] & code_mask;  // Load first input index.
      var code_table = { };  // Key'd on our 20-bit "tuple".
    
      emit_code(clear_code);  // Spec says first code should be a clear code.
    
      // First index already loaded, process the rest of the stream.
      for (var i = 1, il = index_stream.length; i < il; ++i) {
        var k = index_stream[i] & code_mask;
        var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.
        var cur_code = code_table[cur_key];  // buffer + k.
    
        // Check if we have to create a new code table entry.
        if (cur_code === undefined) {  // We don't have buffer + k.
          // Emit index buffer (without k).
          // This is an inline version of emit_code, because this is the core
          // writing routine of the compressor (and V8 cannot inline emit_code
          // because it is a closure here in a different context).  Additionally
          // we can call emit_byte_to_buffer less often, because we can have
          // 30-bits (from our 31-bit signed SMI), and we know our codes will only
          // be 12-bits, so can safely have 18-bits there without overflow.
          // emit_code(ib_code);
          cur |= ib_code << cur_shift;
          cur_shift += cur_code_size;
          while (cur_shift >= 8) {
            buf[p++] = cur & 0xff;
            cur >>= 8; cur_shift -= 8;
            if (p === cur_subblock + 256) {  // Finished a subblock.
              buf[cur_subblock] = 255;
              cur_subblock = p++;
            }
          }
    
          if (next_code === 4096) {  // Table full, need a clear.
            emit_code(clear_code);
            next_code = eoi_code + 1;
            cur_code_size = min_code_size + 1;
            code_table = { };
          } else {  // Table not full, insert a new entry.
            // Increase our variable bit code sizes if necessary.  This is a bit
            // tricky as it is based on "timing" between the encoding and
            // decoder.  From the encoders perspective this should happen after
            // we've already emitted the index buffer and are about to create the
            // first table entry that would overflow our current code bit size.
            if (next_code >= (1 << cur_code_size)) ++cur_code_size;
            code_table[cur_key] = next_code++;  // Insert into code table.
          }
    
          ib_code = k;  // Index buffer to single input k.
        } else {
          ib_code = cur_code;  // Index buffer to sequence in code table.
        }
      }
    
      emit_code(ib_code);  // There will still be something in the index buffer.
      emit_code(eoi_code);  // End Of Information.
    
      // Flush / finalize the sub-blocks stream to the buffer.
      emit_bytes_to_buffer(1);
    
      // Finish the sub-blocks, writing out any unfinished lengths and
      // terminating with a sub-block of length 0.  If we have already started
      // but not yet used a sub-block it can just become the terminator.
      if (cur_subblock + 1 === p) {  // Started but unused.
        buf[cur_subblock] = 0;
      } else {  // Started and used, write length and additional terminator block.
        buf[cur_subblock] = p - cur_subblock - 1;
        buf[p++] = 0;
      }
      return p;
    }
    
    function GifReader(buf) {
      var p = 0;
    
      // - Header (GIF87a or GIF89a).
      if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
          buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
        throw "Invalid GIF 87a/89a header.";
      }
    
      // - Logical Screen Descriptor.
      var width = buf[p++] | buf[p++] << 8;
      var height = buf[p++] | buf[p++] << 8;
      var pf0 = buf[p++];  // <Packed Fields>.
      var global_palette_flag = pf0 >> 7;
      var num_global_colors_pow2 = pf0 & 0x7;
      var num_global_colors = 1 << (num_global_colors_pow2 + 1);
      var background = buf[p++];
      buf[p++];  // Pixel aspect ratio (unused?).
    
      var global_palette_offset = null;
    
      if (global_palette_flag) {
        global_palette_offset = p;
        p += num_global_colors * 3;  // Seek past palette.
      }
    
      var no_eof = true;
    
      var frames = [ ];
    
      var delay = 0;
      var transparent_index = null;
      var disposal = 0;  // 0 - No disposal specified.
      var loop_count = null;
    
      this.width = width;
      this.height = height;
    
      while (no_eof && p < buf.length) {
        switch (buf[p++]) {
          case 0x21:  // Graphics Control Extension Block
            switch (buf[p++]) {
              case 0xff:  // Application specific block
                // Try if it's a Netscape block (with animation loop counter).
                if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.
                    // NETSCAPE2.0
                    buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&
                    buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&
                    buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&
                    buf[p+10] == 0x2e && buf[p+11] == 0x30 &&
                    // Sub-block
                    buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {
                  p += 14;
                  loop_count = buf[p++] | buf[p++] << 8;
                  p++;  // Skip terminator.
                } else {  // We don't know what it is, just try to get past it.
                  p += 12;
                  while (true) {  // Seek through subblocks.
                    var block_size = buf[p++];
                    if (block_size === 0) break;
                    p += block_size;
                  }
                }
                break;
    
              case 0xf9:  // Graphics Control Extension
                if (buf[p++] !== 0x4 || buf[p+4] !== 0)
                  throw "Invalid graphics extension block.";
                var pf1 = buf[p++];
                delay = buf[p++] | buf[p++] << 8;
                transparent_index = buf[p++];
                if ((pf1 & 1) === 0) transparent_index = null;
                disposal = pf1 >> 2 & 0x7;
                p++;  // Skip terminator.
                break;
    
              case 0xfe:  // Comment Extension.
                while (true) {  // Seek through subblocks.
                  var block_size = buf[p++];
                  if (block_size === 0) break;
                  // console.log(buf.slice(p, p+block_size).toString('ascii'));
                  p += block_size;
                }
                break;
    
              default:
                throw "Unknown graphic control label: 0x" + buf[p-1].toString(16);
            }
            break;
    
          case 0x2c:  // Image Descriptor.
            var x = buf[p++] | buf[p++] << 8;
            var y = buf[p++] | buf[p++] << 8;
            var w = buf[p++] | buf[p++] << 8;
            var h = buf[p++] | buf[p++] << 8;
            var pf2 = buf[p++];
            var local_palette_flag = pf2 >> 7;
            var interlace_flag = pf2 >> 6 & 1;
            var num_local_colors_pow2 = pf2 & 0x7;
            var num_local_colors = 1 << (num_local_colors_pow2 + 1);
            var palette_offset = global_palette_offset;
            var has_local_palette = false;
            if (local_palette_flag) {
              var has_local_palette = true;
              palette_offset = p;  // Override with local palette.
              p += num_local_colors * 3;  // Seek past palette.
            }
    
            var data_offset = p;
    
            p++;  // codesize
            while (true) {
              var block_size = buf[p++];
              if (block_size === 0) break;
              p += block_size;
            }
    
            frames.push({x: x, y: y, width: w, height: h,
                         has_local_palette: has_local_palette,
                         palette_offset: palette_offset,
                         data_offset: data_offset,
                         data_length: p - data_offset,
                         transparent_index: transparent_index,
                         interlaced: !!interlace_flag,
                         delay: delay,
                         disposal: disposal});
            break;
    
          case 0x3b:  // Trailer Marker (end of file).
            no_eof = false;
            break;
    
          default:
            throw "Unknown gif block: 0x" + buf[p-1].toString(16);
            break;
        }
      }
    
      this.numFrames = function() {
        return frames.length;
      };
    
      this.loopCount = function() {
        return loop_count;
      };
    
      this.frameInfo = function(frame_num) {
        if (frame_num < 0 || frame_num >= frames.length)
          throw "Frame index out of range.";
        return frames[frame_num];
      }
    
      this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
        var frame = this.frameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
        GifReaderLZWOutputIndexStream(
            buf, frame.data_offset, index_stream, num_pixels);
        var palette_offset = frame.palette_offset;
    
        // NOTE(deanm): It seems to be much faster to compare index to 256 than
        // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
        // the profile, not sure if it's related to using a Uint8Array.
        var trans = frame.transparent_index;
        if (trans === null) trans = 256;
    
        // We are possibly just blitting to a portion of the entire frame.
        // That is a subrect within the framerect, so the additional pixels
        // must be skipped over after we finished a scanline.
        var framewidth  = frame.width;
        var framestride = width - framewidth;
        var xleft       = framewidth;  // Number of subrect pixels left in scanline.
    
        // Output indicies of the top left and bottom right corners of the subrect.
        var opbeg = ((frame.y * width) + frame.x) * 4;
        var opend = ((frame.y + frame.height) * width + frame.x) * 4;
        var op    = opbeg;
    
        var scanstride = framestride * 4;
    
        // Use scanstride to skip past the rows when interlacing.  This is skipping
        // 7 rows for the first two passes, then 3 then 1.
        if (frame.interlaced === true) {
          scanstride += width * 4 * 7;  // Pass 1.
        }
    
        var interlaceskip = 8;  // Tracking the row interval in the current pass.
    
        for (var i = 0, il = index_stream.length; i < il; ++i) {
          var index = index_stream[i];
    
          if (xleft === 0) {  // Beginning of new scan line
            op += scanstride;
            xleft = framewidth;
            if (op >= opend) { // Catch the wrap to switch passes when interlacing.
              scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
              // interlaceskip / 2 * 4 is interlaceskip << 1.
              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
              interlaceskip >>= 1;
            }
          }
    
          if (index === trans) {
            op += 4;
          } else {
            var r = buf[palette_offset + index * 3];
            var g = buf[palette_offset + index * 3 + 1];
            var b = buf[palette_offset + index * 3 + 2];
            pixels[op++] = b;
            pixels[op++] = g;
            pixels[op++] = r;
            pixels[op++] = 255;
          }
          --xleft;
        }
      };
    
      // I will go to copy and paste hell one day...
      this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
        var frame = this.frameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
        GifReaderLZWOutputIndexStream(
            buf, frame.data_offset, index_stream, num_pixels);
        var palette_offset = frame.palette_offset;
    
        // NOTE(deanm): It seems to be much faster to compare index to 256 than
        // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
        // the profile, not sure if it's related to using a Uint8Array.
        var trans = frame.transparent_index;
        if (trans === null) trans = 256;
    
        // We are possibly just blitting to a portion of the entire frame.
        // That is a subrect within the framerect, so the additional pixels
        // must be skipped over after we finished a scanline.
        var framewidth  = frame.width;
        var framestride = width - framewidth;
        var xleft       = framewidth;  // Number of subrect pixels left in scanline.
    
        // Output indicies of the top left and bottom right corners of the subrect.
        var opbeg = ((frame.y * width) + frame.x) * 4;
        var opend = ((frame.y + frame.height) * width + frame.x) * 4;
        var op    = opbeg;
    
        var scanstride = framestride * 4;
    
        // Use scanstride to skip past the rows when interlacing.  This is skipping
        // 7 rows for the first two passes, then 3 then 1.
        if (frame.interlaced === true) {
          scanstride += width * 4 * 7;  // Pass 1.
        }
    
        var interlaceskip = 8;  // Tracking the row interval in the current pass.
    
        for (var i = 0, il = index_stream.length; i < il; ++i) {
          var index = index_stream[i];
    
          if (xleft === 0) {  // Beginning of new scan line
            op += scanstride;
            xleft = framewidth;
            if (op >= opend) { // Catch the wrap to switch passes when interlacing.
              scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
              // interlaceskip / 2 * 4 is interlaceskip << 1.
              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
              interlaceskip >>= 1;
            }
          }
    
          if (index === trans) {
            op += 4;
          } else {
            var r = buf[palette_offset + index * 3];
            var g = buf[palette_offset + index * 3 + 1];
            var b = buf[palette_offset + index * 3 + 2];
            pixels[op++] = r;
            pixels[op++] = g;
            pixels[op++] = b;
            pixels[op++] = 255;
          }
          --xleft;
        }
      };
    }
    
    function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
      var min_code_size = code_stream[p++];
    
      var clear_code = 1 << min_code_size;
      var eoi_code = clear_code + 1;
      var next_code = eoi_code + 1;
    
      var cur_code_size = min_code_size + 1;  // Number of bits per code.
      // NOTE: This shares the same name as the encoder, but has a different
      // meaning here.  Here this masks each code coming from the code stream.
      var code_mask = (1 << cur_code_size) - 1;
      var cur_shift = 0;
      var cur = 0;
    
      var op = 0;  // Output pointer.
      
      var subblock_size = code_stream[p++];
    
      // TODO(deanm): Would using a TypedArray be any faster?  At least it would
      // solve the fast mode / backing store uncertainty.
      // var code_table = Array(4096);
      var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.
    
      var prev_code = null;  // Track code-1.
    
      while (true) {
        // Read up to two bytes, making sure we always 12-bits for max sized code.
        while (cur_shift < 16) {
          if (subblock_size === 0) break;  // No more data to be read.
    
          cur |= code_stream[p++] << cur_shift;
          cur_shift += 8;
    
          if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
            subblock_size = code_stream[p++];  // Next subblock.
          } else {
            --subblock_size;
          }
        }
    
        // TODO(deanm): We should never really get here, we should have received
        // and EOI.
        if (cur_shift < cur_code_size)
          break;
    
        var code = cur & code_mask;
        cur >>= cur_code_size;
        cur_shift -= cur_code_size;
    
        // TODO(deanm): Maybe should check that the first code was a clear code,
        // at least this is what you're supposed to do.  But actually our encoder
        // now doesn't emit a clear code first anyway.
        if (code === clear_code) {
          // We don't actually have to clear the table.  This could be a good idea
          // for greater error checking, but we don't really do any anyway.  We
          // will just track it with next_code and overwrite old entries.
    
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_mask = (1 << cur_code_size) - 1;
    
          // Don't update prev_code ?
          prev_code = null;
          continue;
        } else if (code === eoi_code) {
          break;
        }
    
        // We have a similar situation as the decoder, where we want to store
        // variable length entries (code table entries), but we want to do in a
        // faster manner than an array of arrays.  The code below stores sort of a
        // linked list within the code table, and then "chases" through it to
        // construct the dictionary entries.  When a new entry is created, just the
        // last byte is stored, and the rest (prefix) of the entry is only
        // referenced by its table entry.  Then the code chases through the
        // prefixes until it reaches a single byte code.  We have to chase twice,
        // first to compute the length, and then to actually copy the data to the
        // output (backwards, since we know the length).  The alternative would be
        // storing something in an intermediate stack, but that doesn't make any
        // more sense.  I implemented an approach where it also stored the length
        // in the code table, although it's a bit tricky because you run out of
        // bits (12 + 12 + 8), but I didn't measure much improvements (the table
        // entries are generally not the long).  Even when I created benchmarks for
        // very long table entries the complexity did not seem worth it.
        // The code table stores the prefix entry in 12 bits and then the suffix
        // byte in 8 bits, so each entry is 20 bits.
    
        var chase_code = code < next_code ? code : prev_code;
    
        // Chase what we will output, either {CODE} or {CODE-1}.
        var chase_length = 0;
        var chase = chase_code;
        while (chase > clear_code) {
          chase = code_table[chase] >> 8;
          ++chase_length;
        }
    
        var k = chase;
        
        var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
        if (op_end > output_length) {
          console.log("Warning, gif stream longer than expected.");
          return;
        }
    
        // Already have the first byte from the chase, might as well write it fast.
        output[op++] = k;
    
        op += chase_length;
        var b = op;  // Track pointer, writing backwards.
    
        if (chase_code !== code)  // The case of emitting {CODE-1} + k.
          output[op++] = k;
    
        chase = chase_code;
        while (chase_length--) {
          chase = code_table[chase];
          output[--b] = chase & 0xff;  // Write backwards.
          chase >>= 8;  // Pull down to the prefix code.
        }
    
        if (prev_code !== null && next_code < 4096) {
          code_table[next_code++] = prev_code << 8 | k;
          // TODO(deanm): Figure out this clearing vs code growth logic better.  I
          // have an feeling that it should just happen somewhere else, for now it
          // is awkward between when we grow past the max and then hit a clear code.
          // For now just check if we hit the max 12-bits (then a clear code should
          // follow, also of course encoded in 12-bits).
          if (next_code >= code_mask+1 && cur_code_size < 12) {
            ++cur_code_size;
            code_mask = code_mask << 1 | 1;
          }
        }
    
        prev_code = code;
      }
    
      if (op !== output_length) {
        console.log("Warning, gif stream shorter than expected.");
      }
    
      return output;
    }
    
    try { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) { }  // CommonJS.
    
  provide("omggif", module.exports);
}(global));

// pakmanager:node-bitmap/lib/bitmap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Bitmap = module.exports = exports = function(buffer){
      this.buffer = buffer;
      this.initialized = false;
    
      this.fileHeader = null;
      this.infoHeader = null;
      this.coreHeader = null;
      this.colorPalette = null;
      this.dataPos = -1;
    };
    Bitmap.prototype.CORE_TYPE_WINDOWS_V3 = 40;
    Bitmap.prototype.CORE_TYPE_WINDOWS_V4 = 108;
    Bitmap.prototype.CORE_TYPE_WINDOWS_V5 = 124;
    Bitmap.prototype.CORE_TYPE_OS2_V1 = 12;
    Bitmap.prototype.CORE_TYPE_OS2_V2 = 64;
    Bitmap.prototype.BITMAPCOREHEADER = Bitmap.prototype.CORE_TYPE_OS2_V1;
    Bitmap.prototype.BITMAPINFOHEADER = Bitmap.prototype.CORE_TYPE_WINDOWS_V3;
    Bitmap.prototype.BITMAPINFOHEADER2 = Bitmap.prototype.CORE_TYPE_OS2_V2;
    Bitmap.prototype.BITMAPV4HEADER = Bitmap.prototype.CORE_TYPE_WINDOWS_V4;
    Bitmap.prototype.BITMAPV5HEADER = Bitmap.prototype.CORE_TYPE_WINDOWS_V5;
    Bitmap.prototype.COMPRESSION_BI_RGB = 0;
    Bitmap.prototype.COMPRESSION_BI_RLE8 = 1;
    Bitmap.prototype.COMPRESSION_BI_RLE4 = 2;
    Bitmap.prototype.COMPRESSION_BI_BITFIELDS = 3;
    Bitmap.prototype.COMPRESSION_BI_JPEG = 4;
    Bitmap.prototype.COMPRESSION_BI_PNG = 5;
    Bitmap.prototype.BITCOUNT_2 = 1;
    Bitmap.prototype.BITCOUNT_16 = 4;
    Bitmap.prototype.BITCOUNT_256 = 8;
    Bitmap.prototype.BITCOUNT_16bit = 16;
    Bitmap.prototype.BITCOUNT_24bit = 24;
    Bitmap.prototype.BITCOUNT_32bit = 32;
    Bitmap.prototype.init = function(){
      this.readFileHeader();
      this.readInfoHeader();
      this.readCoreHeader();
      this.readColorPalette();
    
      this.initDataPos();
      this.initialized = true;
    };
    Bitmap.prototype.checkInit = function (){
      if(!this.initialized){
        throw new Error('not initialized');
      }
      /* nop */
    };
    Bitmap.prototype.isBitmap = function(){
      this.checkInit();
    
      if('BM' == this.fileHeader.bfType){
        return true;
      }
      return false;
    };
    Bitmap.prototype.getData = function (){
      this.checkInit();
    
      if(this.COMPRESSION_BI_RGB !== this.coreHeader.__copmression__){
        throw new Error('not supported compression: ' + this.coreHeader.__copmression__);
      }
    
      var bitCount = this.coreHeader.__bitCount__;
      var width = this.getWidth();
      var height = this.getHeight();
    
      var line = (width * bitCount) / 8;
      if(0 != (line % 4)){
        line = ((line / 4) + 1) * 4;
      }
    
      var rgbaData = [];
      var dataPos = this.dataPos;
      for(var i = 0; i < height; ++i) {
        var pos = dataPos + (line * (height - (i + 1)));
        var buf = this.buffer.slice(pos, pos + line);
        var color = this.mapColor(buf, bitCount);
        rgbaData.push(color);
      }
      return rgbaData;
    };
    Bitmap.prototype.getWidth = function (){
      this.checkInit();
    
      return this.coreHeader.__width__;
    };
    Bitmap.prototype.getHeight = function (){
      this.checkInit();
    
      return this.coreHeader.__height__;
    };
    Bitmap.prototype.read = function(buf, offset, limit){
      var read = [];
      for(var i = offset, len = offset + limit; i < len; ++i){
        read.push(buf.readInt8(i));
      }
      return new Buffer(read);
    };
    Bitmap.prototype.readFileHeader = function(){
      var bfType = this.read(this.buffer, 0, 2);
      var bfSize = this.read(this.buffer, 2, 4);
      var bfReserved1 = this.read(this.buffer, 6, 2);
      var bfReserved2 = this.read(this.buffer, 8, 2);
      var bfOffBits = this.read(this.buffer, 10, 4);
    
      this.fileHeader = {
        bfType: bfType.toString('ascii'),
        _bfType: bfType,
        bfSize: bfSize.readUInt16LE(0),
        _bfSize: bfSize,
        bfReserved1: 0,
        bfReserved2: 0,
        bfOffBits: bfOffBits.readUInt16LE(0),
        _bfOffBits: bfOffBits
      };
    };
    Bitmap.prototype.readInfoHeader = function (){
      this.infoHeader = this.read(this.buffer, 14, 4);
    };
    Bitmap.prototype.readCoreHeader = function (){
      var coreType = this.infoHeader.readUInt16LE(0);
      switch(coreType){
      case this.BITMAPCOREHEADER:
        return this.readCoreHeaderOS2_V1();
      case this.BITMAPINFOHEADER2:
        return this.readCoreHeaderOS2_V2();
      case this.BITMAPV4HEADER:
        return this.readCoreHeaderWINDOWS_V4();
      case this.BITMAPV5HEADER:
        return this.readCoreHeaderWINDOWS_V5();
      case this.BITMAPINFOHEADER:
        return this.readCoreHeaderWINDOWS_V3();
      default:
        throw new Error('unknown coreType: ' + coreType);
      }
    };
    Bitmap.prototype.readCoreHeaderWINDOWS_V3 = function (){
      var biWidth = this.read(this.buffer, 0x12, 4);
      var biHeight = this.read(this.buffer, 0x16, 4);
      var biPlanes = this.read(this.buffer, 0x1a, 2);
      var biBitCount = this.read(this.buffer, 0x1c, 2);
      var biCopmression = this.read(this.buffer, 0x1e, 4);
      var biSizeImage = this.read(this.buffer, 0x22, 4);
      var biXPixPerMeter = this.read(this.buffer, 0x26, 4);
      var biYPixPerMeter = this.read(this.buffer, 0x2a, 4);
      var biClrUsed = this.read(this.buffer, 0x2e, 4);
      var biCirImportant = this.read(this.buffer, 0x32, 4);
    
      this.coreHeader = {
        __copmression__: biCopmression.readUInt16LE(0),
        __bitCount__: biBitCount.readUInt8(0),
        __width__: biWidth.readUInt16LE(0),
        __height__: biHeight.readUInt16LE(0),
        biWidth: biWidth.readUInt16LE(0),
        _biWidth: biWidth,
        biHeight: biHeight.readUInt16LE(0),
        _biHeight: biHeight,
        biPlanes: biPlanes.readUInt8(0),
        _biPlanes: biPlanes,
        biBitCount: biBitCount.readUInt8(0),
        _biBitCount: biBitCount,
        biCopmression: biCopmression.readUInt16LE(0),
        _biCopmression: biCopmression,
        biSizeImage: biSizeImage.readUInt16LE(0),
        _biSizeImage: biSizeImage,
        biXPixPerMeter: biXPixPerMeter.readUInt16LE(0),
        _biXPixPerMeter: biXPixPerMeter,
        biYPixPerMeter: biYPixPerMeter.readUInt16LE(0),
        _biYPixPerMeter: biYPixPerMeter,
        biClrUsed: biClrUsed.readUInt16LE(0),
        _biClrUsed: biClrUsed,
        biCirImportant: biCirImportant.readUInt16LE(0),
        _biCirImportant: biCirImportant
      };
    };
    Bitmap.prototype.readCoreHeaderWINDOWS_V4 = function (){
      throw new Error('not yet impl');
      
      var bV4Width = this.read(this.buffer, 0x12, 4);
      var bV4Height = this.read(this.buffer, 0x16, 4);
      var bV4Planes = this.read(this.buffer, 0x1a, 2);
      var bV4BitCount = this.read(this.buffer, 0x1c, 2);
      var bV4Compression = this.read(this.buffer, 0x1e, 4);
      var bV4SizeImage = this.read(this.buffer, 0x22, 4);
      var bV4XPelsPerMeter = this.read(this.buffer, 0x26, 4);
      var bV4YPelsPerMeter = this.read(this.buffer, 0x2a, 4);
      var bV4ClrUsed = this.read(this.buffer, 0x2e, 4);
      var bV4ClrImportant = this.read(this.buffer, 0x32, 4);
      var bV4RedMask = this.read(this.buffer, 0x36, 4);
      var bV4GreenMask = this.read(this.buffer, 0x3a, 4);
      var bV4BlueMask = this.read(this.buffer, 0x3e, 4);
      var bV4AlphaMask = this.read(this.buffer, 0x42, 4);
      var bV4CSType = this.read(this.buffer, 0x46, 4);
      var bV4Endpoints = this.read(this.buffer, 0x6a, 36);
      var bV4GammaRed = this.read(this.buffer, 0x6e, 4);
      var bV4GammaGreen = this.read(this.buffer, 0x72, 4);
      var bV4GammaBlue = this.read(this.buffer, 0x76, 4);
    
      this.coreHeader = {
        __compression__: bV4Compression.readUInt16LE(0),
        __bitCount__: bV4BitCount.readUInt8(0),
        __width__: bV4Width.readUInt16LE(0),
        __height__: bV4Height.readUInt16LE(0),
        bV4Width: bV4Width.readUInt16LE(0),
        _bV4Width: bV4Width,
        bV4Height: bV4Height.readUInt16LE(0),
        _bV4Height: bV4Height,
        bV4Planes: bV4Planes.readUInt8(0),
        _bV4Planes: bV4Planes,
        bV4BitCount: bV4BitCount.readUInt8(0),
        _bV4BitCount: bV4BitCount,
        bV4Compression: bV4Compression.readUInt16LE(0),
        _bV4Compression: bV4Compression,
        bV4SizeImage: bV4SizeImage.readUInt16LE(0),
        _bV4SizeImage: bV4SizeImage,
        bV4XPelsPerMeter: bV4XPelsPerMeter.readUInt16LE(0),
        _bV4XPelsPerMeter: bV4XPelsPerMeter,
        bV4YPelsPerMeter: bV4YPelsPerMeter.readUInt16LE(0),
        _bV4YPelsPerMeter: bV4YPelsPerMeter,
        bV4ClrUsed: bV4ClrUsed.readUInt16LE(0),
        _bV4ClrUsed: bV4ClrUsed,
        bV4ClrImportant: bV4ClrImportant.readUInt16LE(0),
        _bV4ClrImportant: bV4ClrImportant,
        bV4RedMask: bV4RedMask.readUInt16LE(0),
        _bV4RedMask: bV4RedMask,
        bV4GreenMask: bV4GreenMask.readUInt16LE(0),
        _bV4GreenMask: bV4GreenMask,
        bV4BlueMask: bV4BlueMask.readUInt16LE(0),
        _bV4BlueMask: bV4BlueMask,
        bV4AlphaMask: bV4AlphaMask.readUInt16LE(0),
        _bV4AlphaMask: bV4AlphaMask,
        bV4CSType: bV4CSType.readUInt16LE(0),
        _bV4CSType: bV4CSType,
        bV4Endpoints: null,
        _bV4Endpoints: bV4Endpoints,
        bV4GammaRed: bV4GammaRed.readUInt16LE(0),
        _bV4GammaRed: bV4GammaRed,
        bV4GammaGreen: bV4GammaGreen.readUInt16LE(0),
        _bV4GammaGreen: bV4GammaGreen,
        bV4GammaBlue: bV4GammaBlue.readUInt16LE(0),
        _bV4GammaBlue: bV4GammaBlue
      };
    };
    Bitmap.prototype.readCoreHeaderWINDOWS_V5 = function (){
      throw new Error('not yet impl');
    
      var bV5Width = this.read(this.buffer, 0x12, 4);
      var bV5Height = this.read(this.buffer, 0x16, 4);
      var bV5Planes = this.read(this.buffer, 0x1a, 2);
      var bV5BitCount = this.read(this.buffer, 0x1c, 2);
      var bV5Compression = this.read(this.buffer, 0x1e, 4);
      var bV5SizeImage = this.read(this.buffer, 0x22, 4);
      var bV5XPelsPerMeter = this.read(this.buffer, 0x26, 4);
      var bV5YPelsPerMeter = this.read(this.buffer, 0x2a, 4);
      var bV5ClrUsed = this.read(this.buffer, 0x2e, 4);
      var bV5ClrImportant = this.read(this.buffer, 0x32, 4);
      var bV5RedMask = this.read(this.buffer, 0x36, 4);
      var bV5GreenMask = this.read(this.buffer, 0x3a, 4);
      var bV5BlueMask = this.read(this.buffer, 0x3e, 4);
      var bV5AlphaMask = this.read(this.buffer, 0x42, 4);
      var bV5CSType = this.read(this.buffer, 0x46, 4);
      var bV5Endpoints = this.read(this.buffer, 0x6a, 36);
      var bV5GammaRed = this.read(this.buffer, 0x6e, 4);
      var bV5GammaGreen = this.read(this.buffer, 0x72, 4);
      var bV5GammaBlue = this.read(this.buffer, 0x76, 4);
      var bV5Intent = this.read(this.buffer, 0x7a, 4);
      var bV5ProfileData = this.read(this.buffer, 0x7e, 4);
      var bV5ProfileSize = this.read(this.buffer, 0x82, 4);
      var bV5Reserved = this.read(this.buffer, 0x86, 4);
    
      this.coreHeader = {
        __compression__: bV5Compression.readUInt16LE(0),
        __bitCount__: bV5BitCount.readUInt8(0),
        __width__: bV5Width.readUInt16LE(0),
        __height__: bV5Height.readUInt16LE(0),
        bV5Width: bV5Width.readUInt16LE(0),
        _bV5Width: bV5Width,
        bV5Height: bV5Height.readUInt16LE(0),
        _bV5Height: bV5Height,
        bV5Planes: bV5Planes.readUInt8(0),
        _bV5Planes: bV5Planes,
        bV5BitCount: bV5BitCount.readUInt8(0),
        _bV5BitCount: bV5BitCount,
        bV5Compression: bV5Compression.readUInt16LE(0),
        _bV5Compression: bV5Compression,
        bV5SizeImage: bV5SizeImage.readUInt16LE(0),
        _bV5SizeImage: bV5SizeImage,
        bV5XPelsPerMeter: bV5XPelsPerMeter.readUInt16LE(0),
        _bV5XPelsPerMeter: bV5XPelsPerMeter,
        bV5YPelsPerMeter: bV5YPelsPerMeter.readUInt16LE(0),
        _bV5YPelsPerMeter: bV5YPelsPerMeter,
        bV5ClrUsed: bV5ClrUsed.readUInt16LE(0),
        _bV5ClrUsed: bV5ClrUsed,
        bV5ClrImportant: bV5ClrImportant.readUInt16LE(0),
        _bV5ClrImportant: bV5ClrImportant,
        bV5RedMask: bV5RedMask.readUInt16LE(0),
        _bV5RedMask: bV5RedMask,
        bV5GreenMask: bV5GreenMask.readUInt16LE(0),
        _bV5GreenMask: bV5GreenMask,
        bV5BlueMask: bV5BlueMask.readUInt16LE(0),
        _bV5BlueMask: bV5BlueMask,
        bV5AlphaMask: bV5AlphaMask.readUInt16LE(0),
        _bV5AlphaMask: bV5AlphaMask,
        bV5CSType: bV5CSType.readUInt16LE(0),
        _bV5CSType: bV5CSType,
        bV5Endpoints: null,
        _bV5Endpoints: bV5Endpoints,
        bV5GammaRed: bV5GammaRed.readUInt16LE(0),
        _bV5GammaRed: bV5GammaRed,
        bV5GammaGreen: bV5GammaGreen.readUInt16LE(0),
        _bV5GammaGreen: bV5GammaGreen,
        bV5GammaBlue: bV5GammaBlue.readUInt16LE(0),
        _bV5GammaBlue: bV5GammaBlue,
        bV5Intent: bV5Intent.readUInt16LE(0),
        _bV5Intent: bV5Intent,
        bV5ProfileData: bV5ProfileData.readUInt16LE(0),
        _bV5ProfileData: bV5ProfileData,
        bV5ProfileSize: bV5ProfileSize.readUInt16LE(0),
        _bV5ProfileSize: bV5ProfileSize,
        bV5Reserved: 0,
        _bV5Reserved: bV5Reserved
      };
    };
    Bitmap.prototype.readCoreHeaderOS2_V1 = function (){
      throw new Error('not yet impl');
    
      var bcWidth = this.read(this.buffer, 0x12, 2);
      var bcHeight = this.read(this.buffer, 0x14, 2);
      var bcPlanes = this.read(this.buffer, 0x16, 2);
      var bcBitCount = this.read(this.buffer, 0x18, 2);
    
      this.coreHeader = {
        __compression__: 0,
        __bitCount__: bcBitCount.readUInt8(0),
        __width__: bcWidth.readUInt8(0),
        __height__: bcHeight.readUInt8(0),
        bcWidth: bcWidth.readUInt8(0),
        _bcWidth: bcWidth,
        bcHeight: bcHeight.readUInt8(0),
        _bcHeight: bcHeight,
        bcPlanes: bcPlanes.readUInt8(0),
        _bcPlanes: bcPlanes,
        bcBitCount: bcBitCount.readUInt8(0),
        _bcBitCount: bcBitCount
      };
    };
    Bitmap.prototype.readCoreHeaderOS2_V2 = function (){
      throw new Error('not yet impl');
    
      var cx = this.read(this.buffer, 0x12, 4);
      var cy = this.read(this.buffer, 0x16, 4);
      var cPlanes = this.read(this.buffer, 0x1a, 2);
      var cBitCount = this.read(this.buffer, 0x1c, 2);
      var ulCompression = this.read(this.buffer, 0x1e, 4);
      var cbImage = this.read(this.buffer, 0x22, 4);
      var cxResolution = this.read(this.buffer, 0x26, 4);
      var cyResolution = this.read(this.buffer, 0x2a, 4);
      var cclrUsed = this.read(this.buffer, 0x2e, 4);
      var cclrImportant = this.read(this.buffer, 0x32, 4);
      var usUnits = this.read(this.buffer, 0x36, 2);
      var usReserved = this.read(this.buffer, 0x38, 2);
      var usRecording = this.read(this.buffer, 0x3a, 2);
      var usRendering = this.read(this.buffer, 0x3c, 2);
      var cSize1 = this.read(this.buffer, 0x3e, 4);
      var cSize2 = this.read(this.buffer, 0x42, 4);
      var ulColorEncoding = this.read(this.buffer, 0x46, 4);
      var ulIdentifier = this.read(this.buffer, 0x4a, 4);
    
      this.coreHeader = {
        __compression__: ulCompression.readUInt16LE(0),
        __bitCount__: cBitCount.readUInt8(0),
        __width__: cx.readUInt16LE(0),
        __height__: cy.readUInt16LE(0),
        cx: cx.readUInt16LE(0),
        _cx: cx,
        cy: cy.readUInt16LE(0),
        _cy: cy,
        cPlanes: cPlanes.readUInt8(0),
        _cPlanes: cPlanes,
        cBitCount: cBitCount.readUInt8(0),
        _cBitCount: cBitCount,
        ulCompression: ulCompression.readUInt16LE(0),
        _ulCompression: ulCompression,
        cbImage: cbImage.readUInt16LE(0),
        _cbImage: cbImage,
        cxResolution: cxResolution.readUInt16LE(0),
        _cxResolution: cxResolution,
        cyResolution: cyResolution.readUInt16LE(0),
        _cyResolution: cyResolution,
        cclrUsed: cclrUsed.readUInt16LE(0),
        _cclrUsed: cclrUsed,
        cclrImportant: cclrImportant.readUInt16LE(0),
        _cclrImportant: cclrImportant,
        usUnits: usUnits.readUInt8(0),
        _usUnits: usUnits,
        usReserved: usReserved.readUInt8(0),
        _usReserved: usReserved,
        usRecording: usRecording.readUInt8(0),
        _usRecording: usRecording,
        usRendering: usRendering.readUInt8(0),
        _usRendering: usRendering,
        cSize1: cSize1.readUInt16LE(0),
        _cSize1: cSize1,
        cSize2: cSize2.readUInt16LE(0),
        _cSize1: cSize1,
        ulColorEncoding: ulColorEncoding.readUInt16LE(0),
        _ulColorEncoding: ulColorEncoding,
        ulIdentifier: ulIdentifier.readUInt16LE(0),
        _ulIdentifier: ulIdentifier
      };
    };
    Bitmap.prototype.readColorPalette = function (){
      var bitCount = this.coreHeader.__bitCount__;
      if(this.BITCOUNT_16bit == bitCount){
        return /* nop */;
      }
      if(this.BITCOUNT_24bit == bitCount){
        return /* nop */;
      }
      if(this.BITCOUNT_32bit == bitCount){
        return /* nop */;
      }
    
      var coreType = this.infoHeader.readUInt16LE(0);
      switch(coreType){
      case this.BITMAPCOREHEADER:
        return this.readColorPalette_RGBTRIPLE(bitCount, 0x1a);
      case this.BITMAPINFOHEADER2:
        return this.readColorPalette_RGBTRIPLE(bitCount, 0x4e);
        case this.BITMAPV4HEADER:
        return this.readColorPalette_RGBQUAD(bitCount, 0x7a);
      case this.BITMAPV5HEADER:
        return this.readColorPalette_RGBQUAD(bitCount, 0x8a);
      case this.BITMAPINFOHEADER:
        return this.readColorPalette_RGBQUAD(bitCount, 0x36);
      default:
        throw new Error('unknown colorPalette: ' + coreType + ',' + bitCount);
      }
    };
    Bitmap.prototype.readColorPalette_RGBTRIPLE = function (bitCount, startPos){
      throw new Error('not yet impl');
    };
    Bitmap.prototype.readColorPalette_RGBQUAD = function (bitCount, startPos){
      if(this.BITCOUNT_2 == bitCount){
        return this.readRGBQUAD(1 << this.BITCOUNT_2, startPos);
      }
      if(this.BITCOUNT_16 == bitCount){
        return this.readRGBQUAD(1 << this.BITCOUNT_16, startPos);
      }
      if(this.BITCOUNT_256 == bitCount){
        return this.readRGBQUAD(1 << this.BITCOUNT_256, startPos);
      }
      throw new Error('unknown bitCount: ' + bitCount);
    };
    Bitmap.prototype.readRGBQUAD = function(count, startPos){
      var palette = [];
      for(var i = startPos, len = startPos + (4 * count); i < len; i += 4){
        palette.push({
          rgbBlue: this.read(this.buffer, i, 1).readUInt8(0),
          rgbGreen: this.read(this.buffer, i + 1, 1).readUInt8(0),
          rgbRed: this.read(this.buffer, i + 2, 1).readUInt8(0),
          rgbReserved: this.read(this.buffer, i + 3, 1).readUInt8(0)
        });
      }
      this.colorPalette = palette;
    };
    Bitmap.prototype.initDataPos = function(){
      var bitCount = this.coreHeader.__bitCount__;
      var hasPalette = true;
      if(this.BITCOUNT_16bit == bitCount){
        hasPalette = true;
      }
      if(this.BITCOUNT_24bit == bitCount){
        hasPalette = true;
      }
      if(this.BITCOUNT_32bit == bitCount){
        hasPalette = true;
      }
    
      var coreType = this.infoHeader.readUInt16LE(0);
      switch(coreType){
      case this.BITMAPCOREHEADER:
        this.dataPos = 0x1a;
        if(hasPalette){
          this.dataPos = this.dataPos + (3 * (1 << bitCount));
        }
        break;
      case this.BITMAPINFOHEADER2:
        this.dataPos = 0x4e;
        if(hasPalette){
          this.dataPos = this.dataPos + (3 * (1 << bitCount));
        }
        break;
      case this.BITMAPV4HEADER:
        this.dataPos = 0x7a;
        if(hasPalette){
          this.dataPos = this.dataPos + (4 * (1 << bitCount));
        }
        break;
      case this.BITMAPV5HEADER:
        this.dataPos = 0x8a;
        if(hasPalette){
          this.dataPos = this.dataPos + (4 * (1 << bitCount));
        }
      case this.BITMAPINFOHEADER:
        this.dataPos = 0x36;
        if(hasPalette){
          this.dataPos = this.dataPos + (4 * (1 << bitCount));
        }
        break;
      default:
        throw new Error('unknown colorPalette: ' + coreType + ',' + bitCount);
      }
    };
    Bitmap.prototype.mapRGBA = function(r, g, b, a){
      var hex = [];
    
      var padHex = function(value){
        var h = value.toString(16);
        if(value < 0x0f){
          return '0' + h;
        }
        return h;
      };
    
      hex.push(padHex(r));
      hex.push(padHex(g));
      hex.push(padHex(b));
    
      return '#' + hex.join('');
    };
    Bitmap.prototype.mapColor = function(bmpBuf, bitCount){
      var b, g, r, a;
      var length = bmpBuf.length;
      var colorData = [];
    
      if(this.BITCOUNT_2 == bitCount){
        for(var i = 0; i < length; ++i){
          var paletteValue = bmpBuf[i];
          var bin = paletteValue.toString(2);
          bin = new Array(8 - bin.length).join('0') + bin;
    
          for(var j = 0; j < bin.length; ++j){
            var paletteIndex = parseInt(bin.substring(j, j + 1), 10);
            var palette = this.colorPalette[paletteIndex];
            colorData.push(this.mapRGBA(palette.rgbRed, palette.rgbGreen, palette.rgbBlue, -1));
          }
        }
        return colorData;
      }
      if(this.BITCOUNT_16 == bitCount){
        for(var i = 0; i < length; i += 2){
          var paletteHigh = bmpBuf.readUInt8(i);
          var paletteLow = bmpBuf.readUInt8(i + 1);
          var indexes = [paletteHigh, paletteLow];
          indexes.forEach(function(paletteIndex){
            var palette = this.colorPalette[paletteIndex];
            colorData.push(this.mapRGBA(palette.rgbRed, palette.rgbGreen, palette.rgbBlue, -1));
          });
        }
    
        return colorData;
      }
      if(this.BITCOUNT_256 == bitCount){
        for(var i = 0; i < length; ++i){
          var paletteIndex = bmpBuf.readUInt16LE(i);
          var palette = this.colorPalette[paletteIndex];
          colorData.push(this.mapRGBA(palette.rgbRed, palette.rgbGreen, palette.rgbBlue, -1));
        }
        return colorData;
      }
      if(this.BITCOUNT_16bit == bitCount){
        for(var i = 0; i < length; i += 3){
          b = bmpBuf[i];
          g = bmpBuf[i + 1];
          r = bmpBuf[i + 2];
          colorData.push(this.mapRGBA(r, g, b, -1));
        }
        return colorData;
      }
      if(this.BITCOUNT_24bit == bitCount){
        for(var i = 0; i < length; i += 3){
          b = bmpBuf[i];
          g = bmpBuf[i + 1];
          r = bmpBuf[i + 2];
          colorData.push(this.mapRGBA(r, g, b, -1));
        }
        return colorData;
      }
      if(this.BITCOUNT_32bit == bitCount){
        for(var i = 0; i < length; i += 4){
          b = bmpBuf[i];
          g = bmpBuf[i + 1];
          r = bmpBuf[i + 2];
          a = bmpBuf[i + 3];
          colorData.push(this.mapRGBA(r, g, b, a));
        }
        return colorData;
      }
      throw new Error('unknown bitCount: ' + bitCount);
    };
    
  provide("node-bitmap/lib/bitmap", module.exports);
}(global));

// pakmanager:node-bitmap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('node-bitmap/lib/bitmap');
    
  provide("node-bitmap", module.exports);
}(global));

// pakmanager:through
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream')
    
    // through
    //
    // a stream that does nothing but re-emit the input.
    // useful for aggregating a series of changing but not ending streams into one stream)
    
    exports = module.exports = through
    through.through = through
    
    //create a readable writable stream.
    
    function through (write, end, opts) {
      write = write || function (data) { this.queue(data) }
      end = end || function () { this.queue(null) }
    
      var ended = false, destroyed = false, buffer = [], _ended = false
      var stream = new Stream()
      stream.readable = stream.writable = true
      stream.paused = false
    
    //  stream.autoPause   = !(opts && opts.autoPause   === false)
      stream.autoDestroy = !(opts && opts.autoDestroy === false)
    
      stream.write = function (data) {
        write.call(this, data)
        return !stream.paused
      }
    
      function drain() {
        while(buffer.length && !stream.paused) {
          var data = buffer.shift()
          if(null === data)
            return stream.emit('end')
          else
            stream.emit('data', data)
        }
      }
    
      stream.queue = stream.push = function (data) {
    //    console.error(ended)
        if(_ended) return stream
        if(data === null) _ended = true
        buffer.push(data)
        drain()
        return stream
      }
    
      //this will be registered as the first 'end' listener
      //must call destroy next tick, to make sure we're after any
      //stream piped from here.
      //this is only a problem if end is not emitted synchronously.
      //a nicer way to do this is to make sure this is the last listener for 'end'
    
      stream.on('end', function () {
        stream.readable = false
        if(!stream.writable && stream.autoDestroy)
          process.nextTick(function () {
            stream.destroy()
          })
      })
    
      function _end () {
        stream.writable = false
        end.call(stream)
        if(!stream.readable && stream.autoDestroy)
          stream.destroy()
      }
    
      stream.end = function (data) {
        if(ended) return
        ended = true
        if(arguments.length) stream.write(data)
        _end() // will emit or queue
        return stream
      }
    
      stream.destroy = function () {
        if(destroyed) return
        destroyed = true
        ended = true
        buffer.length = 0
        stream.writable = stream.readable = false
        stream.emit('close')
        return stream
      }
    
      stream.pause = function () {
        if(stream.paused) return
        stream.paused = true
        return stream
      }
    
      stream.resume = function () {
        if(stream.paused) {
          stream.paused = false
          stream.emit('resume')
        }
        drain()
        //may have become paused again,
        //as drain emits 'data'.
        if(!stream.paused)
          stream.emit('drain')
        return stream
      }
      return stream
    }
    
    
  provide("through", module.exports);
}(global));

// pakmanager:request/lib/cookies
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var tough = require('tough-cookie')
    
    var Cookie = tough.Cookie
      , CookieJar = tough.CookieJar
    
    
    exports.parse = function(str) {
      if (str && str.uri) {
        str = str.uri
      }
      if (typeof str !== 'string') {
        throw new Error('The cookie function only accepts STRING as param')
      }
      return Cookie.parse(str)
    }
    
    // Adapt the sometimes-Async api of tough.CookieJar to our requirements
    function RequestJar(store) {
      var self = this
      self._jar = new CookieJar(store)
    }
    RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
      var self = this
      return self._jar.setCookieSync(cookieOrStr, uri, options || {})
    }
    RequestJar.prototype.getCookieString = function(uri) {
      var self = this
      return self._jar.getCookieStringSync(uri)
    }
    RequestJar.prototype.getCookies = function(uri) {
      var self = this
      return self._jar.getCookiesSync(uri)
    }
    
    exports.jar = function(store) {
      return new RequestJar(store)
    }
    
  provide("request/lib/cookies", module.exports);
}(global));

// pakmanager:request/lib/helpers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var jsonSafeStringify = require('json-stringify-safe')
      , crypto = require('crypto')
    
    function deferMethod() {
      if (typeof setImmediate === 'undefined') {
        return process.nextTick
      }
    
      return setImmediate
    }
    
    function isFunction(value) {
      return typeof value === 'function'
    }
    
    function paramsHaveRequestBody(params) {
      return (
        params.body ||
        params.requestBodyStream ||
        (params.json && typeof params.json !== 'boolean') ||
        params.multipart
      )
    }
    
    function safeStringify (obj) {
      var ret
      try {
        ret = JSON.stringify(obj)
      } catch (e) {
        ret = jsonSafeStringify(obj)
      }
      return ret
    }
    
    function md5 (str) {
      return crypto.createHash('md5').update(str).digest('hex')
    }
    
    function isReadStream (rs) {
      return rs.readable && rs.path && rs.mode
    }
    
    function toBase64 (str) {
      return (new Buffer(str || '', 'utf8')).toString('base64')
    }
    
    function copy (obj) {
      var o = {}
      Object.keys(obj).forEach(function (i) {
        o[i] = obj[i]
      })
      return o
    }
    
    function version () {
      var numbers = process.version.replace('v', '').split('.')
      return {
        major: parseInt(numbers[0], 10),
        minor: parseInt(numbers[1], 10),
        patch: parseInt(numbers[2], 10)
      }
    }
    
    exports.isFunction            = isFunction
    exports.paramsHaveRequestBody = paramsHaveRequestBody
    exports.safeStringify         = safeStringify
    exports.md5                   = md5
    exports.isReadStream          = isReadStream
    exports.toBase64              = toBase64
    exports.copy                  = copy
    exports.version               = version
    exports.defer                 = deferMethod()
    
  provide("request/lib/helpers", module.exports);
}(global));

// pakmanager:request
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2010-2012 Mikeal Rogers
    //
    //    Licensed under the Apache License, Version 2.0 (the "License");
    //    you may not use this file except in compliance with the License.
    //    You may obtain a copy of the License at
    //
    //        http://www.apache.org/licenses/LICENSE-2.0
    //
    //    Unless required by applicable law or agreed to in writing, software
    //    distributed under the License is distributed on an "AS IS" BASIS,
    //    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    //    See the License for the specific language governing permissions and
    //    limitations under the License.
    
    'use strict'
    
    var extend                = require('extend')
      , cookies               =  require('request/lib/cookies')
      , helpers               =  require('request/lib/helpers')
    
    var isFunction            = helpers.isFunction
      , paramsHaveRequestBody = helpers.paramsHaveRequestBody
    
    
    // organize params for patch, post, put, head, del
    function initParams(uri, options, callback) {
      if (typeof options === 'function') {
        callback = options
      }
    
      var params = {}
      if (typeof options === 'object') {
        extend(params, options, {uri: uri})
      } else if (typeof uri === 'string') {
        extend(params, {uri: uri})
      } else {
        extend(params, uri)
      }
    
      params.callback = callback
      return params
    }
    
    function request (uri, options, callback) {
      if (typeof uri === 'undefined') {
        throw new Error('undefined is not a valid uri or options object.')
      }
    
      var params = initParams(uri, options, callback)
    
      if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {
        throw new Error('HTTP HEAD requests MUST NOT include a request body.')
      }
    
      return new request.Request(params)
    }
    
    function verbFunc (verb) {
      var method = verb === 'del' ? 'DELETE' : verb.toUpperCase()
      return function (uri, options, callback) {
        var params = initParams(uri, options, callback)
        params.method = method
        return request(params, params.callback)
      }
    }
    
    // define like this to please codeintel/intellisense IDEs
    request.get = verbFunc('get')
    request.head = verbFunc('head')
    request.post = verbFunc('post')
    request.put = verbFunc('put')
    request.patch = verbFunc('patch')
    request.del = verbFunc('del')
    
    request.jar = function (store) {
      return cookies.jar(store)
    }
    
    request.cookie = function (str) {
      return cookies.parse(str)
    }
    
    function wrapRequestMethod (method, options, requester, verb) {
    
      return function (uri, opts, callback) {
        var params = initParams(uri, opts, callback)
    
        var target = {}
        extend(true, target, options, params)
    
        target.pool = params.pool || options.pool
    
        if (verb) {
          target.method = (verb === 'del' ? 'DELETE' : verb.toUpperCase())
        }
    
        if (isFunction(requester)) {
          method = requester
        }
    
        return method(target, target.callback)
      }
    }
    
    request.defaults = function (options, requester) {
      var self = this
    
      options = options || {}
    
      if (typeof options === 'function') {
        requester = options
        options = {}
      }
    
      var defaults      = wrapRequestMethod(self, options, requester)
    
      var verbs = ['get', 'head', 'post', 'put', 'patch', 'del']
      verbs.forEach(function(verb) {
        defaults[verb]  = wrapRequestMethod(self[verb], options, requester, verb)
      })
    
      defaults.cookie   = wrapRequestMethod(self.cookie, options, requester)
      defaults.jar      = self.jar
      defaults.defaults = self.defaults
      return defaults
    }
    
    request.forever = function (agentOptions, optionsArg) {
      var options = {}
      if (optionsArg) {
        extend(options, optionsArg)
      }
      if (agentOptions) {
        options.agentOptions = agentOptions
      }
    
      options.forever = true
      return request.defaults(options)
    }
    
    // Exports
    
    module.exports = request
    request.Request =   require('request')
    request.initParams = initParams
    
    // Backwards compatibility for request.debug
    Object.defineProperty(request, 'debug', {
      enumerable : true,
      get : function() {
        return request.Request.debug
      },
      set : function(debug) {
        request.Request.debug = debug
      }
    })
    
  provide("request", module.exports);
}(global));

// pakmanager:parse-data-uri
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var toBuffer = require('data-uri-to-buffer')
    
    function parseDataUri (dataUri) {
    
      return {
        mimeType: normalizeMimeType(parseMimeType(dataUri)),
        data: toBuffer(dataUri)
      }
    }
    
    function parseMimeType(uri) {
      return uri.substring(5, uri.indexOf(';'))
    }
    
    var prefix = /^(\w+\/)+/
    function normalizeMimeType(mime) {
      mime = mime.toLowerCase()
      var once = mime.match(prefix)
      if (!once || !(once = once[1])) {
        return mime
      }
      return mime.replace(prefix, once)
    
    }
    
    module.exports = parseDataUri
  provide("parse-data-uri", module.exports);
}(global));

// pakmanager:cwise/lib/cwise-transform.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    module.exports = cwiseTransform
    
    var staticModule = require("static-module")
    var parse = require("cwise-parser")
    var uglify = require("uglify-js")
    
    var REQUIRED_FIELDS = [ "args", "body" ]
    var OPTIONAL_FIELDS = [ "pre", "post", "printCode", "funcName", "blockSize" ]
    
    function processFunc(func) {
      var codeStr = "var X=" + func
      var minified = uglify.minify(codeStr, {fromString: true}).code
      var code = minified.substr(6, minified.length-7)
      return parse(code)
    }
    
    function cwiseTransform(file, opts) {
      var sm = staticModule({
        cwise: function(user_args) {
          for(var id in user_args) {
            if(REQUIRED_FIELDS.indexOf(id) < 0 &&
               OPTIONAL_FIELDS.indexOf(id) < 0) {
              console.warn("cwise: Unknown argument '"+id+"' passed to expression compiler")
            }
          }
          for(var i=0; i<REQUIRED_FIELDS.length; ++i) {
            if(!user_args[REQUIRED_FIELDS[i]]) {
              throw new Error("cwise: Missing argument: " + REQUIRED_FIELDS[i])
            }
          }
          var compileBlock = {
            args:       user_args.args,
            pre:        processFunc(user_args.pre || function(){}),
            body:       processFunc(user_args.body),
            post:       processFunc(user_args.post || function(){}),
            debug:      !!user_args.printCode,
            funcName:   user_args.funcName || user_args.body.name || "cwise",
            blockSize:  user_args.blockSize || 64
          }
          var codeStr = "require('cwise/lib/wrapper')(" + JSON.stringify(compileBlock) + ")"
          return codeStr
        }
      })
      return sm
    }
  provide("cwise/lib/cwise-transform.js", module.exports);
}(global));

// pakmanager:cwise/lib/cwise-esprima.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    var parse   = require("cwise-parser")
    var compile = require("cwise-compiler")
    
    var REQUIRED_FIELDS = [ "args", "body" ]
    var OPTIONAL_FIELDS = [ "pre", "post", "printCode", "funcName", "blockSize" ]
    
    function createCWise(user_args) {
      //Check parameters
      for(var id in user_args) {
        if(REQUIRED_FIELDS.indexOf(id) < 0 &&
           OPTIONAL_FIELDS.indexOf(id) < 0) {
          console.warn("cwise: Unknown argument '"+id+"' passed to expression compiler")
        }
      }
      for(var i=0; i<REQUIRED_FIELDS.length; ++i) {
        if(!user_args[REQUIRED_FIELDS[i]]) {
          throw new Error("cwise: Missing argument: " + REQUIRED_FIELDS[i])
        }
      }
      
      //Parse blocks
      return compile({
        args:       user_args.args,
        pre:        parse(user_args.pre || function(){}),
        body:       parse(user_args.body),
        post:       parse(user_args.post || function(){}),
        debug:      !!user_args.printCode,
        funcName:   user_args.funcName || user_args.body.name || "cwise",
        blockSize:  user_args.blockSize || 64
      })
    }
    
    module.exports = createCWise
    
  provide("cwise/lib/cwise-esprima.js", module.exports);
}(global));

// pakmanager:cwise
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    var transform =  require('cwise/lib/cwise-transform.js')
    var base =  require('cwise/lib/cwise-esprima.js')
    
    module.exports = function(a, b) {
      if(typeof a === "string") {
        return transform(a, b)
      } else if(typeof a === "object") {
        return base(a)
      } else {
        throw new Error("cwise: Invalid arguments")
      }
    }
  provide("cwise", module.exports);
}(global));

// pakmanager:contentstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**!
     * contentstream - index.js
     *
     * Copyright(c) fengmk2 and other contributors.
     * MIT Licensed
     *
     * Authors:
     *   fengmk2 <fengmk2@gmail.com> (http://fengmk2.github.com)
     */
    
    'use strict';
    
    /**
     * Module dependencies.
     */
    
    var Readable = require('readable-stream').Readable;
    var util = require('util');
    
    module.exports = ContentStream;
    
    function ContentStream(obj, options) {
      if (!(this instanceof ContentStream)) {
        return new ContentStream(obj, options);
      }
      Readable.call(this, options);
      if (obj === null || obj === undefined) {
        obj = String(obj);
      }
      this._obj = obj;
    }
    
    util.inherits(ContentStream, Readable);
    
    ContentStream.prototype._read = function (n) {
      var obj = this._obj;
      if (typeof obj === 'string') {
        this.push(new Buffer(obj));
      } else if (Buffer.isBuffer(obj)) {
        this.push(obj);
      } else {
        this.push(new Buffer(JSON.stringify(obj)));
      }
      this.push(null);
    };
    
  provide("contentstream", module.exports);
}(global));

// pakmanager:gif-encoder/lib/TypedNeuQuant.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* NeuQuant Neural-Net Quantization Algorithm
     * ------------------------------------------
     *
     * Copyright (c) 1994 Anthony Dekker
     *
     * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.
     * See "Kohonen neural networks for optimal colour quantization"
     * in "Network: Computation in Neural Systems" Vol. 5 (1994) pp 351-367.
     * for a discussion of the algorithm.
     * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML
     *
     * Any party obtaining a copy of these files from the author, directly or
     * indirectly, is granted, free of charge, a full and unrestricted irrevocable,
     * world-wide, paid up, royalty-free, nonexclusive right and license to deal
     * in this software and documentation files (the "Software"), including without
     * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
     * and/or sell copies of the Software, and to permit persons who receive
     * copies from any such party to do so, with the only requirement being
     * that this copyright notice remain intact.
     *
     * (JavaScript port 2012 by Johan Nordberg)
     */
    
    var ncycles = 100; // number of learning cycles
    var netsize = 256; // number of colors used
    var maxnetpos = netsize - 1;
    
    // defs for freq and bias
    var netbiasshift = 4; // bias for colour values
    var intbiasshift = 16; // bias for fractions
    var intbias = (1 << intbiasshift);
    var gammashift = 10;
    var gamma = (1 << gammashift);
    var betashift = 10;
    var beta = (intbias >> betashift); /* beta = 1/1024 */
    var betagamma = (intbias << (gammashift - betashift));
    
    // defs for decreasing radius factor
    var initrad = (netsize >> 3); // for 256 cols, radius starts
    var radiusbiasshift = 6; // at 32.0 biased by 6 bits
    var radiusbias = (1 << radiusbiasshift);
    var initradius = (initrad * radiusbias); //and decreases by a
    var radiusdec = 30; // factor of 1/30 each cycle
    
    // defs for decreasing alpha factor
    var alphabiasshift = 10; // alpha starts at 1.0
    var initalpha = (1 << alphabiasshift);
    var alphadec; // biased by 10 bits
    
    /* radbias and alpharadbias used for radpower calculation */
    var radbiasshift = 8;
    var radbias = (1 << radbiasshift);
    var alpharadbshift = (alphabiasshift + radbiasshift);
    var alpharadbias = (1 << alpharadbshift);
    
    // four primes near 500 - assume no image has a length so large that it is
    // divisible by all four primes
    var prime1 = 499;
    var prime2 = 491;
    var prime3 = 487;
    var prime4 = 503;
    var minpicturebytes = (3 * prime4);
    
    /*
      Constructor: NeuQuant
    
      Arguments:
    
      pixels - array of pixels in RGB format
      samplefac - sampling factor 1 to 30 where lower is better quality
    
      >
      > pixels = [r, g, b, r, g, b, r, g, b, ..]
      >
    */
    function NeuQuant(pixels, samplefac) {
      var network; // int[netsize][4]
      var netindex; // for network lookup - really 256
    
      // bias and freq arrays for learning
      var bias;
      var freq;
      var radpower;
    
      /*
        Private Method: init
    
        sets up arrays
      */
      function init() {
        network = [];
        netindex = new Int32Array(256);
        bias = new Int32Array(netsize);
        freq = new Int32Array(netsize);
        radpower = new Int32Array(netsize >> 3);
    
        var i, v;
        for (i = 0; i < netsize; i++) {
          v = (i << (netbiasshift + 8)) / netsize;
          network[i] = new Float64Array([v, v, v, 0]);
          //network[i] = [v, v, v, 0]
          freq[i] = intbias / netsize;
          bias[i] = 0;
        }
      }
    
      /*
        Private Method: unbiasnet
    
        unbiases network to give byte values 0..255 and record position i to prepare for sort
      */
      function unbiasnet() {
        for (var i = 0; i < netsize; i++) {
          network[i][0] >>= netbiasshift;
          network[i][1] >>= netbiasshift;
          network[i][2] >>= netbiasshift;
          network[i][3] = i; // record color number
        }
      }
    
      /*
        Private Method: altersingle
    
        moves neuron *i* towards biased (b,g,r) by factor *alpha*
      */
      function altersingle(alpha, i, b, g, r) {
        network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;
        network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;
        network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;
      }
    
      /*
        Private Method: alterneigh
    
        moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*
      */
      function alterneigh(radius, i, b, g, r) {
        var lo = Math.abs(i - radius);
        var hi = Math.min(i + radius, netsize);
    
        var j = i + 1;
        var k = i - 1;
        var m = 1;
    
        var p, a;
        while ((j < hi) || (k > lo)) {
          a = radpower[m++];
    
          if (j < hi) {
            p = network[j++];
            p[0] -= (a * (p[0] - b)) / alpharadbias;
            p[1] -= (a * (p[1] - g)) / alpharadbias;
            p[2] -= (a * (p[2] - r)) / alpharadbias;
          }
    
          if (k > lo) {
            p = network[k--];
            p[0] -= (a * (p[0] - b)) / alpharadbias;
            p[1] -= (a * (p[1] - g)) / alpharadbias;
            p[2] -= (a * (p[2] - r)) / alpharadbias;
          }
        }
      }
    
      /*
        Private Method: contest
    
        searches for biased BGR values
      */
      function contest(b, g, r) {
        /*
          finds closest neuron (min dist) and updates freq
          finds best neuron (min dist-bias) and returns position
          for frequently chosen neurons, freq[i] is high and bias[i] is negative
          bias[i] = gamma * ((1 / netsize) - freq[i])
        */
    
        var bestd = ~(1 << 31);
        var bestbiasd = bestd;
        var bestpos = -1;
        var bestbiaspos = bestpos;
    
        var i, n, dist, biasdist, betafreq;
        for (i = 0; i < netsize; i++) {
          n = network[i];
    
          dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);
          if (dist < bestd) {
            bestd = dist;
            bestpos = i;
          }
    
          biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));
          if (biasdist < bestbiasd) {
            bestbiasd = biasdist;
            bestbiaspos = i;
          }
    
          betafreq = (freq[i] >> betashift);
          freq[i] -= betafreq;
          bias[i] += (betafreq << gammashift);
        }
    
        freq[bestpos] += beta;
        bias[bestpos] -= betagamma;
    
        return bestbiaspos;
      }
    
      /*
        Private Method: inxbuild
    
        sorts network and builds netindex[0..255]
      */
      function inxbuild() {
        var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;
        for (i = 0; i < netsize; i++) {
          p = network[i];
          smallpos = i;
          smallval = p[1]; // index on g
          // find smallest in i..netsize-1
          for (j = i + 1; j < netsize; j++) {
            q = network[j];
            if (q[1] < smallval) { // index on g
              smallpos = j;
              smallval = q[1]; // index on g
            }
          }
          q = network[smallpos];
          // swap p (i) and q (smallpos) entries
          if (i != smallpos) {
            j = q[0];   q[0] = p[0];   p[0] = j;
            j = q[1];   q[1] = p[1];   p[1] = j;
            j = q[2];   q[2] = p[2];   p[2] = j;
            j = q[3];   q[3] = p[3];   p[3] = j;
          }
          // smallval entry is now in position i
    
          if (smallval != previouscol) {
            netindex[previouscol] = (startpos + i) >> 1;
            for (j = previouscol + 1; j < smallval; j++)
              netindex[j] = i;
            previouscol = smallval;
            startpos = i;
          }
        }
        netindex[previouscol] = (startpos + maxnetpos) >> 1;
        for (j = previouscol + 1; j < 256; j++)
          netindex[j] = maxnetpos; // really 256
      }
    
      /*
        Private Method: inxsearch
    
        searches for BGR values 0..255 and returns a color index
      */
      function inxsearch(b, g, r) {
        var a, p, dist;
    
        var bestd = 1000; // biggest possible dist is 256*3
        var best = -1;
    
        var i = netindex[g]; // index on g
        var j = i - 1; // start at netindex[g] and work outwards
    
        while ((i < netsize) || (j >= 0)) {
          if (i < netsize) {
            p = network[i];
            dist = p[1] - g; // inx key
            if (dist >= bestd) i = netsize; // stop iter
            else {
              i++;
              if (dist < 0) dist = -dist;
              a = p[0] - b; if (a < 0) a = -a;
              dist += a;
              if (dist < bestd) {
                a = p[2] - r; if (a < 0) a = -a;
                dist += a;
                if (dist < bestd) {
                  bestd = dist;
                  best = p[3];
                }
              }
            }
          }
          if (j >= 0) {
            p = network[j];
            dist = g - p[1]; // inx key - reverse dif
            if (dist >= bestd) j = -1; // stop iter
            else {
              j--;
              if (dist < 0) dist = -dist;
              a = p[0] - b; if (a < 0) a = -a;
              dist += a;
              if (dist < bestd) {
                a = p[2] - r; if (a < 0) a = -a;
                dist += a;
                if (dist < bestd) {
                  bestd = dist;
                  best = p[3];
                }
              }
            }
          }
        }
    
        return best;
      }
    
      /*
        Private Method: learn
    
        "Main Learning Loop"
      */
      function learn() {
        var i;
    
        var lengthcount = pixels.length;
        var alphadec = 30 + ((samplefac - 1) / 3);
        var samplepixels = lengthcount / (3 * samplefac);
        var delta = ~~(samplepixels / ncycles);
        var alpha = initalpha;
        var radius = initradius;
    
        var rad = radius >> radiusbiasshift;
    
        if (rad <= 1) rad = 0;
        for (i = 0; i < rad; i++)
          radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));
    
        var step;
        if (lengthcount < minpicturebytes) {
          samplefac = 1;
          step = 3;
        } else if ((lengthcount % prime1) !== 0) {
          step = 3 * prime1;
        } else if ((lengthcount % prime2) !== 0) {
          step = 3 * prime2;
        } else if ((lengthcount % prime3) !== 0)  {
          step = 3 * prime3;
        } else {
          step = 3 * prime4;
        }
    
        var b, g, r, j;
        var pix = 0; // current pixel
    
        i = 0;
        while (i < samplepixels) {
          b = (pixels[pix] & 0xff) << netbiasshift;
          g = (pixels[pix + 1] & 0xff) << netbiasshift;
          r = (pixels[pix + 2] & 0xff) << netbiasshift;
    
          j = contest(b, g, r);
    
          altersingle(alpha, j, b, g, r);
          if (rad !== 0) alterneigh(rad, j, b, g, r); // alter neighbours
    
          pix += step;
          if (pix >= lengthcount) pix -= lengthcount;
    
          i++;
    
          if (delta === 0) delta = 1;
          if (i % delta === 0) {
            alpha -= alpha / alphadec;
            radius -= radius / radiusdec;
            rad = radius >> radiusbiasshift;
    
            if (rad <= 1) rad = 0;
            for (j = 0; j < rad; j++)
              radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));
          }
        }
      }
    
      /*
        Method: buildColormap
    
        1. initializes network
        2. trains it
        3. removes misconceptions
        4. builds colorindex
      */
      function buildColormap() {
        init();
        learn();
        unbiasnet();
        inxbuild();
      }
      this.buildColormap = buildColormap;
    
      /*
        Method: getColormap
    
        builds colormap from the index
    
        returns array in the format:
    
        >
        > [r, g, b, r, g, b, r, g, b, ..]
        >
      */
      function getColormap() {
        var map = [];
        var index = [];
    
        for (var i = 0; i < netsize; i++)
          index[network[i][3]] = i;
    
        var k = 0;
        for (var l = 0; l < netsize; l++) {
          var j = index[l];
          map[k++] = (network[j][0]);
          map[k++] = (network[j][1]);
          map[k++] = (network[j][2]);
        }
        return map;
      }
      this.getColormap = getColormap;
    
      /*
        Method: lookupRGB
    
        looks for the closest *r*, *g*, *b* color in the map and
        returns its index
      */
      this.lookupRGB = inxsearch;
    }
    
    module.exports = NeuQuant;
    
  provide("gif-encoder/lib/TypedNeuQuant.js", module.exports);
}(global));

// pakmanager:gif-encoder/lib/LZWEncoder.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      LZWEncoder.js
    
      Authors
      Kevin Weiner (original Java version - kweiner@fmsware.com)
      Thibault Imbert (AS3 version - bytearray.org)
      Johan Nordberg (JS version - code@johan-nordberg.com)
    
      Acknowledgements
      GIFCOMPR.C - GIF Image compression routines
      Lempel-Ziv compression based on 'compress'. GIF modifications by
      David Rowley (mgardi@watdcsu.waterloo.edu)
      GIF Image compression - modified 'compress'
      Based on: compress.c - File compression ala IEEE Computer, June 1984.
      By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)
      Jim McKie (decvax!mcvax!jim)
      Steve Davies (decvax!vax135!petsd!peora!srd)
      Ken Turkowski (decvax!decwrl!turtlevax!ken)
      James A. Woods (decvax!ihnp4!ames!jaw)
      Joe Orost (decvax!vax135!petsd!joe)
    */
    
    var EOF = -1;
    var BITS = 12;
    var HSIZE = 5003; // 80% occupancy
    var masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F,
                 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF,
                 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];
    
    function LZWEncoder(width, height, pixels, colorDepth) {
      var initCodeSize = Math.max(2, colorDepth);
    
      var accum = new Uint8Array(256);
      var htab = new Int32Array(HSIZE);
      var codetab = new Int32Array(HSIZE);
    
      var cur_accum, cur_bits = 0;
      var a_count;
      var free_ent = 0; // first unused entry
      var maxcode;
    
      // block compression parameters -- after all codes are used up,
      // and compression rate changes, start over.
      var clear_flg = false;
    
      // Algorithm: use open addressing double hashing (no chaining) on the
      // prefix code / next character combination. We do a variant of Knuth's
      // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
      // secondary probe. Here, the modular division first probe is gives way
      // to a faster exclusive-or manipulation. Also do block compression with
      // an adaptive reset, whereby the code table is cleared when the compression
      // ratio decreases, but after the table fills. The variable-length output
      // codes are re-sized at this point, and a special CLEAR code is generated
      // for the decompressor. Late addition: construct the table according to
      // file size for noticeable speed improvement on small files. Please direct
      // questions about this implementation to ames!jaw.
      var g_init_bits, ClearCode, EOFCode;
    
      // Add a character to the end of the current packet, and if it is 254
      // characters, flush the packet to disk.
      function char_out(c, outs) {
        accum[a_count++] = c;
        if (a_count >= 254) flush_char(outs);
      }
    
      // Clear out the hash table
      // table clear for block compress
      function cl_block(outs) {
        cl_hash(HSIZE);
        free_ent = ClearCode + 2;
        clear_flg = true;
        output(ClearCode, outs);
      }
    
      // Reset code table
      function cl_hash(hsize) {
        for (var i = 0; i < hsize; ++i) htab[i] = -1;
      }
    
      function compress(init_bits, outs) {
        var fcode, c, i, ent, disp, hsize_reg, hshift;
    
        // Set up the globals: g_init_bits - initial number of bits
        g_init_bits = init_bits;
    
        // Set up the necessary values
        clear_flg = false;
        n_bits = g_init_bits;
        maxcode = MAXCODE(n_bits);
    
        ClearCode = 1 << (init_bits - 1);
        EOFCode = ClearCode + 1;
        free_ent = ClearCode + 2;
    
        a_count = 0; // clear packet
    
        ent = nextPixel();
    
        hshift = 0;
        for (fcode = HSIZE; fcode < 65536; fcode *= 2) ++hshift;
        hshift = 8 - hshift; // set hash code range bound
        hsize_reg = HSIZE;
        cl_hash(hsize_reg); // clear hash table
    
        output(ClearCode, outs);
    
        outer_loop: while ((c = nextPixel()) != EOF) {
          fcode = (c << BITS) + ent;
          i = (c << hshift) ^ ent; // xor hashing
          if (htab[i] === fcode) {
            ent = codetab[i];
            continue;
          } else if (htab[i] >= 0) { // non-empty slot
            disp = hsize_reg - i; // secondary hash (after G. Knott)
            if (i === 0) disp = 1;
            do {
              if ((i -= disp) < 0) i += hsize_reg;
              if (htab[i] === fcode) {
                ent = codetab[i];
                continue outer_loop;
              }
            } while (htab[i] >= 0);
          }
          output(ent, outs);
          ent = c;
          if (free_ent < 1 << BITS) {
            codetab[i] = free_ent++; // code -> hashtable
            htab[i] = fcode;
          } else {
            cl_block(outs);
          }
        }
    
        // Put out the final code.
        output(ent, outs);
        output(EOFCode, outs);
      }
    
      function encode(outs) {
        outs.writeByte(initCodeSize); // write "initial code size" byte
        remaining = width * height; // reset navigation variables
        curPixel = 0;
        compress(initCodeSize + 1, outs); // compress and write the pixel data
        outs.writeByte(0); // write block terminator
      }
    
      // Flush the packet to disk, and reset the accumulator
      function flush_char(outs) {
        if (a_count > 0) {
          outs.writeByte(a_count);
          outs.writeBytes(accum, 0, a_count);
          a_count = 0;
        }
      }
    
      function MAXCODE(n_bits) {
        return (1 << n_bits) - 1;
      }
    
      // Return the next pixel from the image
      function nextPixel() {
        if (remaining === 0) return EOF;
        --remaining;
        var pix = pixels[curPixel++];
        return pix & 0xff;
      }
    
      function output(code, outs) {
        cur_accum &= masks[cur_bits];
    
        if (cur_bits > 0) cur_accum |= (code << cur_bits);
        else cur_accum = code;
    
        cur_bits += n_bits;
    
        while (cur_bits >= 8) {
          char_out((cur_accum & 0xff), outs);
          cur_accum >>= 8;
          cur_bits -= 8;
        }
    
        // If the next entry is going to be too big for the code size,
        // then increase it, if possible.
        if (free_ent > maxcode || clear_flg) {
          if (clear_flg) {
            maxcode = MAXCODE(n_bits = g_init_bits);
            clear_flg = false;
          } else {
            ++n_bits;
            if (n_bits == BITS) maxcode = 1 << BITS;
            else maxcode = MAXCODE(n_bits);
          }
        }
    
        if (code == EOFCode) {
          // At EOF, write the rest of the buffer.
          while (cur_bits > 0) {
            char_out((cur_accum & 0xff), outs);
            cur_accum >>= 8;
            cur_bits -= 8;
          }
          flush_char(outs);
        }
      }
    
      this.encode = encode;
    }
    
    module.exports = LZWEncoder;
    
  provide("gif-encoder/lib/LZWEncoder.js", module.exports);
}(global));

// pakmanager:gif-encoder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      GIFEncoder.js
    
      Authors
      Kevin Weiner (original Java version - kweiner@fmsware.com)
      Thibault Imbert (AS3 version - bytearray.org)
      Johan Nordberg (JS version - code@johan-nordberg.com)
      Todd Wolfson (Implemented streams - todd@twolfson.com)
    */
    
    var assert = require('assert');
    var EventEmitter = require('events').EventEmitter;
    var ReadableStream = require('readable-stream');
    var util = require('util');
    
    var NeuQuant =  require('gif-encoder/lib/TypedNeuQuant.js');
    var LZWEncoder =  require('gif-encoder/lib/LZWEncoder.js');
    
    // DEV: By using a capacitor, we prevent creating a data event for every byte written
    function ByteCapacitor(options) {
      // Inherit from ReadableStream
      ReadableStream.call(this, options);
    
      // Start with an empty buffer and allow writes
      this.okayToPush = true;
      this.resetData();
    }
    util.inherits(ByteCapacitor, ReadableStream);
    
    ByteCapacitor.prototype._read = function () {
      // The output is controlled by the input provided by methods.
      // If we exceed the highwater mark, we will raise an error.
      this.okayToPush = true;
    };
    
    ByteCapacitor.prototype.resetData = function () {
      this.data = [];
    };
    
    ByteCapacitor.prototype.flushData = function () {
      // If we are not okay to push, emit an error
      if (!this.okayToPush) {
        var err = new Error('GIF memory limit exceeded. Please `read` from GIF before writing additional frames/information.');
        return this.emit('error', err);
      }
    
      // Otherwise, push out the new buffer
      var buff = new Buffer(this.data);
      this.resetData();
      this.okayToPush = this.push(buff);
    };
    
    ByteCapacitor.prototype.writeByte = function (val) {
      this.data.push(val);
    };
    
    ByteCapacitor.prototype.writeUTFBytes = function (string) {
      for (var l = string.length, i = 0; i < l; i++) {
        this.writeByte(string.charCodeAt(i));
      }
    };
    
    ByteCapacitor.prototype.writeBytes = function (array, offset, length) {
      for (var l = length || array.length, i = offset || 0; i < l; i++) {
        this.writeByte(array[i]);
      }
    };
    
    function GIFEncoder(width, height, options) {
      // Fallback options
      options = options || {};
    
      // Inherit from ByteCapacitor immediately
      // https://github.com/isaacs/readable-stream/blob/v1.1.9/lib/_stream_readable.js#L60-L63
      var hwm = options.highWaterMark;
      ByteCapacitor.call(this, {
        // Allow for up to 64kB of GIFfy-goodness
        highWaterMark: (hwm || hwm === 0) ? hwm : 64 * 1024
      });
    
      // image size
      this.width = ~~width;
      this.height = ~~height;
    
      // transparent color if given
      this.transparent = null;
    
      // transparent index in color table
      this.transIndex = 0;
    
      // -1 = no repeat, 0 = forever. anything else is repeat count
      this.repeat = -1;
    
      // frame delay (hundredths)
      this.delay = 0;
    
      this.pixels = null; // BGR byte array from frame
      this.indexedPixels = null; // converted frame indexed to palette
      this.colorDepth = null; // number of bit planes
      this.colorTab = null; // RGB palette
      this.usedEntry = []; // active palette entries
      this.palSize = 7; // color table size (bits-1)
      this.dispose = -1; // disposal code (-1 = use default)
      this.firstFrame = true;
      this.sample = 10; // default sample interval for quantizer
    
      // When we encounter a header, new frame, or stop, emit data
      var that = this;
      function flushData() {
        that.flushData();
      }
      this.on('writeHeader#stop', flushData);
      this.on('frame#stop', flushData);
      this.on('finish#stop', function finishGif () {
        // Flush the data
        flushData();
    
        // Close the gif
        that.push(null);
      });
    }
    util.inherits(GIFEncoder, ByteCapacitor);
    
    /*
      Sets the delay time between each frame, or changes it for subsequent frames
      (applies to last frame added)
    */
    GIFEncoder.prototype.setDelay = function(milliseconds) {
      this.delay = Math.round(milliseconds / 10);
    };
    
    /*
      Sets frame rate in frames per second.
    */
    GIFEncoder.prototype.setFrameRate = function(fps) {
      this.delay = Math.round(100 / fps);
    };
    
    /*
      Sets the GIF frame disposal code for the last added frame and any
      subsequent frames.
    
      Default is 0 if no transparent color has been set, otherwise 2.
    */
    GIFEncoder.prototype.setDispose = function(disposalCode) {
      if (disposalCode >= 0) this.dispose = disposalCode;
    };
    
    /*
      Sets the number of times the set of GIF frames should be played.
    
      -1 = play once
      0 = repeat indefinitely
    
      Default is -1
    
      Must be invoked before the first image is added
    */
    
    GIFEncoder.prototype.setRepeat = function(repeat) {
      this.repeat = repeat;
    };
    
    /*
      Sets the transparent color for the last added frame and any subsequent
      frames. Since all colors are subject to modification in the quantization
      process, the color in the final palette for each frame closest to the given
      color becomes the transparent color for that frame. May be set to null to
      indicate no transparent color.
    */
    GIFEncoder.prototype.setTransparent = function(color) {
      this.transparent = color;
    };
    
    // Custom methods for performance hacks around streaming GIF data pieces without re-analyzing/loading
    GIFEncoder.prototype.analyzeImage = function (imageData) {
      // convert to correct format if necessary
      this.setImagePixels(this.removeAlphaChannel(imageData));
      this.analyzePixels(); // build color table & map pixels
    };
    
    GIFEncoder.prototype.writeImageInfo = function () {
      if (this.firstFrame) {
        this.writeLSD(); // logical screen descriptior
        this.writePalette(); // global color table
        if (this.repeat >= 0) {
          // use NS app extension to indicate reps
          this.writeNetscapeExt();
        }
      }
    
      this.writeGraphicCtrlExt(); // write graphic control extension
      this.writeImageDesc(); // image descriptor
      if (!this.firstFrame) this.writePalette(); // local color table
    
      // DEV: This was originally after outputImage but it does not affect order it seems
      this.firstFrame = false;
    };
    
    GIFEncoder.prototype.outputImage = function () {
      this.writePixels(); // encode and write pixel data
    };
    
    /*
      Adds next GIF frame. The frame is not written immediately, but is
      actually deferred until the next frame is received so that timing
      data can be inserted.  Invoking finish() flushes all frames.
    */
    GIFEncoder.prototype.addFrame = function(imageData) {
      this.emit('frame#start');
    
      this.analyzeImage(imageData);
      this.writeImageInfo();
      this.outputImage();
    
      this.emit('frame#stop');
    };
    
    /*
      Adds final trailer to the GIF stream, if you don't call the finish method
      the GIF stream will not be valid.
    */
    GIFEncoder.prototype.finish = function() {
      this.emit('finish#start');
      this.writeByte(0x3b); // gif trailer
      this.emit('finish#stop');
    };
    
    /*
      Sets quality of color quantization (conversion of images to the maximum 256
      colors allowed by the GIF specification). Lower values (minimum = 1)
      produce better colors, but slow processing significantly. 10 is the
      default, and produces good color mapping at reasonable speeds. Values
      greater than 20 do not yield significant improvements in speed.
    */
    GIFEncoder.prototype.setQuality = function(quality) {
      if (quality < 1) quality = 1;
      this.sample = quality;
    };
    
    /*
      Writes GIF file header
    */
    GIFEncoder.prototype.writeHeader = function() {
      this.emit('writeHeader#start');
      this.writeUTFBytes("GIF89a");
      this.emit('writeHeader#stop');
    };
    
    /*
      Analyzes current frame colors and creates color map.
    */
    GIFEncoder.prototype.analyzePixels = function() {
      var len = this.pixels.length;
      var nPix = len / 3;
    
      // TODO: Re-use indexedPixels
      this.indexedPixels = new Uint8Array(nPix);
    
      var imgq = new NeuQuant(this.pixels, this.sample);
      imgq.buildColormap(); // create reduced palette
      this.colorTab = imgq.getColormap();
    
      // map image pixels to new palette
      var k = 0;
      for (var j = 0; j < nPix; j++) {
        var index = imgq.lookupRGB(
          this.pixels[k++] & 0xff,
          this.pixels[k++] & 0xff,
          this.pixels[k++] & 0xff
        );
        this.usedEntry[index] = true;
        this.indexedPixels[j] = index;
      }
    
      this.pixels = null;
      this.colorDepth = 8;
      this.palSize = 7;
    
      // get closest match to transparent color if specified
      if (this.transparent !== null) {
        this.transIndex = this.findClosest(this.transparent);
      }
    };
    
    /*
      Returns index of palette color closest to c
    */
    GIFEncoder.prototype.findClosest = function(c) {
      if (this.colorTab === null) return -1;
    
      var r = (c & 0xFF0000) >> 16;
      var g = (c & 0x00FF00) >> 8;
      var b = (c & 0x0000FF);
      var minpos = 0;
      var dmin = 256 * 256 * 256;
      var len = this.colorTab.length;
    
      for (var i = 0; i < len;) {
        var dr = r - (this.colorTab[i++] & 0xff);
        var dg = g - (this.colorTab[i++] & 0xff);
        var db = b - (this.colorTab[i] & 0xff);
        var d = dr * dr + dg * dg + db * db;
        var index = i / 3;
        if (this.usedEntry[index] && (d < dmin)) {
          dmin = d;
          minpos = index;
        }
        i++;
      }
    
      return minpos;
    };
    
    /*
      Extracts image pixels into byte array pixels
      (removes alphachannel from canvas imagedata)
    */
    GIFEncoder.prototype.removeAlphaChannel = function (data) {
      var w = this.width;
      var h = this.height;
      var pixels = new Uint8Array(w * h * 3);
    
      var count = 0;
    
      for (var i = 0; i < h; i++) {
        for (var j = 0; j < w; j++) {
          var b = (i * w * 4) + j * 4;
          pixels[count++] = data[b];
          pixels[count++] = data[b+1];
          pixels[count++] = data[b+2];
        }
      }
    
      return pixels;
    };
    
    GIFEncoder.prototype.setImagePixels = function(pixels) {
      this.pixels = pixels;
    };
    
    /*
      Writes Graphic Control Extension
    */
    GIFEncoder.prototype.writeGraphicCtrlExt = function() {
      this.writeByte(0x21); // extension introducer
      this.writeByte(0xf9); // GCE label
      this.writeByte(4); // data block size
    
      var transp, disp;
      if (this.transparent === null) {
        transp = 0;
        disp = 0; // dispose = no action
      } else {
        transp = 1;
        disp = 2; // force clear if using transparent color
      }
    
      if (this.dispose >= 0) {
        disp = dispose & 7; // user override
      }
      disp <<= 2;
    
      // packed fields
      this.writeByte(
        0 | // 1:3 reserved
        disp | // 4:6 disposal
        0 | // 7 user input - 0 = none
        transp // 8 transparency flag
      );
    
      this.writeShort(this.delay); // delay x 1/100 sec
      this.writeByte(this.transIndex); // transparent color index
      this.writeByte(0); // block terminator
    };
    
    /*
      Writes Image Descriptor
    */
    GIFEncoder.prototype.writeImageDesc = function() {
      this.writeByte(0x2c); // image separator
      this.writeShort(0); // image position x,y = 0,0
      this.writeShort(0);
      this.writeShort(this.width); // image size
      this.writeShort(this.height);
    
      // packed fields
      if (this.firstFrame) {
        // no LCT - GCT is used for first (or only) frame
        this.writeByte(0);
      } else {
        // specify normal LCT
        this.writeByte(
          0x80 | // 1 local color table 1=yes
          0 | // 2 interlace - 0=no
          0 | // 3 sorted - 0=no
          0 | // 4-5 reserved
          this.palSize // 6-8 size of color table
        );
      }
    };
    
    /*
      Writes Logical Screen Descriptor
    */
    GIFEncoder.prototype.writeLSD = function() {
      // logical screen size
      this.writeShort(this.width);
      this.writeShort(this.height);
    
      // packed fields
      this.writeByte(
        0x80 | // 1 : global color table flag = 1 (gct used)
        0x70 | // 2-4 : color resolution = 7
        0x00 | // 5 : gct sort flag = 0
        this.palSize // 6-8 : gct size
      );
    
      this.writeByte(0); // background color index
      this.writeByte(0); // pixel aspect ratio - assume 1:1
    };
    
    /*
      Writes Netscape application extension to define repeat count.
    */
    GIFEncoder.prototype.writeNetscapeExt = function() {
      this.writeByte(0x21); // extension introducer
      this.writeByte(0xff); // app extension label
      this.writeByte(11); // block size
      this.writeUTFBytes('NETSCAPE2.0'); // app id + auth code
      this.writeByte(3); // sub-block size
      this.writeByte(1); // loop sub-block id
      this.writeShort(this.repeat); // loop count (extra iterations, 0=repeat forever)
      this.writeByte(0); // block terminator
    };
    
    /*
      Writes color table
    */
    GIFEncoder.prototype.writePalette = function() {
      this.writeBytes(this.colorTab);
      var n = (3 * 256) - this.colorTab.length;
      for (var i = 0; i < n; i++)
        this.writeByte(0);
    };
    
    GIFEncoder.prototype.writeShort = function(pValue) {
      this.writeByte(pValue & 0xFF);
      this.writeByte((pValue >> 8) & 0xFF);
    };
    
    /*
      Encodes and writes pixel data
    */
    GIFEncoder.prototype.writePixels = function() {
      var enc = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth);
      enc.encode(this);
    };
    
    /*
      Retrieves the GIF stream
    */
    GIFEncoder.prototype.stream = function() {
      return this;
    };
    
    GIFEncoder.ByteCapacitor = ByteCapacitor;
    
    module.exports = GIFEncoder;
    
  provide("gif-encoder", module.exports);
}(global));

// pakmanager:pngjs/lib/chunkstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright (c) 2012 Kuba Niegowski
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.
    
    'use strict';
    
    
    var util = require('util'),
        Stream = require('stream');
    
    
    var ChunkStream = module.exports = function() {
        Stream.call(this);
    
        this._buffers = [];
        this._buffered = 0;
    
        this._reads = [];
        this._paused = false;
    
        this._encoding = 'utf8';
        this.writable = true;
    };
    util.inherits(ChunkStream, Stream);
    
    
    ChunkStream.prototype.read = function(length, callback) {
    
        this._reads.push({
            length: Math.abs(length),  // if length < 0 then at most this length
            allowLess: length < 0,
            func: callback
        });
    
        this._process();
    
        // its paused and there is not enought data then ask for more
        if (this._paused && this._reads.length > 0) {
            this._paused = false;
    
            this.emit('drain');
        }
    };
    
    ChunkStream.prototype.write = function(data, encoding) {
    
        if (!this.writable) {
            this.emit('error', new Error('Stream not writable'));
            return false;
        }
    
        if (!Buffer.isBuffer(data))
            data = new Buffer(data, encoding || this._encoding);
    
        this._buffers.push(data);
        this._buffered += data.length;
    
        this._process();
    
        // ok if there are no more read requests
        if (this._reads && this._reads.length == 0)
            this._paused = true;
    
        return this.writable && !this._paused;
    };
    
    ChunkStream.prototype.end = function(data, encoding) {
    
        if (data) this.write(data, encoding);
    
        this.writable = false;
    
        // already destroyed
        if (!this._buffers) return;
    
        // enqueue or handle end
        if (this._buffers.length == 0) {
            this._end();
        } else {
            this._buffers.push(null);
            this._process();
        }
    };
    
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    
    ChunkStream.prototype._end = function() {
    
        if (this._reads.length > 0) {
            this.emit('error',
                new Error('There are some read requests waitng on finished stream')
            );
        }
    
        this.destroy();
    };
    
    ChunkStream.prototype.destroy = function() {
    
        if (!this._buffers) return;
    
        this.writable = false;
        this._reads = null;
        this._buffers = null;
    
        this.emit('close');
    };
    
    ChunkStream.prototype._process = function() {
    
        // as long as there is any data and read requests
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
    
            var read = this._reads[0];
    
            // read any data (but no more than length)
            if (read.allowLess) {
    
                // ok there is any data so that we can satisfy this request
                this._reads.shift(); // == read
    
                // first we need to peek into first buffer
                var buf = this._buffers[0];
    
                // ok there is more data than we need
                if (buf.length > read.length) {
    
                    this._buffered -= read.length;
                    this._buffers[0] = buf.slice(read.length);
    
                    read.func.call(this, buf.slice(0, read.length));
    
                } else {
                    // ok this is less than maximum length so use it all
                    this._buffered -= buf.length;
                    this._buffers.shift(); // == buf
    
                    read.func.call(this, buf);
                }
    
            } else if (this._buffered >= read.length) {
                // ok we can meet some expectations
    
                this._reads.shift(); // == read
    
                var pos = 0,
                    count = 0,
                    data = new Buffer(read.length);
    
                // create buffer for all data
                while (pos < read.length) {
    
                    var buf = this._buffers[count++],
                        len = Math.min(buf.length, read.length - pos);
    
                    buf.copy(data, pos, 0, len);
                    pos += len;
    
                    // last buffer wasn't used all so just slice it and leave
                    if (len != buf.length)
                        this._buffers[--count] = buf.slice(len);
                }
    
                // remove all used buffers
                if (count > 0)
                    this._buffers.splice(0, count);
    
                this._buffered -= read.length;
    
                read.func.call(this, data);
    
            } else {
                // not enought data to satisfy first request in queue
                // so we need to wait for more
                break;
            }
        }
    
        if (this._buffers && this._buffers.length > 0 && this._buffers[0] == null) {
            this._end();
        }
    };
    
  provide("pngjs/lib/chunkstream", module.exports);
}(global));

// pakmanager:pngjs/lib/crc
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright (c) 2012 Kuba Niegowski
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.
    
    'use strict';
    
    var util = require('util'),
        Stream = require('stream');
    
    
    var CrcStream = module.exports = function() {
        Stream.call(this);
    
        this._crc = -1;
    
        this.writable = true;
    };
    util.inherits(CrcStream, Stream);
    
    
    CrcStream.prototype.write = function(data) {
    
        for (var i = 0; i < data.length; i++) {
            this._crc = crcTable[(this._crc ^ data[i]) & 0xff] ^ (this._crc >>> 8);
        }
        return true;
    };
    
    CrcStream.prototype.end = function(data) {
        if (data) this.write(data);
    
        this.emit('crc', this.crc32());
    };
    
    CrcStream.prototype.crc32 = function() {
        return this._crc ^ -1;
    };
    
    
    CrcStream.crc32 = function(buf) {
    
        var crc = -1;
        for (var i = 0; i < buf.length; i++) {
            crc = crcTable[(crc ^ buf[i]) & 0xff] ^ (crc >>> 8);
        }
        return crc ^ -1;
    };
    
    
    
    var crcTable = [];
    
    for (var i = 0; i < 256; i++) {
        var c = i;
        for (var j = 0; j < 8; j++) {
            if (c & 1) {
                c = 0xedb88320 ^ (c >>> 1);
            } else {
                c = c >>> 1;
            }
        }
        crcTable[i] = c;
    }
    
  provide("pngjs/lib/crc", module.exports);
}(global));

// pakmanager:pngjs/lib/constants
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright (c) 2012 Kuba Niegowski
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.
    
    'use strict';
    
    
    module.exports = {
    
        PNG_SIGNATURE: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],
    
        TYPE_IHDR: 0x49484452,
        TYPE_IEND: 0x49454e44,
        TYPE_IDAT: 0x49444154,
        TYPE_PLTE: 0x504c5445,
        TYPE_tRNS: 0x74524e53,
        TYPE_gAMA: 0x67414d41,
    
        COLOR_PALETTE: 1,
        COLOR_COLOR: 2,
        COLOR_ALPHA: 4
    };
    
  provide("pngjs/lib/constants", module.exports);
}(global));

// pakmanager:pngjs/lib/filter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright (c) 2012 Kuba Niegowski
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.
    
    'use strict';
    
    var util = require('util'),
        zlib = require('zlib'),
        ChunkStream =  require('pngjs/lib/chunkstream');
    
    
    var Filter = module.exports = function(width, height, Bpp, data, options) {
        ChunkStream.call(this);
    
        this._width = width;
        this._height = height;
        this._Bpp = Bpp;
        this._data = data;
        this._options = options;
    
        this._line = 0;
    
        if (!('filterType' in options) || options.filterType == -1) {
            options.filterType = [0, 1, 2, 3, 4];
        } else if (typeof options.filterType == 'number') {
            options.filterType = [options.filterType];
        }
    
        this._filters = {
            0: this._filterNone.bind(this),
            1: this._filterSub.bind(this),
            2: this._filterUp.bind(this),
            3: this._filterAvg.bind(this),
            4: this._filterPaeth.bind(this)
        };
    
        this.read(this._width * Bpp + 1, this._reverseFilterLine.bind(this));
    };
    util.inherits(Filter, ChunkStream);
    
    
    var pixelBppMap = {
        1: { // L
            0: 0,
            1: 0,
            2: 0,
            3: 0xff
        },
        2: { // LA
            0: 0,
            1: 0,
            2: 0,
            3: 1
        },
        3: { // RGB
            0: 0,
            1: 1,
            2: 2,
            3: 0xff
        },
        4: { // RGBA
            0: 0,
            1: 1,
            2: 2,
            3: 3
        }
    };
    
    Filter.prototype._reverseFilterLine = function(rawData) {
    
        var pxData = this._data,
            pxLineLength = this._width << 2,
            pxRowPos = this._line * pxLineLength,
            filter = rawData[0];
    
        if (filter == 0) {
            for (var x = 0; x < this._width; x++) {
                var pxPos = pxRowPos + (x << 2),
                    rawPos = 1 + x * this._Bpp;
    
                for (var i = 0; i < 4; i++) {
                    var idx = pixelBppMap[this._Bpp][i];
                    pxData[pxPos + i] = idx != 0xff ? rawData[rawPos + idx] : 0xff;
                }
            }
    
        } else if (filter == 1) {
            for (var x = 0; x < this._width; x++) {
                var pxPos = pxRowPos + (x << 2),
                    rawPos = 1 + x * this._Bpp;
    
                for (var i = 0; i < 4; i++) {
                    var idx = pixelBppMap[this._Bpp][i],
                        left = x > 0 ? pxData[pxPos + i - 4] : 0;
    
                    pxData[pxPos + i] = idx != 0xff ? rawData[rawPos + idx] + left : 0xff;
                }
            }
    
        } else if (filter == 2) {
            for (var x = 0; x < this._width; x++) {
                var pxPos = pxRowPos + (x << 2),
                    rawPos = 1 + x * this._Bpp;
    
                for (var i = 0; i < 4; i++) {
                    var idx = pixelBppMap[this._Bpp][i],
                        up = this._line > 0 ? pxData[pxPos - pxLineLength + i] : 0;
    
                    pxData[pxPos + i] = idx != 0xff ? rawData[rawPos + idx] + up : 0xff;
                }
    
            }
    
        } else if (filter == 3) {
            for (var x = 0; x < this._width; x++) {
                var pxPos = pxRowPos + (x << 2),
                    rawPos = 1 + x * this._Bpp;
    
                for (var i = 0; i < 4; i++) {
                    var idx = pixelBppMap[this._Bpp][i],
                        left = x > 0 ? pxData[pxPos + i - 4] : 0,
                        up = this._line > 0 ? pxData[pxPos - pxLineLength + i] : 0,
                        add = Math.floor((left + up) / 2);
    
                     pxData[pxPos + i] = idx != 0xff ? rawData[rawPos + idx] + add : 0xff;
                }
    
            }
    
        } else if (filter == 4) {
            for (var x = 0; x < this._width; x++) {
                var pxPos = pxRowPos + (x << 2),
                    rawPos = 1 + x * this._Bpp;
    
                for (var i = 0; i < 4; i++) {
                    var idx = pixelBppMap[this._Bpp][i],
                        left = x > 0 ? pxData[pxPos + i - 4] : 0,
                        up = this._line > 0 ? pxData[pxPos - pxLineLength + i] : 0,
                        upLeft = x > 0 && this._line > 0
                                ? pxData[pxPos - pxLineLength + i - 4] : 0,
                        add = PaethPredictor(left, up, upLeft);
    
                    pxData[pxPos + i] = idx != 0xff ? rawData[rawPos + idx] + add : 0xff;
                }
            }
        }
    
    
        this._line++;
    
        if (this._line < this._height)
            this.read(this._width * this._Bpp + 1, this._reverseFilterLine.bind(this));
        else
            this.emit('complete', this._data, this._width, this._height);
    };
    
    
    
    
    Filter.prototype.filter = function() {
    
        var pxData = this._data,
            rawData = new Buffer(((this._width << 2) + 1) * this._height);
    
        for (var y = 0; y < this._height; y++) {
    
            // find best filter for this line (with lowest sum of values)
            var filterTypes = this._options.filterType,
                min = Infinity,
                sel = 0;
    
            for (var i = 0; i < filterTypes.length; i++) {
                var sum = this._filters[filterTypes[i]](pxData, y, null);
                if (sum < min) {
                    sel = filterTypes[i];
                    min = sum;
                }
            }
    
            this._filters[sel](pxData, y, rawData);
        }
        return rawData;
    };
    
    Filter.prototype._filterNone = function(pxData, y, rawData) {
    
        var pxRowLength = this._width << 2,
            rawRowLength = pxRowLength + 1,
            sum = 0;
    
        if (!rawData) {
            for (var x = 0; x < pxRowLength; x++)
                sum += Math.abs(pxData[y * pxRowLength + x]);
    
        } else {
            rawData[y * rawRowLength] = 0;
            pxData.copy(rawData, rawRowLength * y + 1, pxRowLength * y, pxRowLength * (y + 1));
        }
    
        return sum;
    };
    
    Filter.prototype._filterSub = function(pxData, y, rawData) {
    
        var pxRowLength = this._width << 2,
            rawRowLength = pxRowLength + 1,
            sum = 0;
    
        if (rawData)
            rawData[y * rawRowLength] = 1;
    
        for (var x = 0; x < pxRowLength; x++) {
    
            var left = x >= 4 ? pxData[y * pxRowLength + x - 4] : 0,
                val = pxData[y * pxRowLength + x] - left;
    
            if (!rawData) sum += Math.abs(val);
            else rawData[y * rawRowLength + 1 + x] = val;
        }
        return sum;
    };
    
    Filter.prototype._filterUp = function(pxData, y, rawData) {
    
        var pxRowLength = this._width << 2,
            rawRowLength = pxRowLength + 1,
            sum = 0;
    
        if (rawData)
            rawData[y * rawRowLength] = 2;
    
        for (var x = 0; x < pxRowLength; x++) {
    
            var up = y > 0 ? pxData[(y - 1) * pxRowLength + x] : 0,
                val = pxData[y * pxRowLength + x] - up;
    
            if (!rawData) sum += Math.abs(val);
            else rawData[y * rawRowLength + 1 + x] = val;
        }
        return sum;
    };
    
    Filter.prototype._filterAvg = function(pxData, y, rawData) {
    
        var pxRowLength = this._width << 2,
            rawRowLength = pxRowLength + 1,
            sum = 0;
    
        if (rawData)
            rawData[y * rawRowLength] = 3;
    
        for (var x = 0; x < pxRowLength; x++) {
    
            var left = x >= 4 ? pxData[y * pxRowLength + x - 4] : 0,
                up = y > 0 ? pxData[(y - 1) * pxRowLength + x] : 0,
                val = pxData[y * pxRowLength + x] - ((left + up) >> 1);
    
            if (!rawData) sum += Math.abs(val);
            else rawData[y * rawRowLength + 1 + x] = val;
        }
        return sum;
    };
    
    Filter.prototype._filterPaeth = function(pxData, y, rawData) {
    
        var pxRowLength = this._width << 2,
            rawRowLength = pxRowLength + 1,
            sum = 0;
    
        if (rawData)
            rawData[y * rawRowLength] = 4;
    
        for (var x = 0; x < pxRowLength; x++) {
    
            var left = x >= 4 ? pxData[y * pxRowLength + x - 4] : 0,
                up = y > 0 ? pxData[(y - 1) * pxRowLength + x] : 0,
                upLeft = x >= 4 && y > 0 ? pxData[(y - 1) * pxRowLength + x - 4] : 0,
                val = pxData[y * pxRowLength + x] - PaethPredictor(left, up, upLeft);
    
            if (!rawData) sum += Math.abs(val);
            else rawData[y * rawRowLength + 1 + x] = val;
        }
        return sum;
    };
    
    
    
    var PaethPredictor = function(left, above, upLeft) {
    
        var p = left + above - upLeft,
            pLeft = Math.abs(p - left),
            pAbove = Math.abs(p - above),
            pUpLeft = Math.abs(p - upLeft);
    
        if (pLeft <= pAbove && pLeft <= pUpLeft) return left;
        else if (pAbove <= pUpLeft) return above;
        else return upLeft;
    };
    
  provide("pngjs/lib/filter", module.exports);
}(global));

// pakmanager:pngjs/lib/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright (c) 2012 Kuba Niegowski
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.
    
    'use strict';
    
    
    var util = require('util'),
        zlib = require('zlib'),
        CrcStream =  require('pngjs/lib/crc'),
        ChunkStream =  require('pngjs/lib/chunkstream'),
        constants =  require('pngjs/lib/constants'),
        Filter =  require('pngjs/lib/filter');
    
    
    var Parser = module.exports = function(options) {
        ChunkStream.call(this);
    
        this._options = options;
        options.checkCRC = options.checkCRC !== false;
    
        this._hasIHDR = false;
        this._hasIEND = false;
    
        this._inflate = null;
        this._filter = null;
        this._crc = null;
    
        // input flags/metadata
        this._palette = [];
        this._colorType = 0;
    
        this._chunks = {};
        this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
        this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
        this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
        this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
        this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
        this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
    
        this.writable = true;
    
        this.on('error', this._handleError.bind(this));
        this._handleSignature();
    };
    util.inherits(Parser, ChunkStream);
    
    
    Parser.prototype._handleError = function() {
    
        this.writable = false;
    
        this.destroy();
    
        if (this._inflate)
            this._inflate.destroy();
    };
    
    Parser.prototype._handleSignature = function() {
        this.read(constants.PNG_SIGNATURE.length,
            this._parseSignature.bind(this)
        );
    };
    
    Parser.prototype._parseSignature = function(data) {
    
        var signature = constants.PNG_SIGNATURE;
    
        for (var i = 0; i < signature.length; i++) {
            if (data[i] != signature[i]) {
                this.emit('error', new Error('Invalid file signature'));
                return;
            }
        }
        this.read(8, this._parseChunkBegin.bind(this));
    };
    
    Parser.prototype._parseChunkBegin = function(data) {
    
        // chunk content length
        var length = data.readUInt32BE(0);
    
        // chunk type
        var type = data.readUInt32BE(4),
            name = '';
        for (var i = 4; i < 8; i++)
            name += String.fromCharCode(data[i]);
    
        // console.log('chunk ', name, length);
    
        // chunk flags
        var ancillary  = !!(data[4] & 0x20),  // or critical
            priv       = !!(data[5] & 0x20),  // or public
            safeToCopy = !!(data[7] & 0x20);  // or unsafe
    
        if (!this._hasIHDR && type != constants.TYPE_IHDR) {
            this.emit('error', new Error('Expected IHDR on beggining'));
            return;
        }
    
        this._crc = new CrcStream();
        this._crc.write(new Buffer(name));
    
        if (this._chunks[type]) {
            return this._chunks[type](length);
    
        } else if (!ancillary) {
            this.emit('error', new Error('Unsupported critical chunk type ' + name));
            return;
        } else {
            this.read(length + 4, this._skipChunk.bind(this));
        }
    };
    
    Parser.prototype._skipChunk = function(data) {
        this.read(8, this._parseChunkBegin.bind(this));
    };
    
    Parser.prototype._handleChunkEnd = function() {
        this.read(4, this._parseChunkEnd.bind(this));
    };
    
    Parser.prototype._parseChunkEnd = function(data) {
    
        var fileCrc = data.readInt32BE(0),
            calcCrc = this._crc.crc32();
    
        // check CRC
        if (this._options.checkCRC && calcCrc != fileCrc) {
            this.emit('error', new Error('Crc error'));
            return;
        }
    
        if (this._hasIEND) {
            this.destroySoon();
    
        } else {
            this.read(8, this._parseChunkBegin.bind(this));
        }
    };
    
    
    Parser.prototype._handleIHDR = function(length) {
        this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
    
        this._crc.write(data);
    
        var width = data.readUInt32BE(0),
            height = data.readUInt32BE(4),
            depth = data[8],
            colorType = data[9], // bits: 1 palette, 2 color, 4 alpha
            compr = data[10],
            filter = data[11],
            interlace = data[12];
    
        // console.log('    width', width, 'height', height,
        //     'depth', depth, 'colorType', colorType,
        //     'compr', compr, 'filter', filter, 'interlace', interlace
        // );
    
        if (depth != 8) {
            this.emit('error', new Error('Unsupported bit depth ' + depth));
            return;
        }
        if (!(colorType in colorTypeToBppMap)) {
            this.emit('error', new Error('Unsupported color type'));
            return;
        }
        if (compr != 0) {
            this.emit('error', new Error('Unsupported compression method'));
            return;
        }
        if (filter != 0) {
            this.emit('error', new Error('Unsupported filter method'));
            return;
        }
        if (interlace != 0) {
            this.emit('error', new Error('Unsupported interlace method'));
            return;
        }
    
        this._colorType = colorType;
    
        this._data = new Buffer(width * height * 4);
        this._filter = new Filter(
            width, height,
            colorTypeToBppMap[this._colorType],
            this._data,
            this._options
        );
    
        this._hasIHDR = true;
    
        this.emit('metadata', {
            width: width,
            height: height,
            palette: !!(colorType & constants.COLOR_PALETTE),
            color: !!(colorType & constants.COLOR_COLOR),
            alpha: !!(colorType & constants.COLOR_ALPHA),
            data: this._data
        });
    
        this._handleChunkEnd();
    };
    
    
    Parser.prototype._handlePLTE = function(length) {
        this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
    
        this._crc.write(data);
    
        var entries = Math.floor(data.length / 3);
        // console.log('Palette:', entries);
    
        for (var i = 0; i < entries; i++) {
            this._palette.push([
                data.readUInt8(i * 3),
                data.readUInt8(i * 3 + 1),
                data.readUInt8(i * 3 + 2 ),
                0xff
            ]);
        }
    
        this._handleChunkEnd();
    };
    
    Parser.prototype._handleTRNS = function(length) {
        this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
    
        this._crc.write(data);
    
        // palette
        if (this._colorType == 3) {
            if (this._palette.length == 0) {
                this.emit('error', new Error('Transparency chunk must be after palette'));
                return;
            }
            if (data.length > this._palette.length) {
                this.emit('error', new Error('More transparent colors than palette size'));
                return;
            }
            for (var i = 0; i < this._palette.length; i++) {
                this._palette[i][3] = i < data.length ? data.readUInt8(i) : 0xff;
            }
        }
    
        // for colorType 0 (grayscale) and 2 (rgb)
        // there might be one gray/color defined as transparent
    
        this._handleChunkEnd();
    };
    
    Parser.prototype._handleGAMA = function(length) {
        this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
    
        this._crc.write(data);
        this.emit('gamma', data.readUInt32BE(0) / 100000);
    
        this._handleChunkEnd();
    };
    
    Parser.prototype._handleIDAT = function(length) {
        this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
    
        this._crc.write(data);
    
        if (this._colorType == 3 && this._palette.length == 0)
            throw new Error('Expected palette not found');
    
        if (!this._inflate) {
            this._inflate = zlib.createInflate();
    
            this._inflate.on('error', this.emit.bind(this, 'error'));
            this._filter.on('complete', this._reverseFiltered.bind(this));
    
            this._inflate.pipe(this._filter);
        }
    
        this._inflate.write(data);
        length -= data.length;
    
        if (length > 0)
            this._handleIDAT(length);
        else
            this._handleChunkEnd();
    };
    
    
    Parser.prototype._handleIEND = function(length) {
        this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
    
        this._crc.write(data);
    
        // no more data to inflate
        this._inflate.end();
    
        this._hasIEND = true;
        this._handleChunkEnd();
    };
    
    
    var colorTypeToBppMap = {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
    };
    
    Parser.prototype._reverseFiltered = function(data, width, height) {
    
        if (this._colorType == 3) { // paletted
    
            // use values from palette
            var pxLineLength = width << 2;
    
            for (var y = 0; y < height; y++) {
                var pxRowPos = y * pxLineLength;
    
                for (var x = 0; x < width; x++) {
                    var pxPos = pxRowPos + (x << 2),
                        color = this._palette[data[pxPos]];
    
                    for (var i = 0; i < 4; i++)
                        data[pxPos + i] = color[i];
                }
            }
        }
    
        this.emit('parsed', data);
    };
    
  provide("pngjs/lib/parser", module.exports);
}(global));

// pakmanager:pngjs/lib/packer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright (c) 2012 Kuba Niegowski
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.
    
    'use strict';
    
    
    var util = require('util'),
        Stream = require('stream'),
        zlib = require('zlib'),
        Filter =  require('pngjs/lib/filter'),
        CrcStream =  require('pngjs/lib/crc'),
        constants =  require('pngjs/lib/constants');
    
    
    var Packer = module.exports = function(options) {
        Stream.call(this);
    
        this._options = options;
    
        options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
        options.deflateLevel = options.deflateLevel || 9;
        options.deflateStrategy = options.deflateStrategy || 3;
    
        this.readable = true;
    };
    util.inherits(Packer, Stream);
    
    
    Packer.prototype.pack = function(data, width, height) {
    
        // Signature
        this.emit('data', new Buffer(constants.PNG_SIGNATURE));
        this.emit('data', this._packIHDR(width, height));
    
        // filter pixel data
        var filter = new Filter(width, height, 4, data, this._options);
        var data = filter.filter();
    
        // compress it
        var deflate = zlib.createDeflate({
                chunkSize: this._options.deflateChunkSize,
                level: this._options.deflateLevel,
                strategy: this._options.deflateStrategy
            });
        deflate.on('error', this.emit.bind(this, 'error'));
    
        deflate.on('data', function(data) {
            this.emit('data', this._packIDAT(data));
        }.bind(this));
    
        deflate.on('end', function() {
            this.emit('data', this._packIEND());
            this.emit('end');
        }.bind(this));
    
        deflate.end(data);
    };
    
    Packer.prototype._packChunk = function(type, data) {
    
        var len = (data ? data.length : 0),
            buf = new Buffer(len + 12);
    
        buf.writeUInt32BE(len, 0);
        buf.writeUInt32BE(type, 4);
    
        if (data) data.copy(buf, 8);
    
        buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
        return buf;
    };
    
    Packer.prototype._packIHDR = function(width, height) {
    
        var buf = new Buffer(13);
        buf.writeUInt32BE(width, 0);
        buf.writeUInt32BE(height, 4);
        buf[8] = 8;
        buf[9] = 6; // colorType
        buf[10] = 0; // compression
        buf[11] = 0; // filter
        buf[12] = 0; // interlace
    
        return this._packChunk(constants.TYPE_IHDR, buf);
    };
    
    Packer.prototype._packIDAT = function(data) {
        return this._packChunk(constants.TYPE_IDAT, data);
    };
    
    Packer.prototype._packIEND = function() {
        return this._packChunk(constants.TYPE_IEND, null);
    };
    
  provide("pngjs/lib/packer", module.exports);
}(global));

// pakmanager:pngjs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright (c) 2012 Kuba Niegowski
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.
    
    'use strict';
    
    
    var util = require('util'),
        Stream = require('stream'),
        Parser =  require('pngjs/lib/parser'),
        Packer =  require('pngjs/lib/packer');
    
    
    var PNG = exports.PNG = function(options) {
        Stream.call(this);
    
        options = options || {};
    
        this.width = options.width || 0;
        this.height = options.height || 0;
    
        this.data = this.width > 0 && this.height > 0
                ? new Buffer(4 * this.width * this.height) : null;
    
        this.gamma = 0;
        this.readable = this.writable = true;
    
        this._parser = new Parser(options || {});
    
        this._parser.on('error', this.emit.bind(this, 'error'));
        this._parser.on('close', this._handleClose.bind(this));
        this._parser.on('metadata', this._metadata.bind(this));
        this._parser.on('gamma', this._gamma.bind(this));
        this._parser.on('parsed', function(data) {
            this.data = data;
            this.emit('parsed', data);
        }.bind(this));
    
        this._packer = new Packer(options);
        this._packer.on('data', this.emit.bind(this, 'data'));
        this._packer.on('end', this.emit.bind(this, 'end'));
        this._parser.on('close', this._handleClose.bind(this));
        this._packer.on('error', this.emit.bind(this, 'error'));
    
    };
    util.inherits(PNG, Stream);
    
    
    PNG.prototype.pack = function() {
    
        process.nextTick(function() {
            this._packer.pack(this.data, this.width, this.height);
        }.bind(this));
    
        return this;
    };
    
    
    PNG.prototype.parse = function(data, callback) {
    
        if (callback) {
            var onParsed = null, onError = null;
    
            this.once('parsed', onParsed = function(data) {
                this.removeListener('error', onError);
    
                this.data = data;
                callback(null, this);
    
            }.bind(this));
    
            this.once('error', onError = function(err) {
                this.removeListener('parsed', onParsed);
    
                callback(err, null);
            }.bind(this));
        }
    
        this.end(data);
        return this;
    };
    
    PNG.prototype.write = function(data) {
        this._parser.write(data);
        return true;
    };
    
    PNG.prototype.end = function(data) {
        this._parser.end(data);
    };
    
    PNG.prototype._metadata = function(metadata) {
        this.width = metadata.width;
        this.height = metadata.height;
        this.data = metadata.data;
    
        delete metadata.data;
        this.emit('metadata', metadata);
    };
    
    PNG.prototype._gamma = function(gamma) {
        this.gamma = gamma;
    };
    
    PNG.prototype._handleClose = function() {
        if (!this._parser.writable && !this._packer.readable)
            this.emit('close');
    };
    
    
    PNG.prototype.bitblt = function(dst, sx, sy, w, h, dx, dy) {
    
        var src = this;
    
        if (sx > src.width || sy > src.height
                || sx + w > src.width || sy + h > src.height)
            throw new Error('bitblt reading outside image');
        if (dx > dst.width || dy > dst.height
                || dx + w > dst.width || dy + h > dst.height)
            throw new Error('bitblt writing outside image');
    
        for (var y = 0; y < h; y++) {
            src.data.copy(dst.data,
                ((dy + y) * dst.width + dx) << 2,
                ((sy + y) * src.width + sx) << 2,
                ((sy + y) * src.width + sx + w) << 2
            );
        }
    
        return this;
    };
    
  provide("pngjs", module.exports);
}(global));

// pakmanager:bin-pack/packer.growing.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /******************************************************************************
    
    This is a binary tree based bin packing algorithm that is more complex than
    the simple Packer (packer.js). Instead of starting off with a fixed width and
    height, it starts with the width and height of the first block passed and then
    grows as necessary to accomodate each subsequent block. As it grows it attempts
    to maintain a roughly square ratio by making 'smart' choices about whether to
    grow right or down.
    
    When growing, the algorithm can only grow to the right OR down. Therefore, if
    the new block is BOTH wider and taller than the current target then it will be
    rejected. This makes it very important to initialize with a sensible starting
    width and height. If you are providing sorted input (largest first) then this
    will not be an issue.
    
    A potential way to solve this limitation would be to allow growth in BOTH
    directions at once, but this requires maintaining a more complex tree
    with 3 children (down, right and center) and that complexity can be avoided
    by simply chosing a sensible starting block.
    
    Best results occur when the input blocks are sorted by height, or even better
    when sorted by max(width,height).
    
    Inputs:
    ------
    
    	blocks: array of any objects that have .w and .h attributes
    
    Outputs:
    -------
    
    	marks each block that fits with a .fit attribute pointing to a
    	node with .x and .y coordinates
    
    Example:
    -------
    
    	var blocks = [
    		{ w: 100, h: 100 },
    		{ w: 100, h: 100 },
    		{ w:  80, h:  80 },
    		{ w:  80, h:  80 },
    		etc
    		etc
    	];
    
    	var packer = new GrowingPacker();
    	packer.fit(blocks);
    
    	for(var n = 0 ; n < blocks.length ; n++) {
    		var block = blocks[n];
    		if (block.fit) {
    			Draw(block.fit.x, block.fit.y, block.w, block.h);
    		}
    	}
    
    
    ******************************************************************************/
    
    GrowingPacker = function() { };
    
    GrowingPacker.prototype = {
    
    	fit: function(blocks) {
    		var n, node, block, len = blocks.length, fit;
    		var width  = len > 0 ? blocks[0].width : 0;
    		var height = len > 0 ? blocks[0].height : 0;
    		this.root = { x: 0, y: 0, width: width, height: height };
    		for (n = 0; n < len ; n++) {
    			block = blocks[n];
    			if (node = this.findNode(this.root, block.width, block.height)) {
    				fit = this.splitNode(node, block.width, block.height);
    				block.x = fit.x;
    				block.y = fit.y;
    			}
    			else {
    				fit = this.growNode(block.width, block.height);
    				block.x = fit.x;
    				block.y = fit.y;
    			}
    		}
    	},
    
    	findNode: function(root, width, height) {
    		if (root.used)
    			return this.findNode(root.right, width, height) || this.findNode(root.down, width, height);
    		else if ((width <= root.width) && (height <= root.height))
    			return root;
    		else
    			return null;
    	},
    
    	splitNode: function(node, width, height) {
    		node.used = true;
    		node.down  = { x: node.x,         y: node.y + height, width: node.width,         height: node.height - height };
    		node.right = { x: node.x + width, y: node.y,          width: node.width - width, height: height               };
    		return node;
    	},
    
    	growNode: function(width, height) {
    		var canGrowDown  = (width  <= this.root.width);
    		var canGrowRight = (height <= this.root.height);
    
    		var shouldGrowRight = canGrowRight && (this.root.height >= (this.root.width  + width )); // attempt to keep square-ish by growing right when height is much greater than width
    		var shouldGrowDown  = canGrowDown  && (this.root.width  >= (this.root.height + height)); // attempt to keep square-ish by growing down  when width  is much greater than height
    
    		if (shouldGrowRight)
    			return this.growRight(width, height);
    		else if (shouldGrowDown)
    			return this.growDown(width, height);
    		else if (canGrowRight)
    			return this.growRight(width, height);
    		else if (canGrowDown)
    			return this.growDown(width, height);
    		else
    			return null; // need to ensure sensible root starting size to avoid this happening
    	},
    
    	growRight: function(width, height) {
    		this.root = {
    			used: true,
    			x: 0,
    			y: 0,
    			width: this.root.width + width,
    			height: this.root.height,
    			down: this.root,
    			right: { x: this.root.width, y: 0, width: width, height: this.root.height }
    		};
    		if (node = this.findNode(this.root, width, height))
    			return this.splitNode(node, width, height);
    		else
    			return null;
    	},
    
    	growDown: function(width, height) {
    		this.root = {
    			used: true,
    			x: 0,
    			y: 0,
    			width: this.root.width,
    			height: this.root.height + height,
    			down:  { x: 0, y: this.root.height, width: this.root.width, height: height },
    			right: this.root
    		};
    		if (node = this.findNode(this.root, width, height))
    			return this.splitNode(node, width, height);
    		else
    			return null;
    	}
    
    };
    
    module.exports = GrowingPacker;
    
    
  provide("bin-pack/packer.growing.js", module.exports);
}(global));

// pakmanager:bin-pack
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    
    var GrowingPacker =  require('bin-pack/packer.growing.js');
    
    module.exports = function(items, options) {
    	options = options || {};
    	var packer = new GrowingPacker();
    	var inPlace = options.inPlace || false;
    
    	// Clone the items.
    	var newItems = items.map(function(item) { return inPlace ? item : { width: item.width, height: item.height, item: item }; });
    
    	newItems = newItems.sort(function(a, b) {
    		// TODO: check that each actually HAS a width and a height.
    		// Sort based on the size (area) of each block.
    		return (b.width * b.height) - (a.width * a.height);
    	});
    
    	packer.fit(newItems);
    
    	var w = newItems.reduce(function(curr, item) { return Math.max(curr, item.x + item.width); }, 0);
    	var h = newItems.reduce(function(curr, item) { return Math.max(curr, item.y + item.height); }, 0);
    
    	var ret = {
    		width: w,
    		height: h
    	};
    
    	if (!inPlace) {
    		ret.items = newItems;
    	}
    
    	return ret;
    };
    
  provide("bin-pack", module.exports);
}(global));

// pakmanager:get-pixels
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var ndarray       = require('ndarray')
    var path          = require('path')
    var PNG           = require('pngjs2').PNG
    var jpeg          = require('jpeg-js')
    var pack          = require('ndarray-pack')
    var GifReader     = require('omggif').GifReader
    var Bitmap        = require('node-bitmap')
    var fs            = require('fs')
    var request       = require('request')
    var mime          = require('mime-types')
    var parseDataURI  = require('parse-data-uri')
    
    function handlePNG(data, cb) {
      var png = new PNG();
      png.parse(data, function(err, img_data) {
        if(err) {
          cb(err)
          return
        }
        cb(null, ndarray(new Uint8Array(img_data.data),
          [img_data.width|0, img_data.height|0, 4],
          [4, 4*img_data.width|0, 1],
          0))
      })
    }
    
    function handleJPEG(data, cb) {
      var jpegData
      try {
        jpegData = jpeg.decode(data)
      }
      catch(e) {
        cb(e)
        return
      }
      if(!jpegData) {
        cb(new Error("Error decoding jpeg"))
        return
      }
      var nshape = [ jpegData.height, jpegData.width, 4 ]
      var result = ndarray(jpegData.data, nshape)
      cb(null, result.transpose(1,0))
    }
    
    function handleGIF(data, cb) {
      var reader
      try {
        reader = new GifReader(data)
      } catch(err) {
        cb(err)
        return
      }
      if(reader.numFrames() > 0) {
        var nshape = [reader.numFrames(), reader.height, reader.width, 4]
        var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3])
        var result = ndarray(ndata, nshape)
        try {
          for(var i=0; i<reader.numFrames(); ++i) {
            reader.decodeAndBlitFrameRGBA(i, ndata.subarray(
              result.index(i, 0, 0, 0),
              result.index(i+1, 0, 0, 0)))
          }
        } catch(err) {
          cb(err)
          return
        }
        cb(null, result.transpose(0,2,1))
      } else {
        var nshape = [reader.height, reader.width, 4]
        var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2])
        var result = ndarray(ndata, nshape)
        try {
          reader.decodeAndBlitFrameRGBA(0, ndata)
        } catch(err) {
          cb(err)
          return
        }
        cb(null, result.transpose(1,0))
      }
    }
    
    function handleBMP(data, cb) {
      var bmp = new Bitmap(data)
      try {
        bmp.init()
      } catch(e) {
        cb(e)
        return
      }
      var bmpData = bmp.getData()
      var nshape = [ bmpData.getHeight(), bmpData.getWidth(), 4 ]
      var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2])
      var result = ndarray(ndata, nshape)
      pack(bmpData, result)
      cb(null, result.transpose(1,0))
    }
    
    
    function doParse(mimeType, data, cb) {
      switch(mimeType) {
        case 'image/png':
          handlePNG(data, cb)
        break
    
        case 'image/jpeg':
          handleJPEG(data, cb)
        break
    
        case 'image/gif':
          handleGIF(data, cb)
        break
    
        case 'image/bmp':
          handleBMP(data, cb)
        break
    
        default:
          cb(new Error("Unsupported file type: " + mimeType))
      }
    }
    
    module.exports = function getPixels(url, type, cb) {
      if(!cb) {
        cb = type
        type = ''
      }
      if(Buffer.isBuffer(url)) {
        if(!type) {
          cb(new Error('Invalid file type'))
          return
        }
        doParse(type, url, cb)
      } else if(url.indexOf('data:') === 0) {
        try {
          var buffer = parseDataURI(url)
          if(buffer) {
            process.nextTick(function() {
              doParse(type || buffer.mimeType, buffer.data, cb)
            })
          } else {
            process.nextTick(function() {
              cb(new Error('Error parsing data URI'))
            })
          }
        } catch(err) {
          process.nextTick(function() {
            cb(err)
          })
        }
      } else if(url.indexOf('http://') === 0 || url.indexOf('https://') === 0) {
        request({url:url, encoding:null}, function(err, response, body) {
          if(err) {
            cb(err)
            return
          }
    
          type = type;
          if(!type){
            if(response.getHeader !== undefined){
    	  type = response.getHeader('content-type');
    	}else if(response.headers !== undefined){
    	  type = response.headers['content-type'];
    	}
          }
          if(!type) {
            cb(new Error('Invalid content-type'))
            return
          }
          doParse(type, body, cb)
        })
      } else {
        fs.readFile(url, function(err, data) {
          if(err) {
            cb(err)
            return
          }
          type = type || mime.lookup(url)
          if(!type) {
            cb(new Error('Invalid file type'))
            return
          }
          doParse(type, data, cb)
        })
      }
    }
    
  provide("get-pixels", module.exports);
}(global));

// pakmanager:ndarray-fill
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    var cwise = require("cwise")
    
    var fill = cwise({
      args: ["index", "array", "scalar"],
      body: function(idx, out, f) {
        out = f.apply(undefined, idx)
      }
    })
    
    module.exports = function(array, f) {
      fill(array, f)
      return array
    }
    
  provide("ndarray-fill", module.exports);
}(global));

// pakmanager:obj-extend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    
    module.exports = function (obj) {
      // Get all the source objects to merge
      var sources = Array.prototype.slice.call(arguments, 1);
    
      // Loop over the source objects and set all of their properties onto the
      // destination object, overriding properties with the same name
      sources.forEach(function (source) {
        var prop;
        for (prop in source) {
          if (source.hasOwnProperty(prop)) {
            obj[prop] = source[prop];
          }
        }
      });
    
      // Return the extended object
      return obj;
    };
    
  provide("obj-extend", module.exports);
}(global));

// pakmanager:save-pixels
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    var ContentStream = require("contentstream")
    var GifEncoder = require("gif-encoder")
    var jpegJs = require("jpeg-js")
    var PNG = require("pngjs").PNG
    var through = require("through")
    
    function handleData(array, data, frame) {
      var i, j, ptr = 0, c
      if(array.shape.length === 4) {
        for(j=0; j<array.shape[2]; ++j) {
          for(i=0; i<array.shape[1]; ++i) {
            data[ptr++] = array.get(frame,i,j,0)>>>0
            data[ptr++] = array.get(frame,i,j,1)>>>0
            data[ptr++] = array.get(frame,i,j,2)>>>0
            data[ptr++] = array.get(frame,i,j,3)>>>0
          }
        }
      } else if(array.shape.length === 3) {
        if(array.shape[2] === 3) {
          for(j=0; j<array.shape[1]; ++j) {
            for(i=0; i<array.shape[0]; ++i) {
              data[ptr++] = array.get(i,j,0)>>>0
              data[ptr++] = array.get(i,j,1)>>>0
              data[ptr++] = array.get(i,j,2)>>>0
              data[ptr++] = 255
            }
          }
        } else if(array.shape[2] === 4) {
          for(j=0; j<array.shape[1]; ++j) {
            for(i=0; i<array.shape[0]; ++i) {
              data[ptr++] = array.get(i,j,0)>>>0
              data[ptr++] = array.get(i,j,1)>>>0
              data[ptr++] = array.get(i,j,2)>>>0
              data[ptr++] = array.get(i,j,3)>>>0
            }
          }
        } else if(array.shape[3] === 1) {
          for(j=0; j<array.shape[1]; ++j) {
            for(i=0; i<array.shape[0]; ++i) {
              var c = array.get(i,j,0)>>>0
              data[ptr++] = c
              data[ptr++] = c
              data[ptr++] = c
              data[ptr++] = 255
            }
          }
        } else {
          return new Error("Incompatible array shape")
        }
      } else if(array.shape.length === 2) {
        for(j=0; j<array.shape[1]; ++j) {
          for(i=0; i<array.shape[0]; ++i) {
            var c = array.get(i,j,0)>>>0
            data[ptr++] = c
            data[ptr++] = c
            data[ptr++] = c
            data[ptr++] = 255
          }
        }
      } else {
        return new Error("Incompatible array shape")
      }
      return data
    }
    
    function haderror(err) {
      var result = through()
      result.emit("error", err)
      return result
    }
    
    module.exports = function savePixels(array, type) {
      switch(type.toUpperCase()) {
        case "JPG":
        case ".JPG":
        case "JPEG":
        case ".JPEG":
        case "JPE":
        case ".JPE":
          var width = array.shape[0]
          var height = array.shape[1]
          var data = new Buffer(width * height * 4)
          data = handleData(array, data)
          var rawImageData = {
            data: data,
            width: width,
            height: height
          }
          var jpegImageData = jpegJs.encode(rawImageData)
          return new ContentStream(jpegImageData.data)
    
        case "GIF":
        case ".GIF":
          var frames = array.shape.length === 4 ? array.shape[0] : 1
          var width = array.shape.length === 4 ? array.shape[1] : array.shape[0]
          var height = array.shape.length === 4 ? array.shape[2] : array.shape[1]
          var data = new Buffer(width * height * 4)
          var gif = new GifEncoder(width, height)
          gif.writeHeader()
          for (var i = 0; i < frames; i++) {
            data = handleData(array, data, i)
            gif.addFrame(data)
          }
          gif.finish()
          return gif
    
        case "PNG":
        case ".PNG":
          var png = new PNG({
            width: array.shape[0],
            height: array.shape[1]
          })
          var data = handleData(array, png.data)
          if (typeof data === "Error") return haderror(data)
          png.data = data
          return png.pack()
    
        case "CANVAS":
          var canvas = document.createElement("canvas")
          var context = canvas.getContext("2d")
          canvas.width = array.shape[0]
          canvas.height = array.shape[1]
          var imageData = context.getImageData(0, 0, canvas.width, canvas.height)
          var data = imageData.data
          data = handleData(array, data)
          if (typeof data === "Error") return haderror(data)
          context.putImageData(imageData, 0, 0)
          return canvas
        
        default:
          return haderror(new Error("Unsupported file type: " + type))
      }
    }
    
  provide("save-pixels", module.exports);
}(global));

// pakmanager:layout/lib/smiths/packing.smith.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  function PackingSmith(algorithm, options) {
      // Define items and save algorithm for later
      this.items = [];
      this.algorithm = algorithm;
    
      // Fallback options and determine whether to sort or not
      options = options || {};
      var sort = options.sort !== undefined ? options.sort : true;
      this.sort = sort;
    }
    PackingSmith.prototype = {
      /**
       * @param {Object} item Item to store -- this currently is mutated in-memory
       * @param {Number} item.width Width of the item
       * @param {Number} item.height Height of the item
       * @param {Mixed} [item.meta] Any meta data you would like to store related to the item
       */
      'addItem': function (item) {
        // Save the item for later
        this.items.push(item);
      },
      // Method to normalize coordinates to 0, 0
      // This is bad to do mid-addition since it messes up the algorithm
      'normalizeCoordinates': function () {
        // Grab the items
        var items = this.items;
    
        // Find the most negative x and y
        var minX = Infinity,
            minY = Infinity;
        items.forEach(function (item) {
          var coords = item;
          minX = Math.min(minX, coords.x);
          minY = Math.min(minY, coords.y);
        });
    
        // Offset each item by -minX, -minY; effectively resetting to 0, 0
        items.forEach(function (item) {
          var coords = item;
          coords.x -= minX;
          coords.y -= minY;
        });
      },
      'getStats': function () {
        // Get the endX and endY for each item
        var items = this.items,
            coordsArr = items.map(function (item) {
              return item;
            }),
            minXArr = coordsArr.map(function (coords) {
              return coords.x;
            }),
            minYArr = coordsArr.map(function (coords) {
              return coords.y;
            }),
            maxXArr = coordsArr.map(function (coords) {
              return coords.x + coords.width;
            }),
            maxYArr = coordsArr.map(function (coords) {
              return coords.y + coords.height;
            });
    
        // Get the maximums of these
        var retObj = {
              'minX': Math.max.apply(Math, minXArr),
              'minY': Math.max.apply(Math, minYArr),
              'maxX': Math.max.apply(Math, maxXArr),
              'maxY': Math.max.apply(Math, maxYArr)
            };
    
        // Return the stats
        return retObj;
      },
      'getItems': function () {
        return this.items;
      },
      'processItems': function () {
        // Run the items through our algorithm
        var items = this.items;
        if (this.sort) {
          items = this.algorithm.sort(items);
        }
        items = this.algorithm.placeItems(items);
    
        // Save the items for later
        this.items = items;
    
        // Return the items
        return items;
      },
      'exportItems': function () {
        // Process the items
        this.processItems();
    
        // Normalize the coordinates to 0, 0
        this.normalizeCoordinates();
    
        // Return the packed items
        return this.items;
      },
      /**
       * @returns {Object} retObj
       * @returns {Number} retObj.height Height of the processed layout
       * @returns {Number} retObj.width Width of the processed layout
       * @returns {Mixed[]} retObj.items Organized items
       */
      'export': function () {
        // Grab the stats, coordinates, and items
        var items = this.exportItems(),
            stats = this.getStats();
    
        // Generate and return our retObj
        var retObj = {
              'height': stats.maxY,
              'width': stats.maxX,
              'items': items
            };
        return retObj;
      }
    };
    
    // Export PackingSmith
    module.exports = PackingSmith;
    
  provide("layout/lib/smiths/packing.smith.js", module.exports);
}(global));

// pakmanager:layout/lib/algorithms/top-down.algorithm.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Add in top-down algorithm
    exports.sort = function (items) {
      // Sort the items by their height
      items.sort(function (a, b) {
        return a.height - b.height;
      });
      return items;
    };
    
    exports.placeItems = function (items) {
      // Iterate over each of the items
      var y = 0;
      items.forEach(function (item) {
        // Update the y to the current height
        item.x = 0;
        item.y = y;
    
        // Increment the y by the item's height
        y += item.height;
      });
    
      // Return the items
      return items;
    };
    
  provide("layout/lib/algorithms/top-down.algorithm.js", module.exports);
}(global));

// pakmanager:layout/lib/algorithms/left-right.algorithm.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Add in left-right algorithm
    exports.sort = function (items) {
      // Sort the items by their width
      items.sort(function (a, b) {
        return a.width - b.width;
      });
      return items;
    };
    
    exports.placeItems = function (items) {
      // Iterate over each of the items
      var x = 0;
      items.forEach(function (item) {
        // Update the x to the current width
        item.x = x;
        item.y = 0;
    
        // Increment the x by the item's width
        x += item.width;
      });
    
      // Return the items
      return items;
    };
    
  provide("layout/lib/algorithms/left-right.algorithm.js", module.exports);
}(global));

// pakmanager:layout/lib/algorithms/diagonal.algorithm.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Add in diagonal algorithm
    exports.sort = function (items) {
      // Sort the items by their diagonal
      items.sort(function (a, b) {
        var aDiag = Math.sqrt(Math.pow(a.height, 2) + Math.pow(a.width, 2)),
            bDiag = Math.sqrt(Math.pow(b.height, 2) + Math.pow(b.width, 2));
        return aDiag - bDiag;
      });
      return items;
    };
    
    exports.placeItems = function (items) {
      // Iterate over each of the items
      var x = 0,
          y = 0;
      items.forEach(function (item) {
        // Update the x to the current width
        item.x = x;
        item.y = y;
    
        // Increment the x and y by the item's dimensions
        x += item.width;
        y += item.height;
      });
    
      // Return the items
      return items;
    };
    
  provide("layout/lib/algorithms/diagonal.algorithm.js", module.exports);
}(global));

// pakmanager:layout/lib/algorithms/alt-diagonal.algorithm.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Add in reverse-diagonal algorithm
    exports.sort = function (items) {
      // Sort the items by their diagonal
      items.sort(function (a, b) {
        var aDiag = Math.sqrt(Math.pow(a.height, 2) + Math.pow(a.width, 2)),
            bDiag = Math.sqrt(Math.pow(b.height, 2) + Math.pow(b.width, 2));
        return aDiag - bDiag;
      });
      return items;
    };
    
    exports.placeItems = function (items) {
      // Iterate over each of the items
      var x = 0,
          y = 0;
      items.forEach(function (item) {
        var itemWidth = item.width;
        item.x = x - itemWidth;
        item.y = y;
    
        // Decrement the x and increment the y by the item's dimensions
        x -= itemWidth;
        y += item.height;
      });
    
      // Return the items
      return items;
    };
    
  provide("layout/lib/algorithms/alt-diagonal.algorithm.js", module.exports);
}(global));

// pakmanager:layout/lib/algorithms/binary-tree.algorithm.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load in our binary packer
    var pack = require('bin-pack');
    
    exports.sort = function (items) {
      // `bin-pack` automatically sorts. Make this a noop.
      return items;
    };
    
    exports.placeItems = function (items) {
      // Pack the items (adds `x` and `y` to each item)
      pack(items, {inPlace: true});
    
      // Return the packed items
      return items;
    };
    
  provide("layout/lib/algorithms/binary-tree.algorithm.js", module.exports);
}(global));

// pakmanager:layout
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load in packing.smith (from spritesmith) and create algorithm store
    var PackingSmith =  require('layout/lib/smiths/packing.smith.js'),
        assert = require('assert'),
        algorithms = {};
    
    /**
     * Layout adds items in an algorithmic fashion
     * @constructor
     * @param {String|Object} [algorithm="top-down"] Name of algorithm or custom algorithm to use
     * @param {Mixed} [options] Options to provide for the algorithm
     */
    function Layout(algorithmName, options) {
      // Save the algorithmName as our algorithm (assume function)
      var algorithm = algorithmName || 'top-down';
    
      // If the algorithm is a string, look it up
      if (typeof algorithm === 'string') {
        algorithm = algorithms[algorithmName];
    
        // Assert that the algorithm was found
        assert(algorithm, 'Sorry, the \'' + algorithmName +'\' algorithm could not be loaded.');
      }
    
      // Create a new PackingSmith with our algorithm and return
      var retSmith = new PackingSmith(algorithm, options);
      return retSmith;
    }
    
    // Expose PackingSmith on Layout
    Layout.PackingSmith = PackingSmith;
    
    /**
     * Method to add new algorithms via
     * @param {String} name Name of algorithm
     * @param {Object} algorithm Algorithm to bind under name
     * @param {Function} algorithm.sort Algorithm to sort object by
     * @param {Function} algorithm.placeItems Algorithm to place items by
     */
    function addAlgorithm(name, algorithm) {
      // Save the algorithm to algorithms
      algorithms[name] = algorithm;
    }
    // Make algorithms easier to add and expose them
    Layout.addAlgorithm = addAlgorithm;
    Layout.algorithms = algorithms;
    
    // Add default algorithms
    addAlgorithm('top-down',  require('layout/lib/algorithms/top-down.algorithm.js'));
    addAlgorithm('left-right',  require('layout/lib/algorithms/left-right.algorithm.js'));
    addAlgorithm('diagonal',  require('layout/lib/algorithms/diagonal.algorithm.js'));
    addAlgorithm('alt-diagonal',  require('layout/lib/algorithms/alt-diagonal.algorithm.js'));
    addAlgorithm('binary-tree',  require('layout/lib/algorithms/binary-tree.algorithm.js'));
    
    // /**
    //  * Method to add reverse algorithms via
    //  * @param {String} reverseName Name of reverse algorithm
    //  * @param {String} origName Name of original algorithm to reverse
    //  */
    // function addReverseAlgorithm(reverseName, origName) {
    //   // Take the original algorithm
    //   var algo = algorithms[origName];
    
    //   // Asser there is an algorithm
    //   assert(algo, 'Algorithm ' + origName + ' could not be found.');
    
    //   // Wrap the algorithm in a reverser
    //   function retFn(items) {
    //     items = algo(items);
    //     items.reverse();
    //     return items;
    //   }
    
    //   // Add the algorithm
    //   addAlgorithm(reverseName, retFn);
    // }
    // // // Add in reverse algorithms
    // // addReverseAlgorithm('bottom-up', 'top-down');
    // // addReverseAlgorithm('right-left', 'left-right');
    // // addReverseAlgorithm('reverse-diagonal', 'diagonal');
    
    // // Expose addReverseAlgorithm
    // Layout.addReverseAlgorithm = addReverseAlgorithm;
    
    // Expose Layout to the outside
    module.exports = Layout;
    
  provide("layout", module.exports);
}(global));

// pakmanager:pixelsmith/lib/exporters
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load our dependencies
    var concat = require('concat-stream');
    var ndarrayFill = require('ndarray-fill');
    var savePixels = require('save-pixels');
    var exporters = {};
    
    // Function to add new exporters
    function addExporter(name, exporter) {
      exporters[name] = exporter;
    }
    
    // Helper to create exporters (could be a class for better abstraction)
    function getExporter(ext) {
      /**
       * Generic exporter
       * @param {Object} options Options to export with
       * @param {Function} cb Error-first callback to return binary image string to
       */
      return function getExporterFn (options, cb) {
        // If we have a custom background, fill it in (otherwise default is transparent black `rgba(0, 0, 0, 0)`)
        var ndarray = this.ndarray;
        if (options.background) {
          ndarrayFill(ndarray, function fillBackground (i, j, k) {
            return options.background[k];
          });
        }
    
        // Add each image to the canvas
        var images = this.images;
        images.forEach(function getUrlPath (imageObj) {
          // Iterate over the image's data across its rows
          // setting the original data at that offset
          // [1, 2, 0, 0,
          //  3, 4, 0, 0,
          //  0, 0, 5, 0,
          //  0, 0, 0, 6]
          var img = imageObj.img;
          var xOffset = imageObj.x;
          var yOffset = imageObj.y;
          var colIndex = 0;
          var colCount = img.width; // DEV: Use `width` for padding
          for (; colIndex < colCount; colIndex += 1) {
            var rowIndex = 0;
            var rowCount = img.height; // DEV: Use `height` for padding
            for (; rowIndex < rowCount; rowIndex += 1) {
              var rgbaIndex = 0;
              var rgbaCount = 4;
              for (; rgbaIndex < rgbaCount; rgbaIndex += 1) {
                // If we are working with a 4 dimensional array, ignore the first dimension
                // DEV: This is a GIF; [frames, width, height, rgba]
                var val;
                if (img.shape.length === 4) {
                  val = img.get(0, colIndex, rowIndex, rgbaIndex);
                // Otherwise, transfer data directly
                } else {
                  val = img.get(colIndex, rowIndex, rgbaIndex);
                }
                ndarray.set(xOffset + colIndex, yOffset + rowIndex, rgbaIndex, val);
              }
            }
          }
        });
    
        // Concatenate the ndarray into a png
        // TODO: We should start sending back streams
        savePixels(ndarray, ext).pipe(concat(function concatenateImage (buff) {
          cb(null, buff.toString('binary'));
        }));
      };
    }
    
    // Generate the image exporters
    var pngExporter = getExporter('png');
    addExporter('png', pngExporter);
    addExporter('image/png', pngExporter);
    var jpegExporter = getExporter('jpeg');
    addExporter('jpg', jpegExporter);
    addExporter('image/jpg', jpegExporter);
    addExporter('jpeg', jpegExporter);
    addExporter('image/jpeg', jpegExporter);
    var gifExporter = getExporter('gif');
    addExporter('gif', gifExporter);
    addExporter('image/gif', gifExporter);
    
    // Export our exporters
    module.exports = {
      exporters: exporters,
      addExporter: addExporter
    };
    
  provide("pixelsmith/lib/exporters", module.exports);
}(global));

// pakmanager:pixelsmith/lib/image
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load in our dependencies
    var async = require('async');
    var getPixels = require('get-pixels');
    
    // Mass image creation
    function createImages(files, cb) {
      // In series
      async.waterfall([
        // Load the images into memory
        // DEV: If this becomes unwieldy, load in stats only. Then, inside of exporters, stream them in individually.
        function loadImages (cb) {
          async.map(files, function loadImage (filepath, cb) {
            getPixels(filepath, cb);
          }, cb);
        },
        function saveImgSizes (images, cb) {
          var i = 0;
          var len = images.length;
          for (; i < len; i++) {
            // Save the width and height
            // DEV: These can be padded later on
            var img = images[i];
    
            // If there are 4 dimensions, use the last 3
            // DEV: For gifs, the first dimension is frames
            if (img.shape.length === 4) {
              img.width = img.shape[1];
              img.height = img.shape[2];
            // Otherwise, use the normal [width, height, rgba] set
            } else {
              img.width = img.shape[0];
              img.height = img.shape[1];
            }
          }
          cb(null, images);
        }
      ], cb);
    }
    
    // Export single image creation and mass image creation
    module.exports = {
      createImages: createImages
    };
    
  provide("pixelsmith/lib/image", module.exports);
}(global));

// pakmanager:pixelsmith/lib/canvas
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load in dependencies
    var assert = require('assert');
    var ndarray = require('ndarray');
    var exporters =  require('pixelsmith/lib/exporters').exporters;
    
    // Define our canvas constructor
    function Canvas(width, height) {
      // Calculate and save dimensions/data for later
      var len = width * height * 4;
      this.width = width;
      this.height = height;
      this.data = new global.Uint8ClampedArray(len);
      this.ndarray = new ndarray(this.data, [width, height, 4]);
    
      // Create a store for images
      this.images = [];
    }
    Canvas.prototype = {
      addImage: function addImage (img, x, y) {
        // Save the image for later
        this.images.push({
          img: img,
          x: x,
          y: y
        });
      },
      'export': function exportFn (options, cb) {
        // Grab the exporter
        var format = options.format || 'png';
        var exporter = exporters[format];
    
        // Assert it exists
        assert(exporter, 'Exporter ' + format + ' does not exist for spritesmith\'s png engine');
    
        // Render the item
        exporter.call(this, options, cb);
      }
    };
    
    // Define an async constructor for our canvas
    function createCanvas(width, height, cb) {
      // Create a new canvas and callback
      var canvas = new Canvas(width, height);
      cb(null, canvas);
    }
    
    // Expose Canvas and createCanvas to engine
    module.exports = {
      Canvas: Canvas,
      createCanvas: createCanvas
    };
    
  provide("pixelsmith/lib/canvas", module.exports);
}(global));

// pakmanager:pixelsmith
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load in and combine all engine parts
    var extend = require('obj-extend');
    module.exports = extend({},
       require('pixelsmith/lib/image'),
       require('pixelsmith/lib/exporters'),
       require('pixelsmith/lib/canvas'));
    
  provide("pixelsmith", module.exports);
}(global));

// pakmanager:mustache
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mustache.js - Logic-less {{mustache}} templates with JavaScript
     * http://github.com/janl/mustache.js
     */
    
    /*global define: false Mustache: true*/
    
    (function defineMustache (global, factory) {
      if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
        factory(exports); // CommonJS
      } else if (typeof define === 'function' && define.amd) {
        define(['exports'], factory); // AMD
      } else {
        global.Mustache = {};
        factory(Mustache); // script, wsh, asp
      }
    }(this, function mustacheFactory (mustache) {
    
      var objectToString = Object.prototype.toString;
      var isArray = Array.isArray || function isArrayPolyfill (object) {
        return objectToString.call(object) === '[object Array]';
      };
    
      function isFunction (object) {
        return typeof object === 'function';
      }
    
      /**
       * More correct typeof string handling array
       * which normally returns typeof 'object'
       */
      function typeStr (obj) {
        return isArray(obj) ? 'array' : typeof obj;
      }
    
      function escapeRegExp (string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
      }
    
      /**
       * Null safe way of checking whether or not an object,
       * including its prototype, has a given property
       */
      function hasProperty (obj, propName) {
        return obj != null && typeof obj === 'object' && (propName in obj);
      }
    
      // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
      // See https://github.com/janl/mustache.js/issues/189
      var regExpTest = RegExp.prototype.test;
      function testRegExp (re, string) {
        return regExpTest.call(re, string);
      }
    
      var nonSpaceRe = /\S/;
      function isWhitespace (string) {
        return !testRegExp(nonSpaceRe, string);
      }
    
      var entityMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '/': '&#x2F;'
      };
    
      function escapeHtml (string) {
        return String(string).replace(/[&<>"'\/]/g, function fromEntityMap (s) {
          return entityMap[s];
        });
      }
    
      var whiteRe = /\s*/;
      var spaceRe = /\s+/;
      var equalsRe = /\s*=/;
      var curlyRe = /\s*\}/;
      var tagRe = /#|\^|\/|>|\{|&|=|!/;
    
      /**
       * Breaks up the given `template` string into a tree of tokens. If the `tags`
       * argument is given here it must be an array with two string values: the
       * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
       * course, the default is to use mustaches (i.e. mustache.tags).
       *
       * A token is an array with at least 4 elements. The first element is the
       * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
       * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
       * all text that appears outside a symbol this element is "text".
       *
       * The second element of a token is its "value". For mustache tags this is
       * whatever else was inside the tag besides the opening symbol. For text tokens
       * this is the text itself.
       *
       * The third and fourth elements of the token are the start and end indices,
       * respectively, of the token in the original template.
       *
       * Tokens that are the root node of a subtree contain two more elements: 1) an
       * array of tokens in the subtree and 2) the index in the original template at
       * which the closing tag for that section begins.
       */
      function parseTemplate (template, tags) {
        if (!template)
          return [];
    
        var sections = [];     // Stack to hold section tokens
        var tokens = [];       // Buffer to hold the tokens
        var spaces = [];       // Indices of whitespace tokens on the current line
        var hasTag = false;    // Is there a {{tag}} on the current line?
        var nonSpace = false;  // Is there a non-space char on the current line?
    
        // Strips all whitespace tokens array for the current line
        // if there was a {{#tag}} on it and otherwise only space.
        function stripSpace () {
          if (hasTag && !nonSpace) {
            while (spaces.length)
              delete tokens[spaces.pop()];
          } else {
            spaces = [];
          }
    
          hasTag = false;
          nonSpace = false;
        }
    
        var openingTagRe, closingTagRe, closingCurlyRe;
        function compileTags (tagsToCompile) {
          if (typeof tagsToCompile === 'string')
            tagsToCompile = tagsToCompile.split(spaceRe, 2);
    
          if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
            throw new Error('Invalid tags: ' + tagsToCompile);
    
          openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
          closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
          closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
        }
    
        compileTags(tags || mustache.tags);
    
        var scanner = new Scanner(template);
    
        var start, type, value, chr, token, openSection;
        while (!scanner.eos()) {
          start = scanner.pos;
    
          // Match any text between tags.
          value = scanner.scanUntil(openingTagRe);
    
          if (value) {
            for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
              chr = value.charAt(i);
    
              if (isWhitespace(chr)) {
                spaces.push(tokens.length);
              } else {
                nonSpace = true;
              }
    
              tokens.push([ 'text', chr, start, start + 1 ]);
              start += 1;
    
              // Check for whitespace on the current line.
              if (chr === '\n')
                stripSpace();
            }
          }
    
          // Match the opening tag.
          if (!scanner.scan(openingTagRe))
            break;
    
          hasTag = true;
    
          // Get the tag type.
          type = scanner.scan(tagRe) || 'name';
          scanner.scan(whiteRe);
    
          // Get the tag value.
          if (type === '=') {
            value = scanner.scanUntil(equalsRe);
            scanner.scan(equalsRe);
            scanner.scanUntil(closingTagRe);
          } else if (type === '{') {
            value = scanner.scanUntil(closingCurlyRe);
            scanner.scan(curlyRe);
            scanner.scanUntil(closingTagRe);
            type = '&';
          } else {
            value = scanner.scanUntil(closingTagRe);
          }
    
          // Match the closing tag.
          if (!scanner.scan(closingTagRe))
            throw new Error('Unclosed tag at ' + scanner.pos);
    
          token = [ type, value, start, scanner.pos ];
          tokens.push(token);
    
          if (type === '#' || type === '^') {
            sections.push(token);
          } else if (type === '/') {
            // Check section nesting.
            openSection = sections.pop();
    
            if (!openSection)
              throw new Error('Unopened section "' + value + '" at ' + start);
    
            if (openSection[1] !== value)
              throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
          } else if (type === 'name' || type === '{' || type === '&') {
            nonSpace = true;
          } else if (type === '=') {
            // Set the tags for the next time around.
            compileTags(value);
          }
        }
    
        // Make sure there are no open sections when we're done.
        openSection = sections.pop();
    
        if (openSection)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
    
        return nestTokens(squashTokens(tokens));
      }
    
      /**
       * Combines the values of consecutive text tokens in the given `tokens` array
       * to a single token.
       */
      function squashTokens (tokens) {
        var squashedTokens = [];
    
        var token, lastToken;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
    
          if (token) {
            if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
              lastToken[1] += token[1];
              lastToken[3] = token[3];
            } else {
              squashedTokens.push(token);
              lastToken = token;
            }
          }
        }
    
        return squashedTokens;
      }
    
      /**
       * Forms the given array of `tokens` into a nested tree structure where
       * tokens that represent a section have two additional items: 1) an array of
       * all tokens that appear in that section and 2) the index in the original
       * template that represents the end of that section.
       */
      function nestTokens (tokens) {
        var nestedTokens = [];
        var collector = nestedTokens;
        var sections = [];
    
        var token, section;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
    
          switch (token[0]) {
          case '#':
          case '^':
            collector.push(token);
            sections.push(token);
            collector = token[4] = [];
            break;
          case '/':
            section = sections.pop();
            section[5] = token[2];
            collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
            break;
          default:
            collector.push(token);
          }
        }
    
        return nestedTokens;
      }
    
      /**
       * A simple string scanner that is used by the template parser to find
       * tokens in template strings.
       */
      function Scanner (string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
      }
    
      /**
       * Returns `true` if the tail is empty (end of string).
       */
      Scanner.prototype.eos = function eos () {
        return this.tail === '';
      };
    
      /**
       * Tries to match the given regular expression at the current position.
       * Returns the matched text if it can match, the empty string otherwise.
       */
      Scanner.prototype.scan = function scan (re) {
        var match = this.tail.match(re);
    
        if (!match || match.index !== 0)
          return '';
    
        var string = match[0];
    
        this.tail = this.tail.substring(string.length);
        this.pos += string.length;
    
        return string;
      };
    
      /**
       * Skips all text until the given regular expression can be matched. Returns
       * the skipped string, which is the entire tail if no match can be made.
       */
      Scanner.prototype.scanUntil = function scanUntil (re) {
        var index = this.tail.search(re), match;
    
        switch (index) {
        case -1:
          match = this.tail;
          this.tail = '';
          break;
        case 0:
          match = '';
          break;
        default:
          match = this.tail.substring(0, index);
          this.tail = this.tail.substring(index);
        }
    
        this.pos += match.length;
    
        return match;
      };
    
      /**
       * Represents a rendering context by wrapping a view object and
       * maintaining a reference to the parent context.
       */
      function Context (view, parentContext) {
        this.view = view;
        this.cache = { '.': this.view };
        this.parent = parentContext;
      }
    
      /**
       * Creates a new context using the given view with this context
       * as the parent.
       */
      Context.prototype.push = function push (view) {
        return new Context(view, this);
      };
    
      /**
       * Returns the value of the given name in this context, traversing
       * up the context hierarchy if the value is absent in this context's view.
       */
      Context.prototype.lookup = function lookup (name) {
        var cache = this.cache;
    
        var value;
        if (cache.hasOwnProperty(name)) {
          value = cache[name];
        } else {
          var context = this, names, index, lookupHit = false;
    
          while (context) {
            if (name.indexOf('.') > 0) {
              value = context.view;
              names = name.split('.');
              index = 0;
    
              /**
               * Using the dot notion path in `name`, we descend through the
               * nested objects.
               *
               * To be certain that the lookup has been successful, we have to
               * check if the last object in the path actually has the property
               * we are looking for. We store the result in `lookupHit`.
               *
               * This is specially necessary for when the value has been set to
               * `undefined` and we want to avoid looking up parent contexts.
               **/
              while (value != null && index < names.length) {
                if (index === names.length - 1)
                  lookupHit = hasProperty(value, names[index]);
    
                value = value[names[index++]];
              }
            } else {
              value = context.view[name];
              lookupHit = hasProperty(context.view, name);
            }
    
            if (lookupHit)
              break;
    
            context = context.parent;
          }
    
          cache[name] = value;
        }
    
        if (isFunction(value))
          value = value.call(this.view);
    
        return value;
      };
    
      /**
       * A Writer knows how to take a stream of tokens and render them to a
       * string, given a context. It also maintains a cache of templates to
       * avoid the need to parse the same template twice.
       */
      function Writer () {
        this.cache = {};
      }
    
      /**
       * Clears all cached templates in this writer.
       */
      Writer.prototype.clearCache = function clearCache () {
        this.cache = {};
      };
    
      /**
       * Parses and caches the given `template` and returns the array of tokens
       * that is generated from the parse.
       */
      Writer.prototype.parse = function parse (template, tags) {
        var cache = this.cache;
        var tokens = cache[template];
    
        if (tokens == null)
          tokens = cache[template] = parseTemplate(template, tags);
    
        return tokens;
      };
    
      /**
       * High-level method that is used to render the given `template` with
       * the given `view`.
       *
       * The optional `partials` argument may be an object that contains the
       * names and templates of partials that are used in the template. It may
       * also be a function that is used to load partial templates on the fly
       * that takes a single argument: the name of the partial.
       */
      Writer.prototype.render = function render (template, view, partials) {
        var tokens = this.parse(template);
        var context = (view instanceof Context) ? view : new Context(view);
        return this.renderTokens(tokens, context, partials, template);
      };
    
      /**
       * Low-level method that renders the given array of `tokens` using
       * the given `context` and `partials`.
       *
       * Note: The `originalTemplate` is only ever used to extract the portion
       * of the original template that was contained in a higher-order section.
       * If the template doesn't use higher-order sections, this argument may
       * be omitted.
       */
      Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
        var buffer = '';
    
        var token, symbol, value;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          value = undefined;
          token = tokens[i];
          symbol = token[0];
    
          if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
          else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
          else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
          else if (symbol === '&') value = this.unescapedValue(token, context);
          else if (symbol === 'name') value = this.escapedValue(token, context);
          else if (symbol === 'text') value = this.rawValue(token);
    
          if (value !== undefined)
            buffer += value;
        }
    
        return buffer;
      };
    
      Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
        var self = this;
        var buffer = '';
        var value = context.lookup(token[1]);
    
        // This function is used to render an arbitrary template
        // in the current context by higher-order sections.
        function subRender (template) {
          return self.render(template, context, partials);
        }
    
        if (!value) return;
    
        if (isArray(value)) {
          for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
          }
        } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
          buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
        } else if (isFunction(value)) {
          if (typeof originalTemplate !== 'string')
            throw new Error('Cannot use higher-order sections without the original template');
    
          // Extract the portion of the original template that the section contains.
          value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
    
          if (value != null)
            buffer += value;
        } else {
          buffer += this.renderTokens(token[4], context, partials, originalTemplate);
        }
        return buffer;
      };
    
      Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
        var value = context.lookup(token[1]);
    
        // Use JavaScript's definition of falsy. Include empty arrays.
        // See https://github.com/janl/mustache.js/issues/186
        if (!value || (isArray(value) && value.length === 0))
          return this.renderTokens(token[4], context, partials, originalTemplate);
      };
    
      Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
        if (!partials) return;
    
        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
        if (value != null)
          return this.renderTokens(this.parse(value), context, partials, value);
      };
    
      Writer.prototype.unescapedValue = function unescapedValue (token, context) {
        var value = context.lookup(token[1]);
        if (value != null)
          return value;
      };
    
      Writer.prototype.escapedValue = function escapedValue (token, context) {
        var value = context.lookup(token[1]);
        if (value != null)
          return mustache.escape(value);
      };
    
      Writer.prototype.rawValue = function rawValue (token) {
        return token[1];
      };
    
      mustache.name = 'mustache.js';
      mustache.version = '2.1.3';
      mustache.tags = [ '{{', '}}' ];
    
      // All high-level mustache.* functions use this writer.
      var defaultWriter = new Writer();
    
      /**
       * Clears all cached templates in the default writer.
       */
      mustache.clearCache = function clearCache () {
        return defaultWriter.clearCache();
      };
    
      /**
       * Parses and caches the given template in the default writer and returns the
       * array of tokens it contains. Doing this ahead of time avoids the need to
       * parse templates on the fly as they are rendered.
       */
      mustache.parse = function parse (template, tags) {
        return defaultWriter.parse(template, tags);
      };
    
      /**
       * Renders the `template` with the given `view` and `partials` using the
       * default writer.
       */
      mustache.render = function render (template, view, partials) {
        if (typeof template !== 'string') {
          throw new TypeError('Invalid template! Template should be a "string" ' +
                              'but "' + typeStr(template) + '" was given as the first ' +
                              'argument for mustache#render(template, view, partials)');
        }
    
        return defaultWriter.render(template, view, partials);
      };
    
      // This is here for backwards compatibility with 0.4.x.,
      /*eslint-disable */ // eslint wants camel cased function name
      mustache.to_html = function to_html (template, view, partials, send) {
        /*eslint-enable*/
    
        var result = mustache.render(template, view, partials);
    
        if (isFunction(send)) {
          send(result);
        } else {
          return result;
        }
      };
    
      // Export the escaping function so that the user may override it.
      // See https://github.com/janl/mustache.js/issues/244
      mustache.escape = escapeHtml;
    
      // Export these mainly for testing, but also for advanced usage.
      mustache.Scanner = Scanner;
      mustache.Context = Context;
      mustache.Writer = Writer;
    
    }));
    
  provide("mustache", module.exports);
}(global));

// pakmanager:underscore
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  //     Underscore.js 1.5.2
    //     http://underscorejs.org
    //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    
    (function() {
    
      // Baseline setup
      // --------------
    
      // Establish the root object, `window` in the browser, or `exports` on the server.
      var root = this;
    
      // Save the previous value of the `_` variable.
      var previousUnderscore = root._;
    
      // Establish the object that gets returned to break out of a loop iteration.
      var breaker = {};
    
      // Save bytes in the minified (but not gzipped) version:
      var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
    
      // Create quick reference variables for speed access to core prototypes.
      var
        push             = ArrayProto.push,
        slice            = ArrayProto.slice,
        concat           = ArrayProto.concat,
        toString         = ObjProto.toString,
        hasOwnProperty   = ObjProto.hasOwnProperty;
    
      // All **ECMAScript 5** native function implementations that we hope to use
      // are declared here.
      var
        nativeForEach      = ArrayProto.forEach,
        nativeMap          = ArrayProto.map,
        nativeReduce       = ArrayProto.reduce,
        nativeReduceRight  = ArrayProto.reduceRight,
        nativeFilter       = ArrayProto.filter,
        nativeEvery        = ArrayProto.every,
        nativeSome         = ArrayProto.some,
        nativeIndexOf      = ArrayProto.indexOf,
        nativeLastIndexOf  = ArrayProto.lastIndexOf,
        nativeIsArray      = Array.isArray,
        nativeKeys         = Object.keys,
        nativeBind         = FuncProto.bind;
    
      // Create a safe reference to the Underscore object for use below.
      var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
      };
    
      // Export the Underscore object for **Node.js**, with
      // backwards-compatibility for the old `require()` API. If we're in
      // the browser, add `_` as a global object via a string identifier,
      // for Closure Compiler "advanced" mode.
      if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
          exports = module.exports = _;
        }
        exports._ = _;
      } else {
        root._ = _;
      }
    
      // Current version.
      _.VERSION = '1.5.2';
    
      // Collection Functions
      // --------------------
    
      // The cornerstone, an `each` implementation, aka `forEach`.
      // Handles objects with the built-in `forEach`, arrays, and raw objects.
      // Delegates to **ECMAScript 5**'s native `forEach` if available.
      var each = _.each = _.forEach = function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, length = obj.length; i < length; i++) {
            if (iterator.call(context, obj[i], i, obj) === breaker) return;
          }
        } else {
          var keys = _.keys(obj);
          for (var i = 0, length = keys.length; i < length; i++) {
            if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
          }
        }
      };
    
      // Return the results of applying the iterator to each element.
      // Delegates to **ECMAScript 5**'s native `map` if available.
      _.map = _.collect = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
        each(obj, function(value, index, list) {
          results.push(iterator.call(context, value, index, list));
        });
        return results;
      };
    
      var reduceError = 'Reduce of empty array with no initial value';
    
      // **Reduce** builds up a single result from a list of values, aka `inject`,
      // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
      _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduce && obj.reduce === nativeReduce) {
          if (context) iterator = _.bind(iterator, context);
          return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }
        each(obj, function(value, index, list) {
          if (!initial) {
            memo = value;
            initial = true;
          } else {
            memo = iterator.call(context, memo, value, index, list);
          }
        });
        if (!initial) throw new TypeError(reduceError);
        return memo;
      };
    
      // The right-associative version of reduce, also known as `foldr`.
      // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
      _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
          if (context) iterator = _.bind(iterator, context);
          return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
        }
        var length = obj.length;
        if (length !== +length) {
          var keys = _.keys(obj);
          length = keys.length;
        }
        each(obj, function(value, index, list) {
          index = keys ? keys[--length] : --length;
          if (!initial) {
            memo = obj[index];
            initial = true;
          } else {
            memo = iterator.call(context, memo, obj[index], index, list);
          }
        });
        if (!initial) throw new TypeError(reduceError);
        return memo;
      };
    
      // Return the first value which passes a truth test. Aliased as `detect`.
      _.find = _.detect = function(obj, iterator, context) {
        var result;
        any(obj, function(value, index, list) {
          if (iterator.call(context, value, index, list)) {
            result = value;
            return true;
          }
        });
        return result;
      };
    
      // Return all the elements that pass a truth test.
      // Delegates to **ECMAScript 5**'s native `filter` if available.
      // Aliased as `select`.
      _.filter = _.select = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
        each(obj, function(value, index, list) {
          if (iterator.call(context, value, index, list)) results.push(value);
        });
        return results;
      };
    
      // Return all the elements for which a truth test fails.
      _.reject = function(obj, iterator, context) {
        return _.filter(obj, function(value, index, list) {
          return !iterator.call(context, value, index, list);
        }, context);
      };
    
      // Determine whether all of the elements match a truth test.
      // Delegates to **ECMAScript 5**'s native `every` if available.
      // Aliased as `all`.
      _.every = _.all = function(obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = true;
        if (obj == null) return result;
        if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
        each(obj, function(value, index, list) {
          if (!(result = result && iterator.call(context, value, index, list))) return breaker;
        });
        return !!result;
      };
    
      // Determine if at least one element in the object matches a truth test.
      // Delegates to **ECMAScript 5**'s native `some` if available.
      // Aliased as `any`.
      var any = _.some = _.any = function(obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = false;
        if (obj == null) return result;
        if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
        each(obj, function(value, index, list) {
          if (result || (result = iterator.call(context, value, index, list))) return breaker;
        });
        return !!result;
      };
    
      // Determine if the array or object contains a given value (using `===`).
      // Aliased as `include`.
      _.contains = _.include = function(obj, target) {
        if (obj == null) return false;
        if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
        return any(obj, function(value) {
          return value === target;
        });
      };
    
      // Invoke a method (with arguments) on every item in a collection.
      _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
          return (isFunc ? method : value[method]).apply(value, args);
        });
      };
    
      // Convenience version of a common use case of `map`: fetching a property.
      _.pluck = function(obj, key) {
        return _.map(obj, function(value){ return value[key]; });
      };
    
      // Convenience version of a common use case of `filter`: selecting only objects
      // containing specific `key:value` pairs.
      _.where = function(obj, attrs, first) {
        if (_.isEmpty(attrs)) return first ? void 0 : [];
        return _[first ? 'find' : 'filter'](obj, function(value) {
          for (var key in attrs) {
            if (attrs[key] !== value[key]) return false;
          }
          return true;
        });
      };
    
      // Convenience version of a common use case of `find`: getting the first object
      // containing specific `key:value` pairs.
      _.findWhere = function(obj, attrs) {
        return _.where(obj, attrs, true);
      };
    
      // Return the maximum element or (element-based computation).
      // Can't optimize arrays of integers longer than 65,535 elements.
      // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
      _.max = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
          return Math.max.apply(Math, obj);
        }
        if (!iterator && _.isEmpty(obj)) return -Infinity;
        var result = {computed : -Infinity, value: -Infinity};
        each(obj, function(value, index, list) {
          var computed = iterator ? iterator.call(context, value, index, list) : value;
          computed > result.computed && (result = {value : value, computed : computed});
        });
        return result.value;
      };
    
      // Return the minimum element (or element-based computation).
      _.min = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
          return Math.min.apply(Math, obj);
        }
        if (!iterator && _.isEmpty(obj)) return Infinity;
        var result = {computed : Infinity, value: Infinity};
        each(obj, function(value, index, list) {
          var computed = iterator ? iterator.call(context, value, index, list) : value;
          computed < result.computed && (result = {value : value, computed : computed});
        });
        return result.value;
      };
    
      // Shuffle an array, using the modern version of the 
      // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
      _.shuffle = function(obj) {
        var rand;
        var index = 0;
        var shuffled = [];
        each(obj, function(value) {
          rand = _.random(index++);
          shuffled[index - 1] = shuffled[rand];
          shuffled[rand] = value;
        });
        return shuffled;
      };
    
      // Sample **n** random values from an array.
      // If **n** is not specified, returns a single random element from the array.
      // The internal `guard` argument allows it to work with `map`.
      _.sample = function(obj, n, guard) {
        if (arguments.length < 2 || guard) {
          return obj[_.random(obj.length - 1)];
        }
        return _.shuffle(obj).slice(0, Math.max(0, n));
      };
    
      // An internal function to generate lookup iterators.
      var lookupIterator = function(value) {
        return _.isFunction(value) ? value : function(obj){ return obj[value]; };
      };
    
      // Sort the object's values by a criterion produced by an iterator.
      _.sortBy = function(obj, value, context) {
        var iterator = lookupIterator(value);
        return _.pluck(_.map(obj, function(value, index, list) {
          return {
            value: value,
            index: index,
            criteria: iterator.call(context, value, index, list)
          };
        }).sort(function(left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
          }
          return left.index - right.index;
        }), 'value');
      };
    
      // An internal function used for aggregate "group by" operations.
      var group = function(behavior) {
        return function(obj, value, context) {
          var result = {};
          var iterator = value == null ? _.identity : lookupIterator(value);
          each(obj, function(value, index) {
            var key = iterator.call(context, value, index, obj);
            behavior(result, key, value);
          });
          return result;
        };
      };
    
      // Groups the object's values by a criterion. Pass either a string attribute
      // to group by, or a function that returns the criterion.
      _.groupBy = group(function(result, key, value) {
        (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
      });
    
      // Indexes the object's values by a criterion, similar to `groupBy`, but for
      // when you know that your index values will be unique.
      _.indexBy = group(function(result, key, value) {
        result[key] = value;
      });
    
      // Counts instances of an object that group by a certain criterion. Pass
      // either a string attribute to count by, or a function that returns the
      // criterion.
      _.countBy = group(function(result, key) {
        _.has(result, key) ? result[key]++ : result[key] = 1;
      });
    
      // Use a comparator function to figure out the smallest index at which
      // an object should be inserted so as to maintain order. Uses binary search.
      _.sortedIndex = function(array, obj, iterator, context) {
        iterator = iterator == null ? _.identity : lookupIterator(iterator);
        var value = iterator.call(context, obj);
        var low = 0, high = array.length;
        while (low < high) {
          var mid = (low + high) >>> 1;
          iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
      };
    
      // Safely create a real, live array from anything iterable.
      _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (obj.length === +obj.length) return _.map(obj, _.identity);
        return _.values(obj);
      };
    
      // Return the number of elements in an object.
      _.size = function(obj) {
        if (obj == null) return 0;
        return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
      };
    
      // Array Functions
      // ---------------
    
      // Get the first element of an array. Passing **n** will return the first N
      // values in the array. Aliased as `head` and `take`. The **guard** check
      // allows it to work with `_.map`.
      _.first = _.head = _.take = function(array, n, guard) {
        if (array == null) return void 0;
        return (n == null) || guard ? array[0] : slice.call(array, 0, n);
      };
    
      // Returns everything but the last entry of the array. Especially useful on
      // the arguments object. Passing **n** will return all the values in
      // the array, excluding the last N. The **guard** check allows it to work with
      // `_.map`.
      _.initial = function(array, n, guard) {
        return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
      };
    
      // Get the last element of an array. Passing **n** will return the last N
      // values in the array. The **guard** check allows it to work with `_.map`.
      _.last = function(array, n, guard) {
        if (array == null) return void 0;
        if ((n == null) || guard) {
          return array[array.length - 1];
        } else {
          return slice.call(array, Math.max(array.length - n, 0));
        }
      };
    
      // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
      // Especially useful on the arguments object. Passing an **n** will return
      // the rest N values in the array. The **guard**
      // check allows it to work with `_.map`.
      _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, (n == null) || guard ? 1 : n);
      };
    
      // Trim out all falsy values from an array.
      _.compact = function(array) {
        return _.filter(array, _.identity);
      };
    
      // Internal implementation of a recursive `flatten` function.
      var flatten = function(input, shallow, output) {
        if (shallow && _.every(input, _.isArray)) {
          return concat.apply(output, input);
        }
        each(input, function(value) {
          if (_.isArray(value) || _.isArguments(value)) {
            shallow ? push.apply(output, value) : flatten(value, shallow, output);
          } else {
            output.push(value);
          }
        });
        return output;
      };
    
      // Flatten out an array, either recursively (by default), or just one level.
      _.flatten = function(array, shallow) {
        return flatten(array, shallow, []);
      };
    
      // Return a version of the array that does not contain the specified value(s).
      _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
      };
    
      // Produce a duplicate-free version of the array. If the array has already
      // been sorted, you have the option of using a faster algorithm.
      // Aliased as `unique`.
      _.uniq = _.unique = function(array, isSorted, iterator, context) {
        if (_.isFunction(isSorted)) {
          context = iterator;
          iterator = isSorted;
          isSorted = false;
        }
        var initial = iterator ? _.map(array, iterator, context) : array;
        var results = [];
        var seen = [];
        each(initial, function(value, index) {
          if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
            seen.push(value);
            results.push(array[index]);
          }
        });
        return results;
      };
    
      // Produce an array that contains the union: each distinct element from all of
      // the passed-in arrays.
      _.union = function() {
        return _.uniq(_.flatten(arguments, true));
      };
    
      // Produce an array that contains every item shared between all the
      // passed-in arrays.
      _.intersection = function(array) {
        var rest = slice.call(arguments, 1);
        return _.filter(_.uniq(array), function(item) {
          return _.every(rest, function(other) {
            return _.indexOf(other, item) >= 0;
          });
        });
      };
    
      // Take the difference between one array and a number of other arrays.
      // Only the elements present in just the first array will remain.
      _.difference = function(array) {
        var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
        return _.filter(array, function(value){ return !_.contains(rest, value); });
      };
    
      // Zip together multiple lists into a single array -- elements that share
      // an index go together.
      _.zip = function() {
        var length = _.max(_.pluck(arguments, "length").concat(0));
        var results = new Array(length);
        for (var i = 0; i < length; i++) {
          results[i] = _.pluck(arguments, '' + i);
        }
        return results;
      };
    
      // Converts lists into objects. Pass either a single array of `[key, value]`
      // pairs, or two parallel arrays of the same length -- one of keys, and one of
      // the corresponding values.
      _.object = function(list, values) {
        if (list == null) return {};
        var result = {};
        for (var i = 0, length = list.length; i < length; i++) {
          if (values) {
            result[list[i]] = values[i];
          } else {
            result[list[i][0]] = list[i][1];
          }
        }
        return result;
      };
    
      // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
      // we need this function. Return the position of the first occurrence of an
      // item in an array, or -1 if the item is not included in the array.
      // Delegates to **ECMAScript 5**'s native `indexOf` if available.
      // If the array is large and already in sort order, pass `true`
      // for **isSorted** to use binary search.
      _.indexOf = function(array, item, isSorted) {
        if (array == null) return -1;
        var i = 0, length = array.length;
        if (isSorted) {
          if (typeof isSorted == 'number') {
            i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
          } else {
            i = _.sortedIndex(array, item);
            return array[i] === item ? i : -1;
          }
        }
        if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
        for (; i < length; i++) if (array[i] === item) return i;
        return -1;
      };
    
      // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
      _.lastIndexOf = function(array, item, from) {
        if (array == null) return -1;
        var hasIndex = from != null;
        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
          return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
        }
        var i = (hasIndex ? from : array.length);
        while (i--) if (array[i] === item) return i;
        return -1;
      };
    
      // Generate an integer Array containing an arithmetic progression. A port of
      // the native Python `range()` function. See
      // [the Python documentation](http://docs.python.org/library/functions.html#range).
      _.range = function(start, stop, step) {
        if (arguments.length <= 1) {
          stop = start || 0;
          start = 0;
        }
        step = arguments[2] || 1;
    
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(length);
    
        while(idx < length) {
          range[idx++] = start;
          start += step;
        }
    
        return range;
      };
    
      // Function (ahem) Functions
      // ------------------
    
      // Reusable constructor function for prototype setting.
      var ctor = function(){};
    
      // Create a function bound to a given object (assigning `this`, and arguments,
      // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
      // available.
      _.bind = function(func, context) {
        var args, bound;
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError;
        args = slice.call(arguments, 2);
        return bound = function() {
          if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
          ctor.prototype = func.prototype;
          var self = new ctor;
          ctor.prototype = null;
          var result = func.apply(self, args.concat(slice.call(arguments)));
          if (Object(result) === result) return result;
          return self;
        };
      };
    
      // Partially apply a function by creating a version that has had some of its
      // arguments pre-filled, without changing its dynamic `this` context.
      _.partial = function(func) {
        var args = slice.call(arguments, 1);
        return function() {
          return func.apply(this, args.concat(slice.call(arguments)));
        };
      };
    
      // Bind all of an object's methods to that object. Useful for ensuring that
      // all callbacks defined on an object belong to it.
      _.bindAll = function(obj) {
        var funcs = slice.call(arguments, 1);
        if (funcs.length === 0) throw new Error("bindAll must be passed function names");
        each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
        return obj;
      };
    
      // Memoize an expensive function by storing its results.
      _.memoize = function(func, hasher) {
        var memo = {};
        hasher || (hasher = _.identity);
        return function() {
          var key = hasher.apply(this, arguments);
          return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
        };
      };
    
      // Delays a function for the given number of milliseconds, and then calls
      // it with the arguments supplied.
      _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function(){ return func.apply(null, args); }, wait);
      };
    
      // Defers a function, scheduling it to run after the current call stack has
      // cleared.
      _.defer = function(func) {
        return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
      };
    
      // Returns a function, that, when invoked, will only be triggered at most once
      // during a given window of time. Normally, the throttled function will run
      // as much as it can, without ever going more than once per `wait` duration;
      // but if you'd like to disable the execution on the leading edge, pass
      // `{leading: false}`. To disable execution on the trailing edge, ditto.
      _.throttle = function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        options || (options = {});
        var later = function() {
          previous = options.leading === false ? 0 : new Date;
          timeout = null;
          result = func.apply(context, args);
        };
        return function() {
          var now = new Date;
          if (!previous && options.leading === false) previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0) {
            clearTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
      };
    
      // Returns a function, that, as long as it continues to be invoked, will not
      // be triggered. The function will be called after it stops being called for
      // N milliseconds. If `immediate` is passed, trigger the function on the
      // leading edge, instead of the trailing.
      _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        return function() {
          context = this;
          args = arguments;
          timestamp = new Date();
          var later = function() {
            var last = (new Date()) - timestamp;
            if (last < wait) {
              timeout = setTimeout(later, wait - last);
            } else {
              timeout = null;
              if (!immediate) result = func.apply(context, args);
            }
          };
          var callNow = immediate && !timeout;
          if (!timeout) {
            timeout = setTimeout(later, wait);
          }
          if (callNow) result = func.apply(context, args);
          return result;
        };
      };
    
      // Returns a function that will be executed at most one time, no matter how
      // often you call it. Useful for lazy initialization.
      _.once = function(func) {
        var ran = false, memo;
        return function() {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      };
    
      // Returns the first function passed as an argument to the second,
      // allowing you to adjust arguments, run code before and after, and
      // conditionally execute the original function.
      _.wrap = function(func, wrapper) {
        return function() {
          var args = [func];
          push.apply(args, arguments);
          return wrapper.apply(this, args);
        };
      };
    
      // Returns a function that is the composition of a list of functions, each
      // consuming the return value of the function that follows.
      _.compose = function() {
        var funcs = arguments;
        return function() {
          var args = arguments;
          for (var i = funcs.length - 1; i >= 0; i--) {
            args = [funcs[i].apply(this, args)];
          }
          return args[0];
        };
      };
    
      // Returns a function that will only be executed after being called N times.
      _.after = function(times, func) {
        return function() {
          if (--times < 1) {
            return func.apply(this, arguments);
          }
        };
      };
    
      // Object Functions
      // ----------------
    
      // Retrieve the names of an object's properties.
      // Delegates to **ECMAScript 5**'s native `Object.keys`
      _.keys = nativeKeys || function(obj) {
        if (obj !== Object(obj)) throw new TypeError('Invalid object');
        var keys = [];
        for (var key in obj) if (_.has(obj, key)) keys.push(key);
        return keys;
      };
    
      // Retrieve the values of an object's properties.
      _.values = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = new Array(length);
        for (var i = 0; i < length; i++) {
          values[i] = obj[keys[i]];
        }
        return values;
      };
    
      // Convert an object into a list of `[key, value]` pairs.
      _.pairs = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = new Array(length);
        for (var i = 0; i < length; i++) {
          pairs[i] = [keys[i], obj[keys[i]]];
        }
        return pairs;
      };
    
      // Invert the keys and values of an object. The values must be serializable.
      _.invert = function(obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          result[obj[keys[i]]] = keys[i];
        }
        return result;
      };
    
      // Return a sorted list of the function names available on the object.
      // Aliased as `methods`
      _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
          if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
      };
    
      // Extend a given object with all the properties in passed-in object(s).
      _.extend = function(obj) {
        each(slice.call(arguments, 1), function(source) {
          if (source) {
            for (var prop in source) {
              obj[prop] = source[prop];
            }
          }
        });
        return obj;
      };
    
      // Return a copy of the object only containing the whitelisted properties.
      _.pick = function(obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        each(keys, function(key) {
          if (key in obj) copy[key] = obj[key];
        });
        return copy;
      };
    
       // Return a copy of the object without the blacklisted properties.
      _.omit = function(obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        for (var key in obj) {
          if (!_.contains(keys, key)) copy[key] = obj[key];
        }
        return copy;
      };
    
      // Fill in a given object with default properties.
      _.defaults = function(obj) {
        each(slice.call(arguments, 1), function(source) {
          if (source) {
            for (var prop in source) {
              if (obj[prop] === void 0) obj[prop] = source[prop];
            }
          }
        });
        return obj;
      };
    
      // Create a (shallow-cloned) duplicate of an object.
      _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
      };
    
      // Invokes interceptor with the obj, and then returns obj.
      // The primary purpose of this method is to "tap into" a method chain, in
      // order to perform operations on intermediate results within the chain.
      _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
      };
    
      // Internal recursive comparison function for `isEqual`.
      var eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a == 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null) return a === b;
        // Unwrap any wrapped objects.
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className != toString.call(b)) return false;
        switch (className) {
          // Strings, numbers, dates, and booleans are compared by value.
          case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return a == String(b);
          case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
            // other numeric values.
            return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
          case '[object Date]':
          case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
          // RegExps are compared by their source patterns and flags.
          case '[object RegExp]':
            return a.source == b.source &&
                   a.global == b.global &&
                   a.multiline == b.multiline &&
                   a.ignoreCase == b.ignoreCase;
        }
        if (typeof a != 'object' || typeof b != 'object') return false;
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
        var length = aStack.length;
        while (length--) {
          // Linear search. Performance is inversely proportional to the number of
          // unique nested structures.
          if (aStack[length] == a) return bStack[length] == b;
        }
        // Objects with different constructors are not equivalent, but `Object`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                                 _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
          return false;
        }
        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);
        var size = 0, result = true;
        // Recursively compare objects and arrays.
        if (className == '[object Array]') {
          // Compare array lengths to determine if a deep comparison is necessary.
          size = a.length;
          result = size == b.length;
          if (result) {
            // Deep compare the contents, ignoring non-numeric properties.
            while (size--) {
              if (!(result = eq(a[size], b[size], aStack, bStack))) break;
            }
          }
        } else {
          // Deep compare objects.
          for (var key in a) {
            if (_.has(a, key)) {
              // Count the expected number of properties.
              size++;
              // Deep compare each member.
              if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
            }
          }
          // Ensure that both objects contain the same number of properties.
          if (result) {
            for (key in b) {
              if (_.has(b, key) && !(size--)) break;
            }
            result = !size;
          }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return result;
      };
    
      // Perform a deep comparison to check if two objects are equal.
      _.isEqual = function(a, b) {
        return eq(a, b, [], []);
      };
    
      // Is a given array, string, or object empty?
      // An "empty" object has no enumerable own-properties.
      _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
        for (var key in obj) if (_.has(obj, key)) return false;
        return true;
      };
    
      // Is a given value a DOM element?
      _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
      };
    
      // Is a given value an array?
      // Delegates to ECMA5's native Array.isArray
      _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) == '[object Array]';
      };
    
      // Is a given variable an object?
      _.isObject = function(obj) {
        return obj === Object(obj);
      };
    
      // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
      each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
        _['is' + name] = function(obj) {
          return toString.call(obj) == '[object ' + name + ']';
        };
      });
    
      // Define a fallback version of the method in browsers (ahem, IE), where
      // there isn't any inspectable "Arguments" type.
      if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
          return !!(obj && _.has(obj, 'callee'));
        };
      }
    
      // Optimize `isFunction` if appropriate.
      if (typeof (/./) !== 'function') {
        _.isFunction = function(obj) {
          return typeof obj === 'function';
        };
      }
    
      // Is a given object a finite number?
      _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
      };
    
      // Is the given value `NaN`? (NaN is the only number which does not equal itself).
      _.isNaN = function(obj) {
        return _.isNumber(obj) && obj != +obj;
      };
    
      // Is a given value a boolean?
      _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
      };
    
      // Is a given value equal to null?
      _.isNull = function(obj) {
        return obj === null;
      };
    
      // Is a given variable undefined?
      _.isUndefined = function(obj) {
        return obj === void 0;
      };
    
      // Shortcut function for checking if an object has a given property directly
      // on itself (in other words, not on a prototype).
      _.has = function(obj, key) {
        return hasOwnProperty.call(obj, key);
      };
    
      // Utility Functions
      // -----------------
    
      // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
      // previous owner. Returns a reference to the Underscore object.
      _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
      };
    
      // Keep the identity function around for default iterators.
      _.identity = function(value) {
        return value;
      };
    
      // Run a function **n** times.
      _.times = function(n, iterator, context) {
        var accum = Array(Math.max(0, n));
        for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
        return accum;
      };
    
      // Return a random integer between min and max (inclusive).
      _.random = function(min, max) {
        if (max == null) {
          max = min;
          min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
      };
    
      // List of HTML entities for escaping.
      var entityMap = {
        escape: {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#x27;'
        }
      };
      entityMap.unescape = _.invert(entityMap.escape);
    
      // Regexes containing the keys and values listed immediately above.
      var entityRegexes = {
        escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
        unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
      };
    
      // Functions for escaping and unescaping strings to/from HTML interpolation.
      _.each(['escape', 'unescape'], function(method) {
        _[method] = function(string) {
          if (string == null) return '';
          return ('' + string).replace(entityRegexes[method], function(match) {
            return entityMap[method][match];
          });
        };
      });
    
      // If the value of the named `property` is a function then invoke it with the
      // `object` as context; otherwise, return it.
      _.result = function(object, property) {
        if (object == null) return void 0;
        var value = object[property];
        return _.isFunction(value) ? value.call(object) : value;
      };
    
      // Add your own custom functions to the Underscore object.
      _.mixin = function(obj) {
        each(_.functions(obj), function(name) {
          var func = _[name] = obj[name];
          _.prototype[name] = function() {
            var args = [this._wrapped];
            push.apply(args, arguments);
            return result.call(this, func.apply(_, args));
          };
        });
      };
    
      // Generate a unique integer id (unique within the entire client session).
      // Useful for temporary DOM ids.
      var idCounter = 0;
      _.uniqueId = function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      };
    
      // By default, Underscore uses ERB-style template delimiters, change the
      // following template settings to use alternative delimiters.
      _.templateSettings = {
        evaluate    : /<%([\s\S]+?)%>/g,
        interpolate : /<%=([\s\S]+?)%>/g,
        escape      : /<%-([\s\S]+?)%>/g
      };
    
      // When customizing `templateSettings`, if you don't want to define an
      // interpolation, evaluation or escaping regex, we need one that is
      // guaranteed not to match.
      var noMatch = /(.)^/;
    
      // Certain characters need to be escaped so that they can be put into a
      // string literal.
      var escapes = {
        "'":      "'",
        '\\':     '\\',
        '\r':     'r',
        '\n':     'n',
        '\t':     't',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
    
      var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    
      // JavaScript micro-templating, similar to John Resig's implementation.
      // Underscore templating handles arbitrary delimiters, preserves whitespace,
      // and correctly escapes quotes within interpolated code.
      _.template = function(text, data, settings) {
        var render;
        settings = _.defaults({}, settings, _.templateSettings);
    
        // Combine delimiters into one regular expression via alternation.
        var matcher = new RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');
    
        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset)
            .replace(escaper, function(match) { return '\\' + escapes[match]; });
    
          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          }
          if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          }
          if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
    
        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
    
        source = "var __t,__p='',__j=Array.prototype.join," +
          "print=function(){__p+=__j.call(arguments,'');};\n" +
          source + "return __p;\n";
    
        try {
          render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }
    
        if (data) return render(data, _);
        var template = function(data) {
          return render.call(this, data, _);
        };
    
        // Provide the compiled function source as a convenience for precompilation.
        template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
    
        return template;
      };
    
      // Add a "chain" function, which will delegate to the wrapper.
      _.chain = function(obj) {
        return _(obj).chain();
      };
    
      // OOP
      // ---------------
      // If Underscore is called as a function, it returns a wrapped object that
      // can be used OO-style. This wrapper holds altered versions of all the
      // underscore functions. Wrapped objects may be chained.
    
      // Helper function to continue chaining intermediate results.
      var result = function(obj) {
        return this._chain ? _(obj).chain() : obj;
      };
    
      // Add all of the Underscore functions to the wrapper object.
      _.mixin(_);
    
      // Add all mutator Array functions to the wrapper.
      each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          var obj = this._wrapped;
          method.apply(obj, arguments);
          if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
          return result.call(this, obj);
        };
      });
    
      // Add all accessor Array functions to the wrapper.
      each(['concat', 'join', 'slice'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          return result.call(this, method.apply(this._wrapped, arguments));
        };
      });
    
      _.extend(_.prototype, {
    
        // Start chaining a wrapped Underscore object.
        chain: function() {
          this._chain = true;
          return this;
        },
    
        // Extracts the result from a wrapped and chained object.
        value: function() {
          return this._wrapped;
        }
    
      });
    
    }).call(this);
    
  provide("underscore", module.exports);
}(global));

// pakmanager:json-content-demux
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * @param {String} muxStr Muxed content to break up
     * TODO: options is not yet used
     * @param {Object} [options] Options to break up by
     * @param {String|RegExp} [options.delimiter=/\n\r?\n\r?/] Delimiter between JSON and content
     * @returns {Object} retObj
     * @returns {Object} retObj.json JSON found at the head of the content
     * @returns {String} retObj.content Content found in the body
     */
    function jsonContentDemux(muxStr, options) {
      // Find where the JSON ends
      var delimiter = /\n\r?\n\r?/g,
          result = delimiter.exec(muxStr),
          delimiterIndex = delimiter.lastIndex;
    
      // By default, lastIndex = 0 so no fallbacking is necessary
      // // Fallback the dblLineBreakIndex
      // if (delimiterIndex === -1) {
      //   delimiterIndex = 0;
      // }
    
      // Break up the json and content
      var jsonStr = muxStr.slice(0, delimiterIndex) || '{}',
          json = {};
    
      // Attempt to interpret the JSON
      try {
        json = new Function('return ' + jsonStr + ';')();
      } catch (e) {
      // Upon failure, reset the delimiterIndex to 0
        delimiterIndex = 0;
      }
    
      // Extract the content
      var content = muxStr.slice(delimiterIndex);
    
      // Prepare a retObj and return
      var retObj = {
            'json': json,
            'content': content
          };
      return retObj;
    }
    
    // Export jsonContentDemux
    module.exports = jsonContentDemux;
  provide("json-content-demux", module.exports);
}(global));

// pakmanager:spritesmith/src/smiths/engine.smith.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var async = require('async');
    function EngineSmith(engine) {
      this.engine = engine;
    }
    
    EngineSmith.prototype = {
      // Create multiple images
      createImages: function (files, cb) {
        // If there is a engine.createImages method, use it
        var engine = this.engine;
        async.waterfall([
          // Mass create images
          function engineCreateImages (cb) {
            engine.createImages(files, cb);
          },
          // Save the image paths
          function savePaths (imgs, cb) {
            // Iterate over the images and save their paths
            imgs.forEach(function (img, i) {
              img._filepath = files[i];
            });
    
            // Callback with the images
            cb(null, imgs);
          }
        ], cb);
      },
      // Helper to create canvas via engine
      createCanvas: function (width, height, cb) {
        var engine = this.engine;
        return engine.createCanvas(width, height, cb);
      }
    };
    
    // Export EngineSmith
    module.exports = EngineSmith;
    
  provide("spritesmith/src/smiths/engine.smith.js", module.exports);
}(global));

// pakmanager:spritesmith/src/smiths/canvas.smith.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  function CanvasSmith(canvas) {
      this.canvas = canvas;
    }
    CanvasSmith.prototype = {
      addImage: function (imgObj) {
        var img = imgObj.meta.img;
        var x = imgObj.x;
        var y = imgObj.y;
        var canvas = this.canvas;
        canvas.addImage(img, x, y);
      },
      addImages: function (images) {
        var that = this;
        images.forEach(function (img) {
          that.addImage(img);
        });
      },
      addImageMap: function (imageMap) {
        var that = this;
        var imageNames = Object.getOwnPropertyNames(imageMap);
    
        // Add the images
        imageNames.forEach(function (name) {
          var image = imageMap[name];
          that.addImage(image);
        });
      },
      export: function (options, cb) {
        this.canvas['export'](options, cb);
      }
    };
    
    // Export CanvasSmith
    module.exports = CanvasSmith;
    
  provide("spritesmith/src/smiths/canvas.smith.js", module.exports);
}(global));

// pakmanager:spritesmith
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load in dependencies
    var async = require('async');
    var Layout = require('layout');
    var EngineSmith =  require('spritesmith/src/smiths/engine.smith.js');
    var CanvasSmith =  require('spritesmith/src/smiths/canvas.smith.js');
    
    // Specify defaults
    var engineDefault = 'pixelsmith';
    var algorithmDefault = 'binary-tree';
    
    // Define our spritesmith utility
    // Gist of params: {src: files, engine: 'pixelsmith', algorithm: 'binary-tree'}
    // Gist of result: {image: binary, coordinates: {filepath: {x, y, width, height}}, properties: {width, height}}
    function spritesmith(params, callback) {
      // Set up return items and fallback parameters
      var retObj = {};
      var files = params.src;
      var engineName = params.engine || engineDefault;
      var engine = engineName;
      var algorithmName = params.algorithm || algorithmDefault;
    
      // If the engine is a `require` path, attempt to load it
      if (typeof engineName === 'string') {
        // Attempt to resolve the engine to verify it is installed at all
        try {
          require.resolve(engineName);
        } catch (err) {
          console.error('Attempted to find spritesmith engine "' + engineName + '" but could not.');
          console.error('Please verify you have installed "' + engineName + '" and saved it to your `package.json`');
          console.error('');
          console.error('    npm install ' + engineName + ' --save-dev');
          console.error('');
          throw err;
        }
    
        // Attempt to load the engine
        try {
          engine = require(engineName);
        } catch (err) {
          console.error('Attempted to load spritesmith engine "' + engineName + '" but could not.');
          console.error('Please verify you have installed its dependencies. Documentation should be available at ');
          console.error('');
          // TODO: Consider using pkg.homepage and pkg.repository
          console.error('    https://npm.im/' + encodeURIComponent(engineName));
          console.error('');
          throw err;
        }
      }
    
      // If there is a set parameter for the engine, use it
      if (engine.set) {
        var engineOpts = params.engineOpts || {};
        engine.set(engineOpts);
      }
    
      // Create our smiths
      var engineSmith = new EngineSmith(engine);
      var layer = new Layout(algorithmName, params.algorithmOpts);
      var padding = params.padding || 0;
      var exportOpts = params.exportOpts || {};
      var packedObj;
    
      // In a waterfall fashion
      async.waterfall([
        function grabImages (cb) {
          // Map the files into their image counterparts
          engineSmith.createImages(files, cb);
        },
        // Then, add the images to our canvas (dry run)
        function smithAddFiles (images, cb) {
          images.forEach(function (img) {
            // Save the non-padded properties as meta data
            var width = img.width;
            var height = img.height;
            var meta = {img: img, actualWidth: width, actualHeight: height};
    
            // Add the item with padding to our layer
            layer.addItem({
              width: width + padding,
              height: height + padding,
              meta: meta
            });
          });
    
          // Callback with nothing
          cb(null);
        },
        // Then, output the coordinates
        function smithOutputCoordinates (cb) {
          // Export and saved packedObj for later
          packedObj = layer['export']();
    
          // Extract the coordinates
          var coordinates = {};
          var packedItems = packedObj.items;
          packedItems.forEach(function (item) {
            var meta = item.meta;
            var img = meta.img;
            var name = img._filepath;
            coordinates[name] = {
              x: item.x,
              y: item.y,
              width: meta.actualWidth,
              height: meta.actualHeight
            };
          });
    
          // Save the coordinates
          retObj.coordinates = coordinates;
    
          // Continue
          cb(null);
        },
        // Then, generate a canvas
        function generateCanvas (cb) {
          // Grab and fallback the width/height
          var width = Math.max(packedObj.width || 0, 0);
          var height = Math.max(packedObj.height || 0, 0);
    
          // If there are items
          var itemsExist = packedObj.items.length;
          if (itemsExist) {
            // Remove the last item's padding
            width -= padding;
            height -= padding;
          }
    
          // Export the total width and height of the generated canvas
          retObj.properties = {
            width: width,
            height: height
          };
    
          // If there are items, generate the canvas
          if (itemsExist) {
            engine.createCanvas(width, height, cb);
          } else {
          // Otherwise, skip over potential errors/CPU
            cb(null, '');
          }
        },
        // Then, export the canvas
        function exportCanvas (canvas, cb) {
          // If there is no canvas, callback with an empty string
          var items = packedObj.items;
          if (!canvas) {
            return cb(null, '');
          }
    
          // Create a CanvasSmithy
          var canvasSmith = new CanvasSmith(canvas);
    
          // Add the images onto canvasSmith
          try {
            canvasSmith.addImages(items);
          } catch (err) {
            return cb(err);
          }
    
          // Export our canvas
          canvasSmith['export'](exportOpts, cb);
        },
        function saveImageToRetObj (imgStr, cb) {
          // Save the image to the retObj
          retObj.image = imgStr;
    
          // Callback
          cb(null);
        },
        function smithCallbackData (cb) {
          // Callback with the return object
          cb(null, retObj);
        }
      ], callback);
    }
    
    // Add the smiths to spritesmith
    spritesmith.EngineSmith = EngineSmith;
    spritesmith.Layout = Layout;
    spritesmith.CanvasSmith = CanvasSmith;
    
    // Export spritesmith
    module.exports = spritesmith;
    
  provide("spritesmith", module.exports);
}(global));

// pakmanager:json2css
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Set up the template store
    var mustache = require('mustache'),
        assert = require('assert'),
        fs = require('fs'),
        jsonContentDemux = require('json-content-demux'),
        _ = require('underscore'),
        templates = {};
    
    /**
     * @param {Object|Object[]} input Object to convert into CSS
     * @param {Object} [options] Options to convert JSON with
     * @param {String} [options.format=css] Format to output json in (Available: json, css, less, sass, scss, stylus)
     * @param {Mixed} [options.formatOpts={}] Options to pass through to the formatter
     */
    function json2css(input, options) {
      // Fallback options
      options = options || {};
    
      var format = options.format || 'css',
          template = templates[format],
          formatOpts = options.formatOpts || {};
    
      // Assert that the template exists
      assert(template, 'The json2css format ' + format + ' could not be found. Please make sure to either add it via addTemplate or the spelling is correct.');
    
      // Clone the input
      input = JSON.parse(JSON.stringify(input));
    
      // Downcast the input into an array
      var inputObj = new Input(input);
      inputObj.coerceToArray();
      inputObj.ensureOffsetAndPx();
      inputObj.escapeImages();
    
      // Process the input via the template
      input = inputObj['export']();
      var retVal = template({'items': input, 'options': formatOpts});
    
      // Return the output
      return retVal;
    }
    
    function Input(input) {
      this.input = input;
    }
    Input.prototype = {
      'coerceToArray': function () {
        var input = this.input,
            retArr = input;
    
        // If the input is not yet an array
        if (!Array.isArray(input)) {
          retArr = [];
    
          // Iterate over the keys of hte input
          var keys = Object.getOwnPropertyNames(input);
          keys.forEach(function (key) {
            // Create a new item with the name as the key
            var item = input[key],
                retObj = _.pick(item, 'width', 'height', 'total_width', 'total_height', 'x', 'y', 'image');
            retObj.name = key;
    
            // Save the item to the input
            retArr.push(retObj);
          });
        }
    
        // save the input back to this
        this.input = retArr;
      },
      // Helper function to ensure offset values exist as well as values with pixels in the name
      'ensureOffsetAndPx': function () {
        // Iterate over the input and ensure there are offset values as well as pixel items
        this.input.forEach(function (item) {
          // Guarantee offsets exist
          item.offset_x = -item.x;
          item.offset_y = -item.y;
    
          // Create a px namespace
          var px = {};
          item.px = px;
    
          // For each of the x, y, offset_x, offset_y, height, width, add a px after that
          ['x', 'y', 'offset_x', 'offset_y', 'height', 'width', 'total_height', 'total_width'].forEach(function (key) {
            px[key] = item[key] + 'px';
          });
        });
      },
      // Helper function to escape images
      'escapeImages': function () {
        // Iterate over the items
        this.input.forEach(function (item) {
          // Grab the image
          var img = item.image;
    
          // Escape the quotes, parentheses, and whitespace
          // http://www.w3.org/TR/CSS21/syndata.html#uri
          var escapedImg = img.replace(/['"\(\)\s]/g, function encodeCssUri (chr) {
            return '%' + chr.charCodeAt(0).toString(16);
          });
    
          // Save the escapedImg for later
          item.escaped_image = escapedImg;
        });
      },
      'export': function () {
        return this.input;
      }
    };
    
    // Expose the Input to the outside
    json2css.Input = Input;
    
    // Helper method to add new templates
    function addTemplate(name, fn) {
      templates[name] = fn;
    }
    function addMustacheTemplate(name, tmplStr) {
      // Break up the template and default options
      var tmplObj = jsonContentDemux(tmplStr),
          defaults = tmplObj.json || {},
          tmpl = tmplObj.content;
    
      // Generate a function which processes objects through the mustache template
      function templateFn(itemObj) {
        // Set up the defaults for the item object
        _.defaults(itemObj.options, defaults);
    
        // Render the items via the template
        var retStr = mustache.render(tmpl, itemObj);
        return retStr;
      }
    
      // Save the template
      addTemplate(name, templateFn);
    }
    
    // Expose template system
    json2css.addTemplate = addTemplate;
    json2css.addMustacheTemplate = addMustacheTemplate;
    json2css.templates = templates;
    
    // Add in the templates from templates
    var templatesDir = __dirname + '/templates';
    
    addTemplate('json', require(templatesDir + '/json.template.js'));
    addTemplate('css', require(templatesDir + '/css.template.js'));
    
    var stylusMustache = fs.readFileSync(templatesDir + '/stylus.template.mustache', 'utf8');
    addMustacheTemplate('stylus', stylusMustache);
    
    var lessMustache = fs.readFileSync(templatesDir + '/less.template.mustache', 'utf8');
    addMustacheTemplate('less', lessMustache);
    
    var sassMustache = fs.readFileSync(templatesDir + '/sass.template.mustache', 'utf8');
    addMustacheTemplate('sass', sassMustache);
    
    var scssMustache = fs.readFileSync(templatesDir + '/scss.template.mustache', 'utf8');
    addMustacheTemplate('scss', scssMustache);
    
    // Expose json2css
    module.exports = json2css;
    
  provide("json2css", module.exports);
}(global));

// pakmanager:when
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /** @license MIT License (c) copyright 2011-2013 original author or authors */
    
    /**
     * A lightweight CommonJS Promises/A and when() implementation
     * when is part of the cujo.js family of libraries (http://cujojs.com/)
     *
     * Licensed under the MIT License at:
     * http://www.opensource.org/licenses/mit-license.php
     *
     * @author Brian Cavalier
     * @author John Hann
     * @version 2.3.0
     */
    (function(define, global) { 'use strict';
    define(function () {
    
    	// Public API
    
    	when.promise   = promise;    // Create a pending promise
    	when.resolve   = resolve;    // Create a resolved promise
    	when.reject    = reject;     // Create a rejected promise
    	when.defer     = defer;      // Create a {promise, resolver} pair
    
    	when.join      = join;       // Join 2 or more promises
    
    	when.all       = all;        // Resolve a list of promises
    	when.map       = map;        // Array.map() for promises
    	when.reduce    = reduce;     // Array.reduce() for promises
    	when.settle    = settle;     // Settle a list of promises
    
    	when.any       = any;        // One-winner race
    	when.some      = some;       // Multi-winner race
    
    	when.isPromise = isPromise;  // Determine if a thing is a promise
    
    	/**
    	 * Register an observer for a promise or immediate value.
    	 *
    	 * @param {*} promiseOrValue
    	 * @param {function?} [onFulfilled] callback to be called when promiseOrValue is
    	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
    	 *   will be invoked immediately.
    	 * @param {function?} [onRejected] callback to be called when promiseOrValue is
    	 *   rejected.
    	 * @param {function?} [onProgress] callback to be called when progress updates
    	 *   are issued for promiseOrValue.
    	 * @returns {Promise} a new {@link Promise} that will complete with the return
    	 *   value of callback or errback or the completion value of promiseOrValue if
    	 *   callback and/or errback is not supplied.
    	 */
    	function when(promiseOrValue, onFulfilled, onRejected, onProgress) {
    		// Get a trusted promise for the input promiseOrValue, and then
    		// register promise handlers
    		return resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);
    	}
    
    	/**
    	 * Trusted Promise constructor.  A Promise created from this constructor is
    	 * a trusted when.js promise.  Any other duck-typed promise is considered
    	 * untrusted.
    	 * @constructor
    	 * @param {function} sendMessage function to deliver messages to the promise's handler
    	 * @param {function?} inspect function that reports the promise's state
    	 * @name Promise
    	 */
    	function Promise(sendMessage, inspect) {
    		this._message = sendMessage;
    		this.inspect = inspect;
    	}
    
    	Promise.prototype = {
    		/**
    		 * Register a rejection handler.  Shortcut for .then(undefined, onRejected)
    		 * @param {function?} onRejected
    		 * @return {Promise}
    		 */
    		otherwise: function(onRejected) {
    			return this.then(undef, onRejected);
    		},
    
    		/**
    		 * Ensures that onFulfilledOrRejected will be called regardless of whether
    		 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
    		 * receive the promises' value or reason.  Any returned value will be disregarded.
    		 * onFulfilledOrRejected may throw or return a rejected promise to signal
    		 * an additional error.
    		 * @param {function} onFulfilledOrRejected handler to be called regardless of
    		 *  fulfillment or rejection
    		 * @returns {Promise}
    		 */
    		ensure: function(onFulfilledOrRejected) {
    			return this.then(injectHandler, injectHandler)['yield'](this);
    
    			function injectHandler() {
    				return resolve(onFulfilledOrRejected());
    			}
    		},
    
    		/**
    		 * Shortcut for .then(function() { return value; })
    		 * @param  {*} value
    		 * @return {Promise} a promise that:
    		 *  - is fulfilled if value is not a promise, or
    		 *  - if value is a promise, will fulfill with its value, or reject
    		 *    with its reason.
    		 */
    		'yield': function(value) {
    			return this.then(function() {
    				return value;
    			});
    		},
    
    		/**
    		 * Runs a side effect when this promise fulfills, without changing the
    		 * fulfillment value.
    		 * @param {function} onFulfilledSideEffect
    		 * @returns {Promise}
    		 */
    		tap: function(onFulfilledSideEffect) {
    			return this.then(onFulfilledSideEffect)['yield'](this);
    		},
    
    		/**
    		 * Assumes that this promise will fulfill with an array, and arranges
    		 * for the onFulfilled to be called with the array as its argument list
    		 * i.e. onFulfilled.apply(undefined, array).
    		 * @param {function} onFulfilled function to receive spread arguments
    		 * @return {Promise}
    		 */
    		spread: function(onFulfilled) {
    			return this.then(function(array) {
    				// array may contain promises, so resolve its contents.
    				return all(array, function(array) {
    					return onFulfilled.apply(undef, array);
    				});
    			});
    		},
    
    		/**
    		 * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)
    		 * @deprecated
    		 */
    		always: function(onFulfilledOrRejected, onProgress) {
    			return this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);
    		}
    	};
    
    	/**
    	 * Returns a resolved promise. The returned promise will be
    	 *  - fulfilled with promiseOrValue if it is a value, or
    	 *  - if promiseOrValue is a promise
    	 *    - fulfilled with promiseOrValue's value after it is fulfilled
    	 *    - rejected with promiseOrValue's reason after it is rejected
    	 * @param  {*} value
    	 * @return {Promise}
    	 */
    	function resolve(value) {
    		return promise(function(resolve) {
    			resolve(value);
    		});
    	}
    
    	/**
    	 * Returns a rejected promise for the supplied promiseOrValue.  The returned
    	 * promise will be rejected with:
    	 * - promiseOrValue, if it is a value, or
    	 * - if promiseOrValue is a promise
    	 *   - promiseOrValue's value after it is fulfilled
    	 *   - promiseOrValue's reason after it is rejected
    	 * @param {*} promiseOrValue the rejected value of the returned {@link Promise}
    	 * @return {Promise} rejected {@link Promise}
    	 */
    	function reject(promiseOrValue) {
    		return when(promiseOrValue, rejected);
    	}
    
    	/**
    	 * Creates a {promise, resolver} pair, either or both of which
    	 * may be given out safely to consumers.
    	 * The resolver has resolve, reject, and progress.  The promise
    	 * has then plus extended promise API.
    	 *
    	 * @return {{
    	 * promise: Promise,
    	 * resolve: function:Promise,
    	 * reject: function:Promise,
    	 * notify: function:Promise
    	 * resolver: {
    	 *	resolve: function:Promise,
    	 *	reject: function:Promise,
    	 *	notify: function:Promise
    	 * }}}
    	 */
    	function defer() {
    		var deferred, pending, resolved;
    
    		// Optimize object shape
    		deferred = {
    			promise: undef, resolve: undef, reject: undef, notify: undef,
    			resolver: { resolve: undef, reject: undef, notify: undef }
    		};
    
    		deferred.promise = pending = promise(makeDeferred);
    
    		return deferred;
    
    		function makeDeferred(resolvePending, rejectPending, notifyPending) {
    			deferred.resolve = deferred.resolver.resolve = function(value) {
    				if(resolved) {
    					return resolve(value);
    				}
    				resolved = true;
    				resolvePending(value);
    				return pending;
    			};
    
    			deferred.reject  = deferred.resolver.reject  = function(reason) {
    				if(resolved) {
    					return resolve(rejected(reason));
    				}
    				resolved = true;
    				rejectPending(reason);
    				return pending;
    			};
    
    			deferred.notify  = deferred.resolver.notify  = function(update) {
    				notifyPending(update);
    				return update;
    			};
    		}
    	}
    
    	/**
    	 * Creates a new promise whose fate is determined by resolver.
    	 * @param {function} resolver function(resolve, reject, notify)
    	 * @returns {Promise} promise whose fate is determine by resolver
    	 */
    	function promise(resolver) {
    		return _promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());
    	}
    
    	/**
    	 * Creates a new promise, linked to parent, whose fate is determined
    	 * by resolver.
    	 * @param {function} resolver function(resolve, reject, notify)
    	 * @param {Promise?} status promise from which the new promise is begotten
    	 * @returns {Promise} promise whose fate is determine by resolver
    	 * @private
    	 */
    	function _promise(resolver, status) {
    		var self, value, consumers = [];
    
    		self = new Promise(_message, inspect);
    		self.then = then;
    
    		// Call the provider resolver to seal the promise's fate
    		try {
    			resolver(promiseResolve, promiseReject, promiseNotify);
    		} catch(e) {
    			promiseReject(e);
    		}
    
    		// Return the promise
    		return self;
    
    		function _message(type, args, resolve, notify) {
    			consumers ? consumers.push(deliver) : enqueue(function() { deliver(value); });
    
    			function deliver(p) {
    				p._message(type, args, resolve, notify);
    			}
    		}
    
    		/**
    		 * Returns a snapshot of the promise's state at the instant inspect()
    		 * is called. The returned object is not live and will not update as
    		 * the promise's state changes.
    		 * @returns {{ state:String, value?:*, reason?:* }} status snapshot
    		 *  of the promise.
    		 */
    		function inspect() {
    			return value ? value.inspect() : toPendingState();
    		}
    
    		/**
    		 * Register handlers for this promise.
    		 * @param [onFulfilled] {Function} fulfillment handler
    		 * @param [onRejected] {Function} rejection handler
    		 * @param [onProgress] {Function} progress handler
    		 * @return {Promise} new Promise
    		 */
    		function then(onFulfilled, onRejected, onProgress) {
    			/*jshint unused:false*/
    			var args = arguments;
    			return _promise(function(resolve, reject, notify) {
    				_message('when', args, resolve, notify);
    			}, status && status.observed());
    		}
    
    		/**
    		 * Transition from pre-resolution state to post-resolution state, notifying
    		 * all listeners of the ultimate fulfillment or rejection
    		 * @param {*|Promise} val resolution value
    		 */
    		function promiseResolve(val) {
    			if(!consumers) {
    				return;
    			}
    
    			value = coerce(val);
    			scheduleConsumers(consumers, value);
    			consumers = undef;
    
    			if(status) {
    				updateStatus(value, status);
    			}
    		}
    
    		/**
    		 * Reject this promise with the supplied reason, which will be used verbatim.
    		 * @param {*} reason reason for the rejection
    		 */
    		function promiseReject(reason) {
    			promiseResolve(rejected(reason));
    		}
    
    		/**
    		 * Issue a progress event, notifying all progress listeners
    		 * @param {*} update progress event payload to pass to all listeners
    		 */
    		function promiseNotify(update) {
    			if(consumers) {
    				scheduleConsumers(consumers, progressed(update));
    			}
    		}
    	}
    
    	/**
    	 * Creates a fulfilled, local promise as a proxy for a value
    	 * NOTE: must never be exposed
    	 * @param {*} value fulfillment value
    	 * @returns {Promise}
    	 */
    	function fulfilled(value) {
    		return near(
    			new NearFulfilledProxy(value),
    			function() { return toFulfilledState(value); }
    		);
    	}
    
    	/**
    	 * Creates a rejected, local promise with the supplied reason
    	 * NOTE: must never be exposed
    	 * @param {*} reason rejection reason
    	 * @returns {Promise}
    	 */
    	function rejected(reason) {
    		return near(
    			new NearRejectedProxy(reason),
    			function() { return toRejectedState(reason); }
    		);
    	}
    
    	/**
    	 * Creates a near promise using the provided proxy
    	 * NOTE: must never be exposed
    	 * @param {object} proxy proxy for the promise's ultimate value or reason
    	 * @param {function} inspect function that returns a snapshot of the
    	 *  returned near promise's state
    	 * @returns {Promise}
    	 */
    	function near(proxy, inspect) {
    		return new Promise(function(type, args, resolve) {
    			try {
    				resolve(proxy[type].apply(proxy, args));
    			} catch(e) {
    				resolve(rejected(e));
    			}
    		}, inspect);
    	}
    
    	/**
    	 * Create a progress promise with the supplied update.
    	 * @private
    	 * @param {*} update
    	 * @return {Promise} progress promise
    	 */
    	function progressed(update) {
    		return new Promise(function (type, args, _, notify) {
    			var onProgress = args[2];
    			try {
    				notify(typeof onProgress === 'function' ? onProgress(update) : update);
    			} catch(e) {
    				notify(e);
    			}
    		});
    	}
    
    	/**
    	 * Coerces x to a trusted Promise
    	 *
    	 * @private
    	 * @param {*} x thing to coerce
    	 * @returns {*} Guaranteed to return a trusted Promise.  If x
    	 *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved
    	 *   Promise whose resolution value is:
    	 *   * the resolution value of x if it's a foreign promise, or
    	 *   * x if it's a value
    	 */
    	function coerce(x) {
    		if(x instanceof Promise) {
    			return x;
    		}
    
    		if (!(x === Object(x) && 'then' in x)) {
    			return fulfilled(x);
    		}
    
    		return promise(function(resolve, reject, notify) {
    			enqueue(function() {
    				try {
    					// We must check and assimilate in the same tick, but not the
    					// current tick, careful only to access promiseOrValue.then once.
    					var untrustedThen = x.then;
    
    					if(typeof untrustedThen === 'function') {
    						fcall(untrustedThen, x, resolve, reject, notify);
    					} else {
    						// It's a value, create a fulfilled wrapper
    						resolve(fulfilled(x));
    					}
    
    				} catch(e) {
    					// Something went wrong, reject
    					reject(e);
    				}
    			});
    		});
    	}
    
    	/**
    	 * Proxy for a near, fulfilled value
    	 * @param {*} value
    	 * @constructor
    	 */
    	function NearFulfilledProxy(value) {
    		this.value = value;
    	}
    
    	NearFulfilledProxy.prototype.when = function(onResult) {
    		return typeof onResult === 'function' ? onResult(this.value) : this.value;
    	};
    
    	/**
    	 * Proxy for a near rejection
    	 * @param {*} value
    	 * @constructor
    	 */
    	function NearRejectedProxy(reason) {
    		this.reason = reason;
    	}
    
    	NearRejectedProxy.prototype.when = function(_, onError) {
    		if(typeof onError === 'function') {
    			return onError(this.reason);
    		} else {
    			throw this.reason;
    		}
    	};
    
    	/**
    	 * Schedule a task that will process a list of handlers
    	 * in the next queue drain run.
    	 * @private
    	 * @param {Array} handlers queue of handlers to execute
    	 * @param {*} value passed as the only arg to each handler
    	 */
    	function scheduleConsumers(handlers, value) {
    		enqueue(function() {
    			var handler, i = 0;
    			while (handler = handlers[i++]) {
    				handler(value);
    			}
    		});
    	}
    
    	function updateStatus(value, status) {
    		value._message('when', [
    			function ()  { status.fulfilled(); },
    			function (r) { status.rejected(r); }
    		], identity, identity);
    	}
    
    	/**
    	 * Determines if promiseOrValue is a promise or not
    	 *
    	 * @param {*} promiseOrValue anything
    	 * @returns {boolean} true if promiseOrValue is a {@link Promise}
    	 */
    	function isPromise(promiseOrValue) {
    		return promiseOrValue && typeof promiseOrValue.then === 'function';
    	}
    
    	/**
    	 * Initiates a competitive race, returning a promise that will resolve when
    	 * howMany of the supplied promisesOrValues have resolved, or will reject when
    	 * it becomes impossible for howMany to resolve, for example, when
    	 * (promisesOrValues.length - howMany) + 1 input promises reject.
    	 *
    	 * @param {Array} promisesOrValues array of anything, may contain a mix
    	 *      of promises and values
    	 * @param howMany {number} number of promisesOrValues to resolve
    	 * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()
    	 * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()
    	 * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()
    	 * @returns {Promise} promise that will resolve to an array of howMany values that
    	 *  resolved first, or will reject with an array of
    	 *  (promisesOrValues.length - howMany) + 1 rejection reasons.
    	 */
    	function some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {
    
    		return when(promisesOrValues, function(promisesOrValues) {
    
    			return promise(resolveSome).then(onFulfilled, onRejected, onProgress);
    
    			function resolveSome(resolve, reject, notify) {
    				var toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;
    
    				len = promisesOrValues.length >>> 0;
    
    				toResolve = Math.max(0, Math.min(howMany, len));
    				values = [];
    
    				toReject = (len - toResolve) + 1;
    				reasons = [];
    
    				// No items in the input, resolve immediately
    				if (!toResolve) {
    					resolve(values);
    
    				} else {
    					rejectOne = function(reason) {
    						reasons.push(reason);
    						if(!--toReject) {
    							fulfillOne = rejectOne = identity;
    							reject(reasons);
    						}
    					};
    
    					fulfillOne = function(val) {
    						// This orders the values based on promise resolution order
    						values.push(val);
    						if (!--toResolve) {
    							fulfillOne = rejectOne = identity;
    							resolve(values);
    						}
    					};
    
    					for(i = 0; i < len; ++i) {
    						if(i in promisesOrValues) {
    							when(promisesOrValues[i], fulfiller, rejecter, notify);
    						}
    					}
    				}
    
    				function rejecter(reason) {
    					rejectOne(reason);
    				}
    
    				function fulfiller(val) {
    					fulfillOne(val);
    				}
    			}
    		});
    	}
    
    	/**
    	 * Initiates a competitive race, returning a promise that will resolve when
    	 * any one of the supplied promisesOrValues has resolved or will reject when
    	 * *all* promisesOrValues have rejected.
    	 *
    	 * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
    	 *      of {@link Promise}s and values
    	 * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()
    	 * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()
    	 * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()
    	 * @returns {Promise} promise that will resolve to the value that resolved first, or
    	 * will reject with an array of all rejected inputs.
    	 */
    	function any(promisesOrValues, onFulfilled, onRejected, onProgress) {
    
    		function unwrapSingleResult(val) {
    			return onFulfilled ? onFulfilled(val[0]) : val[0];
    		}
    
    		return some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);
    	}
    
    	/**
    	 * Return a promise that will resolve only once all the supplied promisesOrValues
    	 * have resolved. The resolution value of the returned promise will be an array
    	 * containing the resolution values of each of the promisesOrValues.
    	 * @memberOf when
    	 *
    	 * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
    	 *      of {@link Promise}s and values
    	 * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()
    	 * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()
    	 * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()
    	 * @returns {Promise}
    	 */
    	function all(promisesOrValues, onFulfilled, onRejected, onProgress) {
    		return _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);
    	}
    
    	/**
    	 * Joins multiple promises into a single returned promise.
    	 * @return {Promise} a promise that will fulfill when *all* the input promises
    	 * have fulfilled, or will reject when *any one* of the input promises rejects.
    	 */
    	function join(/* ...promises */) {
    		return _map(arguments, identity);
    	}
    
    	/**
    	 * Settles all input promises such that they are guaranteed not to
    	 * be pending once the returned promise fulfills. The returned promise
    	 * will always fulfill, except in the case where `array` is a promise
    	 * that rejects.
    	 * @param {Array|Promise} array or promise for array of promises to settle
    	 * @returns {Promise} promise that always fulfills with an array of
    	 *  outcome snapshots for each input promise.
    	 */
    	function settle(array) {
    		return _map(array, toFulfilledState, toRejectedState);
    	}
    
    	/**
    	 * Promise-aware array map function, similar to `Array.prototype.map()`,
    	 * but input array may contain promises or values.
    	 * @param {Array|Promise} array array of anything, may contain promises and values
    	 * @param {function} mapFunc map function which may return a promise or value
    	 * @returns {Promise} promise that will fulfill with an array of mapped values
    	 *  or reject if any input promise rejects.
    	 */
    	function map(array, mapFunc) {
    		return _map(array, mapFunc);
    	}
    
    	/**
    	 * Internal map that allows a fallback to handle rejections
    	 * @param {Array|Promise} array array of anything, may contain promises and values
    	 * @param {function} mapFunc map function which may return a promise or value
    	 * @param {function?} fallback function to handle rejected promises
    	 * @returns {Promise} promise that will fulfill with an array of mapped values
    	 *  or reject if any input promise rejects.
    	 */
    	function _map(array, mapFunc, fallback) {
    		return when(array, function(array) {
    
    			return promise(resolveMap);
    
    			function resolveMap(resolve, reject, notify) {
    				var results, len, toResolve, i;
    
    				// Since we know the resulting length, we can preallocate the results
    				// array to avoid array expansions.
    				toResolve = len = array.length >>> 0;
    				results = [];
    
    				if(!toResolve) {
    					resolve(results);
    					return;
    				}
    
    				// Since mapFunc may be async, get all invocations of it into flight
    				for(i = 0; i < len; i++) {
    					if(i in array) {
    						resolveOne(array[i], i);
    					} else {
    						--toResolve;
    					}
    				}
    
    				function resolveOne(item, i) {
    					when(item, mapFunc, fallback).then(function(mapped) {
    						results[i] = mapped;
    						notify(mapped);
    
    						if(!--toResolve) {
    							resolve(results);
    						}
    					}, reject);
    				}
    			}
    		});
    	}
    
    	/**
    	 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
    	 * input may contain promises and/or values, and reduceFunc
    	 * may return either a value or a promise, *and* initialValue may
    	 * be a promise for the starting value.
    	 *
    	 * @param {Array|Promise} promise array or promise for an array of anything,
    	 *      may contain a mix of promises and values.
    	 * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),
    	 *      where total is the total number of items being reduced, and will be the same
    	 *      in each call to reduceFunc.
    	 * @returns {Promise} that will resolve to the final reduced value
    	 */
    	function reduce(promise, reduceFunc /*, initialValue */) {
    		var args = fcall(slice, arguments, 1);
    
    		return when(promise, function(array) {
    			var total;
    
    			total = array.length;
    
    			// Wrap the supplied reduceFunc with one that handles promises and then
    			// delegates to the supplied.
    			args[0] = function (current, val, i) {
    				return when(current, function (c) {
    					return when(val, function (value) {
    						return reduceFunc(c, value, i, total);
    					});
    				});
    			};
    
    			return reduceArray.apply(array, args);
    		});
    	}
    
    	// Snapshot states
    
    	/**
    	 * Creates a fulfilled state snapshot
    	 * @private
    	 * @param {*} x any value
    	 * @returns {{state:'fulfilled',value:*}}
    	 */
    	function toFulfilledState(x) {
    		return { state: 'fulfilled', value: x };
    	}
    
    	/**
    	 * Creates a rejected state snapshot
    	 * @private
    	 * @param {*} x any reason
    	 * @returns {{state:'rejected',reason:*}}
    	 */
    	function toRejectedState(x) {
    		return { state: 'rejected', reason: x };
    	}
    
    	/**
    	 * Creates a pending state snapshot
    	 * @private
    	 * @returns {{state:'pending'}}
    	 */
    	function toPendingState() {
    		return { state: 'pending' };
    	}
    
    	//
    	// Internals, utilities, etc.
    	//
    
    	var reduceArray, slice, fcall, nextTick, handlerQueue,
    		setTimeout, funcProto, call, arrayProto, monitorApi, undef;
    
    	//
    	// Shared handler queue processing
    	//
    	// Credit to Twisol (https://github.com/Twisol) for suggesting
    	// this type of extensible queue + trampoline approach for
    	// next-tick conflation.
    
    	handlerQueue = [];
    
    	/**
    	 * Enqueue a task. If the queue is not currently scheduled to be
    	 * drained, schedule it.
    	 * @param {function} task
    	 */
    	function enqueue(task) {
    		if(handlerQueue.push(task) === 1) {
    			nextTick(drainQueue);
    		}
    	}
    
    	/**
    	 * Drain the handler queue entirely, being careful to allow the
    	 * queue to be extended while it is being processed, and to continue
    	 * processing until it is truly empty.
    	 */
    	function drainQueue() {
    		var task, i = 0;
    
    		while(task = handlerQueue[i++]) {
    			task();
    		}
    
    		handlerQueue = [];
    	}
    
    	// capture setTimeout to avoid being caught by fake timers
    	// used in time based tests
    	setTimeout = global.setTimeout;
    
    	// Allow attaching the monitor to when() if env has no console
    	monitorApi = typeof console != 'undefined' ? console : when;
    
    	// Prefer setImmediate or MessageChannel, cascade to node,
    	// vertx and finally setTimeout
    	/*global setImmediate,MessageChannel,process,vertx*/
    	if (typeof setImmediate === 'function') {
    		nextTick = setImmediate.bind(global);
    	} else if(typeof MessageChannel !== 'undefined') {
    		var channel = new MessageChannel();
    		channel.port1.onmessage = drainQueue;
    		nextTick = function() { channel.port2.postMessage(0); };
    	} else if (typeof process === 'object' && process.nextTick) {
    		nextTick = process.nextTick;
    	} else if (typeof vertx === 'object') {
    		nextTick = vertx.runOnLoop;
    	} else {
    		nextTick = function(t) { setTimeout(t, 0); };
    	}
    
    	//
    	// Capture/polyfill function and array utils
    	//
    
    	// Safe function calls
    	funcProto = Function.prototype;
    	call = funcProto.call;
    	fcall = funcProto.bind
    		? call.bind(call)
    		: function(f, context) {
    			return f.apply(context, slice.call(arguments, 2));
    		};
    
    	// Safe array ops
    	arrayProto = [];
    	slice = arrayProto.slice;
    
    	// ES5 reduce implementation if native not available
    	// See: http://es5.github.com/#x15.4.4.21 as there are many
    	// specifics and edge cases.  ES5 dictates that reduce.length === 1
    	// This implementation deviates from ES5 spec in the following ways:
    	// 1. It does not check if reduceFunc is a Callable
    	reduceArray = arrayProto.reduce ||
    		function(reduceFunc /*, initialValue */) {
    			/*jshint maxcomplexity: 7*/
    			var arr, args, reduced, len, i;
    
    			i = 0;
    			arr = Object(this);
    			len = arr.length >>> 0;
    			args = arguments;
    
    			// If no initialValue, use first item of array (we know length !== 0 here)
    			// and adjust i to start at second item
    			if(args.length <= 1) {
    				// Skip to the first real element in the array
    				for(;;) {
    					if(i in arr) {
    						reduced = arr[i++];
    						break;
    					}
    
    					// If we reached the end of the array without finding any real
    					// elements, it's a TypeError
    					if(++i >= len) {
    						throw new TypeError();
    					}
    				}
    			} else {
    				// If initialValue provided, use it
    				reduced = args[1];
    			}
    
    			// Do the actual reduce
    			for(;i < len; ++i) {
    				if(i in arr) {
    					reduced = reduceFunc(reduced, arr[i], i, arr);
    				}
    			}
    
    			return reduced;
    		};
    
    	function identity(x) {
    		return x;
    	}
    
    	return when;
    });
    })(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); }, this);
    
  provide("when", module.exports);
}(global));